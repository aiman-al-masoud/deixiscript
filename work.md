# Deixiscript: an approach to spoken naturalistic programming

The issues will be raised following the logical flow of ideas: primary goals will be
stated, solutions will be proposed, their points and counter-points will be
elucidated, and finally: a decision will follow to go forth in a particular
direction.

It may well be that any given design choice may not necessarily be the best, but
an attempt will be made at motivating it and comparing it with the alternatives.

There will also be two final sections, one is dedicated to discussing possible
future extensions that build upon this work, and the other is an appendix that
details some of the related projects that preceded and insipired this work, and
to which reference will be made throughout this work.

The following is an outline of the topics, organized temporally, as a rough
estimate of the mental roadmap that was taken:

- [Do we need a spoken programming language?](#do-we-need-a-spoken-programming-language)
  - [advantages of speech](#advantages-of-speech)
  - [disadvantages of speech](#disadvantages-of-speech)
- [Does a spoken programming language have to imitate natural speech?](#does-a-spoken-programming-language-have-to-imitate-natural-speech)
  - [programming by speech](#programming-by-speech)
  - [naturalistic programming](#naturalistic-programming)
  - [deixis]()
  - [syntactic/semantic compression]()
  - [formalist vs non-formalist](#formalist-vs-non-formalist)
  - [where computer science and linguistics meet](#where-computer-science-and-linguistics-meet)
- [How should natural language be approximated?](#how-should-natural-language-be-approximated)
  - [all grammars leak](#all-grammars-leak)
  - [analytic vs synthetic grammar?](#analytic-vs-synthetic-grammar)
  - [syntax vs morphology?](#syntax-vs-morphology)
  - [dependency vs constituency parsing?](#dependency-vs-constituency-parsing)
- [What shall the basic constituents of a sentence be?](#what-shall-the-basic-constituents-of-a-sentence-be)
  - [noun phrases](#noun-phrases)
  - [relative clauses & gapping](#relative-clauses)
  - [verb sentences (aka: simple sentences)](#verb-sentences-aka-simple-sentences)
  - [compound and complex sentences](#compound-and-complex-sentences)
  - [drawing a parallel with programming language structures](#drawing-a-parallel-with-programming-language-structures)
- [How to represent the world?](#how-to-represent-the-world)
  - [metaphysics: the basic principles](#metaphysics-the-basic-principles)
  - [declarative vs imperative?](#declarative-vs-imperative)
  - [the case for predicate logic](#the-case-for-predicate-logic)
  - [the problem with predicate logic (no deixis)](#the-problem-with-predicate-logic-no-deixis)
  - [adapting predicate logic to support deixis](#adapting-predicate-logic-to-support-deixis)
- [What about higher level abstractions?](#what-about-higher-level-abstractions)
  - [derivation clauses](#derivation-clauses)
  - [analytic (a priori) derivation clauses](#analytic-a-priori-derivation-clauses)
  - [synthetic (a posteriori) derivation clauses](#synthetic-a-posteriori-derivation-clauses)
  - [matching sentences by syntax and semantics](#matching-sentences-by-syntax-and-semantics)
- [How to handle I/O?](#how-to-handle-io)
  - [world model sentences as the interface to the outer world](#world-model-sentences-as-the-interface-to-the-outer-world)
  - [event driven programming](#event-driven-programming)
- [Future work](#future-work)
  - [context sensitivity through a better handling of deixis](#context-sensitivity-through-a-better-handling-of-deixis)
  - [tense](#tense)
  - [ambiguous sentence recognition](#ambiguous-sentence-recognition)
  - [about the license](#about-the-license)
- [Previous related work](#previous-related-work)
  - [Pegasus](#pegasus)
  - [Machines like us](#machines-like-us)
  - [ALVIN](#alvin)
  - [Programming by Voice Efficiency in the Reactive and Imperative Paradigm](#programming-by-voice-efficiency-in-the-reactive-and-imperative-paradigm)

# Do we need a spoken programming language?

## Advantages of speech

## Disadvantages of speech

# Does a spoken programming language have to imitate natural speech?

## programming by speech

## naturalistic programming

## formalist vs non-formalist

## where computer science and linguistics meet

# How should natural language be approximated?

## all grammars leak

## analytic vs synthetic grammar?

## syntax vs morphology?

## dependency vs constituency parsing?

# What shall the basic constituents of a sentence be?

## noun phrases

## relative clauses

## verb sentences (aka: simple sentences)

## compound and complex sentences

## drawing a parallel with programming language structures

# How to represent the world?

## metaphysics: the basic principles

## declarative vs imperative?

## the case for predicate logic

## the problem with predicate logic (no deixis)

## adapting predicate logic to support deixis

# What about higher level abstractions?

## derivation clauses

## analytic (a priori) derivation clauses

## synthetic (a posteriori) derivation clauses

## matching sentences by syntax and semantics

# How to handle I/O?

## world model sentences as the interface to the outer world

## event driven programming

# Future work

## context sensitivity through a better handling of deixis

## tense

## ambiguous sentence recognition

## about the license

# Previous related work

## Pegasus

## Machines like us

## ALVIN

## Programming by Voice Efficiency in the Reactive and Imperative Paradigm
