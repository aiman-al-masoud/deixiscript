# Prolog Approach

The first ["tracer bullet"](./quotes.md#tracer-bullets) had at its core [Tau Prolog](./quotes.md#tau-prolog), an opensource Javascript implementation of Prolog. This is a high-level overview of the architecture that was employed:

<img src='./res/old-architecture.png' width='500'/>

## How it worked

In summary, the Brain (a [facade controller](./quotes.md#facade-sw-design-pattern)) received "natural language" sentences from the user, and called the Parser, which returned an AST (Abstract Syntax Tree). The AST was recursively converted into a "Clause" (a language-agnostic representation of the equivalent predicate logic), which could in turn be converted into (one or more) valid PrologClauses [(see: SWORIER)](./quotes.md#sworier-paper), to be fed to the Prolog engine.

The state of the system was centralized in the Brain, more specifically: in a Prolog object in the Brain, which provided a dynamic knowledge base. New assertions by the user could contain anaphora (references to pre-existing entities) which where resolved by a dedicated class (Anaphora) through [a simple algorithm](./quotes.md#anaphora-resolution-algorithm).


Once new knowledge was asserted in the Brain, the Brain made a "diff" of the old versus the new pieces of knowledge for each single entity, and "pushed" the changes downstream to the Actuator [(cf. React Reconciliation)](./quotes.md#react-reconciliation). Each entity was identified by a unique global ID, and each ID had a corresponding Javascript object in the Entity Dictionary.


The Actuator converted Clauses to Actions, which could run in an asynchronous fashion (waiting for a required but not yet initialized object if need be). These Actions actually produced the required effect in the underlying javascript environment, like creating a button or changing its color.


## Naturalistic Features

The system supported general statements (eg: "every button is red"), through the use of the universal quantifier (implemented as one or more Horn Clauses in Prolog). The system also supported anaphora ("the green button ...").

Support for general statements (or "dynamic sets"), alongside with anaphora, is held to be a highly expressive feature of natural languages, that could be profitably imitated in programming languages. [(see: Beyond AOP)](./quotes.md#beyond-aop)

## Problems of the Prolog Approach
The main problems of this setup were:

* The attributes of an entity had to be declared beforehand and then mapped to the actual attributes on the js object, when they would otherwise be already available in js. This is duplication of effort.

* More generally, the state of the Brain has to be kept in sync with the state of the UI.

* At least on a first approximation, attributes of an entity had to be treated as equal entities in the global namespace, this doesn't scale.

* Dealing with mutually exclusive values of a property (eg: the color of a button) is difficult, you need a general way of dealing with contraddictions in Prolog, which complicates the style of Prolog clauses employed. [(see: SWORIER)](./quotes.md#sworier-dealing-with-contraddictions)

* Also, it's hard to make sure these are all paraphrases of each other: "the color of the button is red", "the button is red", "the background of the style of the button is red" ...

* More generally, Prolog isn't good at building ontologies and dealing with mutating knowledge bases out of the box.

<!-- link to paper about SWORIER -->

<!-- link to paper about ontology -->

# No Prolog Approach

An alternative idea was motivated by the following characteristics of the Javascript programming language:

* Prototypes.

* Polymorphism.

* The possibility to extend prototypes (even native ones) **dynamically**.

<!-- cfr: decorator pattern -->

The current simplified architecture is this:

<img src='./res/architecture.png' width='500'/>

The Parser and the AST-to-Clause conversion mechanism remain more or less unchanged. The Actuator is also still present, but is seen in a very different light. The Prolog and Entity Dictionary components merge into the single "Enviro" object, which holds the variable bindings, and is more akin to the "environment/scope" structure of a conventional programming language, although it can be queried through Clauses for the purpose of resolving anaphora.
<!-- https://lisperator.net/pltut/eval1/ -->

The "knowledge base" is now handled in a decentralized manner: each object knows exactly what predicates apply to itself and can tell, and the same predicate can result in different (polymorphic) behaviors if applied to different objects.

## Concepts

The following mechanisms were added for experimentation:

* Property aliasing (eg: 'style.background' is simply 'color').

* Concept-based grouping of predicates (eg: 'red', 'green', 'blue' refer to the 'color' Concept). A concept, relative to an object, is mapped to a single property or alias (let's start simple).

The addition of these mechanisms was motivated by the need for flexibility in paraphrasing a sentence (eg: "the button is red" == "the color of the button is red" == "the background of the style of the button is red"); as well as the need for the definition of polymorphic behavior across different classes of things (eg: a paragraph object could default to applying colors to its foreground rather than its background).

The idea of a Concept is based on ideas taken from ontology modelling.

<!-- link to ontology paper -->

## Generalization

Generalization can be handled by defining a Concept or applying a predicate not on a regular object, but on a prototype instead (eg: `HTMLElement.prototype`).

## Current State


### Custom Concepts

Right now the goal is to define and implement a general syntax for the definition of custom Concepts and predicates.

### [Bootstrapping](./quotes.md#bootstrapping)

The idea is to create a minimal subset of the language as a natural language sugar-coat over Javascript [(cf. Natural Java)](./quotes.md#natural-java-paper). It would correspond to how some programmer could "declaim" a line of code, in correct (albeit dull) English. It has a minimum level of flexibility.


Examples:

| Minimal Subset     | Javascript |
| ----------- | ----------- |
| background of style of x is red.       | x.style.background = 'red'    |
| invoke push on x with 1.  | x.push(1)      |
|invoke appendChild on x with y. | x.appendChild(y) |

There would then be a set of mechanisms (like Concept-defining statements) to create higher level abstractions, bootstrapped onto the basic js-like subset of the language, eg:

```
background of style of any x is color of x.
```

or even:

```
background of style of any x is its color.
```