# Naturalistic Programming Language Approach

That's it. Full blown naturalistic programming language. After this, the next
step will be to make a naturalistic front-end and a voice interface.

# Language Constructs:

- Naturalistic Types:
  - the "something/any" concept
  - simple concept
  - property types
  - condition types
    - where
    - which/who
    - whose
    - with
  - negation types
  - quantified types

- Naturalistic Constructors

- References:
  - Direct
  - Implicit (through Naturalistic Types)
  - Multiple and/or
  - Every

- Decider-method Definition
- Doer-method Definition

- Sentences:
  - Does-sentence / method invocation with named arguments
    - the argument names are going to be prepositions/grammatical cases
  - Comparative Sentence
  - Is Sentence
  - Is A Sentence
  - Has Sentence
  - Has A Sentence
  - Or Sentence
  - And Sentence
  - Not the case Sentence
  - There is sentence
  - If Sentence ?

- Literals (number, string, boolean)

- Math expressions

- (implicit) class/type defintions through method and has-a definitions

## Notes

- no need to explicitly declare concepts mostly
- some sentences can have a dual meaning, side-effect and non-side-effect laden
- verbs can be implemented through functions (detached from any class)

# Advice Taker

- types are elaborated as concepts in the conceptual model
- world model for compile time analysis
- findAll() for implicit reference resolution
- test() for there is sentences
- defaults
- integrated explainable debugger?
