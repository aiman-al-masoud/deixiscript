# Value of a predicate


"value of wide is 50vw"

Should the value be polymorphic, eg: "value of wide is 50vw ON BUTTONS"?

[cf 1](#lexemes-as-objects)

More generally: any kind of lexeme should be definable from language itself.

# Composite Concepts

1. any dangerous button is red, the width of it is 20vw, the height of it is 10vh.
1. x is a dangerous button.

... and how to discern between the "CopositeConcept" action and the current MultiEdit action?

[cf 1](#preposition-verb-duality)

# Refactor toClause()

Now toClause() doesn't have any hard coded names.

# Macros and syntagms

Now no hardcoded "grammar" names [cf 1](#more-powerful-macro-patterns)

# Actions as objects

ActionWrapper or wrap(action) [cf 1](#aop-support), [cf 2](#object-vs-action-pronoun)

# AOP support 

cf: statement level anaphora/temporal referencing/out of order execution.

console logs something before any x is red.

x is red. before that then x is a button.


# Full Negation

Negation as undoing any particular action, requires general solution when no ad hoc solution is available.

A general solution could be:

At any edit action A1 on an object X, a new copy is made of X and is kept up to date, except for what happened at A1.

When "A1 is negated" the copy is retrieved and it "replaces" (how?) the current object X.

# Boolean Props

hidden of x is true/false, bugs.

# String Literals 

... and their representation as objects. [related to](#more-powerful-macro-patterns).

# More powerful macro patterns

string is open quote then any except open quote then close quote [cf 1](#macro-circularity-problems)

# Macro Circularity Problems

Maybe: if any lexeme is a "grammar" type in a sentence, all other nouns are turned into "grammar" types

Proposed solution (DONE):
1. eliminate explicit references to constituent names in toClause() 
2. add contextual lexing rule to determine that any noun in a macro context is a grammar

Problem to fix is that I reverted to the usage of hyphen for mult-word constituent names ('copula-sentence' ...)

Removed the 'any' LexemeType because it would cause sentences with the 'any' universal quantifier to be classified as macro context in dynamicLexme().

# Verb-Adjective Duality

These should be equivalent, regardless of whether there's an prop or a method on the javascript object:

* x hides
* x is hidden

Boolean props (like hidden) could trigger Wrapper to add extra method to itself (like hide()) so that contextual lexer can pick up the verb.

And even these:

* x clicks
* x is clicked

Methods such as click could add a "prop" that just calls the method??

# Preposition-Verb Duality

These should be equivalent:

* x is on y
* y appendChilds x
* position of x is y

... and the problem of defining it:

* any x is on any y iff x appendChilds y.
* any y is position of any x iff y appendChilds x.
* any x is dangerous iff x is big and x is red.

# Passive/Active voice Duality

Should be equivalent

* x appendChilds y
* y is appendChilded by x

# Lexemes as objects

Maybe lexemes should be objects. Maybe each lexeme should have multiple types.

# Eager Lexer Problem:

Eager lexer lexes everything before new grammar pieces start getting added as lexemes, so you cannot run one single string as startup command, because eager lexer has it all lexed at the beginning.


# Position and other relational concepts

"position of button"


# And Sentence Bugs

"x and y are buttons and every button is green"

problem is probably due to two ands in one sentence.


# Object vs Action pronoun

need a way to favor (regular) objects in lastReferenced/pronoun/it business, or else the last action becomes the last referenced object and breaks stuff:


1. x is a button.
1. it is black. // "it" should be "the button", not the "x is a button" action!


# First/Last

Order established by incremental ID, eg:

* the first button ----> button with smallest ID
* the last button -----> button with largest ID
* the third button -----> button with third ID

Also N first/last:

"the first 3 buttons" ---> first(X),button(X),3(X)

[cf 1](#biggestsmallest)

# Biggest/Smallest

For sortable types such as real numbers.

[cf 1](#firstlast)

# Plurals

Should be taken into account!

* the buttons are red === every button is red === button(X),red(X)

Should add rule in makeImply() to turn clauses with a plural lexeme into implications, but there is a problem with and sentences such as:

"x and y and z are colors"

Temporary Solution: in toClause(), don't call makeImply() if current ast is and sentence. Plurals work.

It would be great if (x and y and z) would just behave like a noun phrase... 
BUT this is a problem for and-sentence: 'x is a button and it is red' if noun-phrase contains 'and then noun-phrase' because left copula sentence gets parsed but within it there is the 'and it' and-phrase!


# And between consecutive adjectives

Can and between ajectives be safely removed, to allow for desired meaning without complicating andToClause()?

big and red ------> big red

# Possessive Adjectives

x is a button and **its** color is red.


# Fix And.query()

it's probably wrong (not entirely right).

# Full Subordinate Clauses

* The button that is blue (OK)
* The button that is on the red div
* The button that is appendChilded by x
* The div that appendChilds the button 
* ...

* every button that is not red (BUG!)

# Breaking down Actions

A button is red.
The last instruction repeats. // full, or just "is red" or just "is button"


# Child Wrapper convey props

test 8 used to fail because child wrapper doesn't convey props to parent.

this also affected: "color of button is yellow"

Need to set name of child when creating it from parent in get(), because the name of the child is part of the chain of props.

(DONE): ugly solution soon to be refactored

# Numbers

numerical types, operations implemented as verbs===methods.

1. x is 1 
1. y is 2
1. z is x plus y

# Return values become it

return values of verbs should become the latest entity in the global namespace.


# BUG Third person s treated as plural s

x adds y
x(id27),y(id28) ---> add(id27,id28) (WRRRRRONG!)

FIXED: check if lexeme is noun in isPlural()

# BUG

value of number being treated as simplePredicate even after reassignment

# Object to Object comparisons (AND ASSIGNMENTS!)

if both objects on left and right side of copula, call "Wrapper.compare()".

1. x is 1
1. y is 1
1. if x is y then b is a red button


# How about some "low level" direct js access?

* add of any number is "(a)=>this+a"

