# Value of a predicate


"value of wide is 50vw"

Should the value be polymorphic, eg: "value of wide is 50vw ON BUTTONS"?

[cf 1](#lexemes-as-objects)

More generally: any kind of lexeme should be definable from language itself.

* button is a noun and proto of button is HTMLButtonElement.
* every is a uniquant.
* if is a subconj.
* ...

Potential problem with [macro context](#macro-circularity-problems) solution in context sensitive lexer. And more generally problem with macros.

Currently solved by the fact that macros can't contain: ['and', 'a', 'an', 'the']

eg:

* 'x is adjective' // is macro
* 'x is an adjective' // not macro 


# Composite Concepts

1. any dangerous button is red, the width of it is 20vw, the height of it is 10vh.
1. x is a dangerous button.

... and how to discern between the "CopositeConcept" action and the current MultiEdit action?

[cf 1](#preposition-verb-duality)

# Refactor toClause()

Now toClause() doesn't have any hard coded names.

# Macros and syntagms

Now no hardcoded "grammar" names [cf 1](#more-powerful-macro-patterns)

# Actions as objects

ActionWrapper or wrap(action) [cf 1](#aop-support), [cf 2](#object-vs-action-pronoun)

# AOP support 

cf: statement level anaphora/temporal referencing/out of order execution.

console logs something before any x is red.

x is red. before that then x is a button.


# Full Negation

Negation as undoing any particular action, requires general solution when no ad hoc solution is available.

A general solution could be:

At any edit action A1 on an object X, a new copy is made of X and is kept up to date, except for what happened at A1.

When "A1 is negated" the copy is retrieved and it "replaces" (how?) the current object X.

# Boolean Props

hidden of x is true/false, bugs.

# String Literals 

... and their representation as objects. [related to](#more-powerful-macro-patterns).

# More powerful macro patterns

string is open quote then any except open quote then close quote [cf 1](#macro-circularity-problems)

# Macro Circularity Problems

Maybe: if any lexeme is a "grammar" type in a sentence, all other nouns are turned into "grammar" types

Proposed solution (DONE):
1. eliminate explicit references to constituent names in toClause() 
2. add contextual lexing rule to determine that any noun in a macro context is a grammar

Problem to fix is that I reverted to the usage of hyphen for mult-word constituent names ('copula-sentence' ...)

Removed the 'any' LexemeType because it would cause sentences with the 'any' universal quantifier to be classified as macro context in dynamicLexme().

# Verb-Adjective Duality

These should be equivalent, regardless of whether there's an prop or a method on the javascript object:

* x hides
* x is hidden

Boolean props (like hidden) could trigger Wrapper to add extra method to itself (like hide()) so that contextual lexer can pick up the verb.

And even these:

* x clicks
* x is clicked

Methods such as click could add a "prop" that just calls the method??

# Preposition-Verb Duality

These should be equivalent:

* x is on y
* y appendChilds x
* position of x is y

... and the problem of defining it:

* any x is on any y iff x appendChilds y.
* any y is position of any x iff y appendChilds x.
* any x is dangerous iff x is big and x is red.

Maybe should introduce Lexeme.order, for order of arguments (subject, object) of a preposition/verb to compare and transform. (eg: 'owns' vs 'of')

# Passive/Active voice Duality

Should be equivalent

* x appendChilds y
* y is appendChilded by x

# Lexemes as objects

Maybe lexemes should be objects. Maybe each lexeme should have multiple types.

Lexemes and Actions should be "discouraged" from appearing as anaphora, "regular" (structure) objects should appear first.

the color of the button is red // a button object

proto of the button lexeme is HTMLButtonElement // the lexeme

Maybe Lexeme subclass of BaseWrapper with overridden clause() that requires a "lexeme" lexeme to return anything non-empty.

# Lexemes Adopt decentralized, normalized model.

PROBLEM: Lexeme.type is used everywhere, with normalized model type could be undefined 'cuz it points to root's type. No reference to root on Lexeme, need to fetch it from Context...

Solution: each LexemeObject (new class) has link to root, in case it has one.

in dynamicLexme() now Wrapper.dynamic:Lexeme[] is called for each heuristically grabbed object, and queried word is searched amongst all of the dynamic lexemes. No more Wrapper.typeOf().

Lexeme.extrapolate() (also used in dynamicLexeme()) to obtain all extrapolated declinations/conjugations of any given Lexeme.


```javascript
{
	root : 'be'	
},
{
	root : 'be', // points to root lexeme 'be'
	token : 'are',
	cardinality : '2+', // this is a plural
	person : [2, 3]
},
{
	root : 'be',
	token : 'is',
	cardinality : 1,
	person : [3]
},
{
	root : 'button',
	proto : 'HTMLButtonElement',
	type : 'noun'

},
{
	root : 'button',
	token : 'buttons',
	cardinality : '2+',
	case : '*', // could be any among nominative, accusative, genitive, dative
	type : 'noun'
},
{
	root : 'of',
	type : 'preposition',
	argsOrder : 'obj-subj',	
},
{
	root : 'of',
	type : 'mverb',
	token : 'own',
	argsOrder: 'subj-obj'
},
{
	root : 'own', // inherits from token of previous lexeme 'own' up there
	token : 'owns',
	cardinality : 1,
	person : [3],
}
```


# Lexeme getter
config.getLexeme()


# Lexer Problems

* Eager lexer lexes everything before new grammar pieces start getting added as lexemes, so you cannot run one single string as startup command, because eager lexer has it all lexed at the beginning.

* Other problem with lexer: it cannot discern distinct but concatenated "words", such as 1+1

# Position and other relational concepts

"position of button"


# And Sentence Bugs

"x and y are buttons and every button is green"

problem is probably due to two ands in one sentence.


# Object vs Action pronoun

need a way to favor (regular) objects in lastReferenced/pronoun/it business, or else the last action becomes the last referenced object and breaks stuff:


1. x is a button.
1. it is black. // "it" should be "the button", not the "x is a button" action!


# First/Last

Order established by incremental ID, eg:

* the first button ----> button with smallest ID
* the last button -----> button with largest ID
* the third button -----> button with third ID

Also N first/last:

"the first 3 buttons" ---> first(X),button(X),3(X)

[cf 1](#biggestsmallest)

# Biggest/Smallest

For sortable types such as real numbers.

[cf 1](#firstlast)

# Plurals

Should be taken into account!

* the buttons are red === every button is red === button(X),red(X)

Should add rule in makeImply() to turn clauses with a plural lexeme into implications, but there is a problem with and sentences such as:

"x and y and z are colors"

Temporary Solution: in toClause(), don't call makeImply() if current ast is and sentence. Plurals work.

It would be great if (x and y and z) would just behave like a noun phrase... 
BUT this is a problem for and-sentence: 'x is a button and it is red' if noun-phrase contains 'and then noun-phrase' because left copula sentence gets parsed but within it there is the 'and it' and-phrase!


# And between consecutive adjectives

Can and between ajectives be safely removed, to allow for desired meaning without complicating andToClause()?

big and red ------> big red

# Possessive Adjectives

x is a button and **its** color is red.


# Fix And.query()

it's probably wrong (not entirely right).

# Full Subordinate Clauses

* The button that is blue (OK)
* The button that is on the red div
* The button that is appendChilded by x
* The div that appendChilds the button 
* ...

* every button that is not red (BUG!)

# Breaking down Actions

A button is red.
The last instruction repeats. // full, or just "is red" or just "is button"


# Child Wrapper convey props

test 8 used to fail because child wrapper doesn't convey props to parent.

this also affected: "color of button is yellow"

Need to set name of child when creating it from parent in get(), because the name of the child is part of the chain of props.

(DONE): ugly solution soon to be refactored

# Numbers

numerical types, operations implemented as verbs===methods.

1. x is 1 
1. y is 2
1. z is x plus y

# Numbers as a CompositeType

* digit is 0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9
* number is one or more digits

related to [string literals](#string-literals)


# Return values become it

return values of verbs should become the latest entity in the global namespace.


# BUG Third person s treated as plural s

x adds y
x(id27),y(id28) ---> add(id27,id28) (WRRRRRONG!)

FIXED: check if lexeme is noun in isPlural()

# BUG

value of number being treated as simplePredicate even after reassignment

# Object to Object comparisons (AND ASSIGNMENTS!)

if both objects on left and right side of copula, call "Wrapper.compare()".

1. x is 1
1. y is 1
1. if x is y then b is a red button


# How about some "low level" direct js access?

* add of any number is "(a)=>this+a"


# Phatic words, fillers and partial parsing

"then" is needed and currenlty employed as a filler, it is used as a delimiter.

Some words should be ignored all the time ("uhm", "errm", "ah", "oh"...)

Maybe some words should be treated as "fillers"/phatics and ignored just in some contexts! (please)

# Naturalistic iterators

with [actions as objects](#actions-as-objects), eg:

* The next 2 actions repeat while x < 10.
* x increments.
* console logs x.

As well as:

* x increments.
* console logs x.
* The previous 2 actions repeat while x < 10.


# Verb (method) definition

with [actions as objects](#actions-as-objects), eg:

* The next 3 actions are blink of any button.
* the button is red.
* the button is green.
* the button is red.

defines a new intransitive verb "blink" on (attaches a method without args other than self) to the button prototype.


# Morphology

* Extract basic hardcoded English morphology that remains to be extracted. 
* Make a more general morphological model to support languages that are more synthetic than English.


# Case Insensitivity

https://stackoverflow.com/questions/12484386/access-javascript-property-case-insensitively
