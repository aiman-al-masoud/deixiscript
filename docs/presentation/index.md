TOTAL 22 mins

# Greetings & Title

Good morning everyone. The title of my thesis is: Deixiscript: Exploring and Implementing a Common Sense Approach to Naturalistic Programming.

# Naturalistic Programming: what is it, why is it relevant

Let's start by defining what we mean by naturalistic programming, and why we think it is relevant today. 

Naturalistic programming is broadly understood as the attempt to write computer code in a some subset of natural language. 

A subset: because natural language (despite the apperences) is an intricate system, and up until recently, it had never seen wide usage in programming. 

Natural language is not only objectively difficult to interpret on a computer, it can also be vague and ambigious. 

This is why attempts to use it for programming have been widely disregarded, even by prominent critics such as Edsger Dijsktra [SHOW QUOTE].

There are reasons to think that the status quo is about to change drastically. The introduction of Large Language Models (or LLMs)  ...through Prompt Engineering and AI-Assisted coding... is rapidly changing the way programmers write code. 

Matt Welsh, a computer scientist, thinks that this transformation very soon: according to him, in the arc of 10 to 30 years the whole field of computer science won't be remotely recognizable.

Traditional programming languages may become (virtually) extinct, being supplanted by natural language for most applications.

This will bring benefits: as more people will be able to do more things with computers, and we surely hope so, but there will be the negative aspects. 

From a purely scientific viewpoint, it is hard to be content with developing larger and larger deep learning models that simply work as black boxes that process language.

Eminent linguists and thinkers such as Noam Chomsky have expressed doubts regarding the LLMs' capacity to model language acquisition in humans: they can learn artificial languages just as easily.

From our point of view we think that it is paramount to understand how natural language is better (and how it is worse) than programming languages at describing computer programs.

# Programming Languages History

Just like natural languages, programming languages change and evolve during time. You can see here a timeline of only some of the most important ones here. 

Programming languages tend to follow a programming paradigm (and some are multiparadigm). The four most popular ones of all times are: procedural, functional, object oriented and logic. These paradigms in turn can be classified as declarative or imperative.

# The need for naturalistic programming
    - precision/expressiveness tradeoff
    - semantic gap & scattering of ideas (some examples)
# Natural Style
    - implicit references
    - universal quantification
    - revisable rules
    - implied knowledge
# Existing Work (maybe timeline)
    - Literate Programming
    - Metafor
    - Pegasus
    - CAL
    - SN
    - Inform 7
<!-- # Prompt Engineering
    - LLMs
    - prompt structure
    - techniques
        - single-shot
        - few-shot
        - CoT
    - LLM settings
    - Risks
        factuality
        bias
        prompt injection
        prompt leaking
        jailbreaking
    - AI assisted coding
    - why not enough -->
# Criticism of natural language programming
    - a lack of precision
    - verbosity
    - are legal documents really natural language?
    - what is natural anyway in SW?
# Essence of Naturalistic Programming
    - high-level/low-level integration
    - reads almost as English
    - moderate use of implicit references
    - revisable rules
    - error reporting in natural style
    - declarative (with compromises) 
# Common Sense in relation to naturalistic programming
    - what is common sense
    - points in common with NP
        - disambiguation & implied knowledge
        - revisable rules
        - automated planning & declarative programming
# Deixiscript
    - origin of name 
    - goals and non goals
    - evolution
# Implementation Details
    - language
    - libraries & licenses
    - parser
    - functional style 
    - interpreter pattern
# Simple Sentences & Noun Phrases
    - the simple sentence
    - ASK/TELL
    - must be defined
    - the noun phrase
# Syntax matching
    - Definitions
# Knowledge Base
    - world model
    - short term memory
# Orders and planning
    - facts vs events
    - potentials
    - search heuristic
# Pronouns Example
# Fish Example
# Player/Enemy Example
# Player/Enemy/Defender Example
# Improvements
    - syntactic compression
    - semantic compression
    - better heuristics
# Extensions
    - voice programming
# Final Remarks
    - natural language will grow in importance
# Thank You!


<!-- 
Image Sources
https://www.javatpoint.com/what-is-machine-language
https://www.discovercoding.ca/hello-world-mips-assembly/
https://it.wikipedia.org/wiki/Fortran#/media/File:Fortran_acs_cover.jpeg 
-->