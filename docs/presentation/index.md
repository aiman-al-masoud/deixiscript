TOTAL 22 mins

# Greetings & Title

Good morning everyone. The title of my thesis is: Deixiscript: Exploring and Implementing a Common Sense Approach to Naturalistic Programming.

# Naturalistic Programming: what is it, why is it relevant

Naturalistic programming is broadly understood as the attempt to write computer code in a some subset of natural language. 

Natural language (despite the apperences) is an intricate system, and up until recently, it had never seen wide usage in programming. 

Natural language can be vague and ambiguous, this is why attempts to use it for programming have been widely disregarded, even by prominent critics such as Edsger Dijsktra [SHOW QUOTE].

There are reasons to think that the status quo is about to change drastically. The introduction of Large Language Models (or LLMs), and of Prompt Engineering and AI-Assisted coding, is rapidly changing the way programmers write code. 

Matt Welsh, a computer scientist, thinks that in the arc of 10 to 30 years the whole field of computer science won't be remotely recognizable. 

Traditional programming languages may become (virtually) extinct.

This will bring benefits: as more people will be able to do more things with computers, but there will be the negative aspects. 

From a purely scientific viewpoint, it is hard to be content with developing larger and larger deep learning black boxes.

Eminent linguists and thinkers such as Noam Chomsky have expressed doubts regarding the LLMs' capacity to model language acquisition in humans: they can learn artificial languages just as easily.

From our point of view we think that it is paramount to understand how natural language is better (and how it is worse) than programming languages at describing computer programs.

# Programming Languages History

Just like natural languages, programming languages change and evolve during time. You can see here a timeline of only some of the most important ones here. 

Programming languages tend to follow a programming paradigm (and some are multiparadigm). 

The four most popular ones of all times are: procedural, functional, object oriented and logic. 

These paradigms in turn can be classified as declarative or imperative. 

As we all know, declarative programming is about telling the computer what has to be done. Imperative programming puts more focus on the how.

# The need for naturalistic programming

Programming languages are precise, but there is a tradeoff between the precision and the expressiveness of a language. 

As is shown in this graph from a survey on Controlled Natural Languages (a kind of naturalistic language).

There is also the issue of semantic gap: there is a wider gap between the concepts easily represented in programming languages and the natural human way of describing things.

This sometimes leads to the scattering of ideas in code: it may take disproportionate effort to understand even simple logic expressed in a programming language, versus the same concept expressed in natural language.

Past experiences with new paradigms (such as Aspect Oriented Programming) have shown that it is possible to incorporate new ideas from natural languages into the artificial ones.

# Existing Work (maybe timeline)
    - Pegasus
    - CAL
    - SN
    - Inform 7
    - Literate Programming?
    - Metafor?

# Naturalistic Ideas
    - high-level/low-level integration
    - reads almost as English
    - implicit references
    - implied knowledge
    - revisable rules
    - error reporting in natural style
    - declarative (with compromises) 
    - universal quantification ?

# Common Sense in relation to naturalistic programming
    - what is common sense
    - points in common with NP
        - disambiguation & implied knowledge
        - revisable rules
        - automated planning & declarative programming

# Criticism of natural language programming
    - a lack of precision
    - verbosity
    - are legal documents really natural language?
    - what is natural anyway in SW?

# Deixiscript
    - origin of name 
    - goals and non goals
    - evolution
# Implementation Details
    - language
    - libraries & licenses
    - parser
    - functional style 
    - interpreter pattern

# interpreter pattern

# Simple Sentences
    - the simple sentence
    - ASK/TELL
    - must be defined
# noun phrases
    -
# Syntactic matching
    - Definitions
# Knowledge Base
    - world model
    - short term memory
# Orders and planning
    - facts vs events
    - potentials
    - search heuristic
# Pronouns Example
# Fish Example
# Player/Enemy Example
# Player/Enemy/Defender Example
# Improvements
    - syntactic compression
    - semantic compression
    - better heuristics
# Extensions
    - voice programming
# Final Remarks
    - natural language will grow in importance
# Thank You!


<!-- 
Image Sources
https://www.javatpoint.com/what-is-machine-language
https://www.discovercoding.ca/hello-world-mips-assembly/
https://it.wikipedia.org/wiki/Fortran#/media/File:Fortran_acs_cover.jpeg 
https://www.iconfinder.com/icons/109573/dead_fish_pollution_raw_simple_waste_icon
https://www.onlinewebfonts.com/icon/499063

-->


