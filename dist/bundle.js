/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/readline-sync/lib/readline-sync.js":
/*!*********************************************************!*\
  !*** ./node_modules/readline-sync/lib/readline-sync.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __dirname = "/";
/*
 * readlineSync
 * https://github.com/anseki/readline-sync
 *
 * Copyright (c) 2018 anseki
 * Licensed under the MIT license.
 */



var
  IS_WIN = process.platform === 'win32',

  ALGORITHM_CIPHER = 'aes-256-cbc',
  ALGORITHM_HASH = 'sha256',
  DEFAULT_ERR_MSG = 'The current environment doesn\'t support interactive reading from TTY.',

  fs = __webpack_require__(/*! fs */ "?b05a"),
  TTY = process.binding('tty_wrap').TTY,
  childProc = __webpack_require__(/*! child_process */ "?a95c"),
  pathUtil = __webpack_require__(/*! path */ "?1b04"),

  defaultOptions = {
    /* eslint-disable key-spacing */
    prompt:             '> ',
    hideEchoBack:       false,
    mask:               '*',
    limit:              [],
    limitMessage:       'Input another, please.$<( [)limit(])>',
    defaultInput:       '',
    trueValue:          [],
    falseValue:         [],
    caseSensitive:      false,
    keepWhitespace:     false,
    encoding:           'utf8',
    bufferSize:         1024,
    print:              void 0,
    history:            true,
    cd:                 false,
    phContent:          void 0,
    preCheck:           void 0
    /* eslint-enable key-spacing */
  },

  fdR = 'none', fdW, ttyR, isRawMode = false,
  extHostPath, extHostArgs, tempdir, salt = 0,
  lastInput = '', inputHistory = [], rawInput,
  _DBG_useExt = false, _DBG_checkOptions = false, _DBG_checkMethod = false;

function getHostArgs(options) {
  // Send any text to crazy Windows shell safely.
  function encodeArg(arg) {
    return arg.replace(/[^\w\u0080-\uFFFF]/g, function(chr) {
      return '#' + chr.charCodeAt(0) + ';';
    });
  }

  return extHostArgs.concat((function(conf) {
    var args = [];
    Object.keys(conf).forEach(function(optionName) {
      if (conf[optionName] === 'boolean') {
        if (options[optionName]) { args.push('--' + optionName); }
      } else if (conf[optionName] === 'string') {
        if (options[optionName]) {
          args.push('--' + optionName, encodeArg(options[optionName]));
        }
      }
    });
    return args;
  })({
    /* eslint-disable key-spacing */
    display:        'string',
    displayOnly:    'boolean',
    keyIn:          'boolean',
    hideEchoBack:   'boolean',
    mask:           'string',
    limit:          'string',
    caseSensitive:  'boolean'
    /* eslint-enable key-spacing */
  }));
}

// piping via files (for Node.js v0.10-)
function _execFileSync(options, execOptions) {

  function getTempfile(name) {
    var filepath, suffix = '', fd;
    tempdir = tempdir || (__webpack_require__(/*! os */ "?a1b8").tmpdir)();

    while (true) {
      filepath = pathUtil.join(tempdir, name + suffix);
      try {
        fd = fs.openSync(filepath, 'wx');
      } catch (e) {
        if (e.code === 'EEXIST') {
          suffix++;
          continue;
        } else {
          throw e;
        }
      }
      fs.closeSync(fd);
      break;
    }
    return filepath;
  }

  var hostArgs, shellPath, shellArgs, res = {}, exitCode, extMessage,
    pathStdout = getTempfile('readline-sync.stdout'),
    pathStderr = getTempfile('readline-sync.stderr'),
    pathExit = getTempfile('readline-sync.exit'),
    pathDone = getTempfile('readline-sync.done'),
    crypto = __webpack_require__(/*! crypto */ "?4ec4"), shasum, decipher, password;

  shasum = crypto.createHash(ALGORITHM_HASH);
  shasum.update('' + process.pid + (salt++) + Math.random());
  password = shasum.digest('hex');
  decipher = crypto.createDecipher(ALGORITHM_CIPHER, password);

  hostArgs = getHostArgs(options);
  if (IS_WIN) {
    shellPath = process.env.ComSpec || 'cmd.exe';
    process.env.Q = '"'; // The quote (") that isn't escaped.
    // `()` for ignore space by echo
    shellArgs = ['/V:ON', '/S', '/C',
      '(%Q%' + shellPath + '%Q% /V:ON /S /C %Q%' + /* ESLint bug? */ // eslint-disable-line no-path-concat
        '%Q%' + extHostPath + '%Q%' +
          hostArgs.map(function(arg) { return ' %Q%' + arg + '%Q%'; }).join('') +
        ' & (echo !ERRORLEVEL!)>%Q%' + pathExit + '%Q%%Q%) 2>%Q%' + pathStderr + '%Q%' +
      ' |%Q%' + process.execPath + '%Q% %Q%' + __dirname + '\\encrypt.js%Q%' +
        ' %Q%' + ALGORITHM_CIPHER + '%Q% %Q%' + password + '%Q%' +
        ' >%Q%' + pathStdout + '%Q%' +
      ' & (echo 1)>%Q%' + pathDone + '%Q%'];
  } else {
    shellPath = '/bin/sh';
    shellArgs = ['-c',
      // Use `()`, not `{}` for `-c` (text param)
      '("' + extHostPath + '"' + /* ESLint bug? */ // eslint-disable-line no-path-concat
          hostArgs.map(function(arg) { return " '" + arg.replace(/'/g, "'\\''") + "'"; }).join('') +
        '; echo $?>"' + pathExit + '") 2>"' + pathStderr + '"' +
      ' |"' + process.execPath + '" "' + __dirname + '/encrypt.js"' +
        ' "' + ALGORITHM_CIPHER + '" "' + password + '"' +
        ' >"' + pathStdout + '"' +
      '; echo 1 >"' + pathDone + '"'];
  }
  if (_DBG_checkMethod) { _DBG_checkMethod('_execFileSync', hostArgs); }
  try {
    childProc.spawn(shellPath, shellArgs, execOptions);
  } catch (e) {
    res.error = new Error(e.message);
    res.error.method = '_execFileSync - spawn';
    res.error.program = shellPath;
    res.error.args = shellArgs;
  }

  while (fs.readFileSync(pathDone, {encoding: options.encoding}).trim() !== '1') {} // eslint-disable-line no-empty
  if ((exitCode =
      fs.readFileSync(pathExit, {encoding: options.encoding}).trim()) === '0') {
    res.input =
      decipher.update(fs.readFileSync(pathStdout, {encoding: 'binary'}),
        'hex', options.encoding) +
      decipher.final(options.encoding);
  } else {
    extMessage = fs.readFileSync(pathStderr, {encoding: options.encoding}).trim();
    res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
    res.error.method = '_execFileSync';
    res.error.program = shellPath;
    res.error.args = shellArgs;
    res.error.extMessage = extMessage;
    res.error.exitCode = +exitCode;
  }

  fs.unlinkSync(pathStdout);
  fs.unlinkSync(pathStderr);
  fs.unlinkSync(pathExit);
  fs.unlinkSync(pathDone);

  return res;
}

function readlineExt(options) {
  var hostArgs, res = {}, extMessage,
    execOptions = {env: process.env, encoding: options.encoding};

  if (!extHostPath) {
    if (IS_WIN) {
      if (process.env.PSModulePath) { // Windows PowerShell
        extHostPath = 'powershell.exe';
        extHostArgs = ['-ExecutionPolicy', 'Bypass', '-File', __dirname + '\\read.ps1']; // eslint-disable-line no-path-concat
      } else {                        // Windows Script Host
        extHostPath = 'cscript.exe';
        extHostArgs = ['//nologo', __dirname + '\\read.cs.js']; // eslint-disable-line no-path-concat
      }
    } else {
      extHostPath = '/bin/sh';
      extHostArgs = [__dirname + '/read.sh']; // eslint-disable-line no-path-concat
    }
  }
  if (IS_WIN && !process.env.PSModulePath) { // Windows Script Host
    // ScriptPW (Win XP and Server2003) needs TTY stream as STDIN.
    // In this case, If STDIN isn't TTY, an error is thrown.
    execOptions.stdio = [process.stdin];
  }

  if (childProc.execFileSync) {
    hostArgs = getHostArgs(options);
    if (_DBG_checkMethod) { _DBG_checkMethod('execFileSync', hostArgs); }
    try {
      res.input = childProc.execFileSync(extHostPath, hostArgs, execOptions);
    } catch (e) { // non-zero exit code
      extMessage = e.stderr ? (e.stderr + '').trim() : '';
      res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
      res.error.method = 'execFileSync';
      res.error.program = extHostPath;
      res.error.args = hostArgs;
      res.error.extMessage = extMessage;
      res.error.exitCode = e.status;
      res.error.code = e.code;
      res.error.signal = e.signal;
    }
  } else {
    res = _execFileSync(options, execOptions);
  }
  if (!res.error) {
    res.input = res.input.replace(/^\s*'|'\s*$/g, '');
    options.display = '';
  }

  return res;
}

/*
  display:            string
  displayOnly:        boolean
  keyIn:              boolean
  hideEchoBack:       boolean
  mask:               string
  limit:              string (pattern)
  caseSensitive:      boolean
  keepWhitespace:     boolean
  encoding, bufferSize, print
*/
function _readlineSync(options) {
  var input = '', displaySave = options.display,
    silent = !options.display &&
      options.keyIn && options.hideEchoBack && !options.mask;

  function tryExt() {
    var res = readlineExt(options);
    if (res.error) { throw res.error; }
    return res.input;
  }

  if (_DBG_checkOptions) { _DBG_checkOptions(options); }

  (function() { // open TTY
    var fsB, constants, verNum;

    function getFsB() {
      if (!fsB) {
        fsB = process.binding('fs'); // For raw device path
        constants = process.binding('constants');
      }
      return fsB;
    }

    if (typeof fdR !== 'string') { return; }
    fdR = null;

    if (IS_WIN) {
      // iojs-v2.3.2+ input stream can't read first line. (#18)
      // ** Don't get process.stdin before check! **
      // Fixed v5.1.0
      // Fixed v4.2.4
      // It regressed again in v5.6.0, it is fixed in v6.2.0.
      verNum = (function(ver) { // getVerNum
        var nums = ver.replace(/^\D+/, '').split('.');
        var verNum = 0;
        if ((nums[0] = +nums[0])) { verNum += nums[0] * 10000; }
        if ((nums[1] = +nums[1])) { verNum += nums[1] * 100; }
        if ((nums[2] = +nums[2])) { verNum += nums[2]; }
        return verNum;
      })(process.version);
      if (!(verNum >= 20302 && verNum < 40204 || verNum >= 50000 && verNum < 50100 || verNum >= 50600 && verNum < 60200) &&
          process.stdin.isTTY) {
        process.stdin.pause();
        fdR = process.stdin.fd;
        ttyR = process.stdin._handle;
      } else {
        try {
          // The stream by fs.openSync('\\\\.\\CON', 'r') can't switch to raw mode.
          // 'CONIN$' might fail on XP, 2000, 7 (x86).
          fdR = getFsB().open('CONIN$', constants.O_RDWR, parseInt('0666', 8));
          ttyR = new TTY(fdR, true);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('\\\\.\\CON', 'w');
        } catch (e) { /* ignore */ }
        if (typeof fdW !== 'number') { // Retry
          try {
            fdW = getFsB().open('CONOUT$', constants.O_RDWR, parseInt('0666', 8));
          } catch (e) { /* ignore */ }
        }
      }

    } else {
      if (process.stdin.isTTY) {
        process.stdin.pause();
        try {
          fdR = fs.openSync('/dev/tty', 'r'); // device file, not process.stdin
          ttyR = process.stdin._handle;
        } catch (e) { /* ignore */ }
      } else {
        // Node.js v0.12 read() fails.
        try {
          fdR = fs.openSync('/dev/tty', 'r');
          ttyR = new TTY(fdR, false);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('/dev/tty', 'w');
        } catch (e) { /* ignore */ }
      }
    }
  })();

  (function() { // try read
    var atEol, limit,
      isCooked = !options.hideEchoBack && !options.keyIn,
      buffer, reqSize, readSize, chunk, line;
    rawInput = '';

    // Node.js v0.10- returns an error if same mode is set.
    function setRawMode(mode) {
      if (mode === isRawMode) { return true; }
      if (ttyR.setRawMode(mode) !== 0) { return false; }
      isRawMode = mode;
      return true;
    }

    if (_DBG_useExt || !ttyR ||
        typeof fdW !== 'number' && (options.display || !isCooked)) {
      input = tryExt();
      return;
    }

    if (options.display) {
      fs.writeSync(fdW, options.display);
      options.display = '';
    }
    if (options.displayOnly) { return; }

    if (!setRawMode(!isCooked)) {
      input = tryExt();
      return;
    }

    reqSize = options.keyIn ? 1 : options.bufferSize;
    // Check `allocUnsafe` to make sure of the new API.
    buffer = Buffer.allocUnsafe && Buffer.alloc ? Buffer.alloc(reqSize) : new Buffer(reqSize);

    if (options.keyIn && options.limit) {
      limit = new RegExp('[^' + options.limit + ']',
        'g' + (options.caseSensitive ? '' : 'i'));
    }

    while (true) {
      readSize = 0;
      try {
        readSize = fs.readSync(fdR, buffer, 0, reqSize);
      } catch (e) {
        if (e.code !== 'EOF') {
          setRawMode(false);
          input += tryExt();
          return;
        }
      }
      if (readSize > 0) {
        chunk = buffer.toString(options.encoding, 0, readSize);
        rawInput += chunk;
      } else {
        chunk = '\n';
        rawInput += String.fromCharCode(0);
      }

      if (chunk && typeof (line = (chunk.match(/^(.*?)[\r\n]/) || [])[1]) === 'string') {
        chunk = line;
        atEol = true;
      }

      // other ctrl-chars
      // eslint-disable-next-line no-control-regex
      if (chunk) { chunk = chunk.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]/g, ''); }
      if (chunk && limit) { chunk = chunk.replace(limit, ''); }

      if (chunk) {
        if (!isCooked) {
          if (!options.hideEchoBack) {
            fs.writeSync(fdW, chunk);
          } else if (options.mask) {
            fs.writeSync(fdW, (new Array(chunk.length + 1)).join(options.mask));
          }
        }
        input += chunk;
      }

      if (!options.keyIn && atEol ||
        options.keyIn && input.length >= reqSize) { break; }
    }

    if (!isCooked && !silent) { fs.writeSync(fdW, '\n'); }
    setRawMode(false);
  })();

  if (options.print && !silent) {
    options.print(displaySave + (options.displayOnly ? '' :
        (options.hideEchoBack ? (new Array(input.length + 1)).join(options.mask)
          : input) + '\n'), // must at least write '\n'
      options.encoding);
  }

  return options.displayOnly ? '' :
    (lastInput = options.keepWhitespace || options.keyIn ? input : input.trim());
}

function flattenArray(array, validator) {
  var flatArray = [];
  function _flattenArray(array) {
    if (array == null) {
      return;
    } else if (Array.isArray(array)) {
      array.forEach(_flattenArray);
    } else if (!validator || validator(array)) {
      flatArray.push(array);
    }
  }
  _flattenArray(array);
  return flatArray;
}

function escapePattern(pattern) {
  return pattern.replace(/[\x00-\x7f]/g, // eslint-disable-line no-control-regex
    function(s) { return '\\x' + ('00' + s.charCodeAt().toString(16)).substr(-2); });
}

// margeOptions(options1, options2 ... )
// margeOptions(true, options1, options2 ... )
//    arg1=true : Start from defaultOptions and pick elements of that.
function margeOptions() {
  var optionsList = Array.prototype.slice.call(arguments),
    optionNames, fromDefault;

  if (optionsList.length && typeof optionsList[0] === 'boolean') {
    fromDefault = optionsList.shift();
    if (fromDefault) {
      optionNames = Object.keys(defaultOptions);
      optionsList.unshift(defaultOptions);
    }
  }

  return optionsList.reduce(function(options, optionsPart) {
    if (optionsPart == null) { return options; }

    // ======== DEPRECATED ========
    if (optionsPart.hasOwnProperty('noEchoBack') &&
        !optionsPart.hasOwnProperty('hideEchoBack')) {
      optionsPart.hideEchoBack = optionsPart.noEchoBack;
      delete optionsPart.noEchoBack;
    }
    if (optionsPart.hasOwnProperty('noTrim') &&
        !optionsPart.hasOwnProperty('keepWhitespace')) {
      optionsPart.keepWhitespace = optionsPart.noTrim;
      delete optionsPart.noTrim;
    }
    // ======== /DEPRECATED ========

    if (!fromDefault) { optionNames = Object.keys(optionsPart); }
    optionNames.forEach(function(optionName) {
      var value;
      if (!optionsPart.hasOwnProperty(optionName)) { return; }
      value = optionsPart[optionName];
      switch (optionName) {
                           // _readlineSync <- *    * -> defaultOptions
        // ================ string
        case 'mask':                        // *    *
        case 'limitMessage':                //      *
        case 'defaultInput':                //      *
        case 'encoding':                    // *    *
          value = value != null ? value + '' : '';
          if (value && optionName !== 'limitMessage') { value = value.replace(/[\r\n]/g, ''); }
          options[optionName] = value;
          break;
        // ================ number(int)
        case 'bufferSize':                  // *    *
          if (!isNaN(value = parseInt(value, 10)) && typeof value === 'number') {
            options[optionName] = value; // limited updating (number is needed)
          }
          break;
        // ================ boolean
        case 'displayOnly':                 // *
        case 'keyIn':                       // *
        case 'hideEchoBack':                // *    *
        case 'caseSensitive':               // *    *
        case 'keepWhitespace':              // *    *
        case 'history':                     //      *
        case 'cd':                          //      *
          options[optionName] = !!value;
          break;
        // ================ array
        case 'limit':                       // *    *     to string for readlineExt
        case 'trueValue':                   //      *
        case 'falseValue':                  //      *
          options[optionName] = flattenArray(value, function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number' ||
              type === 'function' || value instanceof RegExp;
          }).map(function(value) {
            return typeof value === 'string' ? value.replace(/[\r\n]/g, '') : value;
          });
          break;
        // ================ function
        case 'print':                       // *    *
        case 'phContent':                   //      *
        case 'preCheck':                    //      *
          options[optionName] = typeof value === 'function' ? value : void 0;
          break;
        // ================ other
        case 'prompt':                      //      *
        case 'display':                     // *
          options[optionName] = value != null ? value : '';
          break;
        // no default
      }
    });
    return options;
  }, {});
}

function isMatched(res, comps, caseSensitive) {
  return comps.some(function(comp) {
    var type = typeof comp;
    return type === 'string' ?
        (caseSensitive ? res === comp : res.toLowerCase() === comp.toLowerCase()) :
      type === 'number' ? parseFloat(res) === comp :
      type === 'function' ? comp(res) :
      comp instanceof RegExp ? comp.test(res) : false;
  });
}

function replaceHomePath(path, expand) {
  var homePath = pathUtil.normalize(
    IS_WIN ? (process.env.HOMEDRIVE || '') + (process.env.HOMEPATH || '') :
    process.env.HOME || '').replace(/[\/\\]+$/, '');
  path = pathUtil.normalize(path);
  return expand ? path.replace(/^~(?=\/|\\|$)/, homePath) :
    path.replace(new RegExp('^' + escapePattern(homePath) +
      '(?=\\/|\\\\|$)', IS_WIN ? 'i' : ''), '~');
}

function replacePlaceholder(text, generator) {
  var PTN_INNER = '(?:\\(([\\s\\S]*?)\\))?(\\w+|.-.)(?:\\(([\\s\\S]*?)\\))?',
    rePlaceholder = new RegExp('(\\$)?(\\$<' + PTN_INNER + '>)', 'g'),
    rePlaceholderCompat = new RegExp('(\\$)?(\\$\\{' + PTN_INNER + '\\})', 'g');

  function getPlaceholderText(s, escape, placeholder, pre, param, post) {
    var text;
    return escape || typeof (text = generator(param)) !== 'string' ? placeholder :
      text ? (pre || '') + text + (post || '') : '';
  }

  return text.replace(rePlaceholder, getPlaceholderText)
    .replace(rePlaceholderCompat, getPlaceholderText);
}

function array2charlist(array, caseSensitive, collectSymbols) {
  var values, group = [], groupClass = -1, charCode = 0, symbols = '', suppressed;
  function addGroup(groups, group) {
    if (group.length > 3) { // ellipsis
      groups.push(group[0] + '...' + group[group.length - 1]);
      suppressed = true;
    } else if (group.length) {
      groups = groups.concat(group);
    }
    return groups;
  }

  values = array.reduce(
      function(chars, value) { return chars.concat((value + '').split('')); }, [])
    .reduce(function(groups, curChar) {
      var curGroupClass, curCharCode;
      if (!caseSensitive) { curChar = curChar.toLowerCase(); }
      curGroupClass = /^\d$/.test(curChar) ? 1 :
        /^[A-Z]$/.test(curChar) ? 2 : /^[a-z]$/.test(curChar) ? 3 : 0;
      if (collectSymbols && curGroupClass === 0) {
        symbols += curChar;
      } else {
        curCharCode = curChar.charCodeAt(0);
        if (curGroupClass && curGroupClass === groupClass &&
            curCharCode === charCode + 1) {
          group.push(curChar);
        } else {
          groups = addGroup(groups, group);
          group = [curChar];
          groupClass = curGroupClass;
        }
        charCode = curCharCode;
      }
      return groups;
    }, []);
  values = addGroup(values, group); // last group
  if (symbols) { values.push(symbols); suppressed = true; }
  return {values: values, suppressed: suppressed};
}

function joinChunks(chunks, suppressed) {
  return chunks.join(chunks.length > 2 ? ', ' : suppressed ? ' / ' : '/');
}

function getPhContent(param, options) {
  var text, values, resCharlist = {}, arg;
  if (options.phContent) {
    text = options.phContent(param, options);
  }
  if (typeof text !== 'string') {
    switch (param) {
      case 'hideEchoBack':
      case 'mask':
      case 'defaultInput':
      case 'caseSensitive':
      case 'keepWhitespace':
      case 'encoding':
      case 'bufferSize':
      case 'history':
      case 'cd':
        text = !options.hasOwnProperty(param) ? '' :
          typeof options[param] === 'boolean' ? (options[param] ? 'on' : 'off') :
          options[param] + '';
        break;
      // case 'prompt':
      // case 'query':
      // case 'display':
      //   text = options.hasOwnProperty('displaySrc') ? options.displaySrc + '' : '';
      //   break;
      case 'limit':
      case 'trueValue':
      case 'falseValue':
        values = options[options.hasOwnProperty(param + 'Src') ? param + 'Src' : param];
        if (options.keyIn) { // suppress
          resCharlist = array2charlist(values, options.caseSensitive);
          values = resCharlist.values;
        } else {
          values = values.filter(function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number';
          });
        }
        text = joinChunks(values, resCharlist.suppressed);
        break;
      case 'limitCount':
      case 'limitCountNotZero':
        text = options[options.hasOwnProperty('limitSrc') ?
          'limitSrc' : 'limit'].length;
        text = text || param !== 'limitCountNotZero' ? text + '' : '';
        break;
      case 'lastInput':
        text = lastInput;
        break;
      case 'cwd':
      case 'CWD':
      case 'cwdHome':
        text = process.cwd();
        if (param === 'CWD') {
          text = pathUtil.basename(text);
        } else if (param === 'cwdHome') {
          text = replaceHomePath(text);
        }
        break;
      case 'date':
      case 'time':
      case 'localeDate':
      case 'localeTime':
        text = (new Date())['to' +
          param.replace(/^./, function(str) { return str.toUpperCase(); }) +
          'String']();
        break;
      default: // with arg
        if (typeof (arg = (param.match(/^history_m(\d+)$/) || [])[1]) === 'string') {
          text = inputHistory[inputHistory.length - arg] || '';
        }
    }
  }
  return text;
}

function getPhCharlist(param) {
  var matches = /^(.)-(.)$/.exec(param), text = '', from, to, code, step;
  if (!matches) { return null; }
  from = matches[1].charCodeAt(0);
  to = matches[2].charCodeAt(0);
  step = from < to ? 1 : -1;
  for (code = from; code !== to + step; code += step) { text += String.fromCharCode(code); }
  return text;
}

// cmd "arg" " a r g " "" 'a"r"g' "a""rg" "arg
function parseCl(cl) {
  var reToken = new RegExp(/(\s*)(?:("|')(.*?)(?:\2|$)|(\S+))/g), matches,
    taken = '', args = [], part;
  cl = cl.trim();
  while ((matches = reToken.exec(cl))) {
    part = matches[3] || matches[4] || '';
    if (matches[1]) {
      args.push(taken);
      taken = '';
    }
    taken += part;
  }
  if (taken) { args.push(taken); }
  return args;
}

function toBool(res, options) {
  return (
    (options.trueValue.length &&
      isMatched(res, options.trueValue, options.caseSensitive)) ? true :
    (options.falseValue.length &&
      isMatched(res, options.falseValue, options.caseSensitive)) ? false : res);
}

function getValidLine(options) {
  var res, forceNext, limitMessage,
    matches, histInput, args, resCheck;

  function _getPhContent(param) { return getPhContent(param, options); }
  function addDisplay(text) { options.display += (/[^\r\n]$/.test(options.display) ? '\n' : '') + text; }

  options.limitSrc = options.limit;
  options.displaySrc = options.display;
  options.limit = ''; // for readlineExt
  options.display = replacePlaceholder(options.display + '', _getPhContent);

  while (true) {
    res = _readlineSync(options);
    forceNext = false;
    limitMessage = '';

    if (options.defaultInput && !res) { res = options.defaultInput; }

    if (options.history) {
      if ((matches = /^\s*\!(?:\!|-1)(:p)?\s*$/.exec(res))) { // `!!` `!-1` +`:p`
        histInput = inputHistory[0] || '';
        if (matches[1]) { // only display
          forceNext = true;
        } else { // replace input
          res = histInput;
        }
        // Show it even if it is empty (NL only).
        addDisplay(histInput + '\n');
        if (!forceNext) { // Loop may break
          options.displayOnly = true;
          _readlineSync(options);
          options.displayOnly = false;
        }
      } else if (res && res !== inputHistory[inputHistory.length - 1]) {
        inputHistory = [res];
      }
    }

    if (!forceNext && options.cd && res) {
      args = parseCl(res);
      switch (args[0].toLowerCase()) {
        case 'cd':
          if (args[1]) {
            try {
              process.chdir(replaceHomePath(args[1], true));
            } catch (e) {
              addDisplay(e + '');
            }
          }
          forceNext = true;
          break;
        case 'pwd':
          addDisplay(process.cwd());
          forceNext = true;
          break;
        // no default
      }
    }

    if (!forceNext && options.preCheck) {
      resCheck = options.preCheck(res, options);
      res = resCheck.res;
      if (resCheck.forceNext) { forceNext = true; } // Don't switch to false.
    }

    if (!forceNext) {
      if (!options.limitSrc.length ||
        isMatched(res, options.limitSrc, options.caseSensitive)) { break; }
      if (options.limitMessage) {
        limitMessage = replacePlaceholder(options.limitMessage, _getPhContent);
      }
    }

    addDisplay((limitMessage ? limitMessage + '\n' : '') +
      replacePlaceholder(options.displaySrc + '', _getPhContent));
  }
  return toBool(res, options);
}

// for dev
exports._DBG_set_useExt = function(val) { _DBG_useExt = val; };
exports._DBG_set_checkOptions = function(val) { _DBG_checkOptions = val; };
exports._DBG_set_checkMethod = function(val) { _DBG_checkMethod = val; };
exports._DBG_clearHistory = function() { lastInput = ''; inputHistory = []; };

// ------------------------------------

exports.setDefaultOptions = function(options) {
  defaultOptions = margeOptions(true, options);
  return margeOptions(true); // copy
};

exports.question = function(query, options) {
  /* eslint-disable key-spacing */
  return getValidLine(margeOptions(margeOptions(true, options), {
    display:            query
  }));
  /* eslint-enable key-spacing */
};

exports.prompt = function(options) {
  var readOptions = margeOptions(true, options);
  readOptions.display = readOptions.prompt;
  return getValidLine(readOptions);
};

exports.keyIn = function(query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions(margeOptions(true, options), {
    display:            query,
    keyIn:              true,
    keepWhitespace:     true
  });
  /* eslint-enable key-spacing */

  // char list
  readOptions.limitSrc = readOptions.limit.filter(function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number';
  })
  .map(function(text) { return replacePlaceholder(text + '', getPhCharlist); });
  // pattern
  readOptions.limit = escapePattern(readOptions.limitSrc.join(''));

  ['trueValue', 'falseValue'].forEach(function(optionName) {
    readOptions[optionName] = readOptions[optionName].reduce(function(comps, comp) {
      var type = typeof comp;
      if (type === 'string' || type === 'number') {
        comps = comps.concat((comp + '').split(''));
      } else { comps.push(comp); }
      return comps;
    }, []);
  });

  readOptions.display = replacePlaceholder(readOptions.display + '',
    function(param) { return getPhContent(param, readOptions); });

  return toBool(_readlineSync(readOptions), readOptions);
};

// ------------------------------------

exports.questionEMail = function(query, options) {
  if (query == null) { query = 'Input e-mail address: '; }
  /* eslint-disable key-spacing */
  return exports.question(query, margeOptions({
    // -------- default
    hideEchoBack:       false,
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    limit:              /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    limitMessage:       'Input valid e-mail address, please.',
    trueValue:          null,
    falseValue:         null
  }, options, {
    // -------- forced
    keepWhitespace:     false,
    cd:                 false
  }));
  /* eslint-enable key-spacing */
};

exports.questionNewPassword = function(query, options) {
  /* eslint-disable key-spacing */
  var resCharlist, min, max,
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       true,
      mask:               '*',
      limitMessage:       'It can include: $<charlist>\n' +
                            'And the length must be: $<length>',
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      true
    }, options, {
      // -------- forced
      history:            false,
      cd:                 false,
      // limit (by charlist etc.),
      phContent: function(param) {
        return param === 'charlist' ? resCharlist.text :
          param === 'length' ? min + '...' + max : null;
      }
    }),
    // added:     charlist, min, max, confirmMessage, unmatchMessage
    charlist, confirmMessage, unmatchMessage,
    limit, limitMessage, res1, res2;
  /* eslint-enable key-spacing */
  options = options || {};

  charlist = replacePlaceholder(
    options.charlist ? options.charlist + '' : '$<!-~>', getPhCharlist);
  if (isNaN(min = parseInt(options.min, 10)) || typeof min !== 'number') { min = 12; }
  if (isNaN(max = parseInt(options.max, 10)) || typeof max !== 'number') { max = 24; }
  limit = new RegExp('^[' + escapePattern(charlist) +
    ']{' + min + ',' + max + '}$');
  resCharlist = array2charlist([charlist], readOptions.caseSensitive, true);
  resCharlist.text = joinChunks(resCharlist.values, resCharlist.suppressed);

  confirmMessage = options.confirmMessage != null ? options.confirmMessage :
    'Reinput a same one to confirm it: ';
  unmatchMessage = options.unmatchMessage != null ? options.unmatchMessage :
    'It differs from first one.' +
      ' Hit only the Enter key if you want to retry from first one.';

  if (query == null) { query = 'Input new password: '; }

  limitMessage = readOptions.limitMessage;
  while (!res2) {
    readOptions.limit = limit;
    readOptions.limitMessage = limitMessage;
    res1 = exports.question(query, readOptions);

    readOptions.limit = [res1, ''];
    readOptions.limitMessage = unmatchMessage;
    res2 = exports.question(confirmMessage, readOptions);
  }

  return res1;
};

function _questionNum(query, options, parser) {
  var validValue;
  function getValidValue(value) {
    validValue = parser(value);
    return !isNaN(validValue) && typeof validValue === 'number';
  }
  /* eslint-disable key-spacing */
  exports.question(query, margeOptions({
    // -------- default
    limitMessage:       'Input valid number, please.'
  }, options, {
    // -------- forced
    limit:              getValidValue,
    cd:                 false
    // trueValue, falseValue, caseSensitive, keepWhitespace don't work.
  }));
  /* eslint-enable key-spacing */
  return validValue;
}
exports.questionInt = function(query, options) {
  return _questionNum(query, options, function(value) { return parseInt(value, 10); });
};
exports.questionFloat = function(query, options) {
  return _questionNum(query, options, parseFloat);
};

exports.questionPath = function(query, options) {
  /* eslint-disable key-spacing */
  var validPath, error = '',
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       '$<error(\n)>Input valid path, please.' +
                            '$<( Min:)min>$<( Max:)max>',
      history:            true,
      cd:                 true
    }, options, {
      // -------- forced
      keepWhitespace:     false,
      limit: function(value) {
        var exists, stat, res;
        value = replaceHomePath(value, true);
        error = ''; // for validate
        // mkdir -p
        function mkdirParents(dirPath) {
          dirPath.split(/\/|\\/).reduce(function(parents, dir) {
            var path = pathUtil.resolve((parents += dir + pathUtil.sep));
            if (!fs.existsSync(path)) {
              fs.mkdirSync(path);
            } else if (!fs.statSync(path).isDirectory()) {
              throw new Error('Non directory already exists: ' + path);
            }
            return parents;
          }, '');
        }

        try {
          exists = fs.existsSync(value);
          validPath = exists ? fs.realpathSync(value) : pathUtil.resolve(value);
          // options.exists default: true, not-bool: no-check
          if (!options.hasOwnProperty('exists') && !exists ||
              typeof options.exists === 'boolean' && options.exists !== exists) {
            error = (exists ? 'Already exists' : 'No such file or directory') +
              ': ' + validPath;
            return false;
          }
          if (!exists && options.create) {
            if (options.isDirectory) {
              mkdirParents(validPath);
            } else {
              mkdirParents(pathUtil.dirname(validPath));
              fs.closeSync(fs.openSync(validPath, 'w')); // touch
            }
            validPath = fs.realpathSync(validPath);
          }
          if (exists && (options.min || options.max ||
              options.isFile || options.isDirectory)) {
            stat = fs.statSync(validPath);
            // type check first (directory has zero size)
            if (options.isFile && !stat.isFile()) {
              error = 'Not file: ' + validPath;
              return false;
            } else if (options.isDirectory && !stat.isDirectory()) {
              error = 'Not directory: ' + validPath;
              return false;
            } else if (options.min && stat.size < +options.min ||
                options.max && stat.size > +options.max) {
              error = 'Size ' + stat.size + ' is out of range: ' + validPath;
              return false;
            }
          }
          if (typeof options.validate === 'function' &&
              (res = options.validate(validPath)) !== true) {
            if (typeof res === 'string') { error = res; }
            return false;
          }
        } catch (e) {
          error = e + '';
          return false;
        }
        return true;
      },
      // trueValue, falseValue, caseSensitive don't work.
      phContent: function(param) {
        return param === 'error' ? error :
          param !== 'min' && param !== 'max' ? null :
          options.hasOwnProperty(param) ? options[param] + '' : '';
      }
    });
    // added:     exists, create, min, max, isFile, isDirectory, validate
  /* eslint-enable key-spacing */
  options = options || {};

  if (query == null) { query = 'Input path (you can "cd" and "pwd"): '; }

  exports.question(query, readOptions);
  return validPath;
};

// props: preCheck, args, hRes, limit
function getClHandler(commandHandler, options) {
  var clHandler = {}, hIndex = {};
  if (typeof commandHandler === 'object') {
    Object.keys(commandHandler).forEach(function(cmd) {
      if (typeof commandHandler[cmd] === 'function') {
        hIndex[options.caseSensitive ? cmd : cmd.toLowerCase()] = commandHandler[cmd];
      }
    });
    clHandler.preCheck = function(res) {
      var cmdKey;
      clHandler.args = parseCl(res);
      cmdKey = clHandler.args[0] || '';
      if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
      clHandler.hRes =
        cmdKey !== '_' && hIndex.hasOwnProperty(cmdKey) ?
          hIndex[cmdKey].apply(res, clHandler.args.slice(1)) :
        hIndex.hasOwnProperty('_') ? hIndex._.apply(res, clHandler.args) : null;
      return {res: res, forceNext: false};
    };
    if (!hIndex.hasOwnProperty('_')) {
      clHandler.limit = function() { // It's called after preCheck.
        var cmdKey = clHandler.args[0] || '';
        if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
        return hIndex.hasOwnProperty(cmdKey);
      };
    }
  } else {
    clHandler.preCheck = function(res) {
      clHandler.args = parseCl(res);
      clHandler.hRes = typeof commandHandler === 'function' ?
        commandHandler.apply(res, clHandler.args) : true; // true for break loop
      return {res: res, forceNext: false};
    };
  }
  return clHandler;
}

exports.promptCL = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  exports.prompt(readOptions);
  return clHandler.args;
};

exports.promptLoop = function(inputHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
    // -------- default
    hideEchoBack:       false,
    trueValue:          null,
    falseValue:         null,
    caseSensitive:      false,
    history:            true
  }, options);
  /* eslint-enable key-spacing */
  while (true) { if (inputHandler(exports.prompt(readOptions))) { break; } }
  return;
};

exports.promptCLLoop = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  while (true) {
    exports.prompt(readOptions);
    if (clHandler.hRes) { break; }
  }
  return;
};

exports.promptSimShell = function(options) {
  /* eslint-disable key-spacing */
  return exports.prompt(margeOptions({
    // -------- default
    hideEchoBack:       false,
    history:            true
  }, options, {
    // -------- forced
    prompt:             (function() {
      return IS_WIN ?
        '$<cwd>>' :
        // 'user@host:cwd$ '
        (process.env.USER || '') +
        (process.env.HOSTNAME ?
          '@' + process.env.HOSTNAME.replace(/\..*$/, '') : '') +
        ':$<cwdHome>$ ';
    })()
  }));
  /* eslint-enable key-spacing */
};

function _keyInYN(query, options, limit) {
  var res;
  if (query == null) { query = 'Are you sure? '; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s*:?\s*$/, '') + ' [y/n]: ';
  }
  /* eslint-disable key-spacing */
  res = exports.keyIn(query, margeOptions(options, {
    // -------- forced
    hideEchoBack:       false,
    limit:              limit,
    trueValue:          'y',
    falseValue:         'n',
    caseSensitive:      false
    // mask doesn't work.
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return typeof res === 'boolean' ? res : '';
}
exports.keyInYN = function(query, options) { return _keyInYN(query, options); };
exports.keyInYNStrict = function(query, options) { return _keyInYN(query, options, 'yn'); };

exports.keyInPause = function(query, options) {
  if (query == null) { query = 'Continue...'; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s+$/, '') + ' (Hit any key)';
  }
  /* eslint-disable key-spacing */
  exports.keyIn(query, margeOptions({
    // -------- default
    limit:              null
  }, options, {
    // -------- forced
    hideEchoBack:       true,
    mask:               ''
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return;
};

exports.keyInSelect = function(items, query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false
    }, options, {
      // -------- forced
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      false,
      // limit (by items),
      phContent: function(param) {
        return param === 'itemsCount' ? items.length + '' :
          param === 'firstItem' ? (items[0] + '').trim() :
          param === 'lastItem' ? (items[items.length - 1] + '').trim() : null;
      }
    }),
    // added:     guide, cancel
    keylist = '', key2i = {}, charCode = 49 /* '1' */, display = '\n';
  /* eslint-enable key-spacing */
  if (!Array.isArray(items) || !items.length || items.length > 35) {
    throw '`items` must be Array (max length: 35).';
  }

  items.forEach(function(item, i) {
    var key = String.fromCharCode(charCode);
    keylist += key;
    key2i[key] = i;
    display += '[' + key + '] ' + (item + '').trim() + '\n';
    charCode = charCode === 57 /* '9' */ ? 97 /* 'a' */ : charCode + 1;
  });
  if (!options || options.cancel !== false) {
    keylist += '0';
    key2i['0'] = -1;
    display += '[0] ' +
      (options && options.cancel != null && typeof options.cancel !== 'boolean' ?
        (options.cancel + '').trim() : 'CANCEL') + '\n';
  }
  readOptions.limit = keylist;
  display += '\n';

  if (query == null) { query = 'Choose one from list: '; }
  if ((query += '')) {
    if (!options || options.guide !== false) {
      query = query.replace(/\s*:?\s*$/, '') + ' [$<limit>]: ';
    }
    display += query;
  }

  return key2i[exports.keyIn(display, readOptions).toLowerCase()];
};

exports.getRawInput = function() { return rawInput; };

// ======== DEPRECATED ========
function _setOption(optionName, args) {
  var options;
  if (args.length) { options = {}; options[optionName] = args[0]; }
  return exports.setDefaultOptions(options)[optionName];
}
exports.setPrint = function() { return _setOption('print', arguments); };
exports.setPrompt = function() { return _setOption('prompt', arguments); };
exports.setEncoding = function() { return _setOption('encoding', arguments); };
exports.setMask = function() { return _setOption('mask', arguments); };
exports.setBufferSize = function() { return _setOption('bufferSize', arguments); };


/***/ }),

/***/ "./node_modules/tau-prolog/modules/core.js":
/*!*************************************************!*\
  !*** ./node_modules/tau-prolog/modules/core.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function() {
	
	// VERSION
	var version = { major: 0, minor: 3, patch: 4, status: "beta" };



	// IO FILE SYSTEM
	
	// Virtual file
	function TauFile(name, type, parent, text) {
		text = text === undefined ? "" : text;
		this.name = name;
		this.type = type;
		this.parent = parent;
		this.text = text;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauFile.prototype.get = function(length, position) {
		if(position === this.text.length) {
			return "end_of_stream";
		} else if(position > this.text.length) {
			return "end_of_stream";
		} else {
			return this.text.substring(position, position+length);
		}
	};

	TauFile.prototype.eof = function(position) {
		return position === this.text.length;
	};

	TauFile.prototype.put = function(text, position) {
		if(position === "end_of_stream") {
			this.text += text;
			return true;
		} else if(position === "past_end_of_stream") {
			return null;
		} else {
			this.text = this.text.substring(0, position) + text + this.text.substring(position+text.length);
			return true;
		}
	};

	TauFile.prototype.get_byte = function(position) {
		if(position === "end_of_stream")
			return -1;
		var index = Math.floor(position/2);
		if(this.text.length <= index)
			return -1;
		var code = codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0)
			return code & 0xff;
		else
			return code / 256 >>> 0;
	};

	TauFile.prototype.put_byte = function(byte, position) {
		var index = position === "end_of_stream" ? this.text.length : Math.floor(position/2);
		if(this.text.length < index)
			return null;
		var code = this.text.length === index ? -1 : codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0) {
			code = code / 256 >>> 0;
			code = ((code & 0xff) << 8) | (byte & 0xff);
		} else {
			code = code & 0xff;
			code = ((byte & 0xff) << 8) | (code & 0xff);
		}
		if(this.text.length === index)
			this.text += fromCodePoint(code);
		else 
			this.text = this.text.substring(0, index) + fromCodePoint(code) + this.text.substring(index+1);
		return true;
	};

	TauFile.prototype.flush = function() {
		return true;
	};

	TauFile.prototype.close = function() {
		this.modified = Date.now() / 1000;
		return true;
	};

	TauFile.prototype.size = function() {
		return this.text.length;
	};

	// Virtual directory
	function TauDirectory(name, parent) {
		this.name = name;
		this.parent = parent;
		this.files = {};
		this.length = 0;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauDirectory.prototype.lookup = function(file) {
		if(this.files.hasOwnProperty(file))
			return this.files[file];
		return null;
	};

	TauDirectory.prototype.push = function(name, file) {
		if(!this.files.hasOwnProperty(name))
			this.length++;
		this.files[name] = file;
		this.modified = Date.now() / 1000;
	};

	TauDirectory.prototype.remove = function(name) {
		if(this.files.hasOwnProperty(name)) {
			this.length--;
			delete this.files[name];
			this.modified = Date.now() / 1000;
		}
	};

	TauDirectory.prototype.empty = function() {
		return this.length === 0;
	};

	TauDirectory.prototype.size = function() {
		return 4096;
	};

	// Virtual file system for browser
	tau_file_system = {
		// Current files
		files: new TauDirectory("/", "/", null),
		// Open file
		open: function(path, type, mode) {
			var dirs = path.replace(/\/$/, "").split("/");
			var dir = tau_file_system.files;
			var name = dirs[dirs.length-1];
			for(var i = 1; i < dirs.length-1; i++) {
				dir = dir.lookup(dirs[i]);
				if(!pl.type.is_directory(dir))
					return null;
			}
			var file = dir.lookup(name);
			if(file === null) {
				if(mode === "read")
					return null;
				file = new TauFile(name, type, dir);
				dir.push(name, file);
			} else if(!pl.type.is_file(file)) {
				return null;
			}
			if(mode === "write")
				file.text = "";
			return file;
		},
		// Get item
		get: function(path) {
			var dirs = path.replace(/\/$/, "").split("/");
			var file = tau_file_system.files;
			for(var i = 1; i < dirs.length; i++)
				if(pl.type.is_directory(file))
					file = file.lookup(dirs[i]);
				else
					return null;
			return file;
		}
	};

	// User input for browser
	tau_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			while( tau_user_input.buffer.length < length ) {
				text = window.prompt();
				if( text.length === 0 )
					return "end_of_stream";
				if( text ) {
					tau_user_input.buffer += text;
				}
			}
			text = tau_user_input.buffer.substr( 0, length );
			tau_user_input.buffer = tau_user_input.buffer.substr( length );
			return text;
		},
		eof: function(_) {
			return false;
		}
	};

	// User output for browser
	tau_user_output = {
		put: function( text, _ ) {
			console.log( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// User error for browser
	tau_user_error = {
		put: function( text, _ ) {
			(console.error || console.log)( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// Virtual file system for Node.js
	nodejs_file_system = {
		// Open file
		open: function( path, type, mode ) {
			var fd, fs = __webpack_require__(/*! fs */ "?4a0f");
			if( mode === "read" && !fs.existsSync( path ) )
				return null;
			try {
				fd = fs.openSync( path, mode[0] );
			} catch(ex) {
				return false;
			}
			return {
				get: function( length, position ) {
					var buffer = new Buffer( length );
					fs.readSync( fd, buffer, 0, length, position );
					var end_of_file = true;
					var text = buffer.toString();
					for(var i = 0; i < length && end_of_file; i++)
						end_of_file = text[i] === "\u0000";
					return end_of_file ? "end_of_stream" : buffer.toString();
				},
				eof: function(position) {
					var stats = fs.statSync(path)
					return position === stats["size"];
				},
				put: function( text, position ) {
					var buffer = Buffer.from( text );
					if( position === "end_of_stream" )
						fs.writeSync( fd, buffer );
					else if( position === "past_end_of_stream" )
						return null;
					else
						fs.writeSync( fd, buffer, 0, buffer.length, position );
					return true;
				},
				get_byte: function( position ) {
					try {
						var buffer = Buffer.alloc(1);
						var bytesRead = fs.readSync(fd, buffer, 0, 1, position);
						//var _text = buffer.toString("utf8", 0, bytesRead);
						var end_of_file = bytesRead < 1;
						return end_of_file ? "end_of_stream" : buffer.readUInt8(0);
					} catch(ex) {
						return "end_of_stream";
					}
				},
				put_byte: function(byte, position) {
					var buffer = Buffer.from([byte]);
					if(position === "end_of_stream")
						fs.writeSync(fd, buffer);
					else if(position === "past_end_of_stream")
						return null;
					else
						fs.writeSync(fd, buffer, 0, buffer.length, position);
					return true;
				},
				flush: function() {
					return true;
				},
				close: function() {
					fs.closeSync( fd );
					return true;
				}
			};
		}
	};

	// User input for Node.js
	nodejs_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			var readlineSync = __webpack_require__(/*! readline-sync */ "./node_modules/readline-sync/lib/readline-sync.js");
			while( nodejs_user_input.buffer.length < length )
				nodejs_user_input.buffer += readlineSync.question("", {keepWhitespace: true}) + "\n";
			text = nodejs_user_input.buffer.substr( 0, length );
			nodejs_user_input.buffer = nodejs_user_input.buffer.substr( length );
			return text;
		},
		eof: function(length) {
			return false;
		}
	};

	// User output for Node.js
	nodejs_user_output = {
		put: function( text, _ ) {
			process.stdout.write( text );
			return true;
		},
		flush: function() {
			return true;
		}
	};

	// User error for Node.js
	nodejs_user_error = {
		put: function( text, _ ) {
			process.stderr.write( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};
	
	
	
	// COMPATITBILITY
	
	var indexOf;
	if(!Array.prototype.indexOf) {
		indexOf = function(array, elem) {
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(elem === array[i]) return i;
			}
			return -1;
		};
	} else {
		indexOf = function(array, elem) {
			return array.indexOf(elem);
		};
	}

	var reduce = function(array, fn) {
		if(array.length === 0) return undefined;
		var elem = array[0];
		var len = array.length;
		for(var i = 1; i < len; i++) {
			elem = fn(elem, array[i]);
		}
		return elem;
	};

	var map;
	if(!Array.prototype.map) {
		map = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				a.push( fn(array[i]) );
			}
			return a;
		};
	} else {
		map = function(array, fn) {
			return array.map(fn);
		};
	}
	
	var filter;
	if(!Array.prototype.filter) {
		filter = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(fn(array[i]))
					a.push( array[i] );
			}
			return a;
		};
	} else {
		filter = function(array, fn) {
			return array.filter(fn);
		};
	}
	
	var codePointAt;
	if(!String.prototype.codePointAt) {
		codePointAt = function(str, i) {
			return str.charCodeAt(i);
		};
	} else {
		codePointAt = function(str, i) {
			return str.codePointAt(i);
		};
	}
	
	var fromCodePoint;
	if(!String.fromCodePoint) {
		fromCodePoint = function() {
			return String.fromCharCode.apply(null, arguments);
		};
	} else {
		fromCodePoint = function() {
			return String.fromCodePoint.apply(null, arguments);
		};
	}

	var stringLength;
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	if(Array.from)
		stringLength = function(str) {
			return Array.from(str).length;
		};
	else
		stringLength = function(str) {
			return str.replace(regexAstralSymbols, '_').length;
		};

	
	
	// PARSER

	var ERROR = 0;
	var SUCCESS = 1;

	var regex_escape = /(\\a)|(\\b)|(\\d)|(\\e)|(\\f)|(\\n)|(\\r)|(\\s)|(\\t)|(\\v)|\\x([0-9a-fA-F]+)\\|\\([0-7]+)\\|(\\\\)|(\\')|('')|(\\")|(\\`)|(\\.)|(.)/g;
	var escape_map = {"\\a": 7, "\\b": 8, "\\d": 127, "\\e": 27, "\\f": 12, "\\n": 10, "\\r": 13, "\\s": 32, "\\t": 9, "\\v": 11};
	function escape(str) {
		var stack = [];
		var _error = false;
		str.replace(regex_escape, function(match, a, b, d, e, f, n, r, s, t, v, hex, octal, back, single, dsingle, double, backquote, error, char) {
			switch(true) {
				case hex !== undefined:
					stack.push( parseInt(hex, 16) );
					return "";
				case octal !== undefined:
					stack.push( parseInt(octal, 8) );
					return "";
				case back !== undefined:
				case single !== undefined:
				case dsingle !== undefined:
				case double !== undefined:
				case backquote !== undefined:
					stack.push( codePointAt(match.substr(1),0) );
					return "";
				case char !== undefined:
					stack.push( codePointAt(char,0) );
					return "";
				case error !== undefined:
					_error = true;
				default:
					stack.push(escape_map[match]);
					return "";
			}
		});
		if(_error)
			return null;
		return stack;
	}

	// Escape atoms
	function escapeAtom(str, quote) {
		var atom = '';
		if( str === "\\" ) return null;
		if( str.length < 2 ) return str;
		try {
			str = str.replace(/((?:\\\\)+)|\\([0-7]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 8));
			});
			str = str.replace(/((?:\\\\)+)|\\x([0-9a-fA-F]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
			str = str.replace(/((?:\\\\)+)|\\u([0-9a-fA-F]{4})/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
		} catch(error) {
			return null;
		}
		for( var i = 0; i < str.length; i++) {
			var a = str.charAt(i);
			var b = str.charAt(i+1);
			if( a === quote && b === quote ) {
				i++;
				atom += quote;
			} else if( a === '\\' ) {
				if( ['a','b','f','n','r','t','v',"'",'"','\\','\a','\b','\f','\n','\r','\t','\v'].indexOf(b) !== -1 ) {
					i += 1;
					switch( b ) {
						case 'a': atom += '\a'; break;
						case 'b': atom += '\b'; break;
						case 'f': atom += '\f'; break;
						case 'n': atom += '\n'; break;
						case 'r': atom += '\r'; break;
						case 't': atom += '\t'; break;
						case 'v': atom += '\v'; break;
						case "'": atom += "'"; break;
						case '"': atom += '"'; break;
						case '\\': atom += '\\'; break;
					}
				} else {
					return null;
				}
			} else {
				atom += a;
			}
		}
		return atom;
	}
	
	// Redo escape
	function redoEscape(str) {
		var atom = '';
		for( var i = 0; i < str.length; i++) {
			switch( str.charAt(i) ) {
				case "'": atom += "\\'"; break;
				case '\\': atom += '\\\\'; break;
				//case '\a': atom += '\\a'; break;
				case '\b': atom += '\\b'; break;
				case '\f': atom += '\\f'; break;
				case '\n': atom += '\\n'; break;
				case '\r': atom += '\\r'; break;
				case '\t': atom += '\\t'; break;
				case '\v': atom += '\\v'; break;
				default: atom += str.charAt(i); break;
			}
		}
		return atom;
	}

	// String to num
	function convertNum(num) {
		var n = num.substr(2);
		switch(num.substr(0,2).toLowerCase()) {
			case "0x":
				return parseInt(n, 16);
			case "0b":
				return parseInt(n, 2);
			case "0o":
				return parseInt(n, 8);
			case "0'":
				return escape(n)[0];
			default:
				return parseFloat(num);
		}
	}

	// Is graphic token
	function is_graphic_token(string) {
		return /^[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+/.test(string);
	}

	// Regular expressions for tokens
	var rules = {
		whitespace: /^\s*(?:(?:%.*)|(?:\/\*(?:\n|\r|.)*?(?:\*\/|$))|(?:\s+))\s*/,
		variable: /^(?:[A-Z_][a-zA-Z0-9_]*)/,
		atom: /^(\!|,|;|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+|'(?:(?:'')|(?:\\\\)|(?:\\')|[^'])*')/,
		number: /^(?:0o[0-7]+|0x[0-9a-fA-F]+|0b[01]+|0'(?:''|\\[abdefnrstv\\'"`]|\\x?\d+\\|[^\\])|\d+(?:\.\d+(?:[eE][+-]?\d+)?)?)/,
		string: /^(?:"([^"]|""|\\")*"|`([^`]|``|\\`)*`)/,
		l_brace: /^(?:\[)/,
		r_brace: /^(?:\])/,
		l_bracket: /^(?:\{)/,
		r_bracket: /^(?:\})/,
		bar: /^(?:\|)/,
		l_paren: /^(?:\()/,
		r_paren: /^(?:\))/
	};

	// Replace chars of char_conversion session
	function replace( thread, text ) {
		if( thread.get_flag( "char_conversion" ).id === "on" ) {
			return text.replace(/./g, function(char) {
				return thread.get_char_conversion( char );
			});
		}
		return text;
	}

	// Tokenize strings
	function Tokenizer(thread) {
		this.thread = thread;
		this.text = ""; // Current text to be analized
		this.tokens = []; // Consumed tokens
	}

	Tokenizer.prototype.set_last_tokens = function(tokens) {
		return this.tokens = tokens;
	};

	Tokenizer.prototype.new_text = function(text) {
		this.text = text;
		this.tokens = [];
	};

	Tokenizer.prototype.get_tokens = function(init) {
		var text;
		var len = 0; // Total length respect to text
		var line = 0;
		var start = 0;
		var tokens = [];
		var last_is_blank;

		if(init) {
			var token = this.tokens[init-1];
			len = token.len;
			text = replace( this.thread, this.text.substr(token.len) );
			line = token.line;
			start = token.start;
		}
		else
			text = this.text;


		// If there is nothing to be analized, return null
		if(/^\s*$/.test(text))
			return null;

		while(text !== "") {
			var matches = [];
			last_is_blank = false;

			if(/^\n/.exec(text) !== null) {
				line++;
				start = 0;
				len++;
				text = text.replace(/\n/, "");
				last_is_blank = true;
				continue;
			}

			for(var rule in rules) {
				if(rules.hasOwnProperty(rule)) {
					var matchs = rules[rule].exec( text );
					if(matchs) {
						matches.push({
							value: matchs[0],
							name: rule,
							matches: matchs
						});
					}
				}
			}

			// Lexical error
			if(!matches.length)
				return this.set_last_tokens( [{ value: text, matches: [], name: "lexical", line: line, start: start }] );

			var token = reduce( matches, function(a, b) {
				return a.value.length >= b.value.length ? a : b;
			} );

			token.start = start;
			token.line = line;

			text = text.replace(token.value, "");
			start += token.value.length;
			len += token.value.length;

			var nl = (token.value.match(/\n/g) || []).length;
			line += nl;
			if(nl > 0) 
				start = token.value.length - token.value.lastIndexOf("\n") - 1;
			token.line_count = line;
			token.line_position = start;

			switch(token.name) {
				case "atom":
					token.raw = token.value;
					if(token.value.charAt(0) === "'") {
						token.value = escapeAtom( token.value.substring(1, token.value.length - 1), "'" );
						if( token.value === null ) {
							token.name = "lexical";
							token.value = token.raw;
							token.error = "unknown_escape_sequence";
						}
					}
					break;
				case "number":
					var substr = token.value.substring(0,2);
					token.raw = token.value;
					token.float = substr !== "0x" && substr !== "0'" && token.value.match(/[.eE]/) !== null;
					token.value = convertNum( token.value );
					token.blank = last_is_blank;
					if(!token.float && pl.flag.bounded.value.indicator === "true/0" && token.value > pl.flag.max_integer.value.value) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "int_overflow";
					}
					break;
				case "string":
					var del = token.value.charAt(0);
					token.raw = token.value;
					token.value = escapeAtom( token.value.substring(1, token.value.length - 1), del );
					if( token.value === null ) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "unknown_escape_sequence"
					}
					break;
				case "whitespace":
					var last = tokens[tokens.length-1];
					if(last) last.space = true;
					last_is_blank = true;
					continue;
				case "r_bracket":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_bracket" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "{}";
						token.raw = "{}";
						token.space = false;
					}
					break;
				case "r_brace":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_brace" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "[]";
						token.raw = "[]";
						token.space = false;
					}
					break;
			}
			token.len = len;
			tokens.push( token );
			last_is_blank = false;
		}

		var t = this.set_last_tokens( tokens );
		return t.length === 0 ? null : t;
	};

	// Parse an expression
	function parseExpr(thread, tokens, start, priority, toplevel) {
		if(!tokens[start]) return {type: ERROR, value: pl.error.syntax(tokens[start-1], "expression expected", true)};
		var error;

		if(priority === "0") {
			var token = tokens[start];
			switch(token.name) {
				case "number":
					return {type: SUCCESS, len: start+1, value: new pl.type.Num(token.value, token.float)};
				case "variable":
					return {type: SUCCESS, len: start+1, value: new pl.type.Var(token.value)};
				case "string":
					var str;
					switch( thread.get_flag( "double_quotes" ).id ) {
						case "atom":;
							str = new Term( token.value, [] );
							break;
						case "codes":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Num( codePointAt(token.value,i), false ), str] );
							break;
						case "chars":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Term( token.value.charAt(i), [] ), str] );
							break;
					}
					return {type: SUCCESS, len: start+1, value: str};
				case "l_paren":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_paren") {
						expr.len++;
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], ") or operator expected", !tokens[expr.len])}
				case "l_bracket":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_bracket") {
						expr.len++;
						expr.value = new Term( "{}", [expr.value] );
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], "} or operator expected", !tokens[expr.len])}
			}
			// Compound term
			var result = parseTerm(thread, tokens, start, toplevel);
			if(result.type === SUCCESS || result.derived)
				return result;
			// List
			result = parseList(thread, tokens, start);
			if(result.type === SUCCESS || result.derived)
				return result;
			// Unexpected
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], token.error || "unexpected token")};
		}

		var max_priority = thread.__get_max_priority();
		var next_priority = thread.__get_next_priority(priority);
		var aux_start = start;
		
		// Prefix operators
		if(tokens[start].name === "atom" && tokens[start+1] && (tokens[start].space || tokens[start+1].name !== "l_paren")) {
			var token = tokens[start++];
			var classes = thread.__lookup_operator_classes(priority, token.value);
			
			// Associative prefix operator
			if(classes && classes.indexOf("fy") > -1) {
				var expr = parseExpr(thread, tokens, start, priority, toplevel);
				if(expr.type !== ERROR) {
					if( token.value === "-" && !token.space && pl.type.is_number( expr.value ) ) {
						return {
							value: new pl.type.Num(-expr.value.value, expr.value.is_float),
							len: expr.len,
							type: SUCCESS
						};
					} else {
						return {
							value: new pl.type.Term(token.value, [expr.value]),
							len: expr.len,
							type: SUCCESS
						};
					}
				} else {
					error = expr;
				}
			// Non-associative prefix operator
			} else if(classes && classes.indexOf("fx") > -1) {
				var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
				if(expr.type !== ERROR) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: expr.len,
						type: SUCCESS
					};
				} else {
					error = expr;
				}
			}
		}

		start = aux_start;
		var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
		if(expr.type === SUCCESS) {
			start = expr.len;
			var token = tokens[start];
			if(tokens[start] && (
				tokens[start].name === "atom" && thread.__lookup_operator_classes(priority, token.value) ||
				tokens[start].name === "bar" && thread.__lookup_operator_classes(priority, "|")
			) ) {
				var next_priority_lt = next_priority;
				var next_priority_eq = priority;
				var classes = thread.__lookup_operator_classes(priority, token.value);

				if(classes.indexOf("xf") > -1) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: ++expr.len,
						type: SUCCESS
					};
				} else if(classes.indexOf("xfx") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_lt, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(classes.indexOf("xfy") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_eq, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(expr.type !== ERROR) {
					while(true) {
						start = expr.len;
						var token = tokens[start];
						if(token && token.name === "atom" && thread.__lookup_operator_classes(priority, token.value)) {
							var classes = thread.__lookup_operator_classes(priority, token.value);
							if( classes.indexOf("yf") > -1 ) {
								expr = {
									value: new pl.type.Term(token.value, [expr.value]),
									len: ++start,
									type: SUCCESS
								};
							} else if( classes.indexOf("yfx") > -1 ) {
								var expr2 = parseExpr(thread, tokens, ++start, next_priority_lt, toplevel);
								if(expr2.type === ERROR) {
									expr2.derived = true;
									return expr2;
								}
								start = expr2.len;
								expr = {
									value: new pl.type.Term(token.value, [expr.value, expr2.value]),
									len: start,
									type: SUCCESS
								};
							} else { break; }
						} else { break; }
					}
				}
			} else {
				error = {type: ERROR, value: pl.error.syntax(tokens[expr.len-1], "operator expected")};
			}
			return expr;
		}
		return expr;
	}

	// Parse a compound term
	function parseTerm(thread, tokens, start, toplevel) {
		if(!tokens[start] || (tokens[start].name === "atom" && tokens[start].raw === "." && !toplevel && (tokens[start].space || !tokens[start+1] || tokens[start+1].name !== "l_paren")))
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "unfounded token")};
		var atom = tokens[start];
		var exprs = [];
		if(tokens[start].name === "atom" && tokens[start].raw !== ",") {
			start++;
			if(tokens[start-1].space) return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
			if(tokens[start] && tokens[start].name === "l_paren") {
				if(tokens[start+1] && tokens[start+1].name === "r_paren") 
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1], "argument expected")};
				var expr = parseExpr(thread, tokens, ++start, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], "argument expected", !tokens[start])};
				}
				exprs.push(expr.value);
				start = expr.len;
				while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
					expr = parseExpr(thread, tokens, start+1, "999", true);
					if(expr.type === ERROR) {
						if( expr.derived )
							return expr;
						else
							return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
					}
					exprs.push(expr.value);
					start = expr.len;
				}
				if(tokens[start] && tokens[start].name === "r_paren") start++;
				else return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ", or ) expected", !tokens[start])};
			}
			return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "term expected")};
	}

	// Parse a list
	function parseList(thread, tokens, start) {
		if(!tokens[start]) 
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "[ expected")};
		if(tokens[start] && tokens[start].name === "l_brace") {
			var expr = parseExpr(thread, tokens, ++start, "999", true);
			var exprs = [expr.value];
			var cons = undefined;

			if(expr.type === ERROR) {
				if(tokens[start] && tokens[start].name === "r_brace") {
					return {type: SUCCESS, len: start+1, value: new pl.type.Term("[]", [])};
				}
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start], "] expected")};
			}
			
			start = expr.len;

			while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				exprs.push(expr.value);
				start = expr.len;
			}
			var bar = false
			if(tokens[start] && tokens[start].name === "bar") {
				bar = true;
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				cons = expr.value;
				start = expr.len;
			}
			if(tokens[start] && tokens[start].name === "r_brace")
				return {type: SUCCESS, len: start+1, value: arrayToList(exprs, cons) };
			else
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], bar ? "] expected" : ", or | or ] expected", !tokens[start])};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "list expected")};
	}

	// Parse a rule
	function parseRule(thread, tokens, start) {
		var line = tokens[start].line;
		var expr = parseExpr(thread, tokens, start, thread.__get_max_priority(), false);
		var rule = null;
		var obj;
		if(expr.type !== ERROR) {
			start = expr.len;
			if(tokens[start] && tokens[start].name === "atom" && tokens[start].raw === ".") {
				start++;
				if( pl.type.is_term(expr.value) ) {
					if(expr.value.indicator === ":-/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					} else if(expr.value.indicator === "-->/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						rule = rule_to_dcg(rule, thread);
						rule.body = body_conversion(rule.body);
						if(!pl.type.is_rule(rule))
							return {
								value: rule,
								len: start,
								type: ERROR
							};
						obj = {
							value: rule,
							len: start,
							type: pl.type.is_rule( rule ) ? SUCCESS : ERROR
						};
					} else {
						rule = new pl.type.Rule(expr.value, null);
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					}
					if( rule ) {
						var singleton = rule.singleton_variables();
						if( singleton.length > 0 )
							thread.throw_warning( pl.warning.singleton( singleton, rule.head.indicator, line ) );
					}
					return obj;
				} else {
					return { type: ERROR, value: pl.error.syntax(tokens[start], "callable expected") };
				}
			} else {
				return { type: ERROR, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ". or operator expected") };
			}
		}
		return expr;
	}

	// Parse a program
	function parseProgram(thread, string, options) {
		var opts = {};
		options = options ? options : {};
		opts.success = options.success ? options.success : function(){};
		opts.error = options.error ? options.error : function(){};
		opts.from = options.from ? options.from : "$tau-js";
		opts.reconsult = options.reconsult !== undefined ? options.reconsult : true;
		opts.reconsulted = options.reconsulted === undefined ? {} : options.reconsulted;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.initialization = options.initialization === undefined ? [] : options.initialization;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.tokens = options.tokens === undefined ? null : options.tokens;
		opts.string = string;
		opts.term_expansion = false;
		var reconsulted = opts.reconsulted;
		var tokenizer = opts.tokenizer;
		var tokens = opts.tokens;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			tokenizer.new_text(string);
			opts.tokenizer = tokenizer;
			tokens = tokenizer.get_tokens(0);
			opts.tokens = tokens;
		}
		var n = opts.current_token;
		while(tokens !== null && tokens[n]) {
			var expr = parseRule(thread, tokens, n);
			opts.current_token = expr.len;
			if(expr.type === ERROR) {
				if(opts.error !== undefined)
				opts.error(new Term("throw", [expr.value]));
				return;
			} else {
				// Term expansion
				var context_module = opts.context_module;
				var term_expansion = thread.session.modules[context_module].rules["term_expansion/2"];
				if(term_expansion && term_expansion.length > 0) {
					opts.term_expansion = true;
					var n_thread = new Thread(thread.session);
					var term = expr.value.body ? new Term(":-", [expr.value.head, expr.value.body]) : expr.value.head;
					thread.session.renamed_variables = {};
					term = term.rename(thread.session);
					n_thread.query(context_module + ":term_expansion(" + term.toString({quoted: true}) + ", X).");
					n_thread.answer((function(thread, opts, reconsulted, expr) {
						return function(answer) {
							if(answer && !pl.type.is_error(answer) && pl.type.is_term(answer.links['X'])) {
								var term = answer.links['X'];
								var rule = term.indicator === ":-/2" ? new Rule(term.args[0], term.args[1]) : new Rule(term, null);
								parseProgramExpansion(thread, opts, reconsulted, {value: rule, len: expr.len, type: expr.type});
							} else {
								parseProgramExpansion(thread, opts, reconsulted, expr);
							}
						}
					})(thread, opts, reconsulted, expr));
					return;
				} else {
					opts.term_expansion = false;
					var async = parseProgramExpansion(thread, opts, reconsulted, expr);
					if(async)
						return;
					n = expr.len;
				}
			}
		}
		// run goals from initialization/1 directive
		var callback = opts.success;
		var nthread = new Thread(thread.session);
		for(var i = opts.initialization.length-1; i > 0; i--) {
			var next_callback = (function(init, callback) {
				return function(answer) {
					if(answer === null) {
						nthread.answer();
					} else if(pl.type.is_error(answer)) {
						opts.error(answer);
					} else {
						nthread.add_goal(init);
						nthread.answer(callback);
					}
				};
			})(opts.initialization[i], callback);
			callback = next_callback;
		}
		if(opts.initialization.length > 0) {
			nthread.add_goal(opts.initialization[0]);
			nthread.answer(callback);
		} else {
			callback();
		}
	}

	function parseGoalExpansion(thread, options, expr) {
		var n_thread = new Thread( thread.session );
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var varhead = thread.next_free_variable();
		var goal = varhead + " = " + expr.value.head + ", goal_expansion(" + expr.value.body.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				expr.value.head = answer.links[varhead];
				expr.value.body = body_conversion(answer.links[varterm]);
				parseGoalExpansion(thread, options, expr);
			} else {
				thread.add_rule(expr.value, options);
				parseProgram(thread, options.string, options);
			}
		});
	}

	function parseQueryExpansion(thread, term, options) {
		var n_thread = new Thread(thread.session);
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var goal = "goal_expansion(" + term.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		var variables = n_thread.head_point().substitution.domain();
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				for(var i = 0; i < variables.length; i++) {
					if(variables[i] !== varterm.id && answer.links[variables[i]]) {
						var subs = new Substitution();
						subs.links[answer.links[variables[i]]] = variables[i];
						answer.links[varterm] = answer.links[varterm].apply( subs );
					}
				}
				parseQueryExpansion(thread, body_conversion(answer.links[varterm]), options);
			} else {
				thread.add_goal(term);
				options.success(term);
				parseQuery(thread, options.string, options);
			}
		});
	}

	function parseProgramExpansion(thread, options, reconsulted, expr) {
		var async = options.term_expansion === true;
		if(expr.value.body === null && expr.value.head.indicator === "?-/1") {
			async = true;
			var n_thread = new Thread(thread.session);
			n_thread.add_goal(expr.value.head.args[0]);
			n_thread.answer(function(answer) {
				if(pl.type.is_error(answer)) {
					thread.throw_warning(answer.args[0]);
				} else if(answer === false || answer === null) {
					thread.throw_warning(pl.warning.failed_goal(expr.value.head.args[0], expr.len));
				}
				parseProgram(thread, options.string, options);
			});
		} else if(expr.value.body === null && expr.value.head.indicator === ":-/1") {
			var result = thread.run_directive(expr.value.head.args[0], options);
			async = async || (result === true);
			if(async)
				parseProgram(thread, options.string, options);
		} else {
			var context_module = options.context_module;
			var indicator = expr.value.head.indicator;
			if(expr.value.head.indicator === ":/2") {
				context_module = expr.value.head.args[0].id;
				indicator = expr.value.head.args[1].indicator;
			}
			if(!reconsulted.hasOwnProperty(context_module))
				reconsulted[context_module] = {};
			if(options.reconsult !== false && reconsulted[context_module][indicator] !== true && !thread.is_multifile_predicate(indicator)) {
				var get_module = thread.session.modules[context_module];
				if(context_module !== "system" && get_module && get_module.rules[indicator]) {
					get_module.rules[indicator] = filter(get_module.rules[indicator], function(rule) {
						return rule.dynamic;
					});
					get_module.update_indices_predicate(indicator);
				}
				reconsulted[context_module][indicator] = true;
			}
			var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
			if(expr.value.body !== null && goal_expansion && goal_expansion.length > 0) {
				async = true;
				thread.session.renamed_variables = {};
				var origin = {
					head: function() { return expr.value.head; },
					term: function() { return expr.value.body; },
					set: function(h, p){
						expr.value.head = h;
						expr.value.body = p;
					}
				};
				parseGoalExpansion(thread, options, expr, body_conversion(expr.value.body), origin.set, origin);
			} else {
				thread.add_rule(expr.value, options);
				if(async)
					parseProgram(thread, options.string, options);
			}
		}
		return async;
	}
	
	// Parse a query
	function parseQuery(thread, string, options) {
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.string = string;
		var tokenizer = opts.tokenizer;
		var n = opts.current_token;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			opts.tokenizer = tokenizer;
			tokenizer.new_text(string);
		}
		do {
			var tokens = tokenizer.get_tokens(n);
			if(tokens === null)
				break;
			var expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
			if(expr.type !== ERROR) {
				var expr_position = expr.len;
				n = expr.len + 1;
				opts.current_token = n;
				if(tokens[expr_position] && tokens[expr_position].name === "atom" && tokens[expr_position].raw === ".") {
					expr.value = body_conversion(expr.value);
					// Goal expansion
					var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
					if(!thread.__goal_expansion && goal_expansion && goal_expansion.length > 0) {
						parseQueryExpansion(thread, expr.value, opts);
						return;
					} else {
						thread.add_goal(expr.value);
						opts.success(expr.value);
					}
				} else {
					var token = tokens[expr_position];
					opts.error(
						new Term("throw", [
							pl.error.syntax(
								token ? token : tokens[expr_position-1],
								token && token.error ? token.error : ". or operator expected",
								!token
							)
						])
					);
					return;
				}
			} else {
				opts.error(new Term("throw", [expr.value]));
				return;
			}
		} while(true);
	}


	
	// UTILS

	// Rule to DCG
	function rule_to_dcg(rule, thread) {
		thread.session.renamed_variables = {};
		rule = rule.rename(thread);
		var begin = thread.next_free_variable();
		var dcg = body_to_dcg( rule.body, begin, thread );
		if( dcg.error )
			return dcg.value;
		rule.body = dcg.value;
		// push-back lists
		if(rule.head.indicator === ",/2") {
			var terminals = rule.head.args[1];
			rule.head = rule.head.args[0];
			var last = thread.next_free_variable();
			var pointer = terminals;
			if(!pl.type.is_list(pointer)) {
				return pl.error.type("list", pointer, "DCG/0");
			}
			if(pointer.indicator === "[]/0") {
				terminals = dcg.variable;
			} else {
				while(pointer.indicator === "./2" && pl.type.is_list(pointer) && pointer.args[1].indicator !== "[]/0") {
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer))
					return pl.error.instantiation("DCG/0");
				else if(!pl.type.is_list(pointer))
					return pl.error.type("list", terminals, "DCG/0");
				pointer.args[1] = dcg.variable;
			}
			rule.body = new Term(",", [rule.body, new Term("=", [last, terminals])]);
			rule.head = new Term(rule.head.id, rule.head.args.concat([begin, last]));
		} else {
			// replace first assignment
			var first_assign = rule.body;
			if(pl.type.is_term(first_assign) && first_assign.indicator === ",/2")
				first_assign = first_assign.args[0];
			if(pl.type.is_term(first_assign) && first_assign.indicator === "=/2" &&
			   pl.type.is_variable(first_assign.args[0]) && first_assign.args[0] === begin) {
				begin = first_assign.args[1];
				rule.body = rule.body.replace(null);
			}
			// add first and last variables to the head
			if(rule.head.indicator === ":/2")
				rule.head = new Term(":", [
					new Term(rule.head.args[0].id, []),
					new Term(rule.head.args[1].id, rule.head.args[1].args.concat([begin, dcg.variable]))
				]);
			else
				rule.head = new Term(rule.head.id, rule.head.args.concat([begin, dcg.variable]));
		}
		return rule;
	}

	// Body to DCG
	function body_to_dcg(expr, last, thread) {
		var free;
		if( pl.type.is_term( expr ) && expr.indicator === "!/0" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr, new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ":/2" ) {
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(":", [expr.args[0], right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "\\+/1" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			free = thread.next_free_variable();
			return {
				value: new Term(",", [new Term(expr.id, [left.value]), new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && (expr.indicator === ",/2" || expr.indicator === "->/2") ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], left.variable, thread);
			if( right.error ) return right;
			return {
				value: new Term(expr.id, [left.value, right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ";/2" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(",", [new Term(";", [left.value, right.value]), new Term("=", [left.variable, right.variable])]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "{}/1" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr.args[0], new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_empty_list( expr ) ) {
			return {
				value: new Term("true", []),
				variable: last,
				error: false
			};
		} else if( pl.type.is_list( expr ) ) {
			free = thread.next_free_variable();
			var pointer = expr;
			var prev;
			while( pointer.indicator === "./2" ) {
				prev = pointer;
				pointer = pointer.args[1];
			}
			if( pl.type.is_variable( pointer ) ) {
				return {
					value: pl.error.instantiation("DCG/0"),
					variable: last,
					error: true
				};
			} else if( !pl.type.is_empty_list( pointer ) ) {
				return {
					value: pl.error.type("list", expr, "DCG/0"),
					variable: last,
					error: true
				};
			} else {
				prev.args[1] = free;
				return {
					value: new Term("=", [last, expr]),
					variable: free,
					error: false
				};
			}
		} else if( pl.type.is_callable( expr ) ) {
			free = thread.next_free_variable();
			expr = new Term( expr.id, expr.args.concat([last,free]) );
			return {
				value: expr,
				variable: free,
				error: false
			};
		} else {
			return {
				value: pl.error.type( "callable", expr, "DCG/0" ),
				variable: last,
				error: true
			};
		}
	}
	
	// Body conversion
	function body_conversion( expr ) {
		if( pl.type.is_variable( expr ) )
			return new Term( "call", [expr] );
		else if( pl.type.is_term( expr ) && [",/2", ";/2", "->/2"].indexOf(expr.indicator) !== -1 )
			return new Term( expr.id, [body_conversion( expr.args[0] ), body_conversion( expr.args[1] )] );
		else if( pl.type.is_term(expr) && expr.indicator === ":/2" ) {
			var body = body_conversion(expr.args[1]);
			return new Term(":", [expr.args[0], body]);
		}
		return expr;
	}
	
	// List to Prolog list
	function arrayToList( array, cons ) {
		var list = cons ? cons : new Term( "[]", [] );
		for(var i = array.length-1; i >= 0; i-- )
			list = new Term( ".", [array[i], list] );
		return list;
	}

	// Array difference
	function difference(xs, ys) {
		var zs = [];
		for(var i = 0; i < xs.length; i++) {
			if(indexOf(zs, xs[i]) === -1 && indexOf(ys, xs[i]) === -1)
				zs.push(xs[i]);
		}
		return zs;
	}
	
	// Remove element from array
	function remove( array, element ) {
		for( var i = array.length - 1; i >= 0; i-- ) {
			if( array[i] === element ) {
				array.splice(i, 1);
			}
		}
	}
	
	// Remove duplicate elements
	function nub( array ) {
		var seen = {};
		var unique = [];
		for( var i = 0; i < array.length; i++ ) {
			if( !(array[i] in seen) ) {
				unique.push( array[i] );
				seen[array[i]] = true;
			}
		}
		return unique;
	}

	// Retract a rule
	function retract(thread, point, indicator, rule, get_module) {
		if(get_module.rules[indicator]) {
			for(var i = 0; i < get_module.rules[indicator].length; i++) {
				if(get_module.rules[indicator][i] === rule) {
					get_module.rules[indicator].splice(i, 1);
					get_module.update_indices_predicate(indicator);
					thread.success( point );
					break;
				}
			}
		}
	}
	
	// call/n
	function callN(n) {
		return function(thread, point, atom) {
			var closure = atom.args[0], args = atom.args.slice(1, n);
			var module_atom;
			if(pl.type.is_term(closure) && closure.indicator === ":/2") {
				if(!pl.type.is_atom(closure.args[0])) {
					thread.throw_error(pl.error.type("module", closure.args[0], atom.indicator));
					return;
				}
				module_atom = closure.args[0];
				closure = closure.args[1];
			}
			if(pl.type.is_variable(closure)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(closure)) {
				thread.throw_error(pl.error.type("callable", closure, atom.indicator));
			} else {
				var goal = body_conversion(new Term(closure.id, closure.args.concat(args)));
				if(!pl.type.is_callable(goal)) {
					thread.throw_error(pl.error.type("callable", goal, atom.indicator));
					return;
				}
				if(module_atom)
					goal = new Term(":", [module_atom, goal]);
				thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
			}
		};
	}
	
	// String to indicator
	function str_indicator( str ) {
		for( var i = str.length - 1; i >= 0; i-- )
			if( str.charAt(i) === "/" )
				return new Term( "/", [new Term( str.substring(0, i) ), new Num( parseInt(str.substring(i+1)), false )] );
	}

	// Greatest common divisor
	function gcd(a, b) {
		if(b === 0)
			return a;
		return Math.abs(gcd(b, a % b));
	}
	
	

	// PROLOG OBJECTS
	
	// Variables
	function Var( id ) {
		this.id = id;
		this.ground = false;
	}
	
	// Numbers
	function Num( value, is_float ) {
		this.is_float = is_float !== undefined ? is_float : Math.trunc(value) !== value;
		this.value = this.is_float ? value : Math.trunc(value);
		this.index = this.value;
		this.ground = true;
	}
	
	// Terms
	var term_ref = 0;
	function Term( id, args, ref ) {
		term_ref++;
		this.ref = ref || term_ref;
		this.id = id;
		this.args = args || [];
		this.indicator = id + "/" + this.args.length;
		this.index = this.indicator;
		this.ground = true;
		for(var i = 0; i < this.args.length; i++) {
			if(this.args[i].hasOwnProperty("ground") && this.args[i].ground === false) {
				this.ground = false;
				break;
			}
		}
	}

	// Streams
	var stream_ref = 0;
	function Stream( stream, mode, alias, type, reposition, eof_action ) {
		this.id = stream_ref++;
		this.stream = stream;
		this.mode = mode; // "read" or "write" or "append"
		this.alias = alias;
		this.type = type !== undefined ? type : "text"; // "text" or "binary"
		this.reposition = reposition !== undefined ? reposition : true; // true or false
		this.eof_action = eof_action !== undefined ? eof_action : "eof_code"; // "error" or "eof_code" or "reset"
		this.position = this.mode === "append" ? "end_of_stream" : 0;
		this.output = this.mode === "write" || this.mode === "append";
		this.input = this.mode === "read";
		this.line_position = 0;
		this.line_count = 1;
		this.char_count = 0;
	}
	
	// Substitutions
	function Substitution( links, attrs ) {
		links = links || {};
		attrs = attrs || {};
		this.links = links;
		this.attrs = attrs;
	}
	
	// States
	function State( goal, subs, parent ) {
		subs = subs || new Substitution();
		parent = parent || null;
		this.goal = goal;
		this.substitution = subs;
		this.parent = parent;
	}
	
	// Rules
	function Rule( head, body, dynamic ) {
		this.head = head;
		this.body = body;
		this.dynamic = dynamic ? dynamic : false;
	}

	// Session
	function Session( limit ) {
		limit = typeof limit === "number" && limit > 0 ? limit : null;
		this.rename = 0;
		this.modules = {};
		this.modules.user = new Module("user", {}, "all", {
			session: this,
			dependencies: ["system"]
		});
		this.modules.system = pl.modules.system;
		this.rules = this.modules.user.rules;
		this.total_threads = 0;
		this.renamed_variables = {};
		this.public_predicates = this.modules.user.public_predicates;
		this.multifile_predicates = this.modules.user.multifile_predicates;
		this.limit = limit;
		this.streams = {
			"user_input": new Stream(
				nodejs_flag ? nodejs_user_input : tau_user_input,
				"read", "user_input", "text", false, "reset" ),
			"user_output": new Stream(
				nodejs_flag ? nodejs_user_output : tau_user_output,
				"append", "user_output", "text", false, "reset" ),
			"user_error": new Stream(
				nodejs_flag ? nodejs_user_error : tau_user_error,
				"append", "user_error", "text", false, "reset" ),
		};
		this.file_system = nodejs_flag ? nodejs_file_system : tau_file_system;
		this.standard_input = this.streams["user_input"];
		this.standard_output = this.streams["user_output"];
		this.standard_error = this.streams["user_error"];
		this.current_input = this.streams["user_input"];
		this.current_output = this.streams["user_output"];
		this.working_directory = "/"; // only for browser
		this.format_success = function( state ) { return state.substitution; };
		this.format_error = function( state ) { return state.goal; };
		this.flag = {	
			bounded: pl.flag.bounded.value,
			max_integer: pl.flag.max_integer.value,
			min_integer: pl.flag.min_integer.value,
			integer_rounding_function: pl.flag.integer_rounding_function.value,
			char_conversion: pl.flag.char_conversion.value,
			debug: pl.flag.debug.value,
			max_arity: pl.flag.max_arity.value,
			unknown: pl.flag.unknown.value,
			double_quotes: pl.flag.double_quotes.value,
			occurs_check: pl.flag.occurs_check.value,
			dialect: pl.flag.dialect.value,
			version_data: pl.flag.version_data.value,
			nodejs: pl.flag.nodejs.value,
			argv: pl.flag.argv.value
		};
		this.__loaded_modules = [];
		this.__char_conversion = {};
		this.__operators = {
			1200: { ":-": ["fx", "xfx"],  "-->": ["xfx"], "?-": ["fx"] },
			1150: { "meta_predicate": ["fx"] },
			1100: { ";": ["xfy"] },
			1050: { "->": ["xfy"], "*->": ["xfy"] },
			1000: { ",": ["xfy"] },
			900: { "\\+": ["fy"] },
			700: {
				"=": ["xfx"], "\\=": ["xfx"], "==": ["xfx"], "\\==": ["xfx"],
				"@<": ["xfx"], "@=<": ["xfx"], "@>": ["xfx"], "@>=": ["xfx"],
				"=..": ["xfx"], "is": ["xfx"], "=:=": ["xfx"], "=\\=": ["xfx"],
				"<": ["xfx"], "=<": ["xfx"], ">": ["xfx"], ">=": ["xfx"]
			},
			600: { ":": ["xfy"] },
			500: { "+": ["yfx"], "-": ["yfx"], "/\\": ["yfx"], "\\/": ["yfx"] },
			400: {
				"*": ["yfx"], "/": ["yfx"], "//": ["yfx"], "rem": ["yfx"],
				"mod": ["yfx"], "<<": ["yfx"], ">>": ["yfx"], "div": ["yfx"]
			},
			200: { "**": ["xfx"], "^": ["xfy"], "-": ["fy"], "+": ["fy"], "\\": ["fy"] }
		};
		this.thread = new Thread( this );
	}
	
	// Threads
	function Thread( session ) {
		this.epoch = Date.now();
		this.session = session;
		this.session.total_threads++;
		this.format_success = session.format_success;
		this.format_error = session.format_error;
		this.total_steps = 0;
		this.cpu_time = 0;
		this.points = [];
		this.debugger = false;
		this.debugger_states = [];
		this.level = new Term("top_level");
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
		this.warnings = [];
		this.__calls = [];
		this.__goal_expansion = false;
		this.__stacks = {};
	}
	
	// Modules
	function Module(id, rules, exports, options) {
		options = options === undefined ? {} : options;
		options.public_predicates = options.public_predicates === undefined ? {} : options.public_predicates;
		options.multifile_predicates = options.multifile_predicates === undefined ? {} : options.multifile_predicates;
		options.meta_predicates = options.meta_predicates === undefined ? {} : options.meta_predicates;
		options.session = options.session === undefined ? null : options.session;
		options.dependencies = options.dependencies === undefined ? [] : options.dependencies;
		this.id = id;
		this.rules = rules;
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		this.public_predicates = options.public_predicates;
		this.multifile_predicates = options.multifile_predicates;
		this.meta_predicates = options.meta_predicates;
		this.src_predicates = {};
		this.dependencies = options.dependencies;
		this.exports = exports;
		this.is_library = options.session === null;
		this.modules = {};
		if(options.session) {
			options.session.modules[id] = this;
			for(var i = 0; i < options.dependencies.length; i++) {
				var lib = options.dependencies[i];
				if(!options.session.modules.hasOwnProperty(lib))
					options.session.modules[lib] = pl.modules[lib];
			}
		} else {
			pl.modules[id] = this;
		}
		if(exports !== "all") {
			for(var i = 0; i < exports.length; i++) {
				this.public_predicates[exports[i]] =
					options.public_predicates.hasOwnProperty(exports[i]) &&
					options.public_predicates[exports[i]] === true;
			}
		}
		this.update_indices_clauses();
	}
	
	// Check if a predicate is exported
	Module.prototype.exports_predicate = function(indicator) {
		return this.exports === "all" || indexOf(this.exports, indicator) !== -1;
	};

	// Check if a predicate is public
	Module.prototype.is_public_predicate = function(indicator) {
		return !this.public_predicates.hasOwnProperty(indicator) || this.public_predicates[indicator] === true;
	};
	
	// Check if a predicate is multifile
	Module.prototype.is_multifile_predicate = function( indicator ) {
		return this.multifile_predicates.hasOwnProperty(indicator) && this.multifile_predicates[indicator] === true;
	};

	// Check if a predicate is a meta-predicate
	Module.prototype.is_meta_predicate = function( indicator ) {
		if(this.meta_predicates.hasOwnProperty(indicator))
			return this.meta_predicates[indicator];
		return null;
	};

	// Update indices of all predicates
	Module.prototype.update_indices_clauses = function() {
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		for(var indicator in this.rules)
			this.update_indices_predicate(indicator);
	};

	// Update indices of a predicate
	Module.prototype.update_indices_predicate = function(indicator) {
		this.indexed_clauses[indicator] = {};
		this.non_indexable_clauses[indicator] = [];
		if(!Array.isArray(this.rules[indicator]))
			return;
		for(var i = 0; i < this.rules[indicator].length; i++) {
			var clause = this.rules[indicator][i];
			this.add_index_predicate(clause);
		}
	};

	// Add indexed cluuse to a predicate
	Module.prototype.add_index_predicate = function(clause) {
		var indicator = clause.head.indicator;
		var index = clause.head.args.length > 0 ? clause.head.args[0].index : undefined;
		if(index) {
			if(!this.indexed_clauses.hasOwnProperty(indicator))
				this.indexed_clauses[indicator] = {};
			if(!this.indexed_clauses[indicator].hasOwnProperty(index)) {
				this.indexed_clauses[indicator][index] = [];
				if(this.non_indexable_clauses.hasOwnProperty(indicator))
					for(var j = 0; j < this.non_indexable_clauses[indicator].length; j++)
						this.indexed_clauses[indicator][index].push(this.non_indexable_clauses[indicator][j]);
			}
			this.indexed_clauses[indicator][index].push(clause);
		} else {
			if(!this.non_indexable_clauses.hasOwnProperty(indicator))
				this.non_indexable_clauses[indicator] = [];
			this.non_indexable_clauses[indicator].push(clause);
			for(var index in this.indexed_clauses[indicator])
				this.indexed_clauses[indicator][index].push(clause);
		}
	};



	// UNIFY PROLOG OBJECTS

	// Variables
	Var.prototype.unify = function(obj, occurs_check) {
		if(occurs_check && indexOf(obj.variables(), this.id) !== -1 && !pl.type.is_variable(obj))
			return null;
		var links = {};
		links[this.id] = obj;
		return new Substitution(links);
	};

	// Numbers
	Num.prototype.unify = function(obj, occurs_check) {
		if(pl.type.is_number(obj) && this.value === obj.value && this.is_float === obj.is_float)
			return new Substitution();
		return null;
	};

	// Terms
	Term.prototype.unify = function(obj, occurs_check) {
		if(!pl.type.is_term(obj) && obj.unify !== undefined) {
			return obj.unify(this, occurs_check);
		} else if(pl.type.is_term(obj) && this.indicator === obj.indicator) {
			var subs = new Substitution();
			for(var i = 0; i < this.args.length; i++) {
				var mgu = pl.unify(this.args[i].apply(subs), obj.args[i].apply(subs), occurs_check);
				if(mgu === null)
					return null;
				for(var x in mgu.links)
					subs.links[x] = mgu.links[x];
				subs = subs.apply(mgu);
			}
			return subs;
		}
		return null;
	};

	// Streams
	Stream.prototype.unify = function(obj, _occurs_check) {
		if(pl.type.is_stream(obj) && this.id === obj.id)
			return new Substitution();
		return null;
	};

	Stream.prototype.compare = function(obj) {
		if(this.id < obj.id)
			return -1;
		else if(this.id === obj.id)
			return 0;
		else
			return 1;
	};
	
	

	// PROLOG OBJECTS TO STRING
	
	// Variables
	Var.prototype.toString = function( options ) {
		options = options === undefined ? {} : options;
		if(options.variable_names) {
			var pointer = options.variable_names;
			while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
				var head = pointer.args[0];
				if(pl.type.is_term(head) && head.indicator === "=/2"
				&& pl.type.is_variable(head.args[1]) && head.args[1].id === this.id
				&& pl.type.is_atom(head.args[0]))
					return head.args[0].id;
				pointer = pointer.args[1];
			}
		}
		return this.id;
	};
	
	// Numbers
	Num.prototype.toString = function( _ ) {
		var str = this.value.toString();
		var e = str.indexOf("e");
		if(e !== -1) {
			if(str.indexOf(".") !== -1)
				return str;
			else
				return str.replace("e", ".0e");
		}
		return this.is_float && indexOf(str, ".") === -1 ? this.value + ".0" : str;
	};
	
	// Terms
	Term.prototype.toString = function( options, priority, from ) {
		options = !options ? {} : options;
		options.quoted = options.quoted === undefined ? false: options.quoted;
		options.ignore_ops = options.ignore_ops === undefined ? false : options.ignore_ops;
		options.numbervars = options.numbervars === undefined ? false : options.numbervars;
		options.variable_names = options.variable_names === undefined ? false : options.variable_names;
		priority = priority === undefined ? {priority: 1200, class: "", indicator: ""} : priority;
		from = from === undefined ? "" : from;
		var arg_priority = {priority: 999, class: "", indicator: ""};
		if( options.numbervars && this.indicator === "$VAR/1" && pl.type.is_integer( this.args[0] ) && this.args[0].value >= 0 ) {
			var i = this.args[0].value;
			var number = Math.floor( i/26 );
			var letter =  i % 26;
			return "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter] + (number !== 0 ? number : "");
		}
		switch( this.indicator ){
			case "[]/0":
			case "{}/0":
			case "!/0":
				return this.id;
			case "{}/1":
				if( options.ignore_ops === false ) {
					return "{" + this.args[0].toString( options ) + "}";
				} else {
					return "{}(" + this.args[0].toString( options ) + ")";
				}
			case "./2":
				if( options.ignore_ops === false ) {
					var list = "[" + this.args[0].toString( options, arg_priority );
					var pointer = this.args[1];
					while( pointer.indicator === "./2" ) {
						list += "," + pointer.args[0].toString( options, arg_priority );
						pointer = pointer.args[1];
					}
					if( pointer.indicator !== "[]/0" ) {
						list += "|" + pointer.toString( options, arg_priority );
					}
					list += "]";
					return list;
				}
			default:
				var id = this.id;
				var operator = options.session ? options.session.lookup_operator( this.id, this.args.length ) : null;
				if( options.session === undefined || options.ignore_ops || operator === null ) {
					if( options.quoted && (! /^(!|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+)$/.test( id ) && id !== "{}" && id !== "[]" || indexOf([".",",",";"], id) !== -1 || id.substring(0,2) === "/*") )
						id = "'" + redoEscape(id) + "'";
					if( this.args.length === 0 && is_graphic_token(this.id) && priority.indicator !== "")
						return "(" + id + ")";
					return id + (this.args.length > 0 ? "(" + map( this.args,
						function(x) { return x.toString(options, arg_priority); }
					).join(",") + ")" : "");
				} else {
					var priority_op = parseInt(operator.priority);
					var priority_arg = parseInt(priority.priority);
					var cond = priority_op > priority_arg || priority_op === priority_arg && (
						operator.class === "xfx" ||
						operator.class === "xfy" && this.indicator !== priority.indicator ||
						operator.class === "yfx" && this.indicator !== priority.indicator ||
						this.indicator === priority.indicator && operator.class === "yfx" && from === "right" ||
						this.indicator === priority.indicator && operator.class === "xfy" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "xf" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "fx" && from === "right");
					operator.indicator = this.indicator;
					var lpar = cond ? "(" : "";
					var rpar = cond ? ")" : "";
					var space = !(is_graphic_token(this.id) || this.id === "," || this.id === ";")
						|| operator.class.length === 2
						|| operator.class.length === 3 && pl.type.is_number(this.args[1]) && this.args[1].value < 0 ? " " : "";
					if( this.args.length === 0 ) {
						return lpar + this.id + rpar;
					} else if( ["fy","fx"].indexOf( operator.class) !== -1 ) {
						return lpar + id + space + this.args[0].toString( options, operator, "right" ) + rpar;
					} else if( ["yf","xf"].indexOf( operator.class) !== -1 ) {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + id + rpar;
					} else {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + this.id + space + this.args[1].toString( options, operator, "right" ) +  rpar;
					}
				}
		}
	};

	// Streams
	Stream.prototype.toString = function( _ ) {
		return "<stream>(" + this.id + ")";
	};
	
	// Substitutions
	Substitution.prototype.toString = function( options ) {
		var str = "{";
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( str !== "{" ) {
				str += ", ";
			}
			str += link + "/" + this.links[link].toString( options );
		}
		str += "}";
		return str;
	};
	
	// States
	State.prototype.toString = function( options ) {
		if( this.goal === null ) {
			return "<" + this.substitution.toString( options ) + ">";
		} else {
			return "<" + this.goal.toString( options ) + ", " + this.substitution.toString( options ) + ">";
		}
	};
	
	// Rules
	Rule.prototype.toString = function( options ) {
		if( !this.body ) {
			return this.head.toString( options ) + ".";
		} else {
			return this.head.toString( options, 1200, "left" ) + " :- " + this.body.toString( options, 1200, "right" ) + ".";
		}
	};
	
	// Session
	Session.prototype.toString = function( options ) {
		var str = "";
		for(var prop in this.modules) {
			if(this.modules.hasOwnProperty(prop) && this.modules[prop].is_library)
				str += ":- use_module(library(" + this.modules[prop] + ")).\n";
		}
		str += "\n";
		for(var key in this.modules.user.rules) {
			if(!this.modules.user.rules.hasOwnProperty(key)) continue;
			for(i = 0; i < this.modules.user.rules[key].length; i++) {
				str += this.modules.user.rules[key][i].toString(options);
				str += "\n";
			}
		}
		return str;
	};
	
	
	
	// CLONE PROLOG OBJECTS
	
	// Variables
	Var.prototype.clone = function() {
		return new Var( this.id );
	};
	
	// Numbers
	Num.prototype.clone = function() {
		return new Num( this.value, this.is_float );
	};
	
	// Terms
	Term.prototype.clone = function() {
		var term = new Term( this.id, map( this.args, function( arg ) {
			return arg.clone();
		} ) );
		if(this.definition_module)
			term.definition_module = this.definition_module;
		return term;
	};

	// Streams
	Stream.prototype.clone = function() {
		return new Stream( this.stream, this.mode, this.alias, this.type, this.reposition, this.eof_action );
	};
	
	// Substitutions
	Substitution.prototype.clone = function() {
		var links = {};
		var attrs = {};
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].clone();
		}
		for( var attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attrs)) continue;
			attrs[attr] = {};
			for( var m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].clone();
			}
		}
		return new Substitution( links, attrs );
	};
	
	// States
	State.prototype.clone = function() {
		return new State( this.goal.clone(), this.substitution.clone(), this.parent );
	};
	
	// Rules
	Rule.prototype.clone = function() {
		return new Rule( this.head.clone(), this.body !== null ? this.body.clone() : null );
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.equals = function( obj ) {
		return pl.type.is_variable( obj ) && this.id === obj.id;
	};
	
	// Numbers
	Num.prototype.equals = function( obj ) {
		return pl.type.is_number( obj ) && this.value === obj.value && this.is_float === obj.is_float;
	};
	
	// Terms
	Term.prototype.equals = function( obj ) {
		if( !pl.type.is_term( obj ) || this.indicator !== obj.indicator ) {
			return false;
		}
		for( var i = 0; i < this.args.length; i++ ) {
			if( !this.args[i].equals( obj.args[i] ) ) {
				return false;
			}
		}
		return true;
	};

	// Streams
	Stream.prototype.equals = function( obj ) {
		return pl.type.is_stream( obj ) && this.id === obj.id;
	};
	
	// Substitutions
	Substitution.prototype.equals = function( obj ) {
	var link;
		if( !pl.type.is_substitution( obj ) ) {
			return false;
		}
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( !obj.links[link] || !this.links[link].equals( obj.links[link] ) ) {
				return false;
			}
		}
		for( link in obj.links ) {
			if(!obj.links.hasOwnProperty(link)) continue;
			if( !this.links[link] ) {
				return false;
			}
		}
		return true;
	};
	
	// States
	State.prototype.equals = function( obj ) {
		return pl.type.is_state( obj ) && this.goal.equals( obj.goal ) && this.substitution.equals( obj.substitution ) && this.parent === obj.parent;
	};
	
	// Rules
	Rule.prototype.equals = function( obj ) {
		return pl.type.is_rule( obj ) && this.head.equals( obj.head ) && (this.body === null && obj.body === null || this.body !== null && this.body.equals( obj.body ));
	};
	
	
	
	// RENAME VARIABLES OF PROLOG OBJECTS
	
	// Variables
	Var.prototype.rename = function( thread ) {
		return thread.get_free_variable( this );
	};
	
	// Numbers
	Num.prototype.rename = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.rename = function( thread ) {
		// ground
		if(this.ground)
			return new Term(this.id, this.args);
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].rename(thread);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.rename(thread);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].rename(thread);
			args.push(app);
		}
		return new Term(this.id, args);
	};

	// Streams
	Stream.prototype.rename = function( thread ) {
		return this;
	};
	
	// Rules
	Rule.prototype.rename = function( thread ) {
		return new Rule( this.head.rename( thread ), this.body !== null ? this.body.rename( thread ) : null );
	};



	// CHECK IF RENAME

	// Variables
	Var.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_variable(obj)
		|| links.hasOwnProperty(this.id) && links[this.id] !== obj.id
		|| links.hasOwnProperty(obj.id) && links[obj.id] !== this.id)
			return false;
		links[this.id] = obj.id;
		links[obj.id] = this.id;
		return true;
	};
	
	// Numbers
	Num.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	// Terms
	Term.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_term(obj) || this.indicator !== obj.indicator)
			return false;
		for(var i = 0; i < this.args.length; i++) {
			if(!pl.is_rename(this.args[i], obj.args[i], links))
				return false;
		}
		return true;
	};

	// Streams
	Stream.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	
	
	// GET ID OF VARIABLES FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.variables = function() {
		return [this.id];
	};
	
	// Numbers
	Num.prototype.variables = function() {
		return [];
	};
	
	// Terms
	Term.prototype.variables = function() {
		if(this.ground)
			return [];
		return [].concat.apply( [], map( this.args, function( arg ) {
			return arg.variables();
		} ) );
	};

	// Streams
	Stream.prototype.variables = function() {
		return [];
	};
	
	// Rules
	Rule.prototype.variables = function() {
		if( this.body === null ) {
			return this.head.variables();
		} else {
			return this.head.variables().concat( this.body.variables() );
		}
	};
	
	
	
	// APPLY SUBSTITUTIONS TO PROLOG OBJECTS
	
	// Variables
	Var.prototype.apply = function( subs ) {
		if( subs.lookup( this.id ) ) {
			return subs.lookup( this.id );
		}
		return this;
	};
	
	// Numbers
	Num.prototype.apply = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.apply = function( subs ) {
		// ground atom
		if(this.ground)
			return this;
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].apply(subs);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.apply(subs);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].apply(subs);
			args.push(app);
		}
		return new Term(this.id, args, this.ref);
	};

	// Streams
	Stream.prototype.apply = function( _ ) {
		return this;
	};
	
	// Rules
	Rule.prototype.apply = function( subs ) {
		return new Rule( this.head.apply( subs ), this.body !== null ? this.body.apply( subs ) : null );
	};
	
	// Substitutions
	Substitution.prototype.apply = function( subs ) {
		var link, links = {}, attr, attrs = {}, m;
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].apply(subs);
		}
		for( attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attr)) continue;
			attrs[attr] = {};
			for( m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].apply(subs);
			}
		}
		return new Substitution( links, attrs );
	};
	
	
	
	// SELECTION FUNCTION
	
	// Select term
	Term.prototype.select = function() {
		var pointer = this;
		while(pl.type.is_term(pointer) && pointer.indicator === ",/2")
			pointer = pointer.args[0];
		return pointer;
	};
	
	// Replace term
	Term.prototype.replace = function( expr ) {
		if( this.indicator === ",/2" ) {
			if( this.args[0].indicator === ",/2" ) {
				return new Term( ",", [this.args[0].replace( expr ), this.args[1]] );
			} else {
				return expr === null ? this.args[1] : new Term( ",", [expr, this.args[1]] );
			}
		} else {
			return expr;
		}
	};

	// Search term
	Term.prototype.search = function( expr ) {
		if(this == expr || this.ref === expr.ref)
			return true;
		for( var i = 0; i < this.args.length; i++ )
			if( pl.type.is_term( this.args[i] ) && this.args[i].search( expr ) )
				return true;
		return false;
	};
	
	
	
	// PROLOG SESSIONS AND THREADS

	// Push to a global stack
	Session.prototype.push_global_stack = function(stack, value) {
		return this.thread.push_global_stack(stack, value);
	};
	Thread.prototype.push_global_stack = function(stack, value) {
		if(!this.__stacks.hasOwnProperty(stack))
			this.__stacks[stack] = [];
		this.__stacks[stack].push(value);
	};

	// Pop all from a global stack
	Session.prototype.flush_global_stack = function(stack, tail) {
		return this.thread.push_global_stack(stack, tail);
	};
	Thread.prototype.flush_global_stack = function(stack, tail) {
		var list = tail || new Term("[]", []);
		if(this.__stacks.hasOwnProperty(stack)) {
			while(this.__stacks[stack].length > 0)
				list = new Term(".", [this.__stacks[stack].pop(), list]);
			delete this.__stacks[stack];
		}
		return list;
	};

	// Set max inferences
	Session.prototype.setMaxInferences = function(max) {
		this.limit = typeof max === "number" && max > 0 ? max : null;
	};
	Thread.prototype.setMaxInferences = function(max) {
		this.session.setMaxInferences(max);
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
	};

	// Format answer
	Session.prototype.format_answer = function(answer, options) {
		return this.thread.format_answer(answer, options);
	};
	Thread.prototype.format_answer = function(answer, options) {
		return pl.format_answer(answer, this, options);
	};

	// Get current input
	Session.prototype.get_current_input = function() {
		return this.current_input;
	};
	Thread.prototype.get_current_input = function() {
		return this.session.get_current_input();
	};

	// Get current output
	Session.prototype.get_current_output = function() {
		return this.current_output;
	};
	Thread.prototype.get_current_output = function() {
		return this.session.get_current_output();
	};

	// Set current input
	Session.prototype.set_current_input = function( input ) {
		this.current_input = input;
	};
	Thread.prototype.set_current_input = function( input ) {
		return this.session.set_current_input( input );
	};

	// Set current output
	Session.prototype.set_current_output = function( output ) {
		this.current_output = output;
	};
	Thread.prototype.set_current_output = function( output ) {
		return this.session.set_current_output( output);
	};

	// Get stream by alias
	Session.prototype.get_stream_by_alias = function( alias ) {
		return this.streams[alias];
	};
	Thread.prototype.get_stream_by_alias = function( alias ) {
		return this.session.get_stream_by_alias( alias );
	};

	// Open file
	Session.prototype.file_system_open = function( path, type, mode ) {
		if(this.get_flag("nodejs").indicator === "false/0")
			path = this.absolute_file_name(path);
		return this.file_system.open( path, type, mode );
	};
	Thread.prototype.file_system_open = function( path, type, mode ) {
		return this.session.file_system_open( path, type, mode );
	};

	// Absolute file name
	Session.prototype.absolute_file_name = function(filename) {
		var absolute;
		// node.js
		if(this.get_flag("nodejs").indicator === "true/0") {
			var path = __webpack_require__(/*! path */ "?4461");
			absolute = filename;
			for(var prop in process.env) {
				if(!process.env.hasOwnProperty(prop))
					continue;
				absolute = absolute.replace(new RegExp("\\$" + prop, "g"), process.env[prop]);
			}
			return path.resolve(absolute);
		// browser
		} else {
			var cwd = this.working_directory;
			if(filename[0] === "/")
				absolute = filename;
			else
				absolute = cwd + (cwd[cwd.length-1] === "/" ? filename : "/" + filename);
			absolute = absolute.replace(/\/\.\//g, "/");
			var dirs = absolute.split("/");
			var dirs2 = [];
			for(var i = 0; i < dirs.length; i++) {
				if(dirs[i] !== "..") {
					dirs2.push(dirs[i]);
				} else {
					if(dirs2.length !== 0)
						dirs2.pop();
				}
			}
			absolute = dirs2.join("/").replace(/\/\.$/, "/");
		}
		return absolute;
	};
	Thread.prototype.absolute_file_name = function(path, cwd) {
		return this.session.absolute_file_name(path, cwd);
	};

	// Get conversion of the char
	Session.prototype.get_char_conversion = function( char ) {
		return this.__char_conversion[char] || char;
	};
	Thread.prototype.get_char_conversion = function( char ) {
		return this.session.get_char_conversion( char );
	};
	
	// Parse an expression
	Session.prototype.parse = function( string ) {
		return this.thread.parse( string );
	};
	Thread.prototype.parse = function( string ) {
		var tokenizer = new Tokenizer( this );
		tokenizer.new_text( string );
		var tokens = tokenizer.get_tokens();
		if( tokens === null )
			return false;
		var expr = parseExpr(this, tokens, 0, this.__get_max_priority(), false);
		if( expr.len !== tokens.length )
			return false;
		return { value: expr.value, expr: expr, tokens: tokens };
	};
	
	// Get flag value
	Session.prototype.get_flag = function( flag ) {
		return this.flag[flag];
	};
	Thread.prototype.get_flag = function( flag ) {
		return this.session.get_flag( flag );
	};

	// Add a rule
	Session.prototype.add_rule = function(rule, options) {
		return this.thread.add_rule(rule, options);
	};
	Thread.prototype.add_rule = function(rule, options) {
		options = options ? options : {};
		options.from = options.from ? options.from : "$tau-js";
		var module_id, get_module;
		if(pl.type.is_term(rule.head) && rule.head.indicator === ":/2") {
			if(!pl.type.is_atom(rule.head.args[0])) {
				this.throw_warning(pl.error.type("module", rule.head.args[0], "top_level/0"));
				return;
			}
			module_id = rule.head.args[0].id;
			rule.head = rule.head.args[1];
		}
		if(module_id) {
			get_module = this.session.modules[module_id];
			if(!pl.type.is_module(get_module)) {
				get_module = new Module(module_id, {}, "all", {session: this.session});
				this.session.modules[module_id] = get_module;
			}
		} else {
			get_module = this.session.modules[options.context_module];
		}
		get_module.src_predicates[rule.head.indicator] = options.from;
		if(!get_module.rules.hasOwnProperty(rule.head.indicator)) {
			get_module.rules[rule.head.indicator] = [];
		}
		get_module.rules[rule.head.indicator].push(rule);
		if(!get_module.public_predicates.hasOwnProperty(rule.head.indicator))
			get_module.public_predicates[rule.head.indicator] = false;
		// update term indexing
		get_module.add_index_predicate(rule);
		return true;
	};

	// Run a directive
	Session.prototype.run_directive = function(directive, options) {
		return this.thread.run_directive(directive, options);
	};
	Thread.prototype.run_directive = function(directive, options) {
		if(pl.type.is_directive(directive)) {
			if(pl.directive[directive.indicator])
				return pl.directive[directive.indicator](this, directive, options);
			else
				return pl.directive[directive.id + "/*"](this, directive, options);
		}
		return false;
	};
	
	// Get maximum priority of the operators
	Session.prototype.__get_max_priority = function() {
		return "1200";
	};
	Thread.prototype.__get_max_priority = function() {
		return this.session.__get_max_priority();
	};
	
	// Get next priority of the operators
	Session.prototype.__get_next_priority = function( priority ) {
		var max = 0;
		priority = parseInt( priority );
		for( var key in this.__operators ) {
			if( !this.__operators.hasOwnProperty(key) ) continue;
			var n = parseInt(key);
			if( n > max && n < priority ) max = n;
		}
		return max.toString();
	};
	Thread.prototype.__get_next_priority = function( priority ) {
		return this.session.__get_next_priority( priority );
	};
	
	// Get classes of an operator
	Session.prototype.__lookup_operator_classes = function( priority, operator ) {
		if( this.__operators.hasOwnProperty( priority ) && this.__operators[priority][operator] instanceof Array ) {
			return this.__operators[priority][operator]  || false;
		}
		return false;
	};
	Thread.prototype.__lookup_operator_classes = function( priority, operator ) {
		return this.session.__lookup_operator_classes( priority, operator );
	};

	// Get operator
	Session.prototype.lookup_operator = function( name, arity ) {
		for(var p in this.__operators)
			if(this.__operators[p][name])
				for(var i = 0; i < this.__operators[p][name].length; i++)
					if( this.__operators[p][name][i].length === arity+1 )
						return {priority: p, class: this.__operators[p][name][i]};
		return null;
	};
	Thread.prototype.lookup_operator = function( name, arity ) {
		return this.session.lookup_operator( name, arity );
	};
	
	// Throw a warning
	Session.prototype.throw_warning = function( warning ) {
		this.thread.throw_warning( warning );
	};
	Thread.prototype.throw_warning = function( warning ) {
		this.warnings.push( warning );
	};
	
	// Get warnings
	Session.prototype.get_warnings = function() {
		return this.thread.get_warnings();
	};
	Thread.prototype.get_warnings = function() {
		return this.warnings;
	};

	// Add a goal
	Session.prototype.add_goal = function( goal, unique ) {
		this.thread.add_goal( goal, unique );
	};
	Thread.prototype.add_goal = function( goal, unique, parent ) {
		parent = parent ? parent : null;
		if( unique === true )
			this.points = [];
		var vars = goal.variables();
		var links = {};
		for( var i = 0; i < vars.length; i++ )
			links[vars[i]] = new Var(vars[i]);
		this.points.push( new State( goal, new Substitution(links), parent ) );
	};

	// Consult a program from a string
	Session.prototype.consult = function(program, options) {
		return this.thread.consult(program, options);
	};
	Thread.prototype.consult = function(program, options) {
		var string = "", success = false;
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.text = options.text === undefined ? true : options.text;
		opts.html = options.html === undefined ? true : options.html;
		opts.url = options.url === undefined ? true : options.url;
		opts.file = options.file === undefined ? true : options.file;
		opts.script = options.script === undefined ? true : options.script;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		// string
		if(typeof program === "string") {
			string = program;
			// script id
			if(opts.script && this.get_flag("nodejs").indicator === "false/0" && program != "" && document.getElementById(string)) {
				var script = document.getElementById(string);
				var type = script.getAttribute("type");
				if(type !== null && type.replace(/ /g, "").toLowerCase() === "text/prolog") {
					string = script.text;
					success = true;
				}
			}
			// file (node.js)
			if(!success && opts.file && this.get_flag("nodejs").indicator === "true/0") {
				var fs = __webpack_require__(/*! fs */ "?4a0f");
				var thread = this;
				fs.readFile(program, function(error, data) {
					if(error) {
						opts.file = false;
						thread.consult(program, opts);
					} else {
						parseProgram(thread, data.toString(), opts);
					}
				});
				return;
			}
			// http request
			if(!success && this.get_flag("nodejs").indicator === "false/0" && opts.url && program !== "" && !(/\s/.test(program))) {
				try {
					var xhttp = new XMLHttpRequest();
					var thread = this;
					xhttp.onreadystatechange = function() {
						if(this.readyState == 4) {
							if(this.status == 200) {
								string = xhttp.responseText;
								success = true;
								parseProgram(thread, string, opts);
							} else {
								opts.url = false;
								thread.consult(program, opts);
							}
						}
					}
					xhttp.open("GET", program, true);
					xhttp.send();
					return;
				} catch(ex) {
					opts.error(ex);
					return;
				}
			}
			// text
			if(!success && opts.text) {
				success = true;
			}
		// html
		} else if(opts.html && program.nodeName) {
			switch(program.nodeName.toLowerCase()) {
				case "input":
				case "textarea":
					string = program.value;
					success = true;
					break;
				default:
					string = program.innerHTML;
					success = true;
					break;
			}
		} else {
			opts.error(pl.error.existence("source_sink", new Term(string), "top_level/0"));
		}
		this.warnings = [];
		parseProgram(this, string, opts);
	};

	// Query goal from a string (without ?-)
	Session.prototype.query = function(string, options) {
		return this.thread.query(string, options);
	};
	Thread.prototype.query = function(string, options) {
		this.points = [];
		this.debugger_states = [];
		this.level = new Term("top_level");
		return parseQuery(this, string, options);
	};
	
	// Get first choice point
	Session.prototype.head_point = function() {
		return this.thread.head_point();
	};
	Thread.prototype.head_point = function() {
		return this.points[this.points.length-1];
	};
	
	// Get free variable
	Session.prototype.get_free_variable = function( variable ) {
		return this.thread.get_free_variable( variable );
	};
	Thread.prototype.get_free_variable = function( variable ) {
		var variables = [];
		if( variable.id === "_" || this.session.renamed_variables[variable.id] === undefined ) {
			this.session.rename++;
			if( this.current_point )
				variables = this.current_point.substitution.domain();
			while( indexOf( variables, pl.format_variable( this.session.rename, variable.id ) ) !== -1 ) {
				this.session.rename++;
			}
			if( variable.id === "_" ) {
				return new Var( pl.format_variable( this.session.rename, variable.id ) );
			} else {
				this.session.renamed_variables[variable.id] = pl.format_variable( this.session.rename, variable.id );
			}
		}
		return new Var( this.session.renamed_variables[variable.id] );
	};
	
	// Get next free variable
	Session.prototype.next_free_variable = function() {
		return this.thread.next_free_variable();
	};
	Thread.prototype.next_free_variable = function() {
		this.session.rename++;
		var variables = [];
		if( this.current_point )
			variables = this.current_point.substitution.domain();
		while( indexOf( variables, pl.format_variable( this.session.rename ) ) !== -1 ) {
			this.session.rename++;
		}
		return new Var( pl.format_variable( this.session.rename ) );
	};
	
	// Check if a predicate is public
	Session.prototype.is_public_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_public_predicate(indicator);
	};
	Thread.prototype.is_public_predicate = function(indicator, module_id) {
		return this.session.is_public_predicate(indicator, module_id);
	};
	
	// Check if a predicate is multifile
	Session.prototype.is_multifile_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_multifile_predicate(indicator);
	};
	Thread.prototype.is_multifile_predicate = function(indicator, module_id) {
		return this.session.is_multifile_predicate(indicator, module_id);
	};

	// Check if a predicate is a meta-predicate
	Session.prototype.is_meta_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		if(pl.type.is_module(this.modules[module_id]))
			return this.modules[module_id].is_meta_predicate(indicator);
		return null;
	};
	Thread.prototype.is_meta_predicate = function(indicator, module_id) {
		return this.session.is_meta_predicate(indicator, module_id);
	};
	
	// Insert states at the beginning
	Session.prototype.prepend = function( states ) {
		return this.thread.prepend( states );
	};
	Thread.prototype.prepend = function( states ) {
		for(var i = states.length-1; i >= 0; i--)
			this.points.push( states[i] );
	};
	
	// Remove the selected term and prepend the current state
	Session.prototype.success = function( point, parent ) {
		return this.thread.success( point, parent );
	}
	Thread.prototype.success = function( point, parent ) {
		var parent = typeof parent === "undefined" ? point : parent;
		this.prepend( [new State( point.goal.replace( null ), point.substitution, parent ) ] );
	};
	
	// Throw error
	Session.prototype.throw_error = function(error) {
		return this.thread.throw_error(error);
	};
	Thread.prototype.throw_error = function(error) {
		if(pl.type.is_variable(error))
			error = pl.error.instantiation(this.level.indicator);
		var state = new State(
			new Term("throw", [error]),
			new Substitution(),
			null
		);
		state.error = true;
		this.prepend([state]);
	};
	
	// Get the module of a predicate
	Session.prototype.lookup_module = function(atom, context_module) {
		return this.thread.lookup_module(atom, context_module);
	}
	Thread.prototype.lookup_module = function(atom, context_module) {
		var get_module = this.session.modules[context_module];
		if(!pl.type.is_module(get_module))
			get_module = this.session.modules.user;
		if(get_module.rules.hasOwnProperty(atom.indicator) && (
			get_module.exports_predicate(atom.indicator) ||
			get_module.rules.hasOwnProperty(this.level.indicator) ||
			context_module === get_module.id))
				return get_module;
		get_module.modules.system = pl.modules.system;
		get_module.modules.user = this.session.modules.user;
		for(var prop in get_module.modules) {
			if(!this.session.modules.hasOwnProperty(prop))
				continue;
			var get_module = this.session.modules[prop];
			if(get_module.rules.hasOwnProperty(atom.indicator) && (
				get_module.exports_predicate(atom.indicator) ||
				get_module.rules.hasOwnProperty(this.level.indicator) ||
				context_module === get_module.id))
					return get_module;
		}
		return null;
	};

	// Expand a meta-predicate
	Session.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		return this.thread.expand_meta_predicate(atom, definition_module, context_module);
	};
	Thread.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		var get_module = this.session.modules[definition_module];
		if(!get_module)
			return;
		var meta = get_module.is_meta_predicate(atom.indicator);
		if(!meta)
			return;
		for(var i = 0; i < meta.args.length; i++) {
			if(pl.type.is_integer(meta.args[i]) || pl.type.is_atom(meta.args[i]) && indexOf([":"], meta.args[i].id) !== -1) {
				if(!pl.type.is_term(atom.args[i]) || atom.args[i].indicator !== ":/2") {
					atom.args[i] = new Term(":", [new Term(context_module), atom.args[i]]);
				}
			} else if(pl.type.is_atom(meta.args[i]) && meta.args[i].id === "^") {
				var pointer_last = atom;
				var pointer_index = i;
				var pointer = atom.args[i];
				while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
					pointer_last = pointer;
					pointer_index = 1;
					pointer = pointer.args[1];
				}
				if(!pl.type.is_term(pointer) || pointer.indicator !== ":/2") {
					pointer_last.args[pointer_index] = new Term(":", [new Term(context_module), pointer]);
				}
			}
		}
	};
	
	// Resolution step
	Session.prototype.step = function() {
		return this.thread.step();
	}
	Thread.prototype.step = function() {
		if(this.points.length === 0) {
			return;
		}
		var asyn = false;
		var point = this.points.pop();
		this.current_point = point;
		if(this.debugger)
			this.debugger_states.push(point);
		var atom = pl.type.is_term(point.goal) ? point.goal.select() : point.goal;
		if(pl.type.is_term(atom) && (atom.indicator !== ":/2" || pl.type.is_term(atom.args[1]))) {
			var context_module = null;
			var states = [];
			if(atom !== null) {
				this.total_steps++;
				var level = point;
				while(level.parent !== null && level.parent.goal.search(atom))
					level = level.parent;
				if(level.parent === null) {
					this.level = new Term("top_level");
				} else {
					this.level = level.parent.goal.select();
					if(this.level.indicator === ":/2")
						this.level = this.level.args[1];
				}
				if(pl.type.is_term(atom) && atom.indicator === ":/2") {
					context_module = atom.args[0];
					atom = atom.args[1];
					if(!pl.type.is_atom(context_module)) {
						this.throw_error(pl.error.type("module", context_module, this.level.indicator));
						return;
					}
					context_module = context_module.id;
				} else {
					if(this.level.definition_module) {
						context_module = this.level.definition_module;
					} else {
						context_module = "user";
					}
				}
				atom.context_module = context_module;
				if(atom.indicator === ",/2") {
					this.prepend([new State(
						point.goal.replace(new Term(",", [
							new Term(":", [new Term(context_module), atom.args[0]]),
							new Term(":", [new Term(context_module), atom.args[1]])])),
						point.substitution,
						point
					)]);
					return;
				}
				this.__call_indicator = atom.indicator;
				var get_module = this.lookup_module(atom, context_module);
				atom.definition_module = pl.type.is_module(get_module) ? get_module.id : "user";
				this.expand_meta_predicate(atom, atom.definition_module, context_module);
				var clauses = null;
				if(get_module && atom.args.length > 0 && atom.args[0].index && get_module.indexed_clauses.hasOwnProperty(atom.indicator) && get_module.indexed_clauses[atom.indicator].hasOwnProperty(atom.args[0].index))
					clauses = get_module.indexed_clauses[atom.indicator][atom.args[0].index];
				else
					clauses = get_module === null ? null : get_module.rules[atom.indicator];
				if(clauses === null) {
					if(!this.session.modules.user.rules.hasOwnProperty(atom.indicator)) {
						if(this.get_flag("unknown").id === "error") {
							this.throw_error( pl.error.existence( "procedure", atom.indicator, this.level.indicator));
						} else if(this.get_flag("unknown").id === "warning") {
							this.throw_warning("unknown procedure " + atom.indicator + " (from " + this.level.indicator + ")");
						}
					}
				} else if(clauses instanceof Function) {
					asyn = clauses(this, point, atom);
				} else {
					// Goal expansion
					if(this.__goal_expansion && atom.indicator === "goal_expansion/2")
						clauses = clauses.concat(pl.builtin.rules["goal_expansion/2"]);
					for(var i = 0; i < clauses.length; i++) {
						this.session.renamed_variables = {};
						var clause = clauses[i].rename(this);
						var occurs_check = this.get_flag("occurs_check").indicator === "true/0";
						var mgu = pl.unify(atom, clause.head, occurs_check);
						if(mgu !== null) {
							var state = new State();
							state.goal = point.goal.replace(clause.body);
							if(state.goal !== null)
								state.goal = state.goal.apply(mgu);
							state.substitution = point.substitution.apply(mgu);
							state.parent = point;
							states.push(state);
						}
					}
					this.prepend(states);
				}
			}
		} else {
			var term = pl.type.is_term(atom) && atom.indicator === ":/2" ? atom.args[1] : atom;
			if(pl.type.is_variable(term))
				this.throw_error(pl.error.instantiation(this.level.indicator));
			else
				this.throw_error(pl.error.type("callable", term, this.level.indicator));
		}
		return asyn;
	};
	
	// Find next computed answer
	Session.prototype.answer = function(options) {
		return this.thread.answer(options);
	};
	Thread.prototype.answer = function(options) {
		var opts = {};
		options = options || function() {};
		if(typeof options === "function") {
			opts = {
				success: options,
				error: options,
				fail: options,
				limit: options
			};
		} else {
			opts.success = options.success === undefined ? function() {} : options.success;
			opts.error = options.error === undefined ? function() {} : options.error;
			opts.fail = options.fail === undefined ? function() {} : options.fail;
			opts.limit = options.limit === undefined ? function() {} : options.limit;
		}
		this.__calls.push(opts);
		if( this.__calls.length > 1 ) {
			return;
		}
		this.again();
	};
	
	// Find all computed answers
	Session.prototype.answers = function( callback, max, after ) {
		return this.thread.answers( callback, max, after );
	}
	Thread.prototype.answers = function( callback, max, after ) {
		var answers = max === undefined ? 1000 : max;
		var thread = this;
		if( answers <= 0 ) {
			if(after)
				after();
			return;
		}
		this.answer( function( answer ) {
			callback( answer );
			if( answer !== false ) {
				setTimeout( function() {
					thread.answers( callback, answers-1, after );
				}, 0 );
			} else if(after) {
				after();
			}
		} );
	};

	// Again finding next computed answer
	Session.prototype.again = function(reset_limit) {
		return this.thread.again(reset_limit);
	};
	Thread.prototype.again = function(reset_limit) {
		while(this.__calls.length > 0) {
			this.warnings = [];
			if(reset_limit !== false)
				this.current_limit = this.session.limit;
			while((!this.has_limit || this.current_limit > 0) && this.points.length > 0 && this.head_point().goal !== null && !pl.type.is_error_state(this.head_point())) {
				if(this.has_limit)
					this.current_limit--;
				var t0 = Date.now();
				var asyn = this.step();
				var t1 = Date.now();
				this.cpu_time += t1-t0;
				if(asyn === true)
					return;
			}
			var call = this.__calls.shift();
			// limit of inferences
			if(this.has_limit && this.current_limit <= 0) {
				(function(call) {
					return setTimeout(function() {
						call.limit(null);
					}, 0);
				})(call);
			// no answer
			} else if(this.points.length === 0) {
				(function(call) {
					return setTimeout(function() {
						call.fail(false);
					}, 0);
				})(call);
			// error
			} else if(pl.type.is_error(this.head_point().goal)) {
				var error = this.format_error(this.points.pop());
				this.points = [];
				(function(error, call) {
					return setTimeout(function() {
						call.error(error);
					}, 0);
				})(error, call);
			// computed answer
			} else {
				if(this.debugger)
					this.debugger_states.push(this.head_point());
				var answer = this.format_success(this.points.pop());
				(function(answer, call) {
					return setTimeout(function() {
						call.success(answer);
					}, 0);
				})(answer, call);
			}
		}
	};
	
	// Unfolding transformation
	Session.prototype.unfold = function( rule ) {
		if(rule.body === null)
			return false;
		var head = rule.head;
		var body = rule.body;
		var atom = body.select();
		var thread = new Thread( this );
		var unfolded = [];
		thread.add_goal( atom );
		thread.step();
		for( var i = thread.points.length-1; i >= 0; i-- ) {
			var point = thread.points[i];
			var head2 = head.apply( point.substitution );
			var body2 = body.replace( point.goal );
			if( body2 !== null )
				body2 = body2.apply( point.substitution );
			unfolded.push( new Rule( head2, body2 ) );
		}
		var rules = this.modules.user.rules[head.indicator];
		var index = indexOf( rules, rule );
		if( unfolded.length > 0 && index !== -1 ) {
			rules.splice.apply( rules, [index, 1].concat(unfolded) );
			return true;
		}
		return false;
	};
	Thread.prototype.unfold = function(rule) {
		return this.session.unfold(rule);
	};

	
	
	// INTERPRET EXPRESSIONS
	
	// Variables
	Var.prototype.interpret = function( thread ) {
		return pl.error.instantiation( thread.level.indicator );
	};
	
	// Numbers
	Num.prototype.interpret = function( thread ) {
		return this;
	};
	
	// Terms
	Term.prototype.interpret = function( thread ) {
		if( pl.type.is_unitary_list( this ) ) {
			return this.args[0].interpret( thread );
		} else {
			return pl.operate( thread, this );
		}
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.compare = function( obj ) {
		if( this.id < obj.id ) {
			return -1;
		} else if( this.id > obj.id ) {
			return 1;
		} else {
			return 0;
		}
	};
	
	// Numbers
	Num.prototype.compare = function( obj ) {
		if( this.value === obj.value && this.is_float === obj.is_float ) {
			return 0;
		} else if( this.value < obj.value || this.value === obj.value && this.is_float && !obj.is_float ) {
			return -1;
		} else if( this.value > obj.value ) {
			return 1;
		}
	};
	
	// Terms
	Term.prototype.compare = function( obj ) {
		if( this.args.length < obj.args.length || this.args.length === obj.args.length && this.id < obj.id ) {
			return -1;
		} else if( this.args.length > obj.args.length || this.args.length === obj.args.length && this.id > obj.id ) {
			return 1;
		} else {
			for( var i = 0; i < this.args.length; i++ ) {
				var arg = pl.compare( this.args[i], obj.args[i] );
				if( arg !== 0 ) {
					return arg;
				}
			}
			return 0;
		}
	};
	

	
	// SUBSTITUTIONS
	
	// Lookup variable
	Substitution.prototype.lookup = function( variable ) {
		if( this.links[variable] ) {
			return this.links[variable];
		} else {
			return null;
		}
	};
	
	// Filter variables
	Substitution.prototype.filter = function( predicate ) {
		var links = {};
		for( var id in this.links ) {
			if(!this.links.hasOwnProperty(id)) continue;
			var value = this.links[id];
			if( predicate( id, value ) ) {
				links[id] = value;
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Exclude variables
	Substitution.prototype.exclude = function( variables ) {
		var links = {};
		for( var variable in this.links ) {
			if(!this.links.hasOwnProperty(variable)) continue;
			if( indexOf( variables, variable ) === -1 ) {
				links[variable] = this.links[variable];
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Add link
	Substitution.prototype.add = function( variable, value ) {
		this.links[variable] = value;
	};
	
	// Get domain
	Substitution.prototype.domain = function( plain ) {
		var f = plain === true ? function(x){return x;} : function(x){return new Var(x);};
		var vars = [];
		for( var x in this.links )
			vars.push( f(x) );
		return vars;
	};

	// Get an attribute
	Substitution.prototype.get_attribute = function( variable, module ) {
		if( this.attrs[variable] )
			return this.attrs[variable][module];
	}

	// Set an attribute (in a new substitution)
	Substitution.prototype.set_attribute = function( variable, module, value ) {
		var subs = new Substitution( this.links );
		for( var v in this.attrs ) {
			if( v === variable ) {
				subs.attrs[v] = {};
				for( var m in this.attrs[v] ) {
					subs.attrs[v][m] = this.attrs[v][m];
				}
			} else {
				subs.attrs[v] = this.attrs[v];
			}
		}
		if( !subs.attrs[variable] ) {
			subs.attrs[variable] = {};
		}
		subs.attrs[variable][module] = value;
		return subs;
	}

	// Check if a variables has attributes
	Substitution.prototype.has_attributes = function( variable ) {
		return this.attrs[variable] && this.attrs[variable] !== {};
	}
	
	
	
	// GENERATE JAVASCRIPT CODE FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.compile = function() {
		return 'new pl.type.Var("' + this.id.toString() + '")';
	};
	
	// Numbers
	Num.prototype.compile = function() {
		return 'new pl.type.Num(' + this.value.toString() + ', ' + this.is_float.toString() + ')';
	};
	
	// Terms
	Term.prototype.compile = function() {
		return 'new pl.type.Term("' + this.id.replace(/"/g, '\\"') + '", [' + map( this.args, function( arg ) {
			return arg.compile();
		} ) + '])';
	};
	
	// Rules
	Rule.prototype.compile = function() {
		return 'new pl.type.Rule(' + this.head.compile() + ', ' + (this.body === null ? 'null' : this.body.compile()) + ')';
	};
	
	// Sessions
	Session.prototype.compile = function() {
		var str, obj = [], rules;
		for( var _indicator in this.modules.user.rules ) {
			if(!this.modules.user.rules.hasOwnProperty(_indicator)) continue;
			var indicator = this.modules.user.rules[_indicator];
			rules = [];
			str = "\"" + _indicator + "\": [";
			for(var i = 0; i < indicator.length; i++) {
				rules.push(indicator[i].compile());
			}
			str += rules.join();
			str += "]";
			obj.push( str );
		}
		return "{" + obj.join() + "};";
	};

	// Module
	Module.prototype.compile = function() {
		var length = 0;
		var dependencies = 0;
		var str = "var pl;\n";
		str += "(function(pl) {\n";
		// name
		str += "\tvar name = \"" + this.id + "\";\n";
		// predicates
		str += "\tvar predicates = function() {\n";
		str += "\t\treturn {\n";
		for(var prop in this.rules) {
			if(length > 0)
				str += ",\n";
			str += "\t\t\t\"" + prop + "\": ";
			if(typeof this.rules[prop] === "function") {
				str += this.rules[prop];
			} else {
				str += "[\n";
				for(var i = 0; i < this.rules[prop].length; i++) {
					str += "\t\t\t\t" + this.rules[prop][i].compile();
					if(i < this.rules[prop].length-1)
						str += ",";
					str += "\n";
				}
				str += "\t\t\t]";
			}
			length++;
		}
		str += "\n\t\t};\n";
		str += "\t};\n";
		// exports
		str += "\tvar exports = [";
		for(var i = 0; i < this.exports.length; i++) {
			if(i > 0)
				str += ", ";
			str += "\"" + this.exports[i] + "\"";
		}
		str += "];\n";
		// options
		str += "\tvar options = function() {\n";
		str += "\t\treturn {\n";
		// dependencies
		str += "\t\t\tdependencies: [";
		for(var prop in this.modules) {
			if(dependencies > 0)
				str += ", ";
			str += "\"" + prop + "\"";
			dependencies++;
		}
		str += "]\n";
		str += "\t\t};\n";
		str += "};\n";
		// fixed code
		str += "\tif(typeof module !== 'undefined') {\n";
		str += "\t\tmodule.exports = function(p) {\n";
		str += "\t\t\tpl = p;\n";
		str += "\t\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t\t};\n";
		str += "\t} else {\n";
		str += "\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t}\n";
		str += "})(pl);\n";
		return str;
	};
	
	
	
	// PROLOG TO JAVASCRIPT
	Var.prototype.toJavaScript = function() {
		return this.toString();
	};
	
	// Numbers
	Num.prototype.toJavaScript = function() {
		return this.value;
	};
	
	// Terms
	Term.prototype.toJavaScript = function(options) {
		// Atom => String
		if( this.args.length === 0 && this.indicator !== "[]/0" ) {
			return this.toString(options);
		} else if( pl.type.is_list( this ) ) {
			// List => Array
			var all_obj = true;
			var arr = [];
			var obj = {};
			var pointer = this;
			var value;
			while( pointer.indicator === "./2" ) {
				value = pointer.args[0].toJavaScript(options);
				arr.push( value );
				all_obj = all_obj && pl.type.is_term(pointer.args[0]) && pointer.args[0].indicator === "-/2" && pl.type.is_atom(pointer.args[0].args[0]);
				if(all_obj)
					obj[pointer.args[0].args[0].id] = pointer.args[0].args[1].toJavaScript(options);
				pointer = pointer.args[1];
			}
			if( pointer.indicator === "[]/0" )
				return all_obj && arr.length > 0 ? obj : arr;

		}
		return this.toString(options);
	};
	
	
	
	// RULES
	
	// Return singleton variables in the session
	Rule.prototype.singleton_variables = function(include_named) {
		include_named = include_named || false;
		var variables = this.head.variables();
		var count = {};
		var singleton = [];
		if(this.body !== null)
			variables = variables.concat(this.body.variables());
		for(var i = 0; i < variables.length; i++) {
			if(count[variables[i]] === undefined)
				count[variables[i]] = 0;
			count[variables[i]]++;
		}
		for(var key in count) {
			if(!count.hasOwnProperty(key))
				continue;
			if(count[key] === 1) {
				var charcode = codePointAt(key, 1);
				if(!include_named || key === "_")
					if(key === "_" || key[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
						continue;
				singleton.push(key);
			}
		}
		return singleton;
	};



	// NODEJS

	var nodejs_flag = typeof process !== 'undefined' && !process.browser

	var nodejs_arguments = nodejs_flag ?
		arrayToList( map(process.argv.slice(1), function(arg) { return new Term( arg ); })) :
		new Term("[]", []);
	
	
	
	// PROLOG

	var pl = {
		
		// Environment
		__env: nodejs_flag ? __webpack_require__.g : window,
		
		// Modules
		modules: {},
		
		// Version
		version: version,
		
		// Parser
		parser: {
			tokenizer: Tokenizer,
			expression: parseExpr
		},
		
		// Utils
		utils: {
			
			// String to indicator
			str_indicator: str_indicator,
			// Code point at
			codePointAt: codePointAt,
			// From code point
			fromCodePoint: fromCodePoint,
			// Length of string
			stringLength: stringLength
			
		},
		
		// Statistics
		statistics: {
			
			// Number of created terms
			getCountTerms: function() {
				return term_ref;
			}
			
		},
		
		// JavaScript to Prolog
		fromJavaScript: {
			
			// Type testing
			test: {
				
				// Boolean
				boolean: function( obj, tobj ) {
					return obj === true || obj === false;
				},
				
				// Number
				number: function( obj, tobj ) {
					return typeof obj === "number";
				},
				
				// String
				string: function( obj, tobj ) {
					return typeof obj === "string";
				},
				
				// List
				list: function( obj, tobj ) {
					return obj instanceof Array;
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return obj === undefined;
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					return tobj && !(obj instanceof Array) && typeof obj === "object";
				},
				
				// Any
				any: function( _, tobj ) {
					return true;
				}
				
			},
			
			// Function conversion
			conversion: {
				
				// Bolean
				boolean: function( obj, tobj ) {
					return new Term( obj ? "true" : "false", [] );
				},
				
				// Number
				number: function( obj, tobj ) {
					return new Num( obj, obj % 1 !== 0 );
				},
				
				// String
				string: function( obj, tobj ) {
					return new Term( obj, [] );
				},
				
				// List
				list: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var arr = [];
					var elem;
					for( var i = 0; i < obj.length; i++ ) {
						elem = pl.fromJavaScript.apply( obj[i], tobj );
						if( elem === undefined )
							return undefined;
						arr.push( elem );
					}
					return arrayToList( arr );
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return new Var( "_" );
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var list = new Term("[]", []);
					var arr = [];
					for(var prop in obj) {
						if(!obj.hasOwnProperty(prop)) continue;
						arr.push(new Term("-", [
							pl.fromJavaScript.apply(prop, tobj),
							pl.fromJavaScript.apply(obj[prop], tobj)
						]));
					}
					return arrayToList(arr);
				},
				
				// Any
				any: function( obj, tobj ) {
					return undefined;
				}
				
			},
			
			// Transform object
			apply: function( obj, tobj ) {
				tobj = tobj === undefined ? false : tobj;
				for( var i in pl.fromJavaScript.test )
					if( i !== "any" && pl.fromJavaScript.test[i]( obj, tobj ) )
						return pl.fromJavaScript.conversion[i]( obj, tobj );
				return pl.fromJavaScript.conversion.any( obj, tobj );
			}
		},
		
		// Types
		type: {
			
			// Objects
			Var: Var,
			Num: Num,
			Term: Term,
			Rule: Rule,
			State: State,
			Stream: Stream,
			Module: Module,
			Thread: Thread,
			Session: Session,
			Substitution: Substitution,
			File: TauFile,
			Directory: TauDirectory,
			
			// Order
			order: [Var, Num, Term, Stream],
			
			// Compare types
			compare: function( x, y ) {
				var ord_x = indexOf( pl.type.order, x.constructor );
				var ord_y = indexOf( pl.type.order, y.constructor );
				if( ord_x < ord_y ) {
					return -1;
				} else if( ord_x > ord_y ) {
					return 1;
				} else {
					if( x.constructor === Num )
						if( x.is_float && y.is_float )
							return 0;
						else if( x.is_float )
							return -1;
						else if( y.is_float )
							return 1;
					return 0;
				}
			},
			
			// Is a substitution
			is_substitution: function( obj ) {
				return obj instanceof Substitution;
			},
			
			// Is a state
			is_state: function( obj ) {
				return obj instanceof State;
			},
			
			// Is a rule
			is_rule: function( obj ) {
				return obj instanceof Rule;
			},
			
			// Is a variable
			is_variable: function( obj ) {
				return obj instanceof Var;
			},

			// Is a stream
			is_stream: function( obj ) {
				return obj instanceof Stream;
			},
			
			// Is an anonymous variable
			is_anonymous_var: function( obj ) {
				return obj instanceof Var && obj.id === "_";
			},
			
			// Is a callable term
			is_callable: function( obj ) {
				return obj instanceof Term
				&& (indexOf([",/2",";/2","->/2"], obj.indicator) === -1
				|| pl.type.is_callable(obj.args[0]) && pl.type.is_callable(obj.args[1]))
				|| obj instanceof Var;
			},
			
			// Is a number
			is_number: function( obj ) {
				return obj instanceof Num;
			},
			
			// Is an integer
			is_integer: function( obj ) {
				return obj instanceof Num && !obj.is_float;
			},
			
			// Is a float
			is_float: function( obj ) {
				return obj instanceof Num && obj.is_float;
			},
			
			// Is a term
			is_term: function( obj ) {
				return obj instanceof Term;
			},
			
			// Is an atom
			is_atom: function( obj ) {
				return obj instanceof Term && obj.args.length === 0;
			},
			
			// Is a ground term
			is_ground: function( obj ) {
				if( obj instanceof Var ) return false;
				if( obj instanceof Term )
					for( var i = 0; i < obj.args.length; i++ )
						if( !pl.type.is_ground( obj.args[i] ) )
							return false;
				return true;
			},
			
			// Is atomic
			is_atomic: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 || obj instanceof Num;
			},
			
			// Is compound
			is_compound: function( obj ) {
				return obj instanceof Term && obj.args.length > 0;
			},
			
			// Is a list
			is_list: function( obj ) {
				return obj instanceof Term && (obj.indicator === "[]/0" || obj.indicator === "./2");
			},
			
			// Is an empty list
			is_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a non empty list
			is_non_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2";
			},
			
			// Is a fully list
			is_fully_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Var || obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a instantiated list
			is_instantiated_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is an unitary list
			is_unitary_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2" && obj.args[1] instanceof Term && obj.args[1].indicator === "[]/0";
			},
			
			// Is a character
			is_character: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && (obj.id.length === 1 || obj.id.length > 0 && obj.id.length <= 2 && codePointAt( obj.id, 0 ) >= 65536);
			},
			
			// Is a in_character
			is_in_character: function( obj ) {
				return obj instanceof Term && (obj.indicator === "end_of_file/0"
				|| obj.id.length === 1
				|| obj.id.length > 0 && obj.id.length <= 2 && codePointAt(obj.id, 0) >= 65536);
			},
			
			// Is a character_code
			is_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 1114111;
			},
			
			// Is a in_character_code
			is_in_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 1114111;
			},

			// Is a byte
			is_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 255;
			},

			// Is a in_byte
			is_in_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 255;
			},
			
			// Is an operator
			is_operator: function( obj ) {
				return obj instanceof Term && pl.arithmetic.evaluation[obj.indicator];
			},
			
			// Is a directive
			is_directive: function( obj ) {
				return obj instanceof Term && (pl.directive[obj.indicator] !== undefined || pl.directive[obj.id + "/*"] !== undefined);
			},
			
			// Is a built-in predicate
			is_builtin: function( obj ) {
				return obj instanceof Term && pl.builtin.rules.hasOwnProperty(obj.indicator) && obj.indicator !== "goal_expansion/2";
			},
			
			// Is an error
			is_error: function( obj ) {
				return obj instanceof Term && obj.indicator === "throw/1";
			},

			// Is an error state
			is_error_state: function( obj ) {
				return pl.type.is_state( obj ) && obj.error && obj.error === true;
			},
			
			// Is a predicate indicator
			is_predicate_indicator: function( obj ) {
				return obj instanceof Term && obj.indicator === "//2" && obj.args[0] instanceof Term && obj.args[0].args.length === 0 && obj.args[1] instanceof Num && obj.args[1].is_float === false;
			},
			
			// Is a flag
			is_flag: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && pl.flag[obj.id] !== undefined;
			},
			
			// Is a valid value for a flag
			is_value_flag: function( flag, obj ) {
				if( !pl.type.is_flag( flag ) ) return false;
				for( var value in pl.flag[flag.id].allowed ) {
					if(!pl.flag[flag.id].allowed.hasOwnProperty(value)) continue;
					if( pl.flag[flag.id].allowed[value].equals( obj ) ) return true;
				}
				return false;
			},

			// Is a io mode
			is_io_mode: function( obj ) {
				return pl.type.is_atom( obj ) && ["read","write","append"].indexOf( obj.id ) !== -1;
			},

			// Is a stream option
			is_stream_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "alias/1" && pl.type.is_atom(obj.args[0]) ||
					obj.indicator === "reposition/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "type/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary") ||
					obj.indicator === "eof_action/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")
				);
			},

			// Is a stream position
			is_stream_position: function( obj ) {
				return pl.type.is_term(obj) && (
					obj.indicator === "end_of_stream/0" ||
					obj.indicator === "past_end_of_stream/0" ||
					obj.indicator === "position/3"
						&& pl.type.is_integer(obj.args[0])
						&& pl.type.is_integer(obj.args[1])
						&& pl.type.is_integer(obj.args[2])
				)
			},

			// Is a stream property
			is_stream_property: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "input/0" || 
					obj.indicator === "output/0" || 
					obj.indicator === "alias/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "file_name/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "reposition/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false")) ||
					obj.indicator === "type/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary")) ||
					obj.indicator === "mode/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "read" || obj.args[0].id === "write" || obj.args[0].id === "append")) ||
					obj.indicator === "eof_action/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")) ||
					obj.indicator === "end_of_stream/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "at" || obj.args[0].id === "past" || obj.args[0].id === "not")) ||
					obj.indicator === "position/1"
						&& (pl.type.is_variable(obj.args[0]) || pl.type.is_term(obj.args[0]) && obj.args[0].indicator === "position/3"
							&& (pl.type.is_variable(obj.args[0].args[0]) || pl.type.is_integer(obj.args[0].args[0]))
							&& (pl.type.is_variable(obj.args[0].args[1]) || pl.type.is_integer(obj.args[0].args[1]))
							&& (pl.type.is_variable(obj.args[0].args[2]) || pl.type.is_integer(obj.args[0].args[2])))
				);
			},

			// Is a streamable term
			is_streamable: function( obj ) {
				return obj.__proto__.stream !== undefined;
			},

			// Is a read option
			is_read_option: function( obj ) {
				return pl.type.is_term( obj ) && ["variables/1","variable_names/1","singletons/1"].indexOf( obj.indicator ) !== -1;
			},

			// Is a write option
			is_write_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "quoted/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "ignore_ops/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "numbervars/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "variable_names/1" && pl.type.is_fully_list(obj.args[0])
				);
			},

			// Is a close option
			is_close_option: function( obj ) {
				return pl.type.is_term( obj ) &&
					obj.indicator === "force/1" &&
					pl.type.is_atom(obj.args[0]) &&
					(obj.args[0].id === "true" || obj.args[0].id === "false");
			},
			
			// Is a modifiable flag
			is_modifiable_flag: function( obj ) {
				return pl.type.is_flag( obj ) && pl.flag[obj.id].changeable;
			},

			// Is a module
			is_module: function( obj ) {
				return obj instanceof Module;
			},

			// Is a virtual file
			is_file: function( obj ) {
				return obj instanceof TauFile;
			},

			// Is a virtual directory
			is_directory: function( obj ) {
				return obj instanceof TauDirectory;
			},

			// Is a predicate property
			is_predicate_property: function(obj) {
				return pl.type.is_term(obj) && (
					obj.indicator === "built_in/0" ||
					obj.indicator === "static/0" ||
					obj.indicator === "dynamic/0" ||
					obj.indicator === "native_code/0" ||
					obj.indicator === "multifile/0" ||
					obj.indicator === "meta_predicate/1"
				);
			},

			// Is a meta-argument specifier
			is_meta_argument_specifier: function(obj) {
				return pl.type.is_integer(obj) && obj.value >= 0 ||
					pl.type.is_atom(obj) && indexOf(["+", "-", "?", "*", "^", ":", "//"], obj.id) !== -1;
			},

			// Is a time property
			is_time_property: function( obj ) {
				return pl.type.is_term(obj) && obj.args.length === 1 
				&& (pl.type.is_variable(obj.args[0]) || pl.type.is_integer(obj.args[0]))
				&& indexOf(["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"], obj.id) !== -1;
			},
			
		},

		// Arithmetic functions
		arithmetic: {
			
			// Evaluation
			evaluation: {
				"e/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.E; }
				},
				"pi/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.PI; }
				},
				"tau/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return 2*Math.PI; }
				},
				"epsilon/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Number.EPSILON; }
				},
				"+/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return x; }
				},
				"-/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return -x; }
				},
				"\\/1": {
					type_args: false,
					type_result: false,
					fn: function( x, _ ) { return ~x; }
				},
				"abs/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.abs( x ); }
				},
				"sign/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.sign( x ); }
				},
				"float_integer_part/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"float_fractional_part/1": {
					type_args: true,
					type_result: true,
					fn: function( x, _ ) { return x - parseInt( x ); }
				},
				"float/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return parseFloat( x ); }
				},
				"floor/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.floor( x ); }
				},
				"truncate/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"round/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.round( x ); }
				},
				"ceiling/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.ceil( x ); }
				},
				"sin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sin( x ); }
				},
				"cos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cos( x ); }
				},
				"tan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tan( x ); }
				},
				"asin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.asin(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"acos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.acos(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"atan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.atan( x ); }
				},
				"atan2/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x === 0 && y === 0 ? pl.error.evaluation("undefined", thread.__call_indicator) : Math.atan2(x, y); }
				},
				"acosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 1 ? Math.acosh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"asinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.asinh( x ); }
				},
				"atanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) < 1 ? Math.atanh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"cosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cosh( x ); }
				},
				"sinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sinh( x ); }
				},
				"tanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tanh( x ); }
				},
				"exp/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.exp( x ); }
				},
				"sqrt/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 0 ? Math.sqrt( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x > 0 && y > 0 ? Math.log(y)/Math.log(x) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log10/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log(x)/Math.log(10) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"+/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x + y; }
				},
				"-/2": {
					type_args: null,
					type_result: null,
					fn:  function( x, y, _ ) { return x - y; }
				},
				"*/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x * y; }
				},
				"//2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return y ? x / y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"///2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.trunc( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"div/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.floor( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"**/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"^/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"<</2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x << y; }
				},
				">>/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x >> y; }
				},
				"/\\/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x & y; }
				},
				"\\//2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x | y; }
				},
				"xor/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x ^ y; }
				},
				"rem/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x % y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"mod/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x - Math.floor( x / y ) * y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"max/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.max( x, y ); }
				},
				"min/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.min( x, y ); }
				},
				"gcd/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return gcd(x, y); }
				}
				
			}
			
		},
		
		// Directives
		directive: {
			
			// dynamic/1
			"dynamic/1": function( thread, atom, options ) {
				var indicators = atom.args[0];
				if(!pl.type.is_list(indicators))
					indicators = arrayToList([indicators]);
				var pointer = indicators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					indicator = pointer.args[0];
					if( pl.type.is_variable( indicator ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
						thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
					} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_atom( indicator.args[0] ) ) {
						thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
					} else if( !pl.type.is_integer( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
					} else {
						var key = indicator.args[0].id + "/" + indicator.args[1].value;
						var get_module = thread.session.modules[options.context_module];
						get_module.public_predicates[key] = true;
						if( !get_module.rules[key] )
						get_module.rules[key] = [];
					}
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				}
			},

			// dynamic/[2..]
			"dynamic/*": function( thread, atom ) {
				for(var i = 0; i < atom.args.length; i++) {
					pl.directive["dynamic/1"](thread, new Term("dynamic", [atom.args[i]]));
				}
			},
			
			// multifile/1
			"multifile/1": function( thread, atom, options ) {
				var indicator = atom.args[0];
				if( pl.type.is_variable( indicator ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( indicator.args[0] ) ) {
					thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
				} else if( !pl.type.is_integer( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
				} else {
					var predicate_indicator = atom.args[0].args[0].id + "/" + atom.args[0].args[1].value;
					var get_module = thread.session.modules[options.context_module];
					get_module.multifile_predicates[predicate_indicator] = true;
					if(!get_module.rules.hasOwnProperty(predicate_indicator)) {
						get_module.rules[predicate_indicator] = [];
						get_module.public_predicates[predicate_indicator] = false;
					}
				}
			},

			// meta_predicate/1
			"meta_predicate/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				var head = atom.args[0];
				if( pl.type.is_variable(head) ) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_warning(pl.error.type("callable", head, atom.indicator));
				} else {
					for(var i = 0; i < head.args.length; i++) {
						var arg = head.args[i];
						if(!pl.type.is_meta_argument_specifier(arg)) {
							thread.throw_warning(pl.error.type("meta_argument_specifier", arg, atom.indicator));
							return;
						}
					}
					thread.session.modules[options.context_module].meta_predicates[head.indicator] = head;
				}
			},
			
			// set_prolog_flag
			"set_prolog_flag/2": function( thread, atom ) {
				var flag = atom.args[0], value = atom.args[1];
				if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( flag ) ) {
					thread.throw_warning( pl.error.type( "atom", flag, atom.indicator ) );
				} else if( !pl.type.is_flag( flag ) ) {
					thread.throw_warning( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
				} else if( !pl.type.is_modifiable_flag( flag ) ) {
					thread.throw_warning( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
				} else if( !pl.type.is_value_flag( flag, value ) ) {
					thread.throw_warning( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
				} else {
					thread.session.flag[flag.id] = value;
				}
			},

			// module/2
			"module/2": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0], exports = atom.args[1];
				if(pl.type.is_variable(module_id) || pl.type.is_variable(exports)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_atom(module_id)) {
					thread.throw_warning(pl.error.type("atom", module_id, atom.indicator));
				} else if(!pl.type.is_list(exports)) {
					thread.throw_warning(pl.error.type("list", exports, atom.indicator));
				} else {
					if(!pl.type.is_module(thread.session.modules[module_id.indicator])) {
						var pointer = exports;
						var indicators = [];
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var predicate = pointer.args[0];
							if(!pl.type.is_predicate_indicator(predicate)) {
								thread.throw_warning(pl.error.type("predicate_indicator", predicate, atom.indicator));
							} else {
								indicators.push(predicate.args[0].id + "/" + predicate.args[1].value);
							}
							pointer = pointer.args[1];
						}
						if(pl.type.is_variable(pointer)) {
							thread.throw_warning(pl.error.instantiation(atom.indicator));
						} else if(!pl.type.is_empty_list(pointer)) {
							thread.throw_warning(pl.error.type("list", exports, atom.indicator));
						}
						var new_module = new Module(module_id.id, {}, indicators, {
							session: thread.session
						});
						thread.session.modules[module_id.id] = new_module;
						thread.session.modules[options.context_module].modules[module_id.id] = new_module;
						options.context_module = module_id.id;
					} else {
						thread.throw_warning(pl.error.permission("create", "module", module_id, atom.indicator));
					}
				}
			},
			
			// use_module/1
			"use_module/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0];
				if(pl.type.is_variable(module_id)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_term(module_id)) {
					thread.throw_warning(pl.error.type("term", module_id, atom.indicator));
				} else {
					if(module_id.indicator === "library/1") {
						var name = module_id.args[0].id;
						var get_module = pl.modules[name];
						if(pl.type.is_module(get_module)) {
							if(!thread.session.modules[options.context_module].modules.hasOwnProperty(name)) {
								thread.session.modules[name] = get_module;
								thread.session.modules[options.context_module].modules[name] = get_module;
								for(var i = 0; i < get_module.dependencies.length; i++) {
									var term = new Term("use_module", [new Term("library", [new Term(get_module.dependencies[i])])]);
									pl.directive["use_module/1"](thread, term, {
										context_module: name
									});
								}
							}
						} else {
							thread.throw_warning(pl.error.existence("module", module_id, atom.indicator));
						}
					} else {
						var name = module_id.id;
						thread.consult(name, {
							context_module: options.context_module,
							text: false,
							success: function() {
								parseProgram(thread, options.string, options);
							},
							error: function() {
								options.error(pl.error.existence("module", module_id, atom.indicator));
							}
						});
						return true;
					}
				}
			},
			
			// char_conversion/2
			"char_conversion/2": function(thread, atom, options) {
				var inchar = atom.args[0], outchar = atom.args[1];
				if(pl.type.is_variable(inchar) || pl.type.is_variable(outchar)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_character(inchar)) {
					thread.throw_warning(pl.error.type("character", inchar, atom.indicator));
				} else if(!pl.type.is_character(outchar)) {
					thread.throw_warning(pl.error.type("character", outchar, atom.indicator));
				} else {
					if(inchar.id === outchar.id) {
						delete thread.session.__char_conversion[inchar.id];
					} else {
						thread.session.__char_conversion[inchar.id] = outchar.id;
					}
					options.tokens = options.tokenizer.get_tokens(options.current_token);
					options.current_token = 0;
					return true;
				}
			},
			
			// op/3
			"op/3": function( thread, atom ) {
				var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
				if(pl.type.is_atom(operators))
					operators = new Term(".", [operators, new Term("[]")]);
				if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_integer( priority ) ) {
					thread.throw_warning( pl.error.type( "integer", priority, atom.indicator ) );
				} else if( !pl.type.is_atom( type ) ) {
					thread.throw_warning( pl.error.type( "atom", type, atom.indicator ) );
				} else if( !pl.type.is_list( operators ) ) {
					thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
				} else if( pl.type.is_empty_list( operators ) ) {
					thread.throw_warning( pl.error.permission( "create", "operator", operators, atom.indicator ) );
				} else {
					var pointer = operators;
					while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
						var operator = pointer.args[0];
						pointer = pointer.args[1];
						if( pl.type.is_variable( operator ) ) {
							thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						} else if( !pl.type.is_atom( operator ) ) {
							thread.throw_warning( pl.error.type( "atom", operator, atom.indicator ) );
						} else if( priority.value < 0 || priority.value > 1200 ) {
							thread.throw_warning( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						} else if( operator.id === "," ) {
							thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						} else if( operator.id === "{}" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "[]" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
							thread.throw_warning( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						} else {
							var fix = { prefix: null, infix: null, postfix: null };
							for( var p in thread.session.__operators ) {
								if(!thread.session.__operators.hasOwnProperty(p)) continue;
								var classes = thread.session.__operators[p][operator.id];
								if( classes ) {
									if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
									if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
									if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
									if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
									if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
									if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
									if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
								}
							}
							var current_class;
							switch( type.id ) {
								case "fy": case "fx": current_class = "prefix"; break;
								case "yf": case "xf": current_class = "postfix"; break;
								default: current_class = "infix"; break;
							}
							if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
								thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							} else {
								if( fix[current_class] ) {
									remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
									if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
										delete thread.session.__operators[fix[current_class].priority][operator.id];
									}
								}
								if( priority.value > 0 ) {
									if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
									if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
									thread.session.__operators[priority.value][operator.id].push( type.id );
								}
							}
						}
					}
					if(pl.type.is_variable(pointer)) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						return;
					} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
						thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
						return;
					}
				}
			},

			// initialization/1
			"initialization/1": function(thread, atom, options) {
				var goal = atom.args[0];
				options.initialization.push(goal);
			}
			
		},
		
		// Flags
		flag: {
			
			// Bounded numbers
			bounded: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( "true" ),
				changeable: false
			},
			
			// Maximum integer
			max_integer: {
				allowed: [new Num( Number.MAX_SAFE_INTEGER )],
				value: new Num( Number.MAX_SAFE_INTEGER ),
				changeable: false
			},
			
			// Minimum integer
			min_integer: {
				allowed: [new Num( Number.MIN_SAFE_INTEGER )],
				value: new Num( Number.MIN_SAFE_INTEGER ),
				changeable: false
			},
			
			// Rounding function
			integer_rounding_function: {
				allowed: [new Term( "down" ), new Term( "toward_zero" )],
				value: new Term( "toward_zero" ),
				changeable: false
			},
			
			// Character conversion
			char_conversion: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "on" ),
				changeable: true
			},
			
			// Debugger
			debug: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "off" ),
				changeable: true
			},
			
			// Maximum arity of predicates
			max_arity: {
				allowed: [new Term( "unbounded" )],
				value: new Term( "unbounded" ),
				changeable: false
			},
			
			// Unkwnow predicates behavior
			unknown: {
				allowed: [new Term( "error" ), new Term( "fail" ), new Term( "warning" )],
				value: new Term( "error" ),
				changeable: true
			},
			
			// Double quotes behavior
			double_quotes: {
				allowed: [new Term( "chars" ), new Term( "codes" ), new Term( "atom" )],
				value: new Term( "chars" ),
				changeable: true
			},
			
			// Occurs check behavior
			occurs_check: {
				allowed: [new Term( "false" ), new Term( "true" )],
				value: new Term( "false" ),
				changeable: true
			},
			
			// Dialect
			dialect: {
				allowed: [new Term( "tau" )],
				value: new Term( "tau" ),
				changeable: false
			},
			
			// Version
			version_data: {
				allowed: [new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] )],
				value: new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] ),
				changeable: false
			},
			
			// NodeJS
			nodejs: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( nodejs_flag ? "true" : "false" ),
				changeable: false
			},

			// Arguments
			argv: {
				allowed: [nodejs_arguments],
				value: nodejs_arguments,
				changeble: false
			}
			
		},
		
		// Unify
		unify: function(t1, t2, occurs_check) {
			occurs_check = occurs_check === undefined ? false : occurs_check;
			var left = Array.isArray(t1) ? t1 : [t1];
			var right = Array.isArray(t2) ? t2 : [t2];
			if(left.length !== right.length)
				return null;
			var subs = new Substitution();
			while(left.length > 0) {
				var s = left.pop();
				var t = right.pop();
				if(pl.type.is_variable(s))
					s = s.apply(subs);
				if(pl.type.is_variable(t))
					t = t.apply(subs);
				// same object
				if(s == t)
					continue;
				// compound terms
				if(pl.type.is_term(s) && pl.type.is_term(t)) {
					if(s.indicator !== t.indicator)
						return null;
					for(var i = s.args.length-1; i >= 0; i--) {
						left.push(s.args[i]);
						right.push(t.args[i]);
					}
				// numbers
				} else if(pl.type.is_number(s) && pl.type.is_number(t)) {
					if(s.value !== t.value || s.is_float !== t.is_float)
						return null;
				// variable - term
				} else if(pl.type.is_variable(s)) {
					t = t.apply(subs);
					// x = x
					if(pl.type.is_variable(t) && s.id === t.id)
						continue;
					// occurs check
					if(occurs_check === true && indexOf(t.variables(), s.id) !== -1)
						return null;
					// anonymous variable
					if(s.id !== "_")
						subs.add(s.id, t);
				// term - variable
				} else if(pl.type.is_variable(t)) {
					left.push(t);
					right.push(s);
				// user-defined terms
				} else if(s.unify !== undefined) {
					var user_subs = s.apply(subs).unify(t.apply(subs), occurs_check);
					if(user_subs == null)
						return null;
					for(var i in user_subs.links)
						subs.add(i, user_subs.links[i]);
				} else {
					return null;
				}
			}
			return subs.apply(subs);
		},

		// Is rename
		is_rename: function(obj1, obj2, links) {
			links = links || {};
			if(obj1.is_rename && obj2.is_rename)
				return obj1.is_rename(obj2, links);
			else if(obj1.equals && obj2.equals)
				return obj1.equals(obj2);
			else
				return false;
		},
		
		// Compare
		compare: function( obj1, obj2 ) {
			var type = pl.type.compare( obj1, obj2 );
			return type !== 0 ? type : obj1.compare( obj2 );
		},
		
		// Arithmetic comparison
		arithmetic_compare: function( thread, obj1, obj2 ) {
			var expr1 = obj1.interpret( thread );
			if( !pl.type.is_number( expr1 ) ) {
				return expr1;
			} else {
				var expr2 = obj2.interpret( thread );
				if( !pl.type.is_number( expr2 ) ) {
					return expr2;
				} else {
					return expr1.value < expr2.value ? -1 : (expr1.value > expr2.value ? 1 : 0);
				}
			}
		},
		
		// Operate
		operate: function( thread, obj ) {
			if( pl.type.is_operator( obj ) ) {
				var op = pl.type.is_operator( obj );
				var args = [], value;
				var type = false;
				for( var i = 0; i < obj.args.length; i++ ) {
					value = obj.args[i].interpret( thread );
					if( !pl.type.is_number( value ) ) {
						return value;
					} else if( op.type_args !== null && value.is_float !== op.type_args ) {
						return pl.error.type( op.type_args ? "float" : "integer", value, thread.__call_indicator );
					} else {
						args.push( value.value );
					}
					type = type || value.is_float;
				}
				args.push( thread );
				value = pl.arithmetic.evaluation[obj.indicator].fn.apply( this, args );
				if(obj.indicator === "^/2" && !type && value !== parseInt(value, 10))
					return pl.error.type( "float", new Num(args[0],false), thread.__call_indicator );
				type = op.type_result === null ? type : op.type_result;
				if( pl.type.is_term( value ) ) {
					return value;
				} else if( value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY ) {
					return pl.error.evaluation( "float_overflow", thread.__call_indicator );
				} else if( type === false && thread.get_flag( "bounded" ).id === "true" && (value > thread.get_flag( "max_integer" ).value || value < thread.get_flag( "min_integer" ).value) ) {
					return pl.error.evaluation( "int_overflow", thread.__call_indicator );
				} else {
					return new Num( value, type );
				}
			} else {
				return pl.error.type( "evaluable", str_indicator(obj.indicator), thread.__call_indicator );
			}
		},
		
		// Errors
		error: {
			
			// Existence error
			existence: function( type, object, indicator ) {
				if( typeof object === "string" )
					object = str_indicator( object );
				return new Term( "error", [new Term( "existence_error", [new Term( type ), object] ), str_indicator( indicator )] );
			},
			
			// Type error
			type: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "type_error", [new Term( expected ), found] ), str_indicator( indicator )] );
			},
			
			// Instantation error
			instantiation: function( indicator ) {
				return new Term( "error", [new Term( "instantiation_error" ), str_indicator( indicator )] );
			},
			
			// Uninstantation error
			uninstantiation: function( found, indicator ) {
				return new Term( "error", [new Term( "uninstantiation_error", [new Term( found )] ), str_indicator( indicator )] );
			},
			
			// Domain error
			domain: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "domain_error", [new Term( expected ), found]), str_indicator( indicator )] );
			},
			
			// Representation error
			representation: function( flag, indicator ) {
				return new Term( "error", [new Term( "representation_error", [new Term( flag )] ), str_indicator( indicator )] );
			},
			
			// Permission error
			permission: function( operation, type, found, indicator ) {
				return new Term( "error", [new Term( "permission_error", [new Term( operation ), new Term( type ), found] ), str_indicator( indicator )] );
			},
			
			// Evaluation error
			evaluation: function( error, indicator ) {
				return new Term( "error", [new Term( "evaluation_error", [new Term( error )] ), str_indicator( indicator )] );
			},
			
			// Syntax error
			syntax: function( token, expected, last ) {
				token = token || {value: "", line: 0, column: 0, matches: [""], start: 0};
				var position = last && token.matches.length > 0 ? token.start + token.matches[0].length : token.start;
				var found = last ? new Term("token_not_found") : new Term("found", [new Term(token.value.toString())]);
				var info = new Term( ".", [new Term( "line", [new Num(token.line+1)] ), new Term( ".", [new Term( "column", [new Num(position)] ), new Term( ".", [found, new Term( "[]", [] )] )] )] );
				return new Term( "error", [new Term( "syntax_error", [new Term( expected )] ), info] );
			},
			
			// Syntax error by predicate
			syntax_by_predicate: function( expected, indicator ) {
				return new Term( "error", [new Term( "syntax_error", [new Term( expected ) ] ), str_indicator( indicator )] );
			}
			
		},
		
		// Warnings
		warning: {
			
			// Singleton variables
			singleton: function( variables, rule, line ) {
				var list = new Term( "[]" );
				for( var i = variables.length-1; i >= 0; i-- )
					list = new Term( ".", [new Var(variables[i]), list] );
				return new Term( "warning", [new Term( "singleton_variables", [list, str_indicator(rule)]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			},
			
			// Failed goal
			failed_goal: function( goal, line ) {
				return new Term( "warning", [new Term( "failed_goal", [goal]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			}

		},
		
		// Format of renamed variables
		format_variable: function( id, variable ) {
			var charcode = variable && variable.length > 0 ? codePointAt(variable, 1) : 0;
			if(variable === "_" || variable && variable[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
				return "__" + id;
			return "_" + id;
		},
		
		// Format of computed answers
		format_answer: function( answer, thread, options ) {
			if( thread instanceof Session )
				thread = thread.thread;
			var options = options ? options : {};
			options.session = thread ? thread.session : undefined;
			if( pl.type.is_error( answer ) ) {
				return "uncaught exception: " + answer.args[0].toString(options);
			} else if( answer === false ) {
				return "false";
			} else if( answer === null ) {
				return "limit exceeded";
			} else {
				var i = 0;
				var str = "";
				if( pl.type.is_substitution( answer ) ) {
					var dom = answer.domain( true );
					for( var link in answer.links ){
						if( !answer.links.hasOwnProperty(link) ) continue;
						if( pl.type.is_variable(answer.links[link]) ) {
							var links = {};
							links[answer.links[link].id] = new Var(link);
							answer = answer.apply( new Substitution(links) );
						}
					}
					answer = answer.filter( function( id, value ) {
						return !pl.type.is_variable( value ) ||
							pl.type.is_variable( value ) && answer.has_attributes( id ) ||
							indexOf( dom, value.id ) !== -1 && id !== value.id;
					} );
				}
				for( var link in answer.links ) {
					if(!answer.links.hasOwnProperty(link))
						continue;
					if( pl.type.is_variable( answer.links[link] ) && link === answer.links[link].id ) {
						var attrs = answer.attrs[link];
						for( var module in attrs ) {
							if(!attrs.hasOwnProperty(module))
								continue;
							i++;
							if( str !== "" )
								str += ", ";
							str += "put_attr(" + link + ", " + module + ", " + attrs[module].toString(options) + ")";
						}
					} else {
						i++;
						if( str !== "" )
							str += ", ";
						str += link.toString( options ) + " = " +
							answer.links[link].toString( options, {priority: "700", class: "xfx", indicator: "=/2"}, "right" );
					}
				}
				if( i === 0 ) {
					return "true";
				} else {
					return str;
				}
			}
		},
		
		// Flatten default errors
		flatten_error: function( error ) {
			if( !pl.type.is_error( error ) ) return null;
			error = error.args[0];
			var obj = {};
			obj.type = error.args[0].id;
			obj.thrown = obj.type === "syntax_error" ? null : error.args[1].id;
			obj.expected = null;
			obj.found = null;
			obj.representation = null;
			obj.existence = null;
			obj.existence_type = null;
			obj.line = null;
			obj.column = null;
			obj.permission_operation = null;
			obj.permission_type = null;
			obj.evaluation_type = null;
			if( obj.type === "type_error" || obj.type === "domain_error" ) {
				obj.expected = error.args[0].args[0].id;
				obj.found = error.args[0].args[1].toString();
			} else if( obj.type === "syntax_error" ) {
				if( error.args[1].indicator === "./2" ) {
					obj.expected = error.args[0].args[0].id;
					obj.found = error.args[1].args[1].args[1].args[0];
					obj.found = obj.found.id === "token_not_found" ? obj.found.id : obj.found.args[0].id;
					obj.line = error.args[1].args[0].args[0].value;
					obj.column = error.args[1].args[1].args[0].args[0].value;
				} else {
					obj.thrown = error.args[1].id;
				}
			} else if( obj.type === "permission_error" ) {
				obj.found = error.args[0].args[2].toString();
				obj.permission_operation = error.args[0].args[0].id;
				obj.permission_type = error.args[0].args[1].id;
			} else if( obj.type === "evaluation_error" ) {
				obj.evaluation_type = error.args[0].args[0].id;
			} else if( obj.type === "representation_error" ) {
				obj.representation = error.args[0].args[0].id;
			} else if( obj.type === "existence_error" ) {
				obj.existence = error.args[0].args[1].toString();
				obj.existence_type = error.args[0].args[0].id;
			}
			return obj;
		},
		
		// Create new session
		create: function( limit ) {
			return new pl.type.Session( limit );
		}
		
	};

	// Built-in predicates
	pl.builtin = new Module("system", {

		// TERM AND GOAL EXPANSION

		// goal_expansion/2
		"goal_expansion/2": [
			new Rule(new Term("goal_expansion", [new Term(",", [new Var("X"),new Var("Y")]),new Term(",", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term(";", [new Var("X"),new Var("Y")]),new Term(";", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("->", [new Var("X"),new Var("Y")]),new Term("->", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("catch", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("catch", [new Var("X_"),new Var("Y"),new Var("Z_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Z"),new Var("Z_")]),new Term("=", [new Var("Z_"),new Var("Z")])])]),new Term(",", [new Term("=", [new Var("X_"),new Var("X")]),new Term("goal_expansion", [new Var("Z"),new Var("Z_")])])])),
			new Rule(new Term("goal_expansion", [new Term("\\+", [new Var("X")]),new Term("\\+", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("once", [new Var("X")]),new Term("once", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("findall", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("setof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("bagof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X")]),new Term("call", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term("[]", [])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term("[]", [])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term("[]", [])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term("[]", [])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term("[]", [])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term("[]", [])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6"),new Var("A7")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term(".", [new Var("A7"),new Term("[]", [])])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])]))
		],



		// SYSTEM PREDICATES ($)

		// '$push_global_stack'/2
		"$push_global_stack/2": function(thread, point, atom) {
			var stack = atom.args[0], value = atom.args[1];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				thread.push_global_stack(stack.id, value);
				thread.success(point);
			}
		},

		// '$flush_global_stack'/3
		"$flush_global_stack/3": function(thread, point, atom) {
			var stack = atom.args[0], list = atom.args[1], tail = atom.args[2];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				var values = thread.flush_global_stack(stack.id, tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [list, values])),
					point.substitution,
					point
				)]);
			}
		},

		// '$free_variable_set'/3
		"$free_variable_set/3": function(thread, point, atom) {
			var goal_in = atom.args[0], goal_out = atom.args[1], vars = atom.args[2];
			var bv = [];
			var pointer = goal_in;
			while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
				bv = bv.concat(pointer.args[0].variables());
				pointer = pointer.args[1];
			}
			var gv = pointer.variables();
			var fv = arrayToList(map(difference(gv, bv), function(v) {
				return new Var(v);
			}));
			thread.prepend([
				new State(
					point.goal.replace(new Term(",", [
						new Term("=", [goal_out, pointer]),
						new Term("=", [vars, fv]) 
					])),
					point.substitution,
					point
				)
			]);
		},

		// '$member'/2
		"$member/2": [
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("X"),new pl.type.Var("_")])]), null),
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("_"),new pl.type.Var("Xs")])]), new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Var("Xs")]))
		],

		// '$bind_bagof_keys/2'/2
		"$bind_bagof_keys/2": [
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term("[]", []),new pl.type.Var("_")]), null),
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term(".", [new pl.type.Term("-", [new pl.type.Var("Key"),new pl.type.Var("_")]),new pl.type.Var("Bag")]),new pl.type.Var("Vars")]), new pl.type.Term(",", [new pl.type.Term("term_variables", [new pl.type.Var("Key"),new pl.type.Var("Vars"),new pl.type.Var("_")]),new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Bag"),new pl.type.Var("Vars")])]))
		],

		// '$findall'/4
		"$findall/4": [
			new pl.type.Rule(new pl.type.Term("$findall", [new pl.type.Var("Template0"),new pl.type.Var("Goal0"),new pl.type.Var("Instances"),new pl.type.Var("Tail")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Term("-", [new pl.type.Var("Template0"),new pl.type.Var("Goal0")]),new pl.type.Term("-", [new pl.type.Var("Template1"),new pl.type.Var("Goal1")])]),new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("Goal1")]),new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Var("Template1"),new pl.type.Var("Template2")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Template2")]),new pl.type.Term("false", [])])])])]),new pl.type.Term("$flush_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Instances"),new pl.type.Var("Tail")])]))
		],

		// '$bagof'/3
		"$bagof/3": [
			new pl.type.Rule(new pl.type.Term("$bagof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Answer")]),new pl.type.Var("KeySorted")])])])])])]))
		],

		// '$setof'/3
		"$setof/3": [
			new pl.type.Rule(new pl.type.Term("$setof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term(",", [new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Unsorted")]),new pl.type.Var("KeySorted")]),new pl.type.Term("sort", [new pl.type.Var("Unsorted"),new pl.type.Var("Answer")])])])])])])]))
		],

		// '$if/3'
		"$if/3": [
			new pl.type.Rule(new pl.type.Term("$if", [new pl.type.Var("If"),new pl.type.Var("Then"),new pl.type.Var("Else")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("If")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Stack"),new pl.type.Var("_")]),new pl.type.Term("call", [new pl.type.Var("Then")])])]),new pl.type.Term(",", [new pl.type.Term("$flush_global_stack", [new pl.type.Var("Stack"),new pl.type.Term("[]", []),new pl.type.Term("[]", [])]),new pl.type.Term("call", [new pl.type.Var("Else")])])]))
		],


		// ATTRIBUTED VARIABLES
		
		//put_attr/3
		"put_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var subs = point.substitution.set_attribute( variable.id, module, value );
				thread.prepend( [new State( point.goal.replace(null), subs, point )] );
			}
		},

		// get_attr/3
		"get_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var attr = point.substitution.get_attribute( variable.id, module );
				if( attr ) {
					thread.prepend( [new State(
						point.goal.replace( new Term("=", [value, attr]) ),
						point.substitution,
						point
					)] );
				}
			}
		},


		
		// INPUT AND OUTPUT
		
		// op/3
		"op/3": function( thread, point, atom ) {
			var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
			if(pl.type.is_atom(operators))
				operators = new Term(".", [operators, new Term("[]")]);
			if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( !pl.type.is_atom( type ) ) {
				thread.throw_error( pl.error.type( "atom", type, atom.indicator ) );
			} else if( !pl.type.is_list( operators ) ) {
				thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
			} else if( pl.type.is_empty_list( operators ) ) {
				thread.throw_error( pl.error.permission( "create", "operator", operators, atom.indicator ) );
			} else {
				var pointer = operators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var operator = pointer.args[0];
					pointer = pointer.args[1];
					if( pl.type.is_variable( operator ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( operator ) ) {
						thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
						return;
					} else if( priority.value < 0 || priority.value > 1200 ) {
						thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						return;
					} else if( operator.id === "," ) {
						thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "{}" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "[]" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
						thread.throw_error( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						return;
					} else {
						var fix = { prefix: null, infix: null, postfix: null };
						for( var p in thread.session.__operators ) {
							if(!thread.session.__operators.hasOwnProperty(p)) continue;
							var classes = thread.session.__operators[p][operator.id];
							if( classes ) {
								if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
								if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
								if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
								if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
								if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
								if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
								if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
							}
						}
						var current_class;
						switch( type.id ) {
							case "fy": case "fx": current_class = "prefix"; break;
							case "yf": case "xf": current_class = "postfix"; break;
							default: current_class = "infix"; break;
						}
						if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
							thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							return;
						} else {
							if( fix[current_class] ) {
								remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
								if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
									delete thread.session.__operators[fix[current_class].priority][operator.id];
								}
							}
							if( priority.value > 0 ) {
								if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
								if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
								thread.session.__operators[priority.value][operator.id].push( type.id );
							}
						}
					}
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
					return;
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
					return;
				} else {
					thread.success(point);
				}
			}
		},
		
		// current_op/3
		"current_op/3": function( thread, point, atom ) {
			var priority = atom.args[0], specifier = atom.args[1], operator = atom.args[2];
			var points = [];
			if( !pl.type.is_variable( priority ) && !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( pl.type.is_integer( priority ) && ( priority.value < 0 || priority.value > 1200 ) ) {
				thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
			} else if( !pl.type.is_variable( specifier ) && !pl.type.is_atom( specifier ) ) {
				thread.throw_error( pl.error.type( "atom", specifier, atom.indicator ) );
			} else if( pl.type.is_atom( specifier ) && indexOf( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"], specifier.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "operator_specifier", specifier, atom.indicator ) );
			} else if( !pl.type.is_variable( operator ) && !pl.type.is_atom( operator ) ) {
				thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
			} else {
				for( var p in thread.session.__operators )
					for( var o in thread.session.__operators[p] )
						for( var i = 0; i < thread.session.__operators[p][o].length; i++ )
							points.push( new State(
								point.goal.replace(
									new Term( ",", [
										new Term( "=", [new Num( p, false ), priority] ),
										new Term( ",", [
											new Term( "=", [new Term( thread.session.__operators[p][o][i], [] ), specifier] ),
											new Term( "=", [new Term( o, [] ), operator] )
										] )
									] )
								),
								point.substitution,
								point
							) );
				thread.prepend( points );
			}
		},
	


		// LOGIC AND CONTROL STRUCTURES
	
		// ;/2 (disjunction)
		";/2": function(thread, point, atom) {
			var left = atom.args[0], right = atom.args[1];
			var context_left = left.args[0];
			var free_left = left.indicator === ":/2" ? left.args[1] : left;
			// if then else
			if(pl.type.is_term(free_left) && free_left.indicator === "->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, new Term("call", [free_left.args[0]])]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				var goal_fst = point.goal.replace(new Term( ",", [cond, new Term(",", [new Term("!"), then])] ) );
				var goal_snd = point.goal.replace(new Term( ",", [new Term("!"), otherwise]));
				thread.prepend([
					new State(goal_fst, point.substitution, point),
					new State(goal_snd, point.substitution, point)
				]);
			// soft-cut
			} else if(pl.type.is_term(free_left) && free_left.indicator === "*->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[0]]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				thread.prepend([new State(
					point.goal.replace(new Term("$if", [cond, then, otherwise])),
					point.substitution,
					point
				)]);
			// otherwise
			} else {
				thread.prepend([
					new State(point.goal.replace(left), point.substitution, point),
					new State(point.goal.replace(right), point.substitution, point)
				]);
			}
		},
		
		// !/0 (cut)
		"!/0": function( thread, point, atom ) {
			var parent_cut, last_cut, states = [];
			parent_cut = point;
			last_cut = null;
			while( parent_cut.parent !== null && parent_cut.parent.goal.search( atom ) ) {
				last_cut = parent_cut;
				parent_cut = parent_cut.parent;
				if(parent_cut.goal !== null) {
					var selected = parent_cut.goal.select();
					if(selected && selected.indicator === ":/2")
						selected = selected.args[1];
					if( selected && selected.id === "call" && selected.search(atom) ) {
						parent_cut = last_cut;
						break;
					}
				}
			}
			var setup_call_cleanup = null;
			for( var i = thread.points.length-1; i >= 0; i-- ) {
				var state = thread.points[i];
				var node = state.parent;
				while( node !== null && node !== parent_cut.parent ) {
					node = node.parent;
				}
				if( node === null && node !== parent_cut.parent )
					states.push( state );
				else if(state.setup_call_cleanup_goal)
					setup_call_cleanup = state.setup_call_cleanup_goal
			}
			thread.points = states.reverse();
			thread.prepend([new State(
				point.goal.replace(setup_call_cleanup),
				point.substitution,
				point
			)]);
		},
		
		// \+ (negation)
		"\\+/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			if( pl.type.is_variable( goal ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( goal ) ) {
				thread.throw_error( pl.error.type( "callable", goal, atom.indicator ) );
			} else {
				// TRANSPARENT VERSION OF THE NEGATION
				/*var neg_thread;
				if(point.negation_thread) {
					neg_thread = point.negation_thread;
				} else {
					neg_thread = new Thread( thread.session );
					neg_thread.add_goal( goal );
					point.negation_thread = neg_thread;
				}
				neg_thread.answer( function( answer ) {
					if(answer === false) {
						thread.success( point );
					} else if(pl.type.is_error( answer )) {
						thread.throw_error( answer.args[0] );
					} else if(answer === null) {
						thread.prepend( [point] );
						thread.current_limit = 0;
					}
					thread.again( answer !== null );
				} );
				return true;*/
				
				// '\+'(X) :- call(X), !, fail.
				// '\+'(_).
				thread.prepend( [
					new State( point.goal.replace( new Term( ",", [new Term( ",", [ new Term( "call", [goal] ), new Term( "!", [] ) ] ), new Term( "fail", [] ) ] ) ), point.substitution, point ),
					new State( point.goal.replace( null ), point.substitution, point )
				] );
			}
		},
		
		// ->/2 (implication)
		"->/2": function( thread, point, atom ) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]),
				new Term(",", [new Term("!"), then])
			]));
			thread.prepend( [new State( goal, point.substitution, point )] );
		},

		// *->/2 (soft-cut)
		"*->/2": function(thread, point, atom) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]), then]));
			thread.prepend([new State(goal, point.substitution, point)]);
		},
		
		// fail/0
		"fail/0": function( _1, _2, _3 ) {},
		
		// false/0
		"false/0": function( _1, _2, _3 ) {},
		
		// true/0
		"true/0": function( thread, point, _ ) {
			thread.success( point );
		},
		
		// call/1..8
		"call/1": callN(1),
		"call/2": callN(2),
		"call/3": callN(3),
		"call/4": callN(4),
		"call/5": callN(5),
		"call/6": callN(6),
		"call/7": callN(7),
		"call/8": callN(8),
		
		// once/1
		"once/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			thread.prepend( [new State( point.goal.replace( new Term( ",", [new Term( "call", [goal] ), new Term( "!", [] )] ) ), point.substitution, point )] );
		},
		
		// forall/2
		"forall/2": function( thread, point, atom ) {
			var generate = atom.args[0], test = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "\\+", [new Term( ",", [new Term( "call", [generate] ), new Term( "\\+", [new Term( "call", [test] )] )] )] ) ), point.substitution, point )] );
		},
		
		// repeat/0
		"repeat/0": function( thread, point, _ ) {
			thread.prepend( [new State( point.goal.replace( null ), point.substitution, point ), point] );
		},

		// EXCEPTIONS
		
		// throw/1
		"throw/1": function( thread, point, atom ) {
			var error = atom.args[0];
			if(pl.type.is_variable(error)) {
				thread.throw_error(pl.error.instantiation(thread.level.indicator));
			} else {
				for(var i = 0; i < thread.points.length; i++) {
					var state = thread.points[i];
					if(state.setup_call_cleanup_catch) {
						thread.points = [new State(
							new Term(",", [
								new Term("catch", [
									state.setup_call_cleanup_catch,
									new Var("_"),
									new Term("throw", [error])
								]),
								new Term("throw", [error])
							]),
							point.substitution,
							point
						)];
						return;
					}
					
				}
				thread.throw_error(error);
			}
		},
		
		// catch/3
		"catch/3": function(thread, point, atom) {
			var goal = atom.args[0], catcher = atom.args[1], recover = atom.args[2];
			var nthread;
			if(!point.catch) {
				nthread = new Thread(thread.session);
				nthread.debugger = thread.debugger;
				nthread.format_success = function(state) { return state.substitution; };
				nthread.format_error = function(state) { return state.goal; };
				nthread.add_goal(goal, true, point);
				point.catch = nthread;
			} else {
				nthread = point.catch;
			}
			var callback = function(answer) {
				if(pl.type.is_error(answer)) {
					var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
					var state = new State();
					var mgu = pl.unify(answer.args[0], catcher, occurs_check);
					if(mgu !== null) {
						state.substitution = point.substitution.apply(mgu);
						state.goal = point.goal.replace(recover).apply(mgu);
						state.parent = point;
						thread.prepend([state]);
					} else {
						thread.throw_error(answer.args[0]);
					}
				} else if(answer !== false && answer !== null) {
					var state = answer === null ? [] : new State(
						point.goal.apply(answer).replace(null),
						point.substitution.apply(answer),
						point
					);
					thread.prepend([state, point]);
				} else if(answer === null) {
					thread.prepend([point]);
					if(thread.has_limit)
						thread.current_limit = 0;
				}
				thread.again(answer !== null);
			};
			nthread.answer(callback);
			return true;
		},

		// call_cleanup/2
		"call_cleanup/2": function(thread, point, atom) {
			var call = atom.args[0], cleanup = atom.args[1];
			if(pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				var nthread, callback;
				if(point.hasOwnProperty("setup_call_cleanup_thread")) {
					nthread = point.setup_call_cleanup_thread;
					callback = point.setup_call_cleanup_callback;
				} else {
					var goal = new Term("call", [call]);
					nthread = new Thread(thread.session);
					nthread.add_goal(goal, true, point);
					callback = function(answer) {
						if(answer === null) {
							var state = new State(
								point.goal,
								point.substitution,
								point
							);
							state.setup_call_cleanup_thread = nthread;
							state.setup_call_cleanup_callback = callback;
							thread.prepend([state]);
						} else if(answer === false) {
							var cleanup_and_fail = new Term(",", [
								new Term("call", [cleanup]),
								new Term("fail")
							]);
							var state = new State(
								point.goal.replace(cleanup_and_fail),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else if(pl.type.is_error(answer)) {
							var cleanup_and_throw = new Term(",", [
								new Term("call", [cleanup]),
								answer
							]);
							var state = new State(
								point.goal.replace(cleanup_and_throw),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else {
							if(nthread.points.length === 0) {
								var state = new State(
									point.goal.replace(
										new Term("call", [cleanup])
									).apply(answer),
									point.substitution.apply(answer),
									point
								);
								thread.prepend([state]);
							} else {
								var state1 = new State(
									point.goal.apply(answer).replace(null),
									point.substitution.apply(answer),
									point
								);
								var state2 = new State(
									point.goal,
									point.substitution,
									point
								);
								state2.setup_call_cleanup_thread = nthread;
								state2.setup_call_cleanup_callback = callback;
								state2.setup_call_cleanup_goal = cleanup.apply(answer);
								state2.setup_call_cleanup_catch = cleanup;
								thread.prepend([state1, state2]);
							}
						}
						thread.again();
					}
				}
				nthread.answer(callback);
				return true;
			}
		},

		// setup_call_cleanup/3
		"setup_call_cleanup/3": function(thread, point, atom) {
			var setup = atom.args[0], call = atom.args[1], cleanup = atom.args[2];
			if(pl.type.is_variable(setup) || pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(setup)) {
				thread.throw_error(pl.error.type("callable", setup, atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term(",", [
						new Term("once", [setup]),
						new Term("call_cleanup", [call, cleanup])
					])),
					point.substitution,
					point
				)]);
			}
		},
		
		// UNIFICATION
		
		// =/2 (unification)
		"=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// unify_with_occurs_check/2
		"unify_with_occurs_check/2": function( thread, point, atom ) {
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], true );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// \=/2
		"\\=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu === null ) {
				thread.success( point );
			}
		},
		
		// subsumes_term/2
		/*
		subsumes_term(General, Specific) :-
			\+ \+ (
			term_variables(Specific, Vars1),
			unify_with_occurs_check(General, Specific),
			term_variables(Vars1, Vars2),
			Vars1 == Vars2
		).
		*/
		"subsumes_term/2": function( thread, point, atom ) {
			var general = atom.args[0], specific = atom.args[1];
			var vars1 = thread.next_free_variable();
			var vars2 = thread.next_free_variable();
			thread.prepend([new State(
				point.goal.replace(new Term("\\+", [
					new Term("\\+", [
						new Term(",", [
							new Term("term_variables", [specific, vars1]),
							new Term(",", [
								new Term("unify_with_occurs_check", [general, specific]),
								new Term(",", [
									new Term("term_variables", [vars1, vars2]),
									new Term("==", [vars1, vars2])
								])
							])
						])
					])
				])),
				point.substitution,
				point
			)]);
		},
		
		// ALL SOLUTIONS

		// findall/3
		"findall/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			var tail = new Term("[]", []);
			thread.prepend([new State(
				point.goal.replace(new Term("findall", [template, goal, instances, tail])),
				point.substitution,
				point
			)]);
		},

		// findall/4
		"findall/4": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2], tail = atom.args[3];
			var proper_goal = goal;
			if(pl.type.is_term(goal) && goal.indicator === ":/2")
				proper_goal = goal.args[1];
			if(pl.type.is_variable(proper_goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(proper_goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error(pl.error.type("list", instances, atom.indicator));
			} else if(!pl.type.is_variable(tail) && !pl.type.is_list(tail)) {
				thread.throw_error(pl.error.type("list", tail, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$findall", [template, goal, instances, tail])),
					point.substitution,
					point
				)]);
			}
		},
		
		// bagof/3
		"bagof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$bagof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},

		// setof/3
		"setof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$setof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},
		
		// TERM CREATION AND DECOMPOSITION
		
		// functor/3
		"functor/3": function( thread, point, atom ) {
			var subs;
			var term = atom.args[0], name = atom.args[1], arity = atom.args[2];
			if( pl.type.is_variable( term ) && (pl.type.is_variable( name ) || pl.type.is_variable( arity )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( arity ) && !pl.type.is_integer( arity ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[2], atom.indicator ) );
			} else if( !pl.type.is_variable( name ) && !pl.type.is_atomic( name ) ) {
				thread.throw_error( pl.error.type( "atomic", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && !pl.type.is_atom( name ) && pl.type.is_integer( arity ) && arity.value > 0 ) {
				thread.throw_error( pl.error.type( "atom", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && pl.type.is_integer( arity ) && arity.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[2], atom.indicator ) );
			} else if( pl.type.is_variable( term ) ) {
				if( atom.args[2].value >= 0 ) {
					var args = [];
					for( var i = 0; i < arity.value; i++ )
						args.push( thread.next_free_variable() );
					var functor = pl.type.is_number( name ) ? name : new Term( name.id, args );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [term, functor] ) ), point.substitution, point )] );
				}
			} else {
				var id = pl.type.is_number( term ) ? term : new Term( term.id, [] );
				var length = pl.type.is_number( term ) ? new Num( 0, false ) : new Num( term.args.length, false );
				var goal = new Term( ",", [new Term( "=", [id, name] ), new Term( "=", [length, arity] )] );
				thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
			}
		},
		
		// arg/3
		"arg/3": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) || pl.type.is_variable( atom.args[1] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[0], atom.indicator ) );
			} else if( atom.args[0].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_compound( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "compound", atom.args[1], atom.indicator ) );
			} else {
				var n = atom.args[0].value;
				if( n > 0 && n <= atom.args[1].args.length ) {
					var goal = new Term( "=", [atom.args[1].args[n-1], atom.args[2]] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				}
			}
		},
		
		// =../2 (univ)
		"=../2": function( thread, point, atom ) {
			var list;
			if( pl.type.is_variable( atom.args[0] ) && (pl.type.is_variable( atom.args[1] )
			|| pl.type.is_non_empty_list( atom.args[1] ) && pl.type.is_variable( atom.args[1].args[0] )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_fully_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "list", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( atom.args[0] ) && pl.type.is_empty_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.domain( "non_empty_list", atom.args[1], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[0] ) ) {
				if( pl.type.is_term( atom.args[0] ) && atom.args[0].args.length > 0 ) {
					list = new Term( "[]" );
					for( var i = atom.args[0].args.length - 1; i >= 0; i-- ) {
						list = new Term( ".", [atom.args[0].args[i], list] );
					}
					list = new Term( ".", [new Term( atom.args[0].id ), list] );
				} else {
					list = new Term( ".", [atom.args[0], new Term( "[]" )] );
				}
				thread.prepend( [new State( point.goal.replace( new Term( "=", [list, atom.args[1]] ) ), point.substitution, point )] );
			} else if( !pl.type.is_variable( atom.args[1] ) ) {
				var args = [];
				list = atom.args[1].args[1];
				while( list.indicator === "./2" ) {
					args.push( list.args[0] );
					list = list.args[1];
				}
				if( pl.type.is_variable( atom.args[0] ) && pl.type.is_variable( list ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( args.length === 0 && pl.type.is_compound( atom.args[1].args[0] ) ) {
					thread.throw_error( pl.error.type( "atomic", atom.args[1].args[0], atom.indicator ) );
				} else if( args.length > 0 && (pl.type.is_compound( atom.args[1].args[0] ) || pl.type.is_number( atom.args[1].args[0] )) ) {
					thread.throw_error( pl.error.type( "atom", atom.args[1].args[0], atom.indicator ) );
				} else {
					if( args.length === 0 ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[1].args[0], atom.args[0]], point ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( atom.args[1].args[0].id, args ), atom.args[0]] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// copy_term/2
		"copy_term/2": function(thread, point, atom) {
			var original_term = atom.args[0], renamed_term = atom.args[1];
			thread.session.renamed_variables = {};
			var new_term = original_term.rename(thread);
			thread.session.renamed_variables = {};
			thread.prepend([
				new State(
					point.goal.replace(new Term("=", [renamed_term, new_term])),
					point.substitution,
					point)
				]
			);
		},
		
		// term_variables/2
		"term_variables/2": [
			new pl.type.Rule(new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars")]), new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars"),new pl.type.Term("[]", [])]))
		],

		// term_variables/3
		"term_variables/3": function(thread, point, atom) {
			var term = atom.args[0], vars = atom.args[1], tail = atom.args[2];
			if( !pl.type.is_fully_list( vars ) ) {
				thread.throw_error( pl.error.type( "list", vars, atom.indicator ) );
			} else {
				var list = arrayToList(map(nub(term.variables()), function(v) {
					return new Var(v);
				}), tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [vars, list])),
					point.substitution,
					point
				)]);
			}
		},

		// numbervars/3
		"numbervars/3": function(thread, point, atom) {
			var term = atom.args[0], start = atom.args[1], end = atom.args[2];
			if(pl.type.is_variable(start)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_integer(start)) {
				thread.throw_error(pl.error.type("integer", start, atom.indicator));
			} else if(!pl.type.is_variable(end) && !pl.type.is_integer(end)) {
				thread.throw_error(pl.error.type("integer", end, atom.indicator));
			} else {
				var variables = nub(term.variables());
				var value = start.value;
				var unif_body = new Term("true");
				for(var i = 0; i < variables.length; i++) {
					unif_body = new Term(",", [
						new Term("=", [
							new Var(variables[i]),
							new Term("$VAR", [new Num(value, false)])]),
							unif_body]);
					value++;
				}
				var unif_end = new Term("=", [end, new Num(value, false)]);
				if(pl.type.is_variable(end) || end.value === value) {
					thread.prepend([new State(
						point.goal.replace(new Term(",", [unif_body, unif_end])),
						point.substitution,
						point
					)]);
				}
			}
		},
		
		// CLAUSE RETRIEVAL AND INFORMATION
		
		// clause/2
		"clause/2": function(thread, point, atom) {
			var head = atom.args[0], body = atom.args[1];
			var module_id = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			var get_module = thread.session.modules[module_id];
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(body) && !pl.type.is_callable(body)) {
				thread.throw_error(pl.error.type("callable", body, atom.indicator));
			} else if(head.indicator === ",/2" || thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
			} else if(pl.type.is_module(get_module) && get_module.rules[head.indicator]) {
				if(get_module.is_public_predicate(head.indicator)) {
					var states = [];
					if(typeof get_module.rules[head.indicator] === "function") {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
						return;
					}
					for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
						var rule = get_module.rules[head.indicator][i];
						thread.session.renamed_variables = {};
						rule = rule.rename(thread);
						if(rule.body === null)
							rule.body = new Term("true");
						var goal = new Term(",", [
							new Term("=", [rule.head, head]),
							new Term("=", [rule.body, body])
						]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				} else {
					thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// current_predicate/1
		"current_predicate/1": function(thread, point, atom) {
			var indicator = atom.args[0];
			var module_id;
			if(pl.type.is_term(indicator) && indicator.indicator === ":/2") {
				if(!pl.type.is_atom(indicator.args[0])) {
					thread.throw_error(pl.error.type("module", indicator.args[0], atom.indicator));
					return;
				}
				module_id = indicator.args[0].id;
				indicator = indicator.args[1];
			} else {
				module_id = "user";
			}
			if(!pl.type.is_variable(indicator) && (!pl.type.is_compound(indicator) || indicator.indicator !== "//2")) {
				thread.throw_error(pl.error.type( "predicate_indicator", indicator, atom.indicator));
			} else if(!pl.type.is_variable( indicator ) && !pl.type.is_variable(indicator.args[0]) && !pl.type.is_atom(indicator.args[0])) {
				thread.throw_error(pl.error.type( "atom", indicator.args[0], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && !pl.type.is_variable(indicator.args[1]) && !pl.type.is_integer(indicator.args[1])) {
				thread.throw_error(pl.error.type("integer", indicator.args[1], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && pl.type.is_integer(indicator.args[1]) && indicator.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", indicator.args[1], atom.indicator));
			} else {
				var states = [];
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					for(var prop in get_module.rules) {
						if(!get_module.rules.hasOwnProperty(prop))
							continue;
						var predicate = str_indicator(prop);
						var goal = new Term("=", [predicate, indicator]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				}
			}
		},

		// current_module/1
		"current_module/1": function(thread, point, atom) {
			var module_id = atom.args[0];
			if(!pl.type.is_variable(module_id) && !pl.type.is_atom(module_id)) {
				thread.throw_error(pl.error.type("atom", module_id, atom.indicator));
			} else {
				if(pl.type.is_variable(module_id)) {
					var states = [];
					for(var prop in thread.session.modules) {
						if(!thread.session.modules.hasOwnProperty(prop))
							continue;
						states.push(new State(
							point.goal.replace(new Term("=", [module_id, new Term(prop)])),
							point.substitution,
							point
						));
					}
					thread.prepend(states);
				} else {
					if(thread.session.modules.hasOwnProperty(module_id.id))
						thread.success(point);
				}
			}
		},

		// predicate_property/2
		"predicate_property/2": function(thread, point, atom) {
			var head = atom.args[0], property = atom.args[1];
			var module_id;
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			if(!pl.type.is_variable(head) && !pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_predicate_property(property)) {
				thread.throw_error(pl.error.domain("predicate_property", property, atom.indicator));
			} else {
				var get_module = module_id ? thread.session.modules[module_id] : thread.session.modules.user;
				var points = [];
				// all predicates
				if(pl.type.is_variable(head)) {
					// built-in predicates (built_in + static + native_code + meta_predicate?)
					if(!module_id) {
						for(var prop in pl.builtin.rules) {
							if(!pl.builtin.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
							if(pl.builtin.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									pl.builtin.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
					// user-defined predicates
					if(pl.type.is_module(get_module)) {
						for(var prop in get_module.rules) {
							if(!get_module.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [];
							if(thread.is_public_predicate(prop, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(get_module.rules[prop] instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(prop, module_id))
								current_properties.push(new Term("multifile"));
							if(get_module.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									get_module.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
				// one predicate
				} else {
					var builtin = !module_id && pl.type.is_builtin(head);
					var predicate = builtin ? pl.builtin.rules[head.indicator] : get_module.rules[head.indicator];
					get_module = builtin ? pl.builtin : get_module;
					if(predicate) {
						var current_properties;
						if(builtin) {
							current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
						} else {
							current_properties = [];
							if(thread.is_public_predicate(head.indicator, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(predicate instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(head.indicator, module_id))
								current_properties.push(new Term("multifile"));
						}
						if(get_module.meta_predicates.hasOwnProperty(head.indicator))
							current_properties.push(new Term("meta_predicate", [
								get_module.meta_predicates[head.indicator]
							]));
						var args = [];
						for(var i = 0; i < head.args.length; i++)
							args.push(thread.next_free_variable());
						var unif_head = new Term(head.id, args);
						// one predicate, one property / all properties
						for(var i = 0; i < current_properties.length; i++) {
							if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
								points.push(new State(
									point.goal.replace(new Term(",", [
										new Term("=", [head, unif_head]),
										new Term("=", [property, current_properties[i]])
									])),
									point.substitution,
									point
								));
							}
						}
					}
				}
				thread.prepend(points);
			}
		},

		// listing/0
		"listing/0": function( thread, point, atom ) {
			var context_module = atom.context_module ? atom.context_module : "user";
			var rules = {};
			if(pl.type.is_module(thread.session.modules[context_module])) {
				rules = thread.session.modules[context_module].rules;
			}
			var str = "";
			for(var indicator in rules) {
				if(!rules.hasOwnProperty(indicator)) continue;
				var predicate = rules[indicator];
				str += "% " + indicator + "\n";
				if(predicate instanceof Array) {
					for(var i = 0; i < predicate.length; i++)
						str += predicate[i].toString( {session: thread.session} ) + "\n";
				} else {
					str += "/*\n" + predicate.toString() + "\n*/";
				}
				str += "\n";
			}
			thread.prepend( [new State(
				point.goal.replace(new Term("write", [new Term(str, [])])),
				point.substitution,
				point
			)] );
		},

		// listing/1
		"listing/1": function( thread, point, atom ) {
			var indicator = atom.args[0];
			var context_module = "user";
			if(indicator.indicator === ":/2") {
				context_module = indicator.args[0].id;
				indicator = indicator.args[1];
			}
			if(pl.type.is_variable(indicator)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_predicate_indicator(indicator)) {
				thread.throw_error( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
			} else {
				var rules = {};
				if(pl.type.is_module(thread.session.modules[context_module])) {
					rules = thread.session.modules[context_module].rules;
				}
				var str = "";
				var str_indicator = indicator.args[0].id + "/" + indicator.args[1].value;
				if(rules.hasOwnProperty(str_indicator)) {
					var predicate = rules[str_indicator];
					if(predicate instanceof Array) {
						for(var i = 0; i < predicate.length; i++)
							str += predicate[i].toString( {session: thread.session} ) + "\n";
					} else {
						str += "/*\n" + predicate.toString() + "\n*/";
					}
					str += "\n";
				}
				thread.prepend( [new State(
					point.goal.replace(new Term("write", [new Term(str, [])])),
					point.substitution,
					point
				)] );
			}
		},

		// LIST OPERATIONS

		// sort/2
		"sort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					arr.push( pointer.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					var sorted_arr = arr.sort( pl.compare );
					for( var i = sorted_arr.length-1; i > 0; i-- ) {
						if( sorted_arr[i].equals(sorted_arr[i-1]) )
							sorted_arr.splice(i,1);
					}
					var sorted_list = new Term( "[]" );
					for( var i = sorted_arr.length-1; i >= 0; i-- ) {
						sorted_list = new Term( ".", [sorted_arr[i], sorted_list] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keysort/2
		"keysort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var elem;
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					elem = pointer.args[0];
					if( pl.type.is_variable( elem ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_term( elem ) || elem.indicator !== "-/2" ) {
						thread.throw_error( pl.error.type( "pair", elem, atom.indicator ) );
						return;
					}
					elem.args[0].pair = elem.args[1];
					arr.push( elem.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error( pl.error.type( "pair", head, atom.indicator ) );
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
							return;
						}
					}
					var sorted_arr = arr.sort( pl.compare );
					var sorted_list = new pl.type.Term( "[]" );
					for( var i = sorted_arr.length - 1; i >= 0; i-- ) {
						sorted_list = new pl.type.Term( ".", [new pl.type.Term( "-", [sorted_arr[i], sorted_arr[i].pair] ), sorted_list] );
						delete sorted_arr[i].pair;
					}
					thread.prepend( [new pl.type.State( point.goal.replace( new pl.type.Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keygroup
		"keygroup/2": function(thread, point, atom) {
			var list = atom.args[0], expected = atom.args[1];
			if(pl.type.is_variable(list)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(expected) && !pl.type.is_fully_list(expected)) {
				thread.throw_error(pl.error.type("list", expected, atom.indicator));
			} else {
				var keys = [];
				var values = [];
				var pointer = list
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var elem = pointer.args[0];
					if(pl.type.is_variable(elem)) {
						thread.throw_error(pl.error.instantiation(atom.indicator));
						return;
					} else if(!pl.type.is_term(elem) || elem.indicator !== "-/2") {
						thread.throw_error(pl.error.type("pair", elem, atom.indicator));
						return;
					}
					var key = elem.args[0], value = elem.args[1];
					var index = -1;
					for(var i = 0; i < keys.length; i++) {
						if(pl.compare(key, keys[i]) === 0) {
							index = i;
							break;
						}
					}
					if(index === -1) {
						index = keys.length;
						keys.push(key);
						values.push([]);
					}
					values[index].push(value);
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_empty_list(pointer)) {
					thread.throw_error(pl.error.type("list", list, atom.indicator));
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error(pl.error.type("pair", head, atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error(pl.error.type("list", expected, atom.indicator));
							return;
						}
					}
					group = new Term("[]", []);
					for(var i = keys.length-1; i >= 0; i--)
						group = new Term(".", [new Term("-", [keys[i], arrayToList(values[i])]), group]);
					thread.prepend([
						new State(
							point.goal.replace(new pl.type.Term("=", [expected, group])),
							point.substitution,
							point
						)
					]);
				}
			}
		},
		
		// CLAUSE CREATION AND DESTRUCTION
		
		// asserta/1
		"asserta/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator] = [new Rule(head, body, true)].concat(get_module.rules[head.indicator]);
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// assertz/1
		"assertz/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator].push(new Rule(head, body, true));
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// retract/1
		"retract/1": function(thread, point, atom) {
			var clause = atom.args[0];
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, module_atom, module_id;
				if(clause.indicator === ":/2") {
					module_atom = clause.args[0];
					clause = clause.args[1];
					if(!pl.type.is_atom(module_atom)) {
						thread.throw_error(pl.error.type("module", module_atom, atom.indicator));
						return;
					}
				} else {
					module_atom = new Term("user");
				}
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = clause.args[1];
				} else {
					head = clause;
					body = new Term("true");
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
					return;
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
					return;
				}
				module_id = module_atom.id;
				var get_module = thread.session.modules[module_id];
				if(!pl.type.is_module(get_module))
					return;
				if(!point.retract) {
					if(thread.is_public_predicate(head.indicator, module_id)
					&& head.indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
						if(get_module.rules[head.indicator] !== undefined) {
							var states = [];
							if(typeof get_module.rules[head.indicator] === "function") {
								thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
								return;
							}
							for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
								thread.session.renamed_variables = {};
								var orule = get_module.rules[head.indicator][i];
								var rule = orule.rename(thread);
								if(rule.body === null)
									rule.body = new Term("true", []);
								var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
								var mgu = pl.unify(new Term(",", [head, body]), new Term(",", [rule.head, rule.body]), occurs_check);
								if(mgu !== null) {
									var state = new State(
										point.goal.replace(new Term(",", [
											new Term(":", [
												module_atom,
												new Term("retract", [new Term(":-", [head, body])]),
											]),
											new Term(",", [
												new Term("=", [head, rule.head]),
												new Term("=", [body, rule.body])
											])
										])), point.substitution, point);
									state.retract = orule;
									states.push(state);
								}
							}
							thread.prepend(states);
						}
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
					}
				} else {
					retract(thread, point, head.indicator, point.retract, get_module);
				}
			}
		},
		
		// retractall/1
		"retractall/1": function(thread, point, atom) {
			var head = atom.args[0];
			var context_module = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				context_module = head.args[0].id;
				head = head.args[1];
			}
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!thread.is_public_predicate(head.indicator, context_module)
			|| head.indicator === ",/2"
			|| thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
			} else {
				thread.prepend([
					new State(point.goal.replace(new Term(",", [
						new Term(":", [
							new Term(context_module),
							new Term("retract", [new pl.type.Term(":-", [head, new Var("_")])])
						]),
						new Term("fail", [])
					])), point.substitution, point),
					new State(point.goal.replace(null), point.substitution, point)
				]);
			}
		},

		// abolish/1
		"abolish/1": function(thread, point, atom) {
			var predicate = atom.args[0];
			var module_id;
			if(pl.type.is_term(predicate) && predicate.indicator === ":/2") {
				if(!pl.type.is_atom(predicate.args[0])) {
					thread.throw_error(pl.error.type("module", predicate.args[0], atom.indicator));
					return;
				}
				module_id = predicate.args[0].id;
				predicate = predicate.args[1];
			} else {
				module_id = "user";
			}
			if(pl.type.is_variable(predicate) || pl.type.is_term(predicate) && predicate.indicator === "//2"
			&& (pl.type.is_variable(predicate.args[0]) || pl.type.is_variable(predicate.args[1]))) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(predicate) || predicate.indicator !== "//2") {
				thread.throw_error(pl.error.type("predicate_indicator", predicate, atom.indicator));
			} else if(!pl.type.is_atom(predicate.args[0])) {
				thread.throw_error(pl.error.type("atom", predicate.args[0], atom.indicator));
			} else if(!pl.type.is_integer(predicate.args[1])) {
				thread.throw_error(pl.error.type("integer", predicate.args[1], atom.indicator));
			} else if(predicate.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", predicate.args[1], atom.indicator));
			} else if(pl.type.is_number(thread.get_flag("max_arity")) && predicate.args[1].value > thread.get_flag("max_arity").value) {
				thread.throw_error(pl.error.representation("max_arity", atom.indicator));
			} else {
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					var indicator = predicate.args[0].id + "/" + predicate.args[1].value;
					if(thread.is_public_predicate(indicator, module_id)
					&& indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(indicator)) {
						delete get_module.rules[indicator];
						delete get_module.indexed_clauses[indicator];
						delete get_module.non_indexable_clauses[indicator];
						delete get_module.public_predicates[indicator];
						delete get_module.multifile_predicates[indicator];
						thread.success(point);
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", atom.args[0], atom.indicator));
					}
				} else {
					thread.success(point);
				}
			}
		},
		
		// ATOM PROCESSING
		
		// atom_length/2
		"atom_length/2": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "atom", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[1] ) && !pl.type.is_integer( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_integer( atom.args[1] ) && atom.args[1].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[1], atom.indicator ) );
			} else {
				var length = new Num( stringLength(atom.args[0].id), false );
				thread.prepend( [new State( point.goal.replace( new Term( "=", [length, atom.args[1]] ) ), point.substitution, point )] );
			}
		},
		
		// atom_concat/3
		"atom_concat/3": function( thread, point, atom ) {
			var str, goal, start = atom.args[0], end = atom.args[1], whole = atom.args[2];
			if( pl.type.is_variable( whole ) && (pl.type.is_variable( start ) || pl.type.is_variable( end )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( start ) && !pl.type.is_atom( start ) ) {
				thread.throw_error( pl.error.type( "atom", start, atom.indicator ) );
			} else if( !pl.type.is_variable( end ) && !pl.type.is_atom( end ) ) {
				thread.throw_error( pl.error.type( "atom", end, atom.indicator ) );
			} else if( !pl.type.is_variable( whole ) && !pl.type.is_atom( whole ) ) {
				thread.throw_error( pl.error.type( "atom", whole, atom.indicator ) );
			} else {
				var v1 = pl.type.is_variable( start );
				var v2 = pl.type.is_variable( end );
				//var v3 = pl.type.is_variable( whole );
				if( !v1 && !v2 ) {
					goal = new Term( "=", [whole, new Term( start.id + end.id )] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				} else if( v1 && !v2 ) {
					str = whole.id.substr( 0, whole.id.length - end.id.length );
					if( str + end.id === whole.id ) {
						goal = new Term( "=", [start, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else if( v2 && !v1 ) {
					str = whole.id.substr( start.id.length );
					if( start.id + str === whole.id ) {
						goal = new Term( "=", [end, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else {
					var states = [];
					for( var i = 0; i <= whole.id.length; i++ ) {
						var atom1 = new Term( whole.id.substr( 0, i ) );
						var atom2 = new Term( whole.id.substr( i ) );
						goal = new Term( ",", [new Term( "=", [atom1, start] ), new Term( "=", [atom2, end] )] );
						states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
					}
					thread.prepend( states );
				}
			}
		},
		
		// sub_atom/5
		"sub_atom/5": function( thread, point, atom ) {
			var i, atom1 = atom.args[0], before = atom.args[1], length = atom.args[2], after = atom.args[3], subatom = atom.args[4];
			if( pl.type.is_variable( atom1 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else if( !pl.type.is_variable( before ) && !pl.type.is_integer( before ) ) {
				thread.throw_error( pl.error.type( "integer", before, atom.indicator ) );
			} else if( !pl.type.is_variable( length ) && !pl.type.is_integer( length ) ) {
				thread.throw_error( pl.error.type( "integer", length, atom.indicator ) );
			} else if( !pl.type.is_variable( after ) && !pl.type.is_integer( after ) ) {
				thread.throw_error( pl.error.type( "integer", after, atom.indicator ) );
			} else if( pl.type.is_integer( before ) && before.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", before, atom.indicator ) );
			} else if( pl.type.is_integer( length ) && length.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", length, atom.indicator ) );
			} else if( pl.type.is_integer( after ) && after.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", after, atom.indicator ) );
			} else if( !pl.type.is_variable( subatom ) && !pl.type.is_atom( subatom ) ) {
				thread.throw_error( pl.error.type( "atom", subatom, atom.indicator ) );
			} else {
				var bs = [], ls = [], as = [];
				if( pl.type.is_variable( before ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						bs.push( i );
					}
				} else {
					bs.push( before.value );
				}
				if( pl.type.is_variable( length ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						ls.push( i );
					}
				} else {
					ls.push( length.value );
				}
				if( pl.type.is_variable( after ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						as.push( i );
					}
				} else {
					as.push( after.value );
				}
				var states = [];
				for( var _i in bs ) {
					if(!bs.hasOwnProperty(_i)) continue;
					i = bs[_i];
					for( var _j in ls ) {
						if(!ls.hasOwnProperty(_j)) continue;
						var j = ls[_j];
						var k = atom1.id.length - i - j;
						if( indexOf( as, k ) !== -1 ) {
						if( i+j+k === atom1.id.length ) {
								var str = atom1.id.substr( i, j );
								if( atom1.id === atom1.id.substr( 0, i ) + str + atom1.id.substr( i+j, k ) ) {
									var pl1 = new Term( "=", [new Term( str ), subatom] );
									var pl2 = new Term( "=", [before, new Num( i )] );
									var pl3 = new Term( "=", [length, new Num( j )] );
									var pl4 = new Term( "=", [after, new Num( k )] );
									var goal = new Term( ",", [ new Term( ",", [ new Term( ",", [pl2, pl3] ), pl4] ), pl1] );
									states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
								}
							}
						}
					}
				}
				thread.prepend( states );
			}
		},
		
		// atom_chars/2
		"atom_chars/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Term( atom1.id.charAt( i ) ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// atom_codes/2
		"atom_codes/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character_code(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("integer", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Num( codePointAt(atom1.id,i), false ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// char_code/2
		"char_code/2": function( thread, point, atom ) {
			var char = atom.args[0], code = atom.args[1];
			if( pl.type.is_variable( char ) && pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else {
				if( pl.type.is_variable( code ) ) {
					var code1 = new Num( codePointAt(char.id,0 ), false );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [code1, code] ) ), point.substitution, point )] );
				} else {
					var char1 = new Term( fromCodePoint( code.value ) );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [char1, char] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_chars/2
		"number_chars/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Term( str.charAt( i ) ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_codes/2
		"number_codes/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Num( codePointAt(str,i), false ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// upcase_atom/2
		"upcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], upcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( upcase ) && !pl.type.is_atom( upcase ) ) {
				thread.throw_error( pl.error.type( "atom", upcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [upcase, new Term( original.id.toUpperCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// downcase_atom/2
		"downcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], downcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( downcase ) && !pl.type.is_atom( downcase ) ) {
				thread.throw_error( pl.error.type( "atom", downcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [downcase, new Term( original.id.toLowerCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// atomic_concat/3
		"atomic_concat/3": function( thread, point, atom ) {
			var atomic1 = atom.args[0], atomic2 = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( atomic1 ) || pl.type.is_variable( atomic2 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic1 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic1, atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic2 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic2, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				if( pl.type.is_atom( atomic1 ) ) {
					id += atomic1.id;
				} else {
					id += "" + atomic1.value;
				}
				if( pl.type.is_atom( atomic2 ) ) {
					id += atomic2.id;
				} else {
					id += "" + atomic2.value;
				}
				var atom = new Term(id, []);
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom, concat] ) ), point.substitution, point )] );
			}
		},

		// atomic_list_concat/2
		"atomic_list_concat/2": function( thread, point, atom ) {
			var list = atom.args[0], concat = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "atomic_list_concat", [list, new Term( "", [] ), concat] ) ), point.substitution, point )] );
		},
		
		// atomic_list_concat/3
		"atomic_list_concat/3": function( thread, point, atom ) {
			var list = atom.args[0], separator = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( separator ) || pl.type.is_variable( list ) && pl.type.is_variable( concat ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else if( !pl.type.is_atom( separator ) && !pl.type.is_number( separator ) ) {
				thread.throw_error( pl.error.type( "atomic", separator, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				var pointer = list;
				while( pl.type.is_term( pointer ) && pointer.indicator === "./2" ) {
					if( pl.type.is_variable( pointer.args[0] ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( pointer.args[0] ) && !pl.type.is_number( pointer.args[0] ) ) {
						thread.throw_error( pl.error.type( "atomic", pointer.args[0], atom.indicator ) );
						return;
					}
					if( id !== "" )
						id += separator.id;
					if( pl.type.is_atom( pointer.args[0] ) )
						id += pointer.args[0].id;
					else
						id += "" + pointer.args[0].value;
					pointer = pointer.args[1];
				}
				id = new Term( id, [] );
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_term( pointer ) || pointer.indicator !== "[]/0" ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					thread.prepend( [new State( point.goal.replace( new Term( "=", [id, concat] ) ), point.substitution, point )] );
				}
			}
		},
		
		// TERM COMPARISON
		
		"@=</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) <= 0 ) {
				thread.success( point );
			}
		},
		
		"==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) === 0 ) {
				thread.success( point );
			}
		},
		
		"\\==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) !== 0 ) {
				thread.success( point );
			}
		},
		
		"@</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) < 0 ) {
				thread.success( point );
			}
		},
		
		"@>/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) > 0 ) {
				thread.success( point );
			}
		},
		
		"@>=/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) >= 0 ) {
				thread.success( point );
			}
		},
		
		"compare/3": function( thread, point, atom ) {
			var order = atom.args[0], left = atom.args[1], right = atom.args[2];
			if( !pl.type.is_variable( order ) && !pl.type.is_atom( order ) ) {
				thread.throw_error( pl.error.type( "atom", order, atom.indicator ) );
			} else if( pl.type.is_atom( order ) && ["<", ">", "="].indexOf( order.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "order", order, atom.indicator ) );
			} else {
				var compare = pl.compare( left, right );
				compare = compare === 0 ? "=" : (compare === -1 ? "<" : ">");
				thread.prepend( [new State( point.goal.replace( new Term( "=", [order, new Term( compare, [] )] ) ), point.substitution, point )] );
			}
		},
		
		// EVALUATION
		
		// is/2
		"is/2": function( thread, point, atom ) {
			var op = atom.args[1].interpret( thread );
			if( !pl.type.is_number( op ) ) {
				thread.throw_error( op );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[0], op], atom.indicator ) ), point.substitution, point )] );
			}
		},
		
		// between/3
		"between/3": function( thread, point, atom ) {
			var lower = atom.args[0], upper = atom.args[1], bet = atom.args[2];
			if( pl.type.is_variable( lower ) || pl.type.is_variable( upper ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( lower ) ) {
				thread.throw_error( pl.error.type( "integer", lower, atom.indicator ) );
			} else if( !pl.type.is_integer( upper ) ) {
				thread.throw_error( pl.error.type( "integer", upper, atom.indicator ) );
			} else if( !pl.type.is_variable( bet ) && !pl.type.is_integer( bet ) ) {
				thread.throw_error( pl.error.type( "integer", bet, atom.indicator ) );
			} else {
				if( pl.type.is_variable( bet ) ) {
					if( lower.value <= upper.value ) {
						var states = [new State( point.goal.replace( new Term( "=", [bet, lower] ) ), point.substitution, point )];
						states.push( new State( point.goal.replace( new Term( "between", [new Num( lower.value+1, false ), upper, bet] ) ), point.substitution, point ) );
						thread.prepend( states );
					}
				} else if( lower.value <= bet.value && upper.value >= bet.value ) {
					thread.success( point );
				}
			}
		},
		
		// succ/2
		"succ/2": function( thread, point, atom ) {
			var n = atom.args[0], m = atom.args[1];
			if( pl.type.is_variable( n ) && pl.type.is_variable( m ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && !pl.type.is_integer( n ) ) {
				thread.throw_error( pl.error.type( "integer", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && !pl.type.is_integer( m ) ) {
				thread.throw_error( pl.error.type( "integer", m, atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && n.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && m.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", m, atom.indicator ) );
			} else {
				if( pl.type.is_variable( m ) || m.value > 0 ) {
					if( pl.type.is_variable( n ) ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [n, new Num( m.value-1, false )] ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [m, new Num( n.value+1, false )] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// =:=/2
		"=:=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp === 0 ) {
				thread.success( point );
			}
		},
		
		// =\=/2
		"=\\=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp !== 0 ) {
				thread.success( point );
			}
		},
		
		// </2
		"</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp < 0 ) {
				thread.success( point );
			}
		},
		
		// =</2
		"=</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp <= 0 ) {
				thread.success( point );
			}
		},
		
		// >/2
		">/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp > 0 ) {
				thread.success( point );
			}
		},
		
		// >=/2
		">=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp >= 0 ) {
				thread.success( point );
			}
		},
		
		// TYPE TEST
		
		// var/1
		"var/1": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atom/1
		"atom/1": function( thread, point, atom ) {
			if( pl.type.is_atom( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atomic/1
		"atomic/1": function( thread, point, atom ) {
			if( pl.type.is_atomic( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// compound/1
		"compound/1": function( thread, point, atom ) {
			if( pl.type.is_compound( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// integer/1
		"integer/1": function( thread, point, atom ) {
			if( pl.type.is_integer( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// float/1
		"float/1": function( thread, point, atom ) {
			if( pl.type.is_float( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// number/1
		"number/1": function( thread, point, atom ) {
			if( pl.type.is_number( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// nonvar/1
		"nonvar/1": function( thread, point, atom ) {
			if( !pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// ground/1
		"ground/1": function( thread, point, atom ) {
			if( atom.variables().length === 0 ) {
				thread.success( point );
			}
		},
		
		// acyclic_term/1
		"acyclic_term/1": function( thread, point, atom ) {
			var test = point.substitution.apply( point.substitution );
			var variables = atom.args[0].variables();
			for( var i = 0; i < variables.length; i++ )
				if( point.substitution.links[variables[i]] !== undefined && !point.substitution.links[variables[i]].equals( test.links[variables[i]] ) )
					return;
			thread.success( point );
		},
		
		// callable/1
		"callable/1": function( thread, point, atom ) {
			var callable = atom.args[0];
			if(pl.type.is_term(callable)) {
				thread.success( point );
			}
		},

		// is_list/1
		"is_list/1": function( thread, point, atom ) {
			var list = atom.args[0];
			while( pl.type.is_term( list ) && list.indicator === "./2" )
				list = list.args[1];
			if( pl.type.is_term( list ) && list.indicator === "[]/0" )
				thread.success( point );
		},



		// STREAM SELECTION AND CONTROL

		// current_input/1
		"current_input/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias(stream.id);
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_input()])),
					point.substitution,
					point)
				] );
			}
		},

		// current_output/1
		"current_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias( stream.id );
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_output()])),
					point.substitution,
					point)
				] );
			}
		},

		// set_input/1
		"set_input/1": function( thread, point, atom ) {
			var input = atom.args[0];
			var stream = pl.type.is_stream( input ) ? input : thread.get_stream_by_alias( input.id );
			if( pl.type.is_variable( input ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( input ) && !pl.type.is_atom( input ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", input, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(input.alias)
													&& !thread.get_stream_by_alias(input.id) ) {
				thread.throw_error( pl.error.existence( "stream", input, atom.indicator ) );
			} else if( stream.output === true ) {
				thread.throw_error( pl.error.permission( "input", "stream", input, atom.indicator ) );
			} else {
				thread.set_current_input( stream );
				thread.success( point );
			}
		},

		// set_output/1
		"set_output/1": function( thread, point, atom ) {
			var output = atom.args[0];
			var stream = pl.type.is_stream( output ) ? output : thread.get_stream_by_alias( output.id );
			if( pl.type.is_variable( output ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( output ) && !pl.type.is_atom( output ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", output, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(output.alias)
													&& !thread.get_stream_by_alias(output.id) ) {
				thread.throw_error( pl.error.existence( "stream", output, atom.indicator ) );
			} else if( stream.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", output, atom.indicator ) );
			} else {
				thread.set_current_output( stream );
				thread.success( point );
			}
		},

		// open/3
		"open/3": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2];
			thread.prepend( [new State(
				point.goal.replace(new Term("open", [dest, mode, stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// open/4
		"open/4": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2], options = atom.args[3];
			if( pl.type.is_variable( dest ) || pl.type.is_variable( mode ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( mode ) && !pl.type.is_atom( mode ) ) {
				thread.throw_error( pl.error.type( "atom", mode, atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.uninstantiation( stream, atom.indicator ) );
			} else if( !pl.type.is_atom( dest ) && !pl.type.is_streamable( dest ) ) {
				thread.throw_error( pl.error.domain( "source_sink", dest, atom.indicator ) );
			} else if( !pl.type.is_io_mode( mode ) ) {
				thread.throw_error( pl.error.domain( "io_mode", mode, atom.indicator ) );
			} else {
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_stream_option( property ) ) {
						thread.throw_error( pl.error.domain( "stream_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id;
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var alias = obj_options["alias"];
					if( alias && thread.get_stream_by_alias(alias) ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", new Term("alias", [new Term(alias, [])]), atom.indicator ) );
						return;
					}
					if( !obj_options["type"] )
						obj_options["type"] = "text";
					var file;
					if( pl.type.is_atom( dest ) )
						file = thread.file_system_open( dest.id, obj_options["type"], mode.id );
					else
						file = dest.stream( obj_options["type"], mode.id );
					if( file === false ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", dest, atom.indicator ) );
						return;
					} else if( file === null ) {
						thread.throw_error( pl.error.existence( "source_sink", dest, atom.indicator ) );
						return;
					}
					var newstream = new Stream(
						file, mode.id,
						obj_options["alias"],
						obj_options["type"],
						obj_options["reposition"] === "true",
						obj_options["eof_action"] );
					if( alias )
						thread.session.streams[alias] = newstream;
					else
						thread.session.streams[newstream.id] = newstream;
					thread.prepend( [new State(
						point.goal.replace( new Term( "=", [stream, newstream] ) ),
						point.substitution,
						point
					)] );
				}
			}
		},

		// close/1
		"close/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State(
				point.goal.replace(new Term("close", [stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// close/2
		"close/2": function( thread, point, atom ) {
			var stream = atom.args[0], options = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_close_option( property ) ) {
						thread.throw_error( pl.error.domain( "close_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					if(stream2 === thread.session.standard_input || stream2 === thread.session.standard_output || stream2 === thread.session.standard_error) {
						thread.success( point );
						return;
					} else if( stream2 === thread.session.current_input ) {
						thread.session.current_input = thread.session.standard_input;
					} else if( stream2 === thread.session.current_output ) {
						thread.session.current_output = thread.session.standard_output;
					}
					if( stream2.alias !== null && stream2.alias !== undefined )
						delete thread.session.streams[stream2.alias];
					else
						delete thread.session.streams[stream2.id];
					if( stream2.output )
						stream2.stream.flush();
					var closed = stream2.stream.close();
					stream2.stream = null;
					if( obj_options.force === true || closed === true ) {
						thread.success( point );
					}
				}
			}
		},

		// flush_output/0
		"flush_output/0": [
			new Rule(new Term("flush_output", []), new Term(",", [new Term("current_output", [new Var("S")]),new Term("flush_output", [new Var("S")])]))
		],

		// flush_output/1
		"flush_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else {
				stream2.stream.flush();
				thread.success( point );
			}
		},

		// stream_property/2
		"stream_property/2": function( thread, point, atom ) {
			var stream = atom.args[0], property = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) ) {
				thread.throw_error( pl.error.domain( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && (!pl.type.is_stream( stream2 ) || stream2.stream === null) ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( property ) && !pl.type.is_stream_property( property ) ) {
				thread.throw_error( pl.error.domain( "stream_property", property, atom.indicator ) );
			} else {
				var streams = [];
				var states = [];
				var propvar = pl.type.is_variable(property);
				if( !pl.type.is_variable( stream ) )
					streams.push( stream2 );
				else
					for( var key in thread.session.streams )
						streams.push( thread.session.streams[key] );
				for( var i = 0; i < streams.length; i++ ) {
					var properties = [];
					// file_name/1
					if( (propvar || property.indicator === "file_name/1") && streams[i].filename )
						properties.push( new Term( "file_name", [new Term(streams[i].file_name, [])] ) );
					// mode/1
					if(propvar || property.indicator === "mode/1")
						properties.push( new Term( "mode", [new Term(streams[i].mode, [])] ) );
					// input/0 or output/0
					if(propvar || property.indicator === "input/0" || property.indicator === "output/0")
						properties.push( new Term( streams[i].input ? "input" : "output", [] ) );
					// alias/1
					if( (propvar || property.indicator === "alias/1") && streams[i].alias )
						properties.push( new Term( "alias", [new Term(streams[i].alias, [])] ) );
					// position/1
					if(propvar || property.indicator === "position/1")
						properties.push( new Term( "position", [
							new Term("position", [
								new Num(streams[i].char_count, false),
								new Num(streams[i].line_count, false),
								new Num(streams[i].line_position, false)
							])
						] ) );
					// end_of_stream/1
					if(propvar || property.indicator === "end_of_stream/1")
						properties.push( new Term( "end_of_stream", [new Term(
							streams[i].position === "end_of_stream" || streams[i].stream.eof && streams[i].stream.eof(streams[i].position) ? "at" :
							streams[i].position === "past_end_of_stream" ? "past" :
							"not", [])] ) );
					// eof_action/1
					if(propvar || property.indicator === "eof_action/1")	
						properties.push( new Term( "eof_action", [new Term(streams[i].eof_action, [])] ) );
					// reposition/1
					if(propvar || property.indicator === "reposition/1")
						properties.push( new Term( "reposition", [new Term(streams[i].reposition ? "true" : "false", [])] ) );
					// type/1
					if(propvar || property.indicator === "type/1")
						properties.push( new Term( "type", [new Term(streams[i].type, [])] ) );
					for( var j = 0; j < properties.length; j++ ) {
						states.push( new State(
							point.goal.replace( new Term( ",", [
								new Term("=", [pl.type.is_variable( stream ) ? stream : stream2, streams[i]]),
								new Term("=", [property, properties[j]])]) ),
							point.substitution,
							point
						) );
					}
				}
				thread.prepend( states );
			}
		},

		// stream_position_data
		"stream_position_data/3": function(thread, point, atom) {
			var field = atom.args[0], position = atom.args[1], value = atom.args[2];
			if(pl.type.is_variable(position)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(position) || position.indicator !== "position/3") {
				thread.throw_error(pl.error.domain("stream_position", position, atom.indicator));
			} else if(!pl.type.is_variable(field) && !pl.type.is_atom(field)) {
				thread.throw_error(pl.error.type("atom", field, atom.indicator));
			} else if(!pl.type.is_variable(value) && !pl.type.is_integer(value)) {
				thread.throw_error(pl.error.type("integer", value, atom.indicator));
			} else {
				var fields = ["char_count", "line_count", "line_position"];
				var states = [];
				var data_pos = {char_count: 0, line_count: 1, line_position: 2};
				if(pl.type.is_variable(field)) {
					for(var i = 0; i < fields.length; i++) {
						states.push(new State(point.goal.replace(
							new Term(",", [
								new Term("=", [new Term(fields[i]), field]),
								new Term("=", [value, position.args[data_pos[fields[i]]]])
							])
						), point.substitution, point));
					}
				} else if(data_pos.hasOwnProperty(field.id)) {
					states.push(new State(point.goal.replace(
						new Term("=", [value, position.args[data_pos[field.id]]])
					), point.substitution, point));
				}
				thread.prepend(states);
			}
		},

		// at_end_of_stream/0
		"at_end_of_stream/0": [
			new Rule(new Term("at_end_of_stream", []), new pl.type.Term(",", [new Term("current_input", [new Var("S")]),new Term(",", [new Term("stream_property", [new Var("S"),new Term("end_of_stream", [new Var("E")])]),new Term(",", [new Term("!", []),new Term(";", [new Term("=", [new Var("E"),new Term("at", [])]),new Term("=", [new Var("E"),new Term("past", [])])])])])]))
		],

		// at_end_of_stream/1
		"at_end_of_stream/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				var e = thread.next_free_variable();
				thread.prepend( [new State(
					point.goal.replace(
						new Term(",", [new Term("stream_property", [stream2,new Term("end_of_stream", [e])]),
						new Term(",", [new Term("!", []),new Term(";", [new Term("=", [e,new Term("at", [])]),
						new Term("=", [e,new Term("past", [])])])])])
					),
					point.substitution,
					point
				)] );
			}
		},

		// set_stream_position/2
		"set_stream_position/2": function( thread, point, atom ) {
			var stream = atom.args[0], position = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( position ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_stream_position( position ) ) {
				thread.throw_error( pl.error.domain( "stream_position", position, atom.indicator ) );
			} else if( stream2.reposition === false ) {
				thread.throw_error( pl.error.permission( "reposition", "stream", stream, atom.indicator ) );
			} else {
				if( position.indicator === "position/3" ) {
					stream2.position = position.args[0].value;
					stream2.char_count = position.args[0].value;
					stream2.line_count = position.args[1].value;
					stream2.line_position = position.args[2].value;
				} else {
					stream2.position = position.id;
				}
				thread.success( point );
			}
		},



		//  CHARACTER INPUT OUTPUT
		
		// get_char/1
		"get_char/1": [
			new Rule(new Term("get_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_char", [new Var("S"),new Var("C")])]))
		],

		// get_char/2
		"get_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_char === "\n") {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// get_code/1
		"get_code/1": [
			new Rule(new Term("get_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_code", [new Var("S"),new Var("C")])]))
		],

		// get_code/2
		"get_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream_code = codePointAt( stream_code, 0 );
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_code === 10) {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_char/1
		"peek_char/1": [
			new Rule(new Term("peek_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_char", [new Var("S"),new Var("C")])]))
		],

		// peek_char/2
		"peek_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_code/1
		"peek_code/1": [
			new Rule(new Term("peek_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_code", [new Var("S"),new Var("C")])]))
		],

		// peek_code/2
		"peek_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
					} else {
						stream_code = codePointAt( stream_code, 0 );
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_char/1
		"put_char/1": [
			new Rule(new Term("put_char", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Var("C")])]))
		],

		// put_char/2
		"put_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( char ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( char.id, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(char.id === "\n") {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// put_code/1
		"put_code/1": [
			new Rule(new Term("put_code", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_code", [new Var("S"),new Var("C")])]))
		],

		// put_code/2
		"put_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( fromCodePoint( code.value ), stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(code.value === 10) {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// nl/0
		"nl/0": [
			new Rule(new Term("nl"), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Term("\n")])]))
		],

		// nl/1
		"nl/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State( 
				point.goal.replace( new Term("put_char", [stream, new Term("\n", [])]) ),
				point.substitution,
				point
			)] );
		},



		// BYTE INPUT/OUTPUT

		// get_byte/1
		"get_byte/1": [
			new Rule(new Term("get_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_byte", [new Var("S"),new Var("B")])]))
		],

		// get_byte/2
		"get_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},
		
		// peek_byte/1
		"peek_byte/1": [
			new Rule(new Term("peek_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_byte", [new Var("S"),new Var("B")])]))
		],

		// peek_byte/2
		"peek_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_byte/1
		"put_byte/1": [
			new Rule(new Term("put_byte", [new Var("B")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_byte", [new Var("S"),new Var("B")])]))
		],

		// put_byte/2
		"put_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( byte ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_byte( byte ) ) {
				thread.throw_error( pl.error.type( "byte", byte, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "output", "text_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put_byte( byte.value, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					thread.success( point );
				}
			}
		},



		// TERM INPUT/OUTPUT

		// read/1
		"read/1": [
			new Rule(new Term("read", [new Var("T")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")])]))
		],

		// read/2
		"read/2": [
			new Rule(new Term("read", [new Var("S"), new Var("T")]), new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")]))
		],

		// read_term/2
		"read_term/2": [
			new Rule(new Term("read_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],

		// read_term/3
		"read_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "eof_code" ) {
				expr = {
					value: new Term("end_of_file", []),
					type: SUCCESS,
					len: -1
				};
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_read_option( property ) ) {
						thread.throw_error( pl.error.domain( "read_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0];
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var char, tokenizer, expr;
					var text = "";
					var tokens = [];
					var last_token = null;
					var lexical_error = false;
					// Get term
					while( last_token === null || lexical_error || last_token.name !== "atom" || last_token.value !== "." || tokens.length > 0 && expr.type === ERROR ) {
						char = stream2.stream.get( 1, stream2.position );
						while(char !== null && char !== "." && char !== "end_of_stream" && char !== "past_end_of_stream") {
							stream2.position++;
							text += char;
							char = stream2.stream.get( 1, stream2.position );
						}
						if( char === null ) {
							thread.throw_error( pl.error.representation( "character", atom.indicator ) );
							return;
						} else if( char === "end_of_stream" || char === "past_end_of_stream" ) {
							if(tokens === null || tokens.length === 0) {
								stream2.position = "past_end_of_stream";
								expr = {
									value: new Term("end_of_file", []),
									type: SUCCESS,
									len: -1
								};
								break;
							} else if(expr) {
								thread.throw_error( pl.error.syntax( last_token, "unexpected end of file", false ) );
								return;
							} else {
								thread.throw_error( pl.error.syntax( last_token, "token not found", true ) );
								return;
							}
						} else if(char === ".") {
							stream2.position++;
							text += char;
						}
						tokenizer = new Tokenizer( thread );
						tokenizer.new_text( text );
						tokens = tokenizer.get_tokens();
						num_token = tokens !== null && tokens.length > 1 ? tokens[tokens.length-2] : null;
						last_token = tokens !== null && tokens.length > 0 ? tokens[tokens.length-1] : null;
						if(tokens === null)
							continue;
						lexical_error = false;
						for(var i = 0; i < tokens.length && !lexical_error; i++)
							lexical_error = tokens[i].name === "lexical";
						if(lexical_error)
							continue;
						expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
						if(num_token && num_token.name === "number" && !num_token.float && !num_token.blank && last_token.value === ".") {
							var next_char = stream2.stream.get(1, stream2.position);
							if(next_char >= '0' && next_char <= '9') {
								stream2.position++;
								text += next_char;
								last_token = null;
								continue;
							}
						}
					}
					if(last_token) {
						if(last_token.line_position === last_token.len)
							stream2.line_position += last_token.line_position;
						else
							stream2.line_position = last_token.line_position;
						stream2.line_count += last_token.line_count;
						stream2.char_count += last_token.len;
					}
					// Succeed analyzing term
					if( expr.type === SUCCESS && (expr.len === -1 || expr.len === tokens.length-1 && last_token.value === "." )) {
						thread.session.renamed_variables = {};
						expr = expr.value.rename( thread );
						var eq = new Term( "=", [term, expr] );
						// Variables
						if( obj_options.variables ) {
							var vars = arrayToList( map( nub( expr.variables() ), function(v) { return new Var(v); } ) );
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variables, vars] )] )
						}
						// Variable names
						if( obj_options.variable_names ) {
							var vars = nub(expr.variables());
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variable_names, plvars] )] );
						}
						// Singletons
						if( obj_options.singletons ) {
							var vars = nub(new Rule(expr, null).singleton_variables(true));
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.singletons, plvars] )] );
						}
						thread.prepend( [new State( point.goal.replace( eq ), point.substitution, point )] );
					// Failed analyzing term
					} else {
						if( expr.type === SUCCESS )
							thread.throw_error( pl.error.syntax( tokens[expr.len], "unexpected token", false ) );
						else
							thread.throw_error( expr.value );
					}
				}
			}
		},

		// write/1
		"write/1": [
			new Rule(new Term("write", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write", [new Var("S"),new Var("T")])]))
		],
		
		// write/2
		"write/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("false", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// writeq/1
		"writeq/1": [
			new Rule(new Term("writeq", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("writeq", [new Var("S"),new Var("T")])]))
		],
		
		// writeq/2
		"writeq/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// write_canonical/1
		"write_canonical/1": [
			new Rule(new Term("write_canonical", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_canonical", [new Var("S"),new Var("T")])]))
		],
		
		// write_canonical/2
		"write_canonical/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("true")]),
							new Term(".", [new Term("numbervars", [new Term("false")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},

		// write_term/2
		"write_term/2": [
			new Rule(new Term("write_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],
		
		// write_term/3
		"write_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "output", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_write_option( property ) ) {
						thread.throw_error( pl.error.domain( "write_option", property, atom.indicator ) );
						return;
					}
					if(property.indicator === "variable_names/1")
						obj_options[property.id] = property.args[0];
					else
						obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					obj_options.session = thread.session;
					var text = term.toString( obj_options );
					stream2.stream.put( text, stream2.position );
					if( typeof stream2.position === "number" )
						stream2.position += text.length;
					var nl = (text.match(/\n/g) || []).length;
					stream2.line_count += nl;
					if(nl > 0)
						stream2.line_position = text.length - text.lastIndexOf("\n") - 1;
					else
						stream2.line_position += text.length;
					stream2.char_count += text.length;
					thread.success( point );
				}
			}
		},
		
		// IMPLEMENTATION DEFINED HOOKS
		
		// halt/0
		"halt/0": function( thread, point, _ ) {
			if( thread.get_flag("nodejs").indicator === "true/0" )
				process.exit();
			thread.points = [];
		},
		
		// halt/1
		"halt/1": function( thread, point, atom ) {
			var int = atom.args[0];
			if( pl.type.is_variable( int ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( int ) ) {
				thread.throw_error( pl.error.type( "integer", int, atom.indicator ) );
			} else {
				if( thread.get_flag("nodejs").indicator === "true/0" )
					process.exit(int.value);
				thread.points = [];
			}
		},
		
		// current_prolog_flag/2
		"current_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( !pl.type.is_variable( flag ) && !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_variable( flag ) && !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else {
				var states = [];
				for( var name in pl.flag ) {
					if(!pl.flag.hasOwnProperty(name)) continue;
					var goal = new Term( ",", [new Term( "=", [new Term( name ), flag] ), new Term( "=", [thread.get_flag(name), value] )] );
					states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
				}
				thread.prepend( states );
			}
		},
		
		// set_prolog_flag/2
		"set_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else if( !pl.type.is_modifiable_flag( flag ) ) {
				thread.throw_error( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
			} else if( !pl.type.is_value_flag( flag, value ) ) {
				thread.throw_error( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
			} else {
				thread.session.flag[flag.id] = value;
				thread.success( point );
			}
		},



		// LOAD PROLOG SOURCE FILES

		// consult/1
		"consult/1": function(thread, point, atom) {
			var src = atom.args[0];
			var context_module = "user";
			if(src.indicator === ":/2") {
				context_module = src.args[0].id;
				src = src.args[1];
			}
			if(pl.type.is_variable(src)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_atom(src)) {
				thread.throw_error( pl.error.type( "atom", src, atom.indicator ) );
			} else {
				if(thread.consult(src.id, {
					context_module: context_module,
					text: false,
					html: false,
					success: function() {
						thread.success(point);
						thread.again();
					},
					error: function(err) {
						thread.throw_error(err);
						thread.again();
					}
				}));
				return true;
			}
		},



		// TIME AND DATES

		// get_time/1
		"get_time/1": function( thread, point, atom ) {
			var time = atom.args[0];
			if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else {
				var current = new Num(Date.now(), true);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [time, current] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_property
		"time_property/2": function(thread, point, atom) {
			var time = atom.args[0], property = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error(pl.error.type("number", time, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_time_property(property)) {
				thread.throw_error(pl.error.domain("time_property", property, atom.indicator));
			} else {
				var props;
				if(pl.type.is_variable(property)) {
					props = ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"];
				} else {
					props = [property.id];
				}
				var date = new Date(time.value);
				var value;
				var states = [];
				for(var i = 0; i < props.length; i++) {
					switch(props[i]) {
						case "year":
							value = new Term("year", [new Num(date.getFullYear(), false)]);
							break;
						case "month":
							value = new Term("month", [new Num(date.getMonth(), false)]);
							break;
						case "day":
							value = new Term("day", [new Num(date.getDate(), false)]);
							break;
						case "hours":
							value = new Term("hours", [new Num(date.getHours(), false)]);
							break;
						case "minutes":
							value = new Term("minutes", [new Num(date.getMinutes(), false)]);
							break;
						case "seconds":
							value = new Term("seconds", [new Num(date.getSeconds(), false)]);
							break;
						case "milliseconds":
							value = new Term("milliseconds", [new Num(date.getMilliseconds(), false)]);
							break;
						case "weekday":
							value = new Term("weekday", [new Num(date.getDay(), false)]);
							break;
					}
					states.push(new State(
						point.goal.replace( new Term( "=", [property, value] ) ), 
						point.substitution,
						point
					));
				}
				thread.prepend(states);
			}
		},

		// time_year/2
		"time_year/2": function( thread, point, atom ) {
			var time = atom.args[0], year = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(year) && !pl.type.is_integer(year)) {
				thread.throw_error( pl.error.type( "integer", year, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getFullYear(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [year, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_month/2
		"time_month/2": function( thread, point, atom ) {
			var time = atom.args[0], month = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(month) && !pl.type.is_integer(month)) {
				thread.throw_error( pl.error.type( "integer", month, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getMonth(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [month, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},



		// GRAMMARS

		// phrase/3
		"phrase/3": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1], s = atom.args[2];
			var context_module = "user";
			if(grbody.indicator === ":/2") {
				context_module = grbody.args[0].id;
				grbody = grbody.args[1];
			}
			if( pl.type.is_variable( grbody ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( grbody ) ) {
				thread.throw_error( pl.error.type( "callable", grbody, atom.indicator ) );
			} else {
				var goal = body_to_dcg( grbody.clone(), s0, thread );
				goal.value = new Term(":", [new Term(context_module), new Term("call", [goal.value])]);
				if(goal !== null) {
					thread.prepend( [new State(
						point.goal.replace( new Term( ",", [goal.value, new Term("=", [goal.variable, s])] ) ), 
						point.substitution,
						point
					)] );
				}
			}
		},

		// phrase/2
		"phrase/2": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1];
			thread.prepend( [new State(
				point.goal.replace( new Term( "phrase", [grbody, s0, new Term("[]", [])] ) ), 
				point.substitution,
				point
			)] );
		},



		// TAU PROLOG INFORMATION

		// version/0
		"version/0": function( thread, point, atom ) {
			var msg = "Welcome to Tau Prolog version " + version.major + "." + version.minor + "." + version.patch + "\n";
			msg += "Tau Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\n";
			msg += "Please run ?- license. for legal details.\n";
			msg += "For online help and background, visit http:/tau-prolog.org";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		},

		// license/0
		"license/0": function( thread, point, atom ) {
			var msg = "Tau Prolog. A Prolog interpreter in JavaScript.\n";
			msg += "Copyright (C) 2017 - 2022 José Antonio Riaza Valverde\n\n";
			msg += "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n";
			msg += "1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n";
			msg += "2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n";
			msg += "3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n";
			msg += "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n";
			msg += "You should have received a copy of the BSD 3-Clause License along with this program. If not, see https://opensource.org/licenses/BSD-3-Clause";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		}

	}, "all", {
		meta_predicates: {
			// '$findall'(?, 0, -, ?)
			"$findall/4": new Term("$findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// '$bagof'(?, ^, -)
			"$bagof/3": new Term("$bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$setof'(?, ^, -)
			"$setof/3": new Term("$setof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$if'(0, 0, 0)
			"$if/3": new Term("$if", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// (0;0)
			";/2": new Term(";", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"->/2": new Term("->", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"*->/2": new Term("*->", [new Num(0, false), new Num(0, false)]),
			// (\+0)
			"\\+/1": new Term("\\+", [new Num(0, false)]),
			// abolish(:)
			"abolish/1": new Term("abolish", [new Term(":")]),
			// asserta(:)
			"asserta/1": new Term("asserta", [new Term(":")]),
			// assertz(:)
			"assertz/1": new Term("assertz", [new Term(":")]),
			// bagof(?, ^, -)
			"bagof/3": new Term("bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// call(0)
			"call/1": new Term("call", [new Num(0, false)]),
			// call(1, ?)
			"call/2": new Term("call", [new Num(1, false), new Term("?")]),
			// call(2, ?, ?)
			"call/3": new Term("call", [new Num(2, false), new Term("?"), new Term("?")]),
			// call(3, ?, ?, ?)
			"call/4": new Term("call", [new Num(3, false), new Term("?"), new Term("?"), new Term("?")]),
			// call(4, ?, ?, ?, ?)
			"call/5": new Term("call", [new Num(4, false), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(5, ?, ?, ?, ?, ?)
			"call/6": new Term("call", [new Num(5, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(6, ?, ?, ?, ?, ?, ?)
			"call/7": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(7, ?, ?, ?, ?, ?, ?, ?)
			"call/8": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call_cleanup(0, 0)
			"call_cleanup/2": new Term("call_cleanup", [new Num(0, false), new Num(0, false)]),
			// catch(0, ?, 0)
			"catch/3": new Term("catch", [new Num(0, false), new Term("?"), new Num(0, false)]),
			// consult(:)
			"consult/1": new Term("consult", [new Term(":")]),
			// clause(:, ?)
			"clause/2": new Term("clause", [new Term(":"), new Term("?")]),
			// current_predicate(?, :)
			"current_predicate/2": new Term("current_predicate", [new Term("?"), new Term(":")]),
			// findall(?, 0, -)
			"findall/3": new Term("findall", [new Term("?"), new Num(0, false), new Term("-")]),
			// findall(?, 0, -, ?)
			"findall/4": new Term("findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// forall(0, 0)
			"forall/2": new Term("forall", [new Num(0, false), new Num(0, false)]),
			// listing(:)
			"listing/1": new Term("listing", [new Term(":")]),
			// once(0)
			"once/1": new Term("once", [new Num(0, false)]),
			// phrase(:, ?)
			"phrase/2": new Term("phrase", [new Term(":"),new Term("?")]),
			// phrase(:, ?, ?)
			"phrase/3": new Term("phrase", [new Term(":"),new Term("?"), new Term("?")]),
			// retract(:)
			"retract/1": new Term("retract", [new Term(":")]),
			// retractall(:)
			"retractall/1": new Term("retractall", [new Term(":")]),
			// setup_call_cleanup(0, 0, 0)
			"setup_call_cleanup/3": new Term("setup_call_cleanup", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// setof(?, ^, -)
			"setof/3": new Term("setof", [new Term("?"), new Term("^"), new Term("-")])
		}
	});

	if( true ) {
		module.exports = pl;
	} else {}
	
})();


/***/ }),

/***/ "./node_modules/tau-prolog/modules/promises.js":
/*!*****************************************************!*\
  !*** ./node_modules/tau-prolog/modules/promises.js ***!
  \*****************************************************/
/***/ ((module) => {

var pl;
(function(pl) {

	// Extend Tau Prolog prototypes
	var extend = function(pl) {

		// Consult a program from a string
		pl.type.Session.prototype.promiseConsult = function(program, options) {
			return this.thread.promiseConsult(program, options);
		};

		pl.type.Thread.prototype.promiseConsult = function(program, options) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				var opts = {};
				options = options === undefined ? {} : options;
				opts.context_module = options.context_module;
				opts.text = options.text;
				opts.html = options.html;
				opts.url = options.url;
				opts.file = options.file;
				opts.script = options.script;
				opts.success = resolve;
				opts.error = reject;
				thread.consult(program, opts);
			});
		};

		// Query goal from a string (without ?-)
		pl.type.Session.prototype.promiseQuery = function(string) {
			return this.thread.promiseQuery(string);
		};

		pl.type.Thread.prototype.promiseQuery = function(string) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.query(string, {
					success: resolve,
					error: reject
				});
			});
		};

		// Find next computed answer
		pl.type.Session.prototype.promiseAnswer = function() {
			return this.thread.promiseAnswer();
		};

		pl.type.Thread.prototype.promiseAnswer = function() {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.answer({
					success: resolve,
					fail: resolve,
					error: reject,
					limit: reject
				});
			});
		};

		// Find all computed answers (asynchronous generator function)
		pl.type.Session.prototype.promiseAnswers = function() {
			return this.thread.promiseAnswers();
		};
		pl.type.Thread.prototype.promiseAnswers = async function*() {
			while(true) {
				var answer = await this.promiseAnswer();
				if(answer !== false)
					yield answer;
				else
					return;
			}
		};

	}

	if(true) {
		module.exports = function(p) {
			pl = p;
			extend(pl);
		};
	} else {}

})(pl);

/***/ }),

/***/ "./app/res/tokens/adjectives.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/adjectives.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "big",
    "small",
    "helpful",
    "red",
    "black",
    "great"
];


/***/ }),

/***/ "./app/res/tokens/copulas.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/copulas.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "is",
    "are",
    "be"
];


/***/ }),

/***/ "./app/res/tokens/definite_articles.ts":
/*!*********************************************!*\
  !*** ./app/res/tokens/definite_articles.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "the"
];


/***/ }),

/***/ "./app/res/tokens/existential_quantifiers.ts":
/*!***************************************************!*\
  !*** ./app/res/tokens/existential_quantifiers.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "some"
];


/***/ }),

/***/ "./app/res/tokens/hverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/hverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "do",
    "does"
];


/***/ }),

/***/ "./app/res/tokens/indefinite_articles.ts":
/*!***********************************************!*\
  !*** ./app/res/tokens/indefinite_articles.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "a",
    "an"
];


/***/ }),

/***/ "./app/res/tokens/iverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/iverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "exist",
    "exists",
    "run",
    "grow",
    "die",
    "live"
];


/***/ }),

/***/ "./app/res/tokens/mverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/mverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "eat",
    "drink",
    "watch",
    "make",
    "hit",
    "click"
];


/***/ }),

/***/ "./app/res/tokens/negations.ts":
/*!*************************************!*\
  !*** ./app/res/tokens/negations.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "doesn't",
    "does not",
    'not',
    "don't",
    'do not'
];


/***/ }),

/***/ "./app/res/tokens/nonsubconj.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/nonsubconj.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "and",
    "or"
];


/***/ }),

/***/ "./app/res/tokens/nouns.ts":
/*!*********************************!*\
  !*** ./app/res/tokens/nouns.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "cat",
    "mat",
    "table",
    "dog",
    "nodejs",
    "color",
    "button",
    "div",
    "president",
    "trump"
];


/***/ }),

/***/ "./app/res/tokens/prepositions.ts":
/*!****************************************!*\
  !*** ./app/res/tokens/prepositions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "to",
    "with",
    "from",
    "of",
    "over",
    "on",
    "at"
];


/***/ }),

/***/ "./app/res/tokens/relprons.ts":
/*!************************************!*\
  !*** ./app/res/tokens/relprons.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "that"
];


/***/ }),

/***/ "./app/res/tokens/subconj.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/subconj.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "if",
    "when",
    "because",
    "while"
];


/***/ }),

/***/ "./app/res/tokens/then.ts":
/*!********************************!*\
  !*** ./app/res/tokens/then.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "then"
];


/***/ }),

/***/ "./app/res/tokens/universal_quantifiers.ts":
/*!*************************************************!*\
  !*** ./app/res/tokens/universal_quantifiers.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "every",
    "all",
    "each"
];


/***/ }),

/***/ "./app/src/ast/phrases/Complement.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/Complement.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class Complement {
    constructor(preposition, nounPhrase) {
        this.preposition = preposition;
        this.nounPhrase = nounPhrase;
    }
    toClause(args) {
        var _a, _b;
        const subjId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (() => { throw new Error('undefined subject id'); })();
        const newId = (0, Clause_1.getRandomId)();
        return (0, Clause_1.clauseOf)(this.preposition.string, subjId, newId)
            .and(this.nounPhrase.toClause(Object.assign(Object.assign({}, args), { roles: { subject: newId } })));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = Complement;


/***/ }),

/***/ "./app/src/ast/phrases/CopulaSubordinateClause.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/phrases/CopulaSubordinateClause.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CopulaSubordinateClause {
    constructor(relpron, predicate, copula) {
        this.relpron = relpron;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a;
        return this.predicate.toClause(Object.assign(Object.assign({}, args), { roles: { subject: (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject } }));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaSubordinateClause;


/***/ }),

/***/ "./app/src/ast/phrases/NounPhrase.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/NounPhrase.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class NounPhrase {
    constructor(adjectives, complements, noun, quantifier, article, subordClause) {
        this.adjectives = adjectives;
        this.complements = complements;
        this.noun = noun;
        this.quantifier = quantifier;
        this.article = article;
        this.subordClause = subordClause;
    }
    isUniQuant() {
        var _a, _b;
        return (_b = (_a = this.quantifier) === null || _a === void 0 ? void 0 : _a.isUniversal()) !== null && _b !== void 0 ? _b : false;
    }
    toClause(args) {
        var _a, _b, _c, _d;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)();
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        return this
            .adjectives
            .map(a => a.string)
            .concat(this.noun ? [this.noun.string] : [])
            .map(p => (0, Clause_1.clauseOf)(p, subjectId))
            .reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)())
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)()))
            .and((_d = (_c = this.subordClause) === null || _c === void 0 ? void 0 : _c.toClause(newArgs)) !== null && _d !== void 0 ? _d : (0, Clause_1.emptyClause)());
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = NounPhrase;


/***/ }),

/***/ "./app/src/ast/sentences/ComplexSentence.ts":
/*!**************************************************!*\
  !*** ./app/src/ast/sentences/ComplexSentence.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
/**
 * A sentence that relates two simple sentences hypotactically, in a
 * condition-outcome relationship.
 */
class ComplexSentence {
    constructor(condition, outcome, subconj) {
        this.condition = condition;
        this.outcome = outcome;
        this.subconj = subconj;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)();
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        //TODO: this is WRONG, subject of condition may NOT always be the subject of the outcome
        const condition = this.condition.toClause(newArgs);
        const outcome = this.outcome.toClause(newArgs);
        return condition.implies(outcome);
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = ComplexSentence;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaQuestion.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaQuestion.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ./CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
class CopulaQuestion {
    constructor(subject, predicate, copula) {
        this.subject = subject;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        //TODO: in case of a universally quantified question eg: "are all cats smart?" the prolog
        // produced should NOT be an implication, but rather a check that all cats are smart.
        return new CopulaSentence_1.default(this.subject, this.copula, this.predicate).toClause(newArgs);
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaQuestion;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaSentence.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaSentence.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class CopulaSentence {
    constructor(subject, copula, predicate, negation) {
        this.subject = subject;
        this.copula = copula;
        this.predicate = predicate;
        this.negation = negation;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const subject = this.subject.toClause(newArgs);
        const predicate = this.predicate.toClause(newArgs).copy({ negate: !!this.negation });
        return this.subject.isUniQuant() ?
            subject.implies(predicate) :
            subject.and(predicate, { asRheme: true });
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = CopulaSentence;


/***/ }),

/***/ "./app/src/ast/sentences/IntransitiveSentence.ts":
/*!*******************************************************!*\
  !*** ./app/src/ast/sentences/IntransitiveSentence.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class IntransitiveSentence {
    constructor(subject, iverb, complements, negation) {
        this.subject = subject;
        this.iverb = iverb;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const theme = this.subject.toClause(newArgs);
        const rheme = (0, Clause_1.clauseOf)(this.iverb.string, subjectId)
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2)));
        return theme.and(rheme, { asRheme: true });
    }
}
exports["default"] = IntransitiveSentence;


/***/ }),

/***/ "./app/src/ast/sentences/MonotransitiveSentence.ts":
/*!*********************************************************!*\
  !*** ./app/src/ast/sentences/MonotransitiveSentence.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MonotransitiveSentence {
    constructor(subject, mverb, object, complements, negation) {
        this.subject = subject;
        this.mverb = mverb;
        this.object = object;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        throw new Error("Method not implemented.");
    }
}
exports["default"] = MonotransitiveSentence;


/***/ }),

/***/ "./app/src/ast/tokens/AbstractToken.ts":
/*!*********************************************!*\
  !*** ./app/src/ast/tokens/AbstractToken.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AbstractToken {
    constructor(string) {
        this.string = string;
    }
}
exports["default"] = AbstractToken;


/***/ }),

/***/ "./app/src/ast/tokens/Adjective.ts":
/*!*****************************************!*\
  !*** ./app/src/ast/tokens/Adjective.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Adjective extends AbstractToken_1.default {
}
exports["default"] = Adjective;


/***/ }),

/***/ "./app/src/ast/tokens/Article.ts":
/*!***************************************!*\
  !*** ./app/src/ast/tokens/Article.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Article extends AbstractToken_1.default {
    isDefinite() {
        return definite_articles_1.default.includes(this.string);
    }
    toString() {
        return `Article(${this.string}, isDefinite=${this.isDefinite()})`;
    }
}
exports["default"] = Article;


/***/ }),

/***/ "./app/src/ast/tokens/Copula.ts":
/*!**************************************!*\
  !*** ./app/src/ast/tokens/Copula.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Copula extends AbstractToken_1.default {
}
exports["default"] = Copula;


/***/ }),

/***/ "./app/src/ast/tokens/FullStop.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/FullStop.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class FullStop extends AbstractToken_1.default {
}
exports["default"] = FullStop;


/***/ }),

/***/ "./app/src/ast/tokens/HVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/HVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class HVerb extends AbstractToken_1.default {
}
exports["default"] = HVerb;


/***/ }),

/***/ "./app/src/ast/tokens/IVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/IVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class IVerb extends AbstractToken_1.default {
}
exports["default"] = IVerb;


/***/ }),

/***/ "./app/src/ast/tokens/MVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/MVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class MVerb extends AbstractToken_1.default {
}
exports["default"] = MVerb;


/***/ }),

/***/ "./app/src/ast/tokens/Negation.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/Negation.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Negation extends AbstractToken_1.default {
}
exports["default"] = Negation;


/***/ }),

/***/ "./app/src/ast/tokens/NonSubordinatingConjunction.ts":
/*!***********************************************************!*\
  !*** ./app/src/ast/tokens/NonSubordinatingConjunction.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class NonSubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = NonSubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Noun.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Noun.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Noun extends AbstractToken_1.default {
}
exports["default"] = Noun;


/***/ }),

/***/ "./app/src/ast/tokens/Preposition.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/tokens/Preposition.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Preposition extends AbstractToken_1.default {
}
exports["default"] = Preposition;


/***/ }),

/***/ "./app/src/ast/tokens/Quantifier.ts":
/*!******************************************!*\
  !*** ./app/src/ast/tokens/Quantifier.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Quantifier extends AbstractToken_1.default {
    isUniversal() {
        return universal_quantifiers_1.default.includes(this.string);
    }
    isExistential() {
        return existential_quantifiers_1.default.includes(this.string);
    }
}
exports["default"] = Quantifier;


/***/ }),

/***/ "./app/src/ast/tokens/RelativePronoun.ts":
/*!***********************************************!*\
  !*** ./app/src/ast/tokens/RelativePronoun.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class RelativePronoun extends AbstractToken_1.default {
}
exports["default"] = RelativePronoun;


/***/ }),

/***/ "./app/src/ast/tokens/SubordinatingConjunction.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/tokens/SubordinatingConjunction.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class SubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = SubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Then.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Then.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Then extends AbstractToken_1.default {
}
exports["default"] = Then;


/***/ }),

/***/ "./app/src/brain/Anaphora.ts":
/*!***********************************!*\
  !*** ./app/src/brain/Anaphora.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAnaphora = void 0;
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
function getAnaphora(clause) {
    return new BaseAnaphora(clause);
}
exports.getAnaphora = getAnaphora;
class BaseAnaphora {
    constructor(clause) {
        this.clause = clause;
    }
    mapTo(universe) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const themeEnts = this.clause.theme.entities;
            // get descriptions of entities in theme omitting relations with entities in rheme
            const themeDescs = this.clause.theme.flatList()
                .filter(e => !e.isImply);
            // get descriptions of entities in rheme omitting relations with entities in theme
            const rhemeDescs = this.clause.rheme.flatList()
                .filter(c => themeEnts.every(e => !c.entities.includes(e)))
                .filter(e => !e.isImply);
            const mapToVar = this.clause.entities
                .map(e => ({ [e]: (0, Clause_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            const reverseMapToVar = Object.fromEntries(Object.entries(mapToVar).map(e => [e[1], e[0]]));
            const bigDescClause = themeDescs
                .concat(rhemeDescs)
                .reduce((c1, c2) => c1.and(c2))
                .copy({ map: mapToVar });
            const candidates = yield universe.query(bigDescClause);
            const chosen = (_a = candidates[0]) !== null && _a !== void 0 ? _a : {}; //TODO: better criterion !!!
            const anaphora = Object
                .keys(chosen)
                .map(k => { var _a; return ({ [reverseMapToVar[k]]: (_a = chosen[k]) !== null && _a !== void 0 ? _a : reverseMapToVar[k] }); })
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
            return anaphora;
        });
    }
}


/***/ }),

/***/ "./app/src/brain/Brain.ts":
/*!********************************!*\
  !*** ./app/src/brain/Brain.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBrain = void 0;
const PrologBrain_1 = __importDefault(__webpack_require__(/*! ./PrologBrain */ "./app/src/brain/PrologBrain.ts"));
function getBrain() {
    return __awaiter(this, void 0, void 0, function* () {
        return new PrologBrain_1.default();
    });
}
exports.getBrain = getBrain;


/***/ }),

/***/ "./app/src/brain/PrologBrain.ts":
/*!**************************************!*\
  !*** ./app/src/brain/PrologBrain.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Parser_1 = __webpack_require__(/*! ../parser/Parser */ "./app/src/parser/Parser.ts");
const Prolog_1 = __webpack_require__(/*! ../prolog/Prolog */ "./app/src/prolog/Prolog.ts");
const Anaphora_1 = __webpack_require__(/*! ./Anaphora */ "./app/src/brain/Anaphora.ts");
class PrologBrain {
    constructor() {
        this.kb = (0, Prolog_1.getProlog)();
    }
    execute(natlang) {
        return __awaiter(this, void 0, void 0, function* () {
            let x = false;
            for (const ast of (0, Parser_1.getParser)(natlang).parseAll()) {
                x = yield this.executeOne(ast);
            }
            return x;
        });
    }
    executeOne(ast) {
        return __awaiter(this, void 0, void 0, function* () {
            if (ast.isSideEffecty) {
                yield this.assert(ast.toClause());
                return true;
            }
            else {
                return yield this.query(ast.toClause());
            }
        });
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapToVar = query.entities
                .map(e => ({ [e]: (0, Clause_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            const q = query
                .copy({ map: mapToVar })
                .toProlog()
                .reduce((a, b) => `${a}, ${b}`) + '.'; // TODO: deal with dot at a lower level ?
            const queryRes = yield this.kb.query(q);
            return queryRes; //TODO: maybe return clause list instead, with query.copy({map:mapToVar}).copy({map:queryRes[i]}) //for each queryRes
        });
    }
    assert(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            const anaphoraMap = yield (0, Anaphora_1.getAnaphora)(clause).mapTo(this);
            const toBeAsserted = clause
                .copy({ map: anaphoraMap })
                .toProlog();
            for (const c of toBeAsserted) { // TODO: bug finding one entity multiple times
                yield this.kb.assert(c);
            }
        });
    }
}
exports["default"] = PrologBrain;


/***/ }),

/***/ "./app/src/clauses/And.ts":
/*!********************************!*\
  !*** ./app/src/clauses/And.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
class And {
    constructor(clauses, negated = false, isImply = false) {
        this.clauses = clauses;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return (opts === null || opts === void 0 ? void 0 : opts.asRheme) ?
            new And([this.copy(), other.copy()]) :
            new And([...this.flatList(), ...other.flatList()]);
    }
    copy(opts) {
        return new And(this.clauses.map(c => c.copy(Object.assign(Object.assign({}, opts), { negate: false }))), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return this.negated ? [this.copy()] : this.clauses.flatMap(c => c.flatList());
    }
    get entities() {
        return Array.from(new Set(this.clauses.flatMap(c => c.entities)));
    }
    get theme() {
        return this.clauses[0];
    }
    get rheme() {
        return this.clauses[1];
    }
    implies(conclusion) {
        return new Imply_1.default(this.copy(), conclusion.copy());
    }
    toProlog() {
        const prologClauses = this.clauses.flatMap(c => c.toProlog());
        return this.negated ?
            [`logicNot(${prologClauses.reduce((a, b) => `${a}, ${b}`)})`] :
            prologClauses;
    }
}
exports["default"] = And;


/***/ }),

/***/ "./app/src/clauses/BasicClause.ts":
/*!****************************************!*\
  !*** ./app/src/clauses/BasicClause.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicClause = void 0;
const Clause_1 = __webpack_require__(/*! ./Clause */ "./app/src/clauses/Clause.ts");
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
class BasicClause {
    constructor(predicate, args, negated = false, isImply = false) {
        this.predicate = predicate;
        this.args = args;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return new And_1.default(this.flatList().concat(other.flatList()));
    }
    copy(opts) {
        return new BasicClause(this.predicate, this.args.map(a => { var _a; return (opts === null || opts === void 0 ? void 0 : opts.map) ? (_a = opts === null || opts === void 0 ? void 0 : opts.map[a]) !== null && _a !== void 0 ? _a : a : a; }), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this.copy()];
    }
    toProlog() {
        const core = `${this.predicate}(${this.args.reduce((a, b) => `${a}, ${b}`)})`;
        return this.negated ? [`logicNot(${core})`] : [core];
    }
    get entities() {
        return Array.from(new Set(this.args.concat([])));
    }
    get theme() {
        return this.copy();
    }
    get rheme() {
        return (0, Clause_1.emptyClause)();
    }
    implies(conclusion) {
        return new Imply_1.default(this.copy(), conclusion.copy());
    }
}
exports.BasicClause = BasicClause;


/***/ }),

/***/ "./app/src/clauses/Clause.ts":
/*!***********************************!*\
  !*** ./app/src/clauses/Clause.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toVar = exports.getRandomId = exports.emptyClause = exports.clauseOf = void 0;
const BasicClause_1 = __webpack_require__(/*! ./BasicClause */ "./app/src/clauses/BasicClause.ts");
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
function clauseOf(predicate, ...args) {
    return new BasicClause_1.BasicClause(predicate, args);
}
exports.clauseOf = clauseOf;
const emptyClause = () => new And_1.default([]);
exports.emptyClause = emptyClause;
function getRandomId(opts) {
    return `${(opts === null || opts === void 0 ? void 0 : opts.asVar) ? 'Id' : 'id'}${parseInt(1000 * Math.random() + '')}`;
}
exports.getRandomId = getRandomId;
function toVar(id) {
    return (!Number.isNaN(Number(id)) ? `id${id}` : id + '').toUpperCase();
}
exports.toVar = toVar;


/***/ }),

/***/ "./app/src/clauses/Imply.ts":
/*!**********************************!*\
  !*** ./app/src/clauses/Imply.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
class Imply {
    constructor(condition, conclusion, negated = false, isImply = true) {
        this.condition = condition;
        this.conclusion = conclusion;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return new And_1.default([this.copy(), other.copy()]);
    }
    copy(opts) {
        return new Imply(this.condition.copy(opts), this.conclusion.copy(opts), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this.copy()];
    }
    /**
     * Generates horn clauses, one for each conclusion.
     * Since prolog only supports that kind of implication.
     * @returns
     */
    toProlog() {
        const conditionString = this.condition
            .toProlog()
            .reduce((c1, c2) => `${c1}, ${c2}`);
        const conclusions = this.conclusion.flatList();
        return conclusions.map(c => `${c.toProlog()[0]} :- ${conditionString}`); //TODO: [0] is to be dealt with better
    }
    get entities() {
        return this.condition.entities.concat(this.conclusion.entities);
    }
    get theme() {
        return this.condition.theme;
    }
    get rheme() {
        return this.copy(); // dunno what I'm doin'
    }
    implies(conclusion) {
        throw new Error('not implemented!');
    }
}
exports["default"] = Imply;


/***/ }),

/***/ "./app/src/index.ts":
/*!**************************!*\
  !*** ./app/src/index.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const compile_logic_test_1 = __importDefault(__webpack_require__(/*! ./tests/compile-logic-test */ "./app/src/tests/compile-logic-test.ts"));
const playground_1 = __importDefault(__webpack_require__(/*! ./tests/playground */ "./app/src/tests/playground.ts"));
// PROLOG TEST //////////////////////////////////////////
// const pro = getProlog();
// (window as any).pro = pro;
// (async () => {
//     await pro.assert('capra(scemo)')
//     await pro.assert('mammal(peloso)')
//     await pro.assert('mammal(fido)')
//     await pro.assert('mammal(X) :- capra(X)')
//     console.log(await pro.query('mammal(X).'))
//     await pro.retract('capra(scemo)')
//     console.log(await pro.query('mammal(X).'))
// })();
// //      //////////////////////////////////////////
//////////////////////////////////////////////////////////////
// console.log((tokenOf('a') as Article).isDefinite())
// console.log(tokenOf('a')  instanceof Article)
// console.log(tokenOf('a')  instanceof Quantifier)
// console.log(tokenOf('every')  instanceof Quantifier)
// console.log(tokenOf('a').toString())
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// const lexer = getLexer('the cat is a cat.')
// console.log(lexer)
// console.log('is it a noun?', lexer.assert(Noun, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it a copula?', lexer.assert(Copula, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it an article?', lexer.assert(Article, {errorOut:false}) )
// console.log(lexer.peek)
///////////////////////////////////////////////////////
// console.log(getParser('the cat is big').parse())
// console.log(getParser('the big cat').parse() )
// console.log(getParser('the big cat on the table is eating tuna').parse() )
// console.log(getParser('the big cat on the mat').parse() )
// console.log(getParser('every dog is stupid').parse() )
// console.log(getParser('the cat that is smart').parse() )
// console.log(getParser('nodejs is not helpful').parse() )
// console.log(getParser('if the dog is stupid then the cat is happy').parse() )
// console.log(getParser('the cat is happy if the dog is stupid').parse() )
// console.log((window as any).ast = getParser('the color of the button is red').parse())
// console.log((window as any).ast = getParser('the color of the button on the black div is red').parse())
// COMPILER TESTS
// function test(string: string) {
//     console.log(string)
//     const clause = getParser(string).parse().toClause().copy({ map: { 'id1': 1000, 'id2': 2000 } })
//     // console.log(clause.flatList().map(c => c.toString()))
//     console.log(clause.toProlog())
//     // console.log(clause)
//     // console.log('entities', clause.entities)
//     // console.log('theme', clause.theme)
//     // console.log('rheme', clause.rheme)
//     // console.log(clause.about('id0'))
// }
// test('the cat is on the mat')
// // test('the cat that is red is on the mat')
// // test('the big cat that is on the mat is black')
// test('every cat is red')
// test('every red cat is on the mat')
// // test('the cat exists on the mat')
// test('if the cat is on the mat then the cat is red')
// // test('the cat is not red')
// test('every cat is not red')
// test('trump is not a great president'); // probably need an and predicate
// END COMPILER TESTS
// (async () => {
//     const brain = await getBrain();
//     const c = clauseOf('capra', 'uno')
//         .concat(clauseOf('capra', 2))
//         .concat(clauseOf('capra', 3))
//         .concat(clauseOf('white', 3))
//         .concat(clauseOf('cat', 4))
//         .concat(clauseOf('white', 4))
//     await brain.assert(c);
//     console.log(await brain.query(clauseOf('white', 'X').concat(clauseOf('cat', 'X'))))
// })()
// (async () => {
//     const state = {
//         timer : setTimeout(()=>{},0),
//         brain : await getBrain(),
//         debouncingTime : 0
//     }
//     const p = document.createElement('p')
//     document.getElementById('root')?.appendChild(p)
//     const textarea = document.createElement('textarea')
//     textarea.style.height = '50vh'
//     textarea.style.width = '50vw'
//     document.getElementById('root')?.appendChild(textarea)
//     const onInput = async () => {
//         const text = textarea.value
//         const ast = getParser(text).parse()
//         const clause = ast.toProlog()
//         if (!clause){
//             return 
//         }
//         const mapping = getSandbox(clause).mapTo(state.brain)
//         p.innerHTML = `${(ast as any).constructor.name}: ${clause.toString()}`
//         if (ast instanceof CopulaQuestion){
//             console.log(await state.brain.query(clause))
//         }else{
//             console.log('asserted:', clause.toString())
//         }
//     }
//     textarea.oninput = e => {
//         clearTimeout(state.timer)
//         state.timer = setTimeout(()=>{
//             onInput()
//         }, state.debouncingTime)
//     }
// })();
// (async () => {
//     const prolog = await getBrain();
//     (window as any).prolog = prolog
//     await prolog.assert(clauseOf('cat', 'a'))
//     await prolog.assert(clauseOf('cat', 'b'))
//     await prolog.assert(clauseOf('cat', 'c'))
//     await prolog.assert(clauseOf('white', 'a'))
//     await prolog.assert(clauseOf('dog', 'd'))
//     await prolog.assert(clauseOf('eat', 'a', 'rabbit'))
//     await prolog.assert(clauseOf('eat', 'a', 'mouse'))
//     await prolog.assert(clauseOf('eat', 'a', 'birdie'))
//     await prolog.assert(clauseOf('eat', 'd', 'bone'))
//     await prolog.assert(clauseOf('table', 'tb1'))
//     // const res = await prolog.query(clauseOf('cat', 'X').concat(clauseOf('eat', 'X', 'Y').concat(clauseOf('dog', 'Z'))))
//     // const clause = clauseOf('cat', 'id0').concat(clauseOf('dog', 'id1')).concat(clauseOf('capra', 'id55')) 
//     // const clause = getParser('the cat that is black is smart').parse().toProlog()
//     const clause = getParser('the cat that is white is on the table').parse().toProlog()
//     console.log(clause.toString())
//     const res = await getSandbox(clause).mapTo(prolog)
//     console.log(res)
//     console.log(clause.rheme.copy({ map: res }).toString())
// })();
// prologPlay()
(0, compile_logic_test_1.default)();
(0, playground_1.default)();
// const x = getParser('the cat is on the mat. the cat is red. the cat is black')
//         .parseAll()
//         .map(c=>c.toClause().toProlog())
// console.log(x)


/***/ }),

/***/ "./app/src/lexer/EagerLexer.ts":
/*!*************************************!*\
  !*** ./app/src/lexer/EagerLexer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tokenOf_1 = __importDefault(__webpack_require__(/*! ./tokenOf */ "./app/src/lexer/tokenOf.ts"));
class EagerLexer {
    constructor(sourceCode) {
        this.sourceCode = sourceCode;
        //TODO: reconstruct "do not" and "does not" tokens
        //TODO: nouns vs adjectives
        this.tokens = sourceCode.trim().split(/\s+|\./).map(e => !e ? '.' : e).map(tokenOf_1.default);
        console.debug('tokens', this.tokens);
        this._pos = 0;
    }
    next() {
        this._pos++;
    }
    get pos() {
        return this._pos;
    }
    backTo(pos) {
        this._pos = pos;
    }
    get peek() {
        return this.tokens[this._pos];
    }
    croak(errorMsg) {
        throw new Error(`${errorMsg} at ${this._pos}`);
    }
    /**
     * Return current token iff of given type and move to next;
     * else return undefined and don't move.
     * @param args
     * @returns
     */
    assert(clazz, args) {
        var _a, _b;
        const current = this.peek;
        if (current instanceof clazz) {
            this.next();
            return current;
        }
        else if ((_a = args.errorOut) !== null && _a !== void 0 ? _a : true) {
            this.croak((_b = args.errorMsg) !== null && _b !== void 0 ? _b : '');
        }
        else {
            return undefined;
        }
    }
    get isEnd() {
        return this.pos >= this.tokens.length;
    }
}
exports["default"] = EagerLexer;


/***/ }),

/***/ "./app/src/lexer/Lexer.ts":
/*!********************************!*\
  !*** ./app/src/lexer/Lexer.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLexer = void 0;
const EagerLexer_1 = __importDefault(__webpack_require__(/*! ./EagerLexer */ "./app/src/lexer/EagerLexer.ts"));
function getLexer(sourceCode) {
    return new EagerLexer_1.default(sourceCode);
}
exports.getLexer = getLexer;


/***/ }),

/***/ "./app/src/lexer/tokenOf.ts":
/*!**********************************!*\
  !*** ./app/src/lexer/tokenOf.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const adjectives_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/adjectives */ "./app/res/tokens/adjectives.ts"));
const indefinite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/indefinite_articles */ "./app/res/tokens/indefinite_articles.ts"));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const copulas_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/copulas */ "./app/res/tokens/copulas.ts"));
const hverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/hverbs */ "./app/res/tokens/hverbs.ts"));
const iverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/iverbs */ "./app/res/tokens/iverbs.ts"));
const mverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/mverbs */ "./app/res/tokens/mverbs.ts"));
const negations_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/negations */ "./app/res/tokens/negations.ts"));
const nonsubconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nonsubconj */ "./app/res/tokens/nonsubconj.ts"));
const nouns_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nouns */ "./app/res/tokens/nouns.ts"));
const prepositions_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/prepositions */ "./app/res/tokens/prepositions.ts"));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const relprons_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/relprons */ "./app/res/tokens/relprons.ts"));
const subconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/subconj */ "./app/res/tokens/subconj.ts"));
const then_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/then */ "./app/res/tokens/then.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const HVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/HVerb */ "./app/src/ast/tokens/HVerb.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const NonSubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/NonSubordinatingConjunction */ "./app/src/ast/tokens/NonSubordinatingConjunction.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const FullStop_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/FullStop */ "./app/src/ast/tokens/FullStop.ts"));
function tokenOf(string) {
    if (indefinite_articles_1.default.concat(definite_articles_1.default).includes(string)) {
        return new Article_1.default(string);
    }
    else if (copulas_1.default.includes(string)) {
        return new Copula_1.default(string);
    }
    else if (hverbs_1.default.includes(string)) {
        return new HVerb_1.default(string);
    }
    else if (iverbs_1.default.includes(string)) {
        return new IVerb_1.default(string);
    }
    else if (mverbs_1.default.includes(string)) {
        return new MVerb_1.default(string);
    }
    else if (negations_1.default.includes(string)) {
        return new Negation_1.default(string);
    }
    else if (nonsubconj_1.default.includes(string)) {
        return new NonSubordinatingConjunction_1.default(string);
    }
    else if (prepositions_1.default.includes(string)) {
        return new Preposition_1.default(string);
    }
    else if (existential_quantifiers_1.default.concat(universal_quantifiers_1.default).includes(string)) {
        return new Quantifier_1.default(string);
    }
    else if (then_1.default.includes(string)) {
        return new Then_1.default(string);
    }
    else if (relprons_1.default.includes(string)) {
        return new RelativePronoun_1.default(string);
    }
    else if (subconj_1.default.includes(string)) {
        return new SubordinatingConjunction_1.default(string);
    }
    else if (nouns_1.default.includes(string)) {
        return new Noun_1.default(string);
    }
    else if (adjectives_1.default.includes(string)) {
        return new Adjective_1.default(string);
    }
    else if ('.' === string) {
        return new FullStop_1.default('.');
    }
    return new Adjective_1.default(string);
}
exports["default"] = tokenOf;


/***/ }),

/***/ "./app/src/parser/BasicParser.ts":
/*!***************************************!*\
  !*** ./app/src/parser/BasicParser.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Complement_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/Complement */ "./app/src/ast/phrases/Complement.ts"));
const NounPhrase_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/NounPhrase */ "./app/src/ast/phrases/NounPhrase.ts"));
const ComplexSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/ComplexSentence */ "./app/src/ast/sentences/ComplexSentence.ts"));
const CopulaQuestion_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaQuestion */ "./app/src/ast/sentences/CopulaQuestion.ts"));
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
const IntransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/IntransitiveSentence */ "./app/src/ast/sentences/IntransitiveSentence.ts"));
const MonotransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/MonotransitiveSentence */ "./app/src/ast/sentences/MonotransitiveSentence.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const Lexer_1 = __webpack_require__(/*! ../lexer/Lexer */ "./app/src/lexer/Lexer.ts");
const CopulaSubordinateClause_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/CopulaSubordinateClause */ "./app/src/ast/phrases/CopulaSubordinateClause.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
const FullStop_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/FullStop */ "./app/src/ast/tokens/FullStop.ts"));
class BasicParser {
    constructor(sourceCode) {
        this.parseDeclaration = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCompound)) !== null && _a !== void 0 ? _a : this.try(this.parseSimple)) !== null && _b !== void 0 ? _b : this.errorOut('parseDeclaration()');
        };
        this.parseQuestion = () => {
            var _a;
            return (_a = this.try(this.parseBinaryQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseQuestion()');
        };
        this.parseSimple = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCopulaSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseVerbSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseSimple()');
        };
        this.parseCompound = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseComplex)) !== null && _a !== void 0 ? _a : this.try(this.parseConjunctive)) !== null && _b !== void 0 ? _b : this.errorOut('parseCompound()');
        };
        this.parseVerbSentence = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseIntransitiveSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseMonotransitiveSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseVerbSentence()');
        };
        this.parseCopulaSentence = () => {
            const subject = this.parseNounPhrase();
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSentence(), expected copula' });
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const predicate = this.parseNounPhrase();
            return new CopulaSentence_1.default(subject, copula, predicate, negation);
        };
        this.parseComplex = () => {
            const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: false });
            if (subconj) {
                const condition = this.parseSimple();
                this.lx.assert(Then_1.default, { errorOut: false });
                const outcome = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
            else {
                const outcome = this.parseSimple();
                const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: true, errorMsg: 'expected subordinating conjunction' });
                const condition = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
        };
        this.parseIntransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const iverb = this.lx.assert(IVerb_1.default, { errorMsg: 'parseIntransitiveSentence(), expected i-verb' });
            const complements = this.parseComplements();
            return new IntransitiveSentence_1.default(subject, iverb, complements, negation);
        };
        this.parseMonotransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const mverb = this.lx.assert(MVerb_1.default, { errorMsg: 'parseMonotransitiveSentence(), expected i-verb' });
            const cs1 = this.parseComplements();
            const object = this.parseNounPhrase();
            const cs2 = this.parseComplements();
            return new MonotransitiveSentence_1.default(subject, mverb, object, cs1.concat(cs2), negation);
        };
        this.parseBinaryQuestion = () => {
            var _a;
            return (_a = this.try(this.parseCopulaQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseBinaryQuestion()');
        };
        this.parseCopulaQuestion = () => {
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaQuestion(), expected copula' });
            const subject = this.parseNounPhrase();
            const predicate = this.parseNounPhrase();
            return new CopulaQuestion_1.default(subject, predicate, copula);
        };
        this.parseNounPhrase = () => {
            const quantifier = this.lx.assert(Quantifier_1.default, { errorOut: false });
            const article = this.lx.assert(Article_1.default, { errorOut: false });
            let adjectives = [];
            let adj;
            while (adj = this.lx.assert(Adjective_1.default, { errorOut: false })) {
                adjectives.push(adj);
            }
            const noun = this.lx.assert(Noun_1.default, { errorOut: false });
            const subordinateClause = this.try(this.parseSubordinateClause);
            const complements = this.parseComplements();
            return new NounPhrase_1.default(adjectives, complements, noun, quantifier, article, subordinateClause);
        };
        this.parseComplements = () => {
            const complements = [];
            let comp;
            while (comp = this.try(this.parseComplement)) {
                complements.push(comp);
            }
            return complements;
        };
        this.parseComplement = () => {
            const preposition = this.lx.assert(Preposition_1.default, { errorMsg: 'parseComplement() expected preposition' });
            const nounPhrase = this.parseNounPhrase();
            return new Complement_1.default(preposition, nounPhrase);
        };
        this.parseSubordinateClause = () => {
            var _a;
            return (_a = this.try(this.parseCopulaSubordinateClause)) !== null && _a !== void 0 ? _a : this.errorOut('parseSubordinateClause()');
        };
        this.parseCopulaSubordinateClause = () => {
            const relpron = this.lx.assert(RelativePronoun_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected relative pronoun' });
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected copula' });
            const subject = this.parseNounPhrase();
            return new CopulaSubordinateClause_1.default(relpron, subject, copula);
        };
        this.parseConjunctive = () => {
            throw new Error('NOT IMPLEMENTED! TODO!');
        };
        this.lx = (0, Lexer_1.getLexer)(sourceCode);
    }
    try(method) {
        const memento = this.lx.pos;
        try {
            return method();
        }
        catch (error) {
            console.debug(error.message);
            this.lx.backTo(memento);
        }
    }
    errorOut(errorMsg) {
        this.lx.croak(errorMsg);
        throw new Error(errorMsg);
    }
    parseAll() {
        const results = [];
        while (!this.lx.isEnd) {
            results.push(this.parse());
            this.lx.assert(FullStop_1.default, { errorOut: false });
        }
        return results;
    }
    parse() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.try(this.parseQuestion)) !== null && _a !== void 0 ? _a : this.try(this.parseDeclaration)) !== null && _b !== void 0 ? _b : this.try(this.parseNounPhrase) // for quick topic reference
        ) !== null && _c !== void 0 ? _c : this.errorOut('parse()');
    }
}
exports["default"] = BasicParser;


/***/ }),

/***/ "./app/src/parser/Parser.ts":
/*!**********************************!*\
  !*** ./app/src/parser/Parser.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParser = void 0;
const BasicParser_1 = __importDefault(__webpack_require__(/*! ./BasicParser */ "./app/src/parser/BasicParser.ts"));
function getParser(sourceCode) {
    return new BasicParser_1.default(sourceCode);
}
exports.getParser = getParser;


/***/ }),

/***/ "./app/src/prolog/Prolog.ts":
/*!**********************************!*\
  !*** ./app/src/prolog/Prolog.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProlog = void 0;
const TauProlog_1 = __importDefault(__webpack_require__(/*! ./TauProlog */ "./app/src/prolog/TauProlog.ts"));
function getProlog() {
    return new TauProlog_1.default();
}
exports.getProlog = getProlog;


/***/ }),

/***/ "./app/src/prolog/TauProlog.ts":
/*!*************************************!*\
  !*** ./app/src/prolog/TauProlog.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tau_prolog_1 = __importDefault(__webpack_require__(/*! tau-prolog */ "./node_modules/tau-prolog/modules/core.js"));
__webpack_require__(/*! tau-prolog/modules/promises.js */ "./node_modules/tau-prolog/modules/promises.js")(tau_prolog_1.default);
class TauProlog {
    constructor() {
        this.session = tau_prolog_1.default.create();
    }
    assert(clause, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`assert${(opts === null || opts === void 0 ? void 0 : opts.z) ? 'z' : 'a'}( ( ${clause} ) ).`);
            return yield this.session.promiseAnswer();
        });
    }
    retract(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`retract(${clause}).`);
            return yield this.session.promiseAnswer();
        });
    }
    performQuery(code) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(code);
            let answers = [];
            try {
                for (var _b = __asyncValues(this.session.promiseAnswers()), _c; _c = yield _b.next(), !_c.done;) {
                    let ans = _c.value;
                    const fmans = tau_prolog_1.default.format_answer(ans);
                    if (['true', 'false'].includes(fmans)) {
                        return fmans === 'true';
                    }
                    const links = ans.links;
                    const entry = Object.keys(links)
                        .map(k => { var _a; return ({ [k]: (_a = links[k].value) !== null && _a !== void 0 ? _a : links[k].id }); })
                        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
                    answers.push(entry);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.queryHasVar(code)) {
                return answers;
            }
            else {
                return false;
            }
        });
    }
    query(code) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.performQuery(code);
            }
            catch (e) {
                console.warn(this.parseError(e));
                return false;
            }
        });
    }
    parseError(e) {
        const error = e.args[0].args[0].id;
        if (error == 'existence_error') {
            const missingPredicate = e.args[0].args[0].args[1].args[0].id;
            return { error, missingPredicate };
        }
        else {
            return e;
        }
    }
    queryHasVar(code) {
        return code.split('').find(c => c.match(/\w+/) && c.toUpperCase() === c);
    }
    predicates(opts) {
        return Object.keys(this.session.rules)
            .map(r => r.split('/'))
            .filter(t => (opts === null || opts === void 0 ? void 0 : opts.arity) !== undefined ? parseInt(t[1]) === (opts === null || opts === void 0 ? void 0 : opts.arity) : true)
            .map(t => t[0]);
    }
}
exports["default"] = TauProlog;


/***/ }),

/***/ "./app/src/tests/compile-logic-test.ts":
/*!*********************************************!*\
  !*** ./app/src/tests/compile-logic-test.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Brain_1 = __webpack_require__(/*! ../brain/Brain */ "./app/src/brain/Brain.ts");
/**
 * Some cool fuzzy tests
 */
function compileLogicTest() {
    return __awaiter(this, void 0, void 0, function* () {
        function test(statement, check) {
            return __awaiter(this, void 0, void 0, function* () {
                const brain = yield (0, Brain_1.getBrain)();
                yield brain.execute(statement);
                console.log(yield brain.execute(check));
            });
        }
        yield test('the cat is on the mat', 'is the cat on the mat');
        yield test('the cat that is red is on the mat', 'is the red cat on the mat');
        yield test('a cat is red. every cat is smart. a cat is black.', 'is the red cat smart');
        yield test('the dog is stupid', 'is the kettle on the stove'); // false
        // test('the big cat that is on the mat is black')
        // test('every cat is red')
        // test('every red cat is on the mat')
        // test('the cat exists on the mat')
        // test('if the cat is on the mat then the cat is red')
        // test('the cat is not red')
        // test('every cat is not red')
        // test('trump is not a great president'); // probably need an and predicate
    });
}
exports["default"] = compileLogicTest;


/***/ }),

/***/ "./app/src/tests/playground.ts":
/*!*************************************!*\
  !*** ./app/src/tests/playground.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Brain_1 = __webpack_require__(/*! ../brain/Brain */ "./app/src/brain/Brain.ts");
function playground() {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const brain = yield (0, Brain_1.getBrain)();
        const button = document.createElement('button');
        button.innerText = 'run';
        (_a = document.getElementById('root')) === null || _a === void 0 ? void 0 : _a.appendChild(button);
        const parag = document.createElement('p');
        (_b = document.getElementById('root')) === null || _b === void 0 ? void 0 : _b.appendChild(parag);
        const textarea = document.createElement('textarea');
        textarea.style.height = '50vh';
        textarea.style.width = '50vw';
        (_c = document.getElementById('root')) === null || _c === void 0 ? void 0 : _c.appendChild(textarea);
        button.onclick = (e) => __awaiter(this, void 0, void 0, function* () {
            console.log(yield brain.execute(textarea.value));
        });
    });
}
exports["default"] = playground;


/***/ }),

/***/ "?a95c":
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4ec4":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b05a":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a1b8":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1b04":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4a0f":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4461":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./app/src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpQkFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFlO0FBQzdDO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0RBQWtELEVBQUU7QUFDcEQ7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsbUJBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUJBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7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Q0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVSx3QkFBd0I7QUFDN0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsd0JBQXdCO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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LEdBQUcsTUFBTTtRQUM5QixRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxNQUFNO1FBQzdCLGNBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLDBDQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUM7UUFFdEQsTUFBTSxDQUFDLE9BQU8sR0FBRyxDQUFNLENBQUMsRUFBQyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNwRCxDQUFDOztDQUVKO0FBcEJELGdDQW9CQzs7Ozs7Ozs7Ozs7QUN0QkQ7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7O1dDdEJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztVRVBEO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGliL3JlYWRsaW5lLXN5bmMuanMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vbm9kZV9tb2R1bGVzL3RhdS1wcm9sb2cvbW9kdWxlcy9jb3JlLmpzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL25vZGVfbW9kdWxlcy90YXUtcHJvbG9nL21vZHVsZXMvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvYWRqZWN0aXZlcy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9jb3B1bGFzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2RlZmluaXRlX2FydGljbGVzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2V4aXN0ZW50aWFsX3F1YW50aWZpZXJzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2h2ZXJicy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9pbmRlZmluaXRlX2FydGljbGVzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2l2ZXJicy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9tdmVyYnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvbmVnYXRpb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL25vbnN1YmNvbmoudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvbm91bnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvcHJlcG9zaXRpb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL3JlbHByb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL3N1YmNvbmoudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvdGhlbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy91bml2ZXJzYWxfcXVhbnRpZmllcnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvcGhyYXNlcy9Db21wbGVtZW50LnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3BocmFzZXMvQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvcGhyYXNlcy9Ob3VuUGhyYXNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3NlbnRlbmNlcy9Db21wbGV4U2VudGVuY2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3Qvc2VudGVuY2VzL0NvcHVsYVF1ZXN0aW9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3NlbnRlbmNlcy9Db3B1bGFTZW50ZW5jZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9zZW50ZW5jZXMvSW50cmFuc2l0aXZlU2VudGVuY2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3Qvc2VudGVuY2VzL01vbm90cmFuc2l0aXZlU2VudGVuY2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0Fic3RyYWN0VG9rZW4udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0FkamVjdGl2ZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvQXJ0aWNsZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvQ29wdWxhLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9GdWxsU3RvcC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvSFZlcmIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0lWZXJiLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9NVmVyYi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvTmVnYXRpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL05vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvTm91bi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvUHJlcG9zaXRpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL1F1YW50aWZpZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL1JlbGF0aXZlUHJvbm91bi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9UaGVuLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYnJhaW4vQW5hcGhvcmEudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9icmFpbi9CcmFpbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2JyYWluL1Byb2xvZ0JyYWluLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvY2xhdXNlcy9BbmQudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9jbGF1c2VzL0Jhc2ljQ2xhdXNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvY2xhdXNlcy9DbGF1c2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9jbGF1c2VzL0ltcGx5LnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9sZXhlci9FYWdlckxleGVyLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvbGV4ZXIvTGV4ZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9sZXhlci90b2tlbk9mLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvcGFyc2VyL0Jhc2ljUGFyc2VyLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvcGFyc2VyL1BhcnNlci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL3Byb2xvZy9Qcm9sb2cudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9wcm9sb2cvVGF1UHJvbG9nLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvdGVzdHMvY29tcGlsZS1sb2dpYy10ZXN0LnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvdGVzdHMvcGxheWdyb3VuZC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWJ8Y2hpbGRfcHJvY2VzcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWJ8Y3J5cHRvIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy9yZWFkbGluZS1zeW5jL2xpYnxmcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWJ8b3MiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGlifHBhdGgiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3RhdS1wcm9sb2cvbW9kdWxlc3xmcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvdGF1LXByb2xvZy9tb2R1bGVzfHBhdGgiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC93ZWJwYWNrL2JlZm9yZS1zdGFydHVwIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogcmVhZGxpbmVTeW5jXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5zZWtpL3JlYWRsaW5lLXN5bmNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTggYW5zZWtpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXJcbiAgSVNfV0lOID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyxcblxuICBBTEdPUklUSE1fQ0lQSEVSID0gJ2Flcy0yNTYtY2JjJyxcbiAgQUxHT1JJVEhNX0hBU0ggPSAnc2hhMjU2JyxcbiAgREVGQVVMVF9FUlJfTVNHID0gJ1RoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuXFwndCBzdXBwb3J0IGludGVyYWN0aXZlIHJlYWRpbmcgZnJvbSBUVFkuJyxcblxuICBmcyA9IHJlcXVpcmUoJ2ZzJyksXG4gIFRUWSA9IHByb2Nlc3MuYmluZGluZygndHR5X3dyYXAnKS5UVFksXG4gIGNoaWxkUHJvYyA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKSxcbiAgcGF0aFV0aWwgPSByZXF1aXJlKCdwYXRoJyksXG5cbiAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICBwcm9tcHQ6ICAgICAgICAgICAgICc+ICcsXG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICBtYXNrOiAgICAgICAgICAgICAgICcqJyxcbiAgICBsaW1pdDogICAgICAgICAgICAgIFtdLFxuICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ0lucHV0IGFub3RoZXIsIHBsZWFzZS4kPCggWylsaW1pdChdKT4nLFxuICAgIGRlZmF1bHRJbnB1dDogICAgICAgJycsXG4gICAgdHJ1ZVZhbHVlOiAgICAgICAgICBbXSxcbiAgICBmYWxzZVZhbHVlOiAgICAgICAgIFtdLFxuICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2UsXG4gICAga2VlcFdoaXRlc3BhY2U6ICAgICBmYWxzZSxcbiAgICBlbmNvZGluZzogICAgICAgICAgICd1dGY4JyxcbiAgICBidWZmZXJTaXplOiAgICAgICAgIDEwMjQsXG4gICAgcHJpbnQ6ICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlLFxuICAgIGNkOiAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgcGhDb250ZW50OiAgICAgICAgICB2b2lkIDAsXG4gICAgcHJlQ2hlY2s6ICAgICAgICAgICB2b2lkIDBcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH0sXG5cbiAgZmRSID0gJ25vbmUnLCBmZFcsIHR0eVIsIGlzUmF3TW9kZSA9IGZhbHNlLFxuICBleHRIb3N0UGF0aCwgZXh0SG9zdEFyZ3MsIHRlbXBkaXIsIHNhbHQgPSAwLFxuICBsYXN0SW5wdXQgPSAnJywgaW5wdXRIaXN0b3J5ID0gW10sIHJhd0lucHV0LFxuICBfREJHX3VzZUV4dCA9IGZhbHNlLCBfREJHX2NoZWNrT3B0aW9ucyA9IGZhbHNlLCBfREJHX2NoZWNrTWV0aG9kID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldEhvc3RBcmdzKG9wdGlvbnMpIHtcbiAgLy8gU2VuZCBhbnkgdGV4dCB0byBjcmF6eSBXaW5kb3dzIHNoZWxsIHNhZmVseS5cbiAgZnVuY3Rpb24gZW5jb2RlQXJnKGFyZykge1xuICAgIHJldHVybiBhcmcucmVwbGFjZSgvW15cXHdcXHUwMDgwLVxcdUZGRkZdL2csIGZ1bmN0aW9uKGNocikge1xuICAgICAgcmV0dXJuICcjJyArIGNoci5jaGFyQ29kZUF0KDApICsgJzsnO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGV4dEhvc3RBcmdzLmNvbmNhdCgoZnVuY3Rpb24oY29uZikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgT2JqZWN0LmtleXMoY29uZikuZm9yRWFjaChmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgICBpZiAoY29uZltvcHRpb25OYW1lXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGlmIChvcHRpb25zW29wdGlvbk5hbWVdKSB7IGFyZ3MucHVzaCgnLS0nICsgb3B0aW9uTmFtZSk7IH1cbiAgICAgIH0gZWxzZSBpZiAoY29uZltvcHRpb25OYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICBhcmdzLnB1c2goJy0tJyArIG9wdGlvbk5hbWUsIGVuY29kZUFyZyhvcHRpb25zW29wdGlvbk5hbWVdKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXJncztcbiAgfSkoe1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICAgZGlzcGxheTogICAgICAgICdzdHJpbmcnLFxuICAgIGRpc3BsYXlPbmx5OiAgICAnYm9vbGVhbicsXG4gICAga2V5SW46ICAgICAgICAgICdib29sZWFuJyxcbiAgICBoaWRlRWNob0JhY2s6ICAgJ2Jvb2xlYW4nLFxuICAgIG1hc2s6ICAgICAgICAgICAnc3RyaW5nJyxcbiAgICBsaW1pdDogICAgICAgICAgJ3N0cmluZycsXG4gICAgY2FzZVNlbnNpdGl2ZTogICdib29sZWFuJ1xuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfSkpO1xufVxuXG4vLyBwaXBpbmcgdmlhIGZpbGVzIChmb3IgTm9kZS5qcyB2MC4xMC0pXG5mdW5jdGlvbiBfZXhlY0ZpbGVTeW5jKG9wdGlvbnMsIGV4ZWNPcHRpb25zKSB7XG5cbiAgZnVuY3Rpb24gZ2V0VGVtcGZpbGUobmFtZSkge1xuICAgIHZhciBmaWxlcGF0aCwgc3VmZml4ID0gJycsIGZkO1xuICAgIHRlbXBkaXIgPSB0ZW1wZGlyIHx8IHJlcXVpcmUoJ29zJykudG1wZGlyKCk7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgZmlsZXBhdGggPSBwYXRoVXRpbC5qb2luKHRlbXBkaXIsIG5hbWUgKyBzdWZmaXgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmQgPSBmcy5vcGVuU3luYyhmaWxlcGF0aCwgJ3d4Jyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgPT09ICdFRVhJU1QnKSB7XG4gICAgICAgICAgc3VmZml4Kys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmlsZXBhdGg7XG4gIH1cblxuICB2YXIgaG9zdEFyZ3MsIHNoZWxsUGF0aCwgc2hlbGxBcmdzLCByZXMgPSB7fSwgZXhpdENvZGUsIGV4dE1lc3NhZ2UsXG4gICAgcGF0aFN0ZG91dCA9IGdldFRlbXBmaWxlKCdyZWFkbGluZS1zeW5jLnN0ZG91dCcpLFxuICAgIHBhdGhTdGRlcnIgPSBnZXRUZW1wZmlsZSgncmVhZGxpbmUtc3luYy5zdGRlcnInKSxcbiAgICBwYXRoRXhpdCA9IGdldFRlbXBmaWxlKCdyZWFkbGluZS1zeW5jLmV4aXQnKSxcbiAgICBwYXRoRG9uZSA9IGdldFRlbXBmaWxlKCdyZWFkbGluZS1zeW5jLmRvbmUnKSxcbiAgICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKSwgc2hhc3VtLCBkZWNpcGhlciwgcGFzc3dvcmQ7XG5cbiAgc2hhc3VtID0gY3J5cHRvLmNyZWF0ZUhhc2goQUxHT1JJVEhNX0hBU0gpO1xuICBzaGFzdW0udXBkYXRlKCcnICsgcHJvY2Vzcy5waWQgKyAoc2FsdCsrKSArIE1hdGgucmFuZG9tKCkpO1xuICBwYXNzd29yZCA9IHNoYXN1bS5kaWdlc3QoJ2hleCcpO1xuICBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcihBTEdPUklUSE1fQ0lQSEVSLCBwYXNzd29yZCk7XG5cbiAgaG9zdEFyZ3MgPSBnZXRIb3N0QXJncyhvcHRpb25zKTtcbiAgaWYgKElTX1dJTikge1xuICAgIHNoZWxsUGF0aCA9IHByb2Nlc3MuZW52LkNvbVNwZWMgfHwgJ2NtZC5leGUnO1xuICAgIHByb2Nlc3MuZW52LlEgPSAnXCInOyAvLyBUaGUgcXVvdGUgKFwiKSB0aGF0IGlzbid0IGVzY2FwZWQuXG4gICAgLy8gYCgpYCBmb3IgaWdub3JlIHNwYWNlIGJ5IGVjaG9cbiAgICBzaGVsbEFyZ3MgPSBbJy9WOk9OJywgJy9TJywgJy9DJyxcbiAgICAgICcoJVElJyArIHNoZWxsUGF0aCArICclUSUgL1Y6T04gL1MgL0MgJVElJyArIC8qIEVTTGludCBidWc/ICovIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcbiAgICAgICAgJyVRJScgKyBleHRIb3N0UGF0aCArICclUSUnICtcbiAgICAgICAgICBob3N0QXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7IHJldHVybiAnICVRJScgKyBhcmcgKyAnJVElJzsgfSkuam9pbignJykgK1xuICAgICAgICAnICYgKGVjaG8gIUVSUk9STEVWRUwhKT4lUSUnICsgcGF0aEV4aXQgKyAnJVElJVElKSAyPiVRJScgKyBwYXRoU3RkZXJyICsgJyVRJScgK1xuICAgICAgJyB8JVElJyArIHByb2Nlc3MuZXhlY1BhdGggKyAnJVElICVRJScgKyBfX2Rpcm5hbWUgKyAnXFxcXGVuY3J5cHQuanMlUSUnICtcbiAgICAgICAgJyAlUSUnICsgQUxHT1JJVEhNX0NJUEhFUiArICclUSUgJVElJyArIHBhc3N3b3JkICsgJyVRJScgK1xuICAgICAgICAnID4lUSUnICsgcGF0aFN0ZG91dCArICclUSUnICtcbiAgICAgICcgJiAoZWNobyAxKT4lUSUnICsgcGF0aERvbmUgKyAnJVElJ107XG4gIH0gZWxzZSB7XG4gICAgc2hlbGxQYXRoID0gJy9iaW4vc2gnO1xuICAgIHNoZWxsQXJncyA9IFsnLWMnLFxuICAgICAgLy8gVXNlIGAoKWAsIG5vdCBge31gIGZvciBgLWNgICh0ZXh0IHBhcmFtKVxuICAgICAgJyhcIicgKyBleHRIb3N0UGF0aCArICdcIicgKyAvKiBFU0xpbnQgYnVnPyAqLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XG4gICAgICAgICAgaG9zdEFyZ3MubWFwKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gXCIgJ1wiICsgYXJnLnJlcGxhY2UoLycvZywgXCInXFxcXCcnXCIpICsgXCInXCI7IH0pLmpvaW4oJycpICtcbiAgICAgICAgJzsgZWNobyAkPz5cIicgKyBwYXRoRXhpdCArICdcIikgMj5cIicgKyBwYXRoU3RkZXJyICsgJ1wiJyArXG4gICAgICAnIHxcIicgKyBwcm9jZXNzLmV4ZWNQYXRoICsgJ1wiIFwiJyArIF9fZGlybmFtZSArICcvZW5jcnlwdC5qc1wiJyArXG4gICAgICAgICcgXCInICsgQUxHT1JJVEhNX0NJUEhFUiArICdcIiBcIicgKyBwYXNzd29yZCArICdcIicgK1xuICAgICAgICAnID5cIicgKyBwYXRoU3Rkb3V0ICsgJ1wiJyArXG4gICAgICAnOyBlY2hvIDEgPlwiJyArIHBhdGhEb25lICsgJ1wiJ107XG4gIH1cbiAgaWYgKF9EQkdfY2hlY2tNZXRob2QpIHsgX0RCR19jaGVja01ldGhvZCgnX2V4ZWNGaWxlU3luYycsIGhvc3RBcmdzKTsgfVxuICB0cnkge1xuICAgIGNoaWxkUHJvYy5zcGF3bihzaGVsbFBhdGgsIHNoZWxsQXJncywgZXhlY09wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzLmVycm9yID0gbmV3IEVycm9yKGUubWVzc2FnZSk7XG4gICAgcmVzLmVycm9yLm1ldGhvZCA9ICdfZXhlY0ZpbGVTeW5jIC0gc3Bhd24nO1xuICAgIHJlcy5lcnJvci5wcm9ncmFtID0gc2hlbGxQYXRoO1xuICAgIHJlcy5lcnJvci5hcmdzID0gc2hlbGxBcmdzO1xuICB9XG5cbiAgd2hpbGUgKGZzLnJlYWRGaWxlU3luYyhwYXRoRG9uZSwge2VuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nfSkudHJpbSgpICE9PSAnMScpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgaWYgKChleGl0Q29kZSA9XG4gICAgICBmcy5yZWFkRmlsZVN5bmMocGF0aEV4aXQsIHtlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZ30pLnRyaW0oKSkgPT09ICcwJykge1xuICAgIHJlcy5pbnB1dCA9XG4gICAgICBkZWNpcGhlci51cGRhdGUoZnMucmVhZEZpbGVTeW5jKHBhdGhTdGRvdXQsIHtlbmNvZGluZzogJ2JpbmFyeSd9KSxcbiAgICAgICAgJ2hleCcsIG9wdGlvbnMuZW5jb2RpbmcpICtcbiAgICAgIGRlY2lwaGVyLmZpbmFsKG9wdGlvbnMuZW5jb2RpbmcpO1xuICB9IGVsc2Uge1xuICAgIGV4dE1lc3NhZ2UgPSBmcy5yZWFkRmlsZVN5bmMocGF0aFN0ZGVyciwge2VuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nfSkudHJpbSgpO1xuICAgIHJlcy5lcnJvciA9IG5ldyBFcnJvcihERUZBVUxUX0VSUl9NU0cgKyAoZXh0TWVzc2FnZSA/ICdcXG4nICsgZXh0TWVzc2FnZSA6ICcnKSk7XG4gICAgcmVzLmVycm9yLm1ldGhvZCA9ICdfZXhlY0ZpbGVTeW5jJztcbiAgICByZXMuZXJyb3IucHJvZ3JhbSA9IHNoZWxsUGF0aDtcbiAgICByZXMuZXJyb3IuYXJncyA9IHNoZWxsQXJncztcbiAgICByZXMuZXJyb3IuZXh0TWVzc2FnZSA9IGV4dE1lc3NhZ2U7XG4gICAgcmVzLmVycm9yLmV4aXRDb2RlID0gK2V4aXRDb2RlO1xuICB9XG5cbiAgZnMudW5saW5rU3luYyhwYXRoU3Rkb3V0KTtcbiAgZnMudW5saW5rU3luYyhwYXRoU3RkZXJyKTtcbiAgZnMudW5saW5rU3luYyhwYXRoRXhpdCk7XG4gIGZzLnVubGlua1N5bmMocGF0aERvbmUpO1xuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHJlYWRsaW5lRXh0KG9wdGlvbnMpIHtcbiAgdmFyIGhvc3RBcmdzLCByZXMgPSB7fSwgZXh0TWVzc2FnZSxcbiAgICBleGVjT3B0aW9ucyA9IHtlbnY6IHByb2Nlc3MuZW52LCBlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZ307XG5cbiAgaWYgKCFleHRIb3N0UGF0aCkge1xuICAgIGlmIChJU19XSU4pIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5QU01vZHVsZVBhdGgpIHsgLy8gV2luZG93cyBQb3dlclNoZWxsXG4gICAgICAgIGV4dEhvc3RQYXRoID0gJ3Bvd2Vyc2hlbGwuZXhlJztcbiAgICAgICAgZXh0SG9zdEFyZ3MgPSBbJy1FeGVjdXRpb25Qb2xpY3knLCAnQnlwYXNzJywgJy1GaWxlJywgX19kaXJuYW1lICsgJ1xcXFxyZWFkLnBzMSddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XG4gICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdpbmRvd3MgU2NyaXB0IEhvc3RcbiAgICAgICAgZXh0SG9zdFBhdGggPSAnY3NjcmlwdC5leGUnO1xuICAgICAgICBleHRIb3N0QXJncyA9IFsnLy9ub2xvZ28nLCBfX2Rpcm5hbWUgKyAnXFxcXHJlYWQuY3MuanMnXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHRIb3N0UGF0aCA9ICcvYmluL3NoJztcbiAgICAgIGV4dEhvc3RBcmdzID0gW19fZGlybmFtZSArICcvcmVhZC5zaCddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XG4gICAgfVxuICB9XG4gIGlmIChJU19XSU4gJiYgIXByb2Nlc3MuZW52LlBTTW9kdWxlUGF0aCkgeyAvLyBXaW5kb3dzIFNjcmlwdCBIb3N0XG4gICAgLy8gU2NyaXB0UFcgKFdpbiBYUCBhbmQgU2VydmVyMjAwMykgbmVlZHMgVFRZIHN0cmVhbSBhcyBTVERJTi5cbiAgICAvLyBJbiB0aGlzIGNhc2UsIElmIFNURElOIGlzbid0IFRUWSwgYW4gZXJyb3IgaXMgdGhyb3duLlxuICAgIGV4ZWNPcHRpb25zLnN0ZGlvID0gW3Byb2Nlc3Muc3RkaW5dO1xuICB9XG5cbiAgaWYgKGNoaWxkUHJvYy5leGVjRmlsZVN5bmMpIHtcbiAgICBob3N0QXJncyA9IGdldEhvc3RBcmdzKG9wdGlvbnMpO1xuICAgIGlmIChfREJHX2NoZWNrTWV0aG9kKSB7IF9EQkdfY2hlY2tNZXRob2QoJ2V4ZWNGaWxlU3luYycsIGhvc3RBcmdzKTsgfVxuICAgIHRyeSB7XG4gICAgICByZXMuaW5wdXQgPSBjaGlsZFByb2MuZXhlY0ZpbGVTeW5jKGV4dEhvc3RQYXRoLCBob3N0QXJncywgZXhlY09wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGUpIHsgLy8gbm9uLXplcm8gZXhpdCBjb2RlXG4gICAgICBleHRNZXNzYWdlID0gZS5zdGRlcnIgPyAoZS5zdGRlcnIgKyAnJykudHJpbSgpIDogJyc7XG4gICAgICByZXMuZXJyb3IgPSBuZXcgRXJyb3IoREVGQVVMVF9FUlJfTVNHICsgKGV4dE1lc3NhZ2UgPyAnXFxuJyArIGV4dE1lc3NhZ2UgOiAnJykpO1xuICAgICAgcmVzLmVycm9yLm1ldGhvZCA9ICdleGVjRmlsZVN5bmMnO1xuICAgICAgcmVzLmVycm9yLnByb2dyYW0gPSBleHRIb3N0UGF0aDtcbiAgICAgIHJlcy5lcnJvci5hcmdzID0gaG9zdEFyZ3M7XG4gICAgICByZXMuZXJyb3IuZXh0TWVzc2FnZSA9IGV4dE1lc3NhZ2U7XG4gICAgICByZXMuZXJyb3IuZXhpdENvZGUgPSBlLnN0YXR1cztcbiAgICAgIHJlcy5lcnJvci5jb2RlID0gZS5jb2RlO1xuICAgICAgcmVzLmVycm9yLnNpZ25hbCA9IGUuc2lnbmFsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXMgPSBfZXhlY0ZpbGVTeW5jKG9wdGlvbnMsIGV4ZWNPcHRpb25zKTtcbiAgfVxuICBpZiAoIXJlcy5lcnJvcikge1xuICAgIHJlcy5pbnB1dCA9IHJlcy5pbnB1dC5yZXBsYWNlKC9eXFxzKid8J1xccyokL2csICcnKTtcbiAgICBvcHRpb25zLmRpc3BsYXkgPSAnJztcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbi8qXG4gIGRpc3BsYXk6ICAgICAgICAgICAgc3RyaW5nXG4gIGRpc3BsYXlPbmx5OiAgICAgICAgYm9vbGVhblxuICBrZXlJbjogICAgICAgICAgICAgIGJvb2xlYW5cbiAgaGlkZUVjaG9CYWNrOiAgICAgICBib29sZWFuXG4gIG1hc2s6ICAgICAgICAgICAgICAgc3RyaW5nXG4gIGxpbWl0OiAgICAgICAgICAgICAgc3RyaW5nIChwYXR0ZXJuKVxuICBjYXNlU2Vuc2l0aXZlOiAgICAgIGJvb2xlYW5cbiAga2VlcFdoaXRlc3BhY2U6ICAgICBib29sZWFuXG4gIGVuY29kaW5nLCBidWZmZXJTaXplLCBwcmludFxuKi9cbmZ1bmN0aW9uIF9yZWFkbGluZVN5bmMob3B0aW9ucykge1xuICB2YXIgaW5wdXQgPSAnJywgZGlzcGxheVNhdmUgPSBvcHRpb25zLmRpc3BsYXksXG4gICAgc2lsZW50ID0gIW9wdGlvbnMuZGlzcGxheSAmJlxuICAgICAgb3B0aW9ucy5rZXlJbiAmJiBvcHRpb25zLmhpZGVFY2hvQmFjayAmJiAhb3B0aW9ucy5tYXNrO1xuXG4gIGZ1bmN0aW9uIHRyeUV4dCgpIHtcbiAgICB2YXIgcmVzID0gcmVhZGxpbmVFeHQob3B0aW9ucyk7XG4gICAgaWYgKHJlcy5lcnJvcikgeyB0aHJvdyByZXMuZXJyb3I7IH1cbiAgICByZXR1cm4gcmVzLmlucHV0O1xuICB9XG5cbiAgaWYgKF9EQkdfY2hlY2tPcHRpb25zKSB7IF9EQkdfY2hlY2tPcHRpb25zKG9wdGlvbnMpOyB9XG5cbiAgKGZ1bmN0aW9uKCkgeyAvLyBvcGVuIFRUWVxuICAgIHZhciBmc0IsIGNvbnN0YW50cywgdmVyTnVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0RnNCKCkge1xuICAgICAgaWYgKCFmc0IpIHtcbiAgICAgICAgZnNCID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpOyAvLyBGb3IgcmF3IGRldmljZSBwYXRoXG4gICAgICAgIGNvbnN0YW50cyA9IHByb2Nlc3MuYmluZGluZygnY29uc3RhbnRzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnNCO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmRSICE9PSAnc3RyaW5nJykgeyByZXR1cm47IH1cbiAgICBmZFIgPSBudWxsO1xuXG4gICAgaWYgKElTX1dJTikge1xuICAgICAgLy8gaW9qcy12Mi4zLjIrIGlucHV0IHN0cmVhbSBjYW4ndCByZWFkIGZpcnN0IGxpbmUuICgjMTgpXG4gICAgICAvLyAqKiBEb24ndCBnZXQgcHJvY2Vzcy5zdGRpbiBiZWZvcmUgY2hlY2shICoqXG4gICAgICAvLyBGaXhlZCB2NS4xLjBcbiAgICAgIC8vIEZpeGVkIHY0LjIuNFxuICAgICAgLy8gSXQgcmVncmVzc2VkIGFnYWluIGluIHY1LjYuMCwgaXQgaXMgZml4ZWQgaW4gdjYuMi4wLlxuICAgICAgdmVyTnVtID0gKGZ1bmN0aW9uKHZlcikgeyAvLyBnZXRWZXJOdW1cbiAgICAgICAgdmFyIG51bXMgPSB2ZXIucmVwbGFjZSgvXlxcRCsvLCAnJykuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHZlck51bSA9IDA7XG4gICAgICAgIGlmICgobnVtc1swXSA9ICtudW1zWzBdKSkgeyB2ZXJOdW0gKz0gbnVtc1swXSAqIDEwMDAwOyB9XG4gICAgICAgIGlmICgobnVtc1sxXSA9ICtudW1zWzFdKSkgeyB2ZXJOdW0gKz0gbnVtc1sxXSAqIDEwMDsgfVxuICAgICAgICBpZiAoKG51bXNbMl0gPSArbnVtc1syXSkpIHsgdmVyTnVtICs9IG51bXNbMl07IH1cbiAgICAgICAgcmV0dXJuIHZlck51bTtcbiAgICAgIH0pKHByb2Nlc3MudmVyc2lvbik7XG4gICAgICBpZiAoISh2ZXJOdW0gPj0gMjAzMDIgJiYgdmVyTnVtIDwgNDAyMDQgfHwgdmVyTnVtID49IDUwMDAwICYmIHZlck51bSA8IDUwMTAwIHx8IHZlck51bSA+PSA1MDYwMCAmJiB2ZXJOdW0gPCA2MDIwMCkgJiZcbiAgICAgICAgICBwcm9jZXNzLnN0ZGluLmlzVFRZKSB7XG4gICAgICAgIHByb2Nlc3Muc3RkaW4ucGF1c2UoKTtcbiAgICAgICAgZmRSID0gcHJvY2Vzcy5zdGRpbi5mZDtcbiAgICAgICAgdHR5UiA9IHByb2Nlc3Muc3RkaW4uX2hhbmRsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhlIHN0cmVhbSBieSBmcy5vcGVuU3luYygnXFxcXFxcXFwuXFxcXENPTicsICdyJykgY2FuJ3Qgc3dpdGNoIHRvIHJhdyBtb2RlLlxuICAgICAgICAgIC8vICdDT05JTiQnIG1pZ2h0IGZhaWwgb24gWFAsIDIwMDAsIDcgKHg4NikuXG4gICAgICAgICAgZmRSID0gZ2V0RnNCKCkub3BlbignQ09OSU4kJywgY29uc3RhbnRzLk9fUkRXUiwgcGFyc2VJbnQoJzA2NjYnLCA4KSk7XG4gICAgICAgICAgdHR5UiA9IG5ldyBUVFkoZmRSLCB0cnVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICAgICAgZmRXID0gcHJvY2Vzcy5zdGRvdXQuZmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZkVyA9IGZzLm9wZW5TeW5jKCdcXFxcXFxcXC5cXFxcQ09OJywgJ3cnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgICBpZiAodHlwZW9mIGZkVyAhPT0gJ251bWJlcicpIHsgLy8gUmV0cnlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmRXID0gZ2V0RnNCKCkub3BlbignQ09OT1VUJCcsIGNvbnN0YW50cy5PX1JEV1IsIHBhcnNlSW50KCcwNjY2JywgOCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLnN0ZGluLmlzVFRZKSB7XG4gICAgICAgIHByb2Nlc3Muc3RkaW4ucGF1c2UoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZFIgPSBmcy5vcGVuU3luYygnL2Rldi90dHknLCAncicpOyAvLyBkZXZpY2UgZmlsZSwgbm90IHByb2Nlc3Muc3RkaW5cbiAgICAgICAgICB0dHlSID0gcHJvY2Vzcy5zdGRpbi5faGFuZGxlO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb2RlLmpzIHYwLjEyIHJlYWQoKSBmYWlscy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZFIgPSBmcy5vcGVuU3luYygnL2Rldi90dHknLCAncicpO1xuICAgICAgICAgIHR0eVIgPSBuZXcgVFRZKGZkUiwgZmFsc2UpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgICAgICBmZFcgPSBwcm9jZXNzLnN0ZG91dC5mZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmRXID0gZnMub3BlblN5bmMoJy9kZXYvdHR5JywgJ3cnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgfVxuICAgIH1cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24oKSB7IC8vIHRyeSByZWFkXG4gICAgdmFyIGF0RW9sLCBsaW1pdCxcbiAgICAgIGlzQ29va2VkID0gIW9wdGlvbnMuaGlkZUVjaG9CYWNrICYmICFvcHRpb25zLmtleUluLFxuICAgICAgYnVmZmVyLCByZXFTaXplLCByZWFkU2l6ZSwgY2h1bmssIGxpbmU7XG4gICAgcmF3SW5wdXQgPSAnJztcblxuICAgIC8vIE5vZGUuanMgdjAuMTAtIHJldHVybnMgYW4gZXJyb3IgaWYgc2FtZSBtb2RlIGlzIHNldC5cbiAgICBmdW5jdGlvbiBzZXRSYXdNb2RlKG1vZGUpIHtcbiAgICAgIGlmIChtb2RlID09PSBpc1Jhd01vZGUpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGlmICh0dHlSLnNldFJhd01vZGUobW9kZSkgIT09IDApIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBpc1Jhd01vZGUgPSBtb2RlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKF9EQkdfdXNlRXh0IHx8ICF0dHlSIHx8XG4gICAgICAgIHR5cGVvZiBmZFcgIT09ICdudW1iZXInICYmIChvcHRpb25zLmRpc3BsYXkgfHwgIWlzQ29va2VkKSkge1xuICAgICAgaW5wdXQgPSB0cnlFeHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBmcy53cml0ZVN5bmMoZmRXLCBvcHRpb25zLmRpc3BsYXkpO1xuICAgICAgb3B0aW9ucy5kaXNwbGF5ID0gJyc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRpc3BsYXlPbmx5KSB7IHJldHVybjsgfVxuXG4gICAgaWYgKCFzZXRSYXdNb2RlKCFpc0Nvb2tlZCkpIHtcbiAgICAgIGlucHV0ID0gdHJ5RXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVxU2l6ZSA9IG9wdGlvbnMua2V5SW4gPyAxIDogb3B0aW9ucy5idWZmZXJTaXplO1xuICAgIC8vIENoZWNrIGBhbGxvY1Vuc2FmZWAgdG8gbWFrZSBzdXJlIG9mIHRoZSBuZXcgQVBJLlxuICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2MgPyBCdWZmZXIuYWxsb2MocmVxU2l6ZSkgOiBuZXcgQnVmZmVyKHJlcVNpemUpO1xuXG4gICAgaWYgKG9wdGlvbnMua2V5SW4gJiYgb3B0aW9ucy5saW1pdCkge1xuICAgICAgbGltaXQgPSBuZXcgUmVnRXhwKCdbXicgKyBvcHRpb25zLmxpbWl0ICsgJ10nLFxuICAgICAgICAnZycgKyAob3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gJycgOiAnaScpKTtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgcmVhZFNpemUgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVhZFNpemUgPSBmcy5yZWFkU3luYyhmZFIsIGJ1ZmZlciwgMCwgcmVxU2l6ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLmNvZGUgIT09ICdFT0YnKSB7XG4gICAgICAgICAgc2V0UmF3TW9kZShmYWxzZSk7XG4gICAgICAgICAgaW5wdXQgKz0gdHJ5RXh0KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVhZFNpemUgPiAwKSB7XG4gICAgICAgIGNodW5rID0gYnVmZmVyLnRvU3RyaW5nKG9wdGlvbnMuZW5jb2RpbmcsIDAsIHJlYWRTaXplKTtcbiAgICAgICAgcmF3SW5wdXQgKz0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaHVuayA9ICdcXG4nO1xuICAgICAgICByYXdJbnB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2h1bmsgJiYgdHlwZW9mIChsaW5lID0gKGNodW5rLm1hdGNoKC9eKC4qPylbXFxyXFxuXS8pIHx8IFtdKVsxXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNodW5rID0gbGluZTtcbiAgICAgICAgYXRFb2wgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlciBjdHJsLWNoYXJzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgaWYgKGNodW5rKSB7IGNodW5rID0gY2h1bmsucmVwbGFjZSgvW1xceDAwLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdL2csICcnKTsgfVxuICAgICAgaWYgKGNodW5rICYmIGxpbWl0KSB7IGNodW5rID0gY2h1bmsucmVwbGFjZShsaW1pdCwgJycpOyB9XG5cbiAgICAgIGlmIChjaHVuaykge1xuICAgICAgICBpZiAoIWlzQ29va2VkKSB7XG4gICAgICAgICAgaWYgKCFvcHRpb25zLmhpZGVFY2hvQmFjaykge1xuICAgICAgICAgICAgZnMud3JpdGVTeW5jKGZkVywgY2h1bmspO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICAgICAgICBmcy53cml0ZVN5bmMoZmRXLCAobmV3IEFycmF5KGNodW5rLmxlbmd0aCArIDEpKS5qb2luKG9wdGlvbnMubWFzaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbnB1dCArPSBjaHVuaztcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLmtleUluICYmIGF0RW9sIHx8XG4gICAgICAgIG9wdGlvbnMua2V5SW4gJiYgaW5wdXQubGVuZ3RoID49IHJlcVNpemUpIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAoIWlzQ29va2VkICYmICFzaWxlbnQpIHsgZnMud3JpdGVTeW5jKGZkVywgJ1xcbicpOyB9XG4gICAgc2V0UmF3TW9kZShmYWxzZSk7XG4gIH0pKCk7XG5cbiAgaWYgKG9wdGlvbnMucHJpbnQgJiYgIXNpbGVudCkge1xuICAgIG9wdGlvbnMucHJpbnQoZGlzcGxheVNhdmUgKyAob3B0aW9ucy5kaXNwbGF5T25seSA/ICcnIDpcbiAgICAgICAgKG9wdGlvbnMuaGlkZUVjaG9CYWNrID8gKG5ldyBBcnJheShpbnB1dC5sZW5ndGggKyAxKSkuam9pbihvcHRpb25zLm1hc2spXG4gICAgICAgICAgOiBpbnB1dCkgKyAnXFxuJyksIC8vIG11c3QgYXQgbGVhc3Qgd3JpdGUgJ1xcbidcbiAgICAgIG9wdGlvbnMuZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnMuZGlzcGxheU9ubHkgPyAnJyA6XG4gICAgKGxhc3RJbnB1dCA9IG9wdGlvbnMua2VlcFdoaXRlc3BhY2UgfHwgb3B0aW9ucy5rZXlJbiA/IGlucHV0IDogaW5wdXQudHJpbSgpKTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbkFycmF5KGFycmF5LCB2YWxpZGF0b3IpIHtcbiAgdmFyIGZsYXRBcnJheSA9IFtdO1xuICBmdW5jdGlvbiBfZmxhdHRlbkFycmF5KGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXkpKSB7XG4gICAgICBhcnJheS5mb3JFYWNoKF9mbGF0dGVuQXJyYXkpO1xuICAgIH0gZWxzZSBpZiAoIXZhbGlkYXRvciB8fCB2YWxpZGF0b3IoYXJyYXkpKSB7XG4gICAgICBmbGF0QXJyYXkucHVzaChhcnJheSk7XG4gICAgfVxuICB9XG4gIF9mbGF0dGVuQXJyYXkoYXJyYXkpO1xuICByZXR1cm4gZmxhdEFycmF5O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgcmV0dXJuIHBhdHRlcm4ucmVwbGFjZSgvW1xceDAwLVxceDdmXS9nLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICBmdW5jdGlvbihzKSB7IHJldHVybiAnXFxcXHgnICsgKCcwMCcgKyBzLmNoYXJDb2RlQXQoKS50b1N0cmluZygxNikpLnN1YnN0cigtMik7IH0pO1xufVxuXG4vLyBtYXJnZU9wdGlvbnMob3B0aW9uczEsIG9wdGlvbnMyIC4uLiApXG4vLyBtYXJnZU9wdGlvbnModHJ1ZSwgb3B0aW9uczEsIG9wdGlvbnMyIC4uLiApXG4vLyAgICBhcmcxPXRydWUgOiBTdGFydCBmcm9tIGRlZmF1bHRPcHRpb25zIGFuZCBwaWNrIGVsZW1lbnRzIG9mIHRoYXQuXG5mdW5jdGlvbiBtYXJnZU9wdGlvbnMoKSB7XG4gIHZhciBvcHRpb25zTGlzdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgb3B0aW9uTmFtZXMsIGZyb21EZWZhdWx0O1xuXG4gIGlmIChvcHRpb25zTGlzdC5sZW5ndGggJiYgdHlwZW9mIG9wdGlvbnNMaXN0WzBdID09PSAnYm9vbGVhbicpIHtcbiAgICBmcm9tRGVmYXVsdCA9IG9wdGlvbnNMaXN0LnNoaWZ0KCk7XG4gICAgaWYgKGZyb21EZWZhdWx0KSB7XG4gICAgICBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRPcHRpb25zKTtcbiAgICAgIG9wdGlvbnNMaXN0LnVuc2hpZnQoZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zTGlzdC5yZWR1Y2UoZnVuY3Rpb24ob3B0aW9ucywgb3B0aW9uc1BhcnQpIHtcbiAgICBpZiAob3B0aW9uc1BhcnQgPT0gbnVsbCkgeyByZXR1cm4gb3B0aW9uczsgfVxuXG4gICAgLy8gPT09PT09PT0gREVQUkVDQVRFRCA9PT09PT09PVxuICAgIGlmIChvcHRpb25zUGFydC5oYXNPd25Qcm9wZXJ0eSgnbm9FY2hvQmFjaycpICYmXG4gICAgICAgICFvcHRpb25zUGFydC5oYXNPd25Qcm9wZXJ0eSgnaGlkZUVjaG9CYWNrJykpIHtcbiAgICAgIG9wdGlvbnNQYXJ0LmhpZGVFY2hvQmFjayA9IG9wdGlvbnNQYXJ0Lm5vRWNob0JhY2s7XG4gICAgICBkZWxldGUgb3B0aW9uc1BhcnQubm9FY2hvQmFjaztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnNQYXJ0Lmhhc093blByb3BlcnR5KCdub1RyaW0nKSAmJlxuICAgICAgICAhb3B0aW9uc1BhcnQuaGFzT3duUHJvcGVydHkoJ2tlZXBXaGl0ZXNwYWNlJykpIHtcbiAgICAgIG9wdGlvbnNQYXJ0LmtlZXBXaGl0ZXNwYWNlID0gb3B0aW9uc1BhcnQubm9UcmltO1xuICAgICAgZGVsZXRlIG9wdGlvbnNQYXJ0Lm5vVHJpbTtcbiAgICB9XG4gICAgLy8gPT09PT09PT0gL0RFUFJFQ0FURUQgPT09PT09PT1cblxuICAgIGlmICghZnJvbURlZmF1bHQpIHsgb3B0aW9uTmFtZXMgPSBPYmplY3Qua2V5cyhvcHRpb25zUGFydCk7IH1cbiAgICBvcHRpb25OYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZTtcbiAgICAgIGlmICghb3B0aW9uc1BhcnQuaGFzT3duUHJvcGVydHkob3B0aW9uTmFtZSkpIHsgcmV0dXJuOyB9XG4gICAgICB2YWx1ZSA9IG9wdGlvbnNQYXJ0W29wdGlvbk5hbWVdO1xuICAgICAgc3dpdGNoIChvcHRpb25OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBfcmVhZGxpbmVTeW5jIDwtICogICAgKiAtPiBkZWZhdWx0T3B0aW9uc1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IHN0cmluZ1xuICAgICAgICBjYXNlICdtYXNrJzogICAgICAgICAgICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgY2FzZSAnbGltaXRNZXNzYWdlJzogICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ2RlZmF1bHRJbnB1dCc6ICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdlbmNvZGluZyc6ICAgICAgICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSArICcnIDogJyc7XG4gICAgICAgICAgaWYgKHZhbHVlICYmIG9wdGlvbk5hbWUgIT09ICdsaW1pdE1lc3NhZ2UnKSB7IHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW1xcclxcbl0vZywgJycpOyB9XG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IG51bWJlcihpbnQpXG4gICAgICAgIGNhc2UgJ2J1ZmZlclNpemUnOiAgICAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICAgIGlmICghaXNOYU4odmFsdWUgPSBwYXJzZUludCh2YWx1ZSwgMTApKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7IC8vIGxpbWl0ZWQgdXBkYXRpbmcgKG51bWJlciBpcyBuZWVkZWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IGJvb2xlYW5cbiAgICAgICAgY2FzZSAnZGlzcGxheU9ubHknOiAgICAgICAgICAgICAgICAgLy8gKlxuICAgICAgICBjYXNlICdrZXlJbic6ICAgICAgICAgICAgICAgICAgICAgICAvLyAqXG4gICAgICAgIGNhc2UgJ2hpZGVFY2hvQmFjayc6ICAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICBjYXNlICdjYXNlU2Vuc2l0aXZlJzogICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgY2FzZSAna2VlcFdoaXRlc3BhY2UnOiAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgIGNhc2UgJ2hpc3RvcnknOiAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdjZCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gISF2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBhcnJheVxuICAgICAgICBjYXNlICdsaW1pdCc6ICAgICAgICAgICAgICAgICAgICAgICAvLyAqICAgICogICAgIHRvIHN0cmluZyBmb3IgcmVhZGxpbmVFeHRcbiAgICAgICAgY2FzZSAndHJ1ZVZhbHVlJzogICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ2ZhbHNlVmFsdWUnOiAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBmbGF0dGVuQXJyYXkodmFsdWUsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgICAgICB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICAgICAgICAgIH0pLm1hcChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJykgOiB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBmdW5jdGlvblxuICAgICAgICBjYXNlICdwcmludCc6ICAgICAgICAgICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgY2FzZSAncGhDb250ZW50JzogICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ3ByZUNoZWNrJzogICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB2YWx1ZSA6IHZvaWQgMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBvdGhlclxuICAgICAgICBjYXNlICdwcm9tcHQnOiAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAnZGlzcGxheSc6ICAgICAgICAgICAgICAgICAgICAgLy8gKlxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiAnJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGlzTWF0Y2hlZChyZXMsIGNvbXBzLCBjYXNlU2Vuc2l0aXZlKSB7XG4gIHJldHVybiBjb21wcy5zb21lKGZ1bmN0aW9uKGNvbXApIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBjb21wO1xuICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyA/XG4gICAgICAgIChjYXNlU2Vuc2l0aXZlID8gcmVzID09PSBjb21wIDogcmVzLnRvTG93ZXJDYXNlKCkgPT09IGNvbXAudG9Mb3dlckNhc2UoKSkgOlxuICAgICAgdHlwZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KHJlcykgPT09IGNvbXAgOlxuICAgICAgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IGNvbXAocmVzKSA6XG4gICAgICBjb21wIGluc3RhbmNlb2YgUmVnRXhwID8gY29tcC50ZXN0KHJlcykgOiBmYWxzZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VIb21lUGF0aChwYXRoLCBleHBhbmQpIHtcbiAgdmFyIGhvbWVQYXRoID0gcGF0aFV0aWwubm9ybWFsaXplKFxuICAgIElTX1dJTiA/IChwcm9jZXNzLmVudi5IT01FRFJJVkUgfHwgJycpICsgKHByb2Nlc3MuZW52LkhPTUVQQVRIIHx8ICcnKSA6XG4gICAgcHJvY2Vzcy5lbnYuSE9NRSB8fCAnJykucmVwbGFjZSgvW1xcL1xcXFxdKyQvLCAnJyk7XG4gIHBhdGggPSBwYXRoVXRpbC5ub3JtYWxpemUocGF0aCk7XG4gIHJldHVybiBleHBhbmQgPyBwYXRoLnJlcGxhY2UoL15+KD89XFwvfFxcXFx8JCkvLCBob21lUGF0aCkgOlxuICAgIHBhdGgucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGVzY2FwZVBhdHRlcm4oaG9tZVBhdGgpICtcbiAgICAgICcoPz1cXFxcL3xcXFxcXFxcXHwkKScsIElTX1dJTiA/ICdpJyA6ICcnKSwgJ34nKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVBsYWNlaG9sZGVyKHRleHQsIGdlbmVyYXRvcikge1xuICB2YXIgUFROX0lOTkVSID0gJyg/OlxcXFwoKFtcXFxcc1xcXFxTXSo/KVxcXFwpKT8oXFxcXHcrfC4tLikoPzpcXFxcKChbXFxcXHNcXFxcU10qPylcXFxcKSk/JyxcbiAgICByZVBsYWNlaG9sZGVyID0gbmV3IFJlZ0V4cCgnKFxcXFwkKT8oXFxcXCQ8JyArIFBUTl9JTk5FUiArICc+KScsICdnJyksXG4gICAgcmVQbGFjZWhvbGRlckNvbXBhdCA9IG5ldyBSZWdFeHAoJyhcXFxcJCk/KFxcXFwkXFxcXHsnICsgUFROX0lOTkVSICsgJ1xcXFx9KScsICdnJyk7XG5cbiAgZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXJUZXh0KHMsIGVzY2FwZSwgcGxhY2Vob2xkZXIsIHByZSwgcGFyYW0sIHBvc3QpIHtcbiAgICB2YXIgdGV4dDtcbiAgICByZXR1cm4gZXNjYXBlIHx8IHR5cGVvZiAodGV4dCA9IGdlbmVyYXRvcihwYXJhbSkpICE9PSAnc3RyaW5nJyA/IHBsYWNlaG9sZGVyIDpcbiAgICAgIHRleHQgPyAocHJlIHx8ICcnKSArIHRleHQgKyAocG9zdCB8fCAnJykgOiAnJztcbiAgfVxuXG4gIHJldHVybiB0ZXh0LnJlcGxhY2UocmVQbGFjZWhvbGRlciwgZ2V0UGxhY2Vob2xkZXJUZXh0KVxuICAgIC5yZXBsYWNlKHJlUGxhY2Vob2xkZXJDb21wYXQsIGdldFBsYWNlaG9sZGVyVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5MmNoYXJsaXN0KGFycmF5LCBjYXNlU2Vuc2l0aXZlLCBjb2xsZWN0U3ltYm9scykge1xuICB2YXIgdmFsdWVzLCBncm91cCA9IFtdLCBncm91cENsYXNzID0gLTEsIGNoYXJDb2RlID0gMCwgc3ltYm9scyA9ICcnLCBzdXBwcmVzc2VkO1xuICBmdW5jdGlvbiBhZGRHcm91cChncm91cHMsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLmxlbmd0aCA+IDMpIHsgLy8gZWxsaXBzaXNcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwWzBdICsgJy4uLicgKyBncm91cFtncm91cC5sZW5ndGggLSAxXSk7XG4gICAgICBzdXBwcmVzc2VkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmxlbmd0aCkge1xuICAgICAgZ3JvdXBzID0gZ3JvdXBzLmNvbmNhdChncm91cCk7XG4gICAgfVxuICAgIHJldHVybiBncm91cHM7XG4gIH1cblxuICB2YWx1ZXMgPSBhcnJheS5yZWR1Y2UoXG4gICAgICBmdW5jdGlvbihjaGFycywgdmFsdWUpIHsgcmV0dXJuIGNoYXJzLmNvbmNhdCgodmFsdWUgKyAnJykuc3BsaXQoJycpKTsgfSwgW10pXG4gICAgLnJlZHVjZShmdW5jdGlvbihncm91cHMsIGN1ckNoYXIpIHtcbiAgICAgIHZhciBjdXJHcm91cENsYXNzLCBjdXJDaGFyQ29kZTtcbiAgICAgIGlmICghY2FzZVNlbnNpdGl2ZSkgeyBjdXJDaGFyID0gY3VyQ2hhci50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICBjdXJHcm91cENsYXNzID0gL15cXGQkLy50ZXN0KGN1ckNoYXIpID8gMSA6XG4gICAgICAgIC9eW0EtWl0kLy50ZXN0KGN1ckNoYXIpID8gMiA6IC9eW2Etel0kLy50ZXN0KGN1ckNoYXIpID8gMyA6IDA7XG4gICAgICBpZiAoY29sbGVjdFN5bWJvbHMgJiYgY3VyR3JvdXBDbGFzcyA9PT0gMCkge1xuICAgICAgICBzeW1ib2xzICs9IGN1ckNoYXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJDaGFyQ29kZSA9IGN1ckNoYXIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGN1ckdyb3VwQ2xhc3MgJiYgY3VyR3JvdXBDbGFzcyA9PT0gZ3JvdXBDbGFzcyAmJlxuICAgICAgICAgICAgY3VyQ2hhckNvZGUgPT09IGNoYXJDb2RlICsgMSkge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VyQ2hhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JvdXBzID0gYWRkR3JvdXAoZ3JvdXBzLCBncm91cCk7XG4gICAgICAgICAgZ3JvdXAgPSBbY3VyQ2hhcl07XG4gICAgICAgICAgZ3JvdXBDbGFzcyA9IGN1ckdyb3VwQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgY2hhckNvZGUgPSBjdXJDaGFyQ29kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSwgW10pO1xuICB2YWx1ZXMgPSBhZGRHcm91cCh2YWx1ZXMsIGdyb3VwKTsgLy8gbGFzdCBncm91cFxuICBpZiAoc3ltYm9scykgeyB2YWx1ZXMucHVzaChzeW1ib2xzKTsgc3VwcHJlc3NlZCA9IHRydWU7IH1cbiAgcmV0dXJuIHt2YWx1ZXM6IHZhbHVlcywgc3VwcHJlc3NlZDogc3VwcHJlc3NlZH07XG59XG5cbmZ1bmN0aW9uIGpvaW5DaHVua3MoY2h1bmtzLCBzdXBwcmVzc2VkKSB7XG4gIHJldHVybiBjaHVua3Muam9pbihjaHVua3MubGVuZ3RoID4gMiA/ICcsICcgOiBzdXBwcmVzc2VkID8gJyAvICcgOiAnLycpO1xufVxuXG5mdW5jdGlvbiBnZXRQaENvbnRlbnQocGFyYW0sIG9wdGlvbnMpIHtcbiAgdmFyIHRleHQsIHZhbHVlcywgcmVzQ2hhcmxpc3QgPSB7fSwgYXJnO1xuICBpZiAob3B0aW9ucy5waENvbnRlbnQpIHtcbiAgICB0ZXh0ID0gb3B0aW9ucy5waENvbnRlbnQocGFyYW0sIG9wdGlvbnMpO1xuICB9XG4gIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICBzd2l0Y2ggKHBhcmFtKSB7XG4gICAgICBjYXNlICdoaWRlRWNob0JhY2snOlxuICAgICAgY2FzZSAnbWFzayc6XG4gICAgICBjYXNlICdkZWZhdWx0SW5wdXQnOlxuICAgICAgY2FzZSAnY2FzZVNlbnNpdGl2ZSc6XG4gICAgICBjYXNlICdrZWVwV2hpdGVzcGFjZSc6XG4gICAgICBjYXNlICdlbmNvZGluZyc6XG4gICAgICBjYXNlICdidWZmZXJTaXplJzpcbiAgICAgIGNhc2UgJ2hpc3RvcnknOlxuICAgICAgY2FzZSAnY2QnOlxuICAgICAgICB0ZXh0ID0gIW9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0pID8gJycgOlxuICAgICAgICAgIHR5cGVvZiBvcHRpb25zW3BhcmFtXSA9PT0gJ2Jvb2xlYW4nID8gKG9wdGlvbnNbcGFyYW1dID8gJ29uJyA6ICdvZmYnKSA6XG4gICAgICAgICAgb3B0aW9uc1twYXJhbV0gKyAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBjYXNlICdwcm9tcHQnOlxuICAgICAgLy8gY2FzZSAncXVlcnknOlxuICAgICAgLy8gY2FzZSAnZGlzcGxheSc6XG4gICAgICAvLyAgIHRleHQgPSBvcHRpb25zLmhhc093blByb3BlcnR5KCdkaXNwbGF5U3JjJykgPyBvcHRpb25zLmRpc3BsYXlTcmMgKyAnJyA6ICcnO1xuICAgICAgLy8gICBicmVhaztcbiAgICAgIGNhc2UgJ2xpbWl0JzpcbiAgICAgIGNhc2UgJ3RydWVWYWx1ZSc6XG4gICAgICBjYXNlICdmYWxzZVZhbHVlJzpcbiAgICAgICAgdmFsdWVzID0gb3B0aW9uc1tvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtICsgJ1NyYycpID8gcGFyYW0gKyAnU3JjJyA6IHBhcmFtXTtcbiAgICAgICAgaWYgKG9wdGlvbnMua2V5SW4pIHsgLy8gc3VwcHJlc3NcbiAgICAgICAgICByZXNDaGFybGlzdCA9IGFycmF5MmNoYXJsaXN0KHZhbHVlcywgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKTtcbiAgICAgICAgICB2YWx1ZXMgPSByZXNDaGFybGlzdC52YWx1ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcic7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IGpvaW5DaHVua3ModmFsdWVzLCByZXNDaGFybGlzdC5zdXBwcmVzc2VkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsaW1pdENvdW50JzpcbiAgICAgIGNhc2UgJ2xpbWl0Q291bnROb3RaZXJvJzpcbiAgICAgICAgdGV4dCA9IG9wdGlvbnNbb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnbGltaXRTcmMnKSA/XG4gICAgICAgICAgJ2xpbWl0U3JjJyA6ICdsaW1pdCddLmxlbmd0aDtcbiAgICAgICAgdGV4dCA9IHRleHQgfHwgcGFyYW0gIT09ICdsaW1pdENvdW50Tm90WmVybycgPyB0ZXh0ICsgJycgOiAnJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsYXN0SW5wdXQnOlxuICAgICAgICB0ZXh0ID0gbGFzdElucHV0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2N3ZCc6XG4gICAgICBjYXNlICdDV0QnOlxuICAgICAgY2FzZSAnY3dkSG9tZSc6XG4gICAgICAgIHRleHQgPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgICBpZiAocGFyYW0gPT09ICdDV0QnKSB7XG4gICAgICAgICAgdGV4dCA9IHBhdGhVdGlsLmJhc2VuYW1lKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtID09PSAnY3dkSG9tZScpIHtcbiAgICAgICAgICB0ZXh0ID0gcmVwbGFjZUhvbWVQYXRoKHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICd0aW1lJzpcbiAgICAgIGNhc2UgJ2xvY2FsZURhdGUnOlxuICAgICAgY2FzZSAnbG9jYWxlVGltZSc6XG4gICAgICAgIHRleHQgPSAobmV3IERhdGUoKSlbJ3RvJyArXG4gICAgICAgICAgcGFyYW0ucmVwbGFjZSgvXi4vLCBmdW5jdGlvbihzdHIpIHsgcmV0dXJuIHN0ci50b1VwcGVyQ2FzZSgpOyB9KSArXG4gICAgICAgICAgJ1N0cmluZyddKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDogLy8gd2l0aCBhcmdcbiAgICAgICAgaWYgKHR5cGVvZiAoYXJnID0gKHBhcmFtLm1hdGNoKC9eaGlzdG9yeV9tKFxcZCspJC8pIHx8IFtdKVsxXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGV4dCA9IGlucHV0SGlzdG9yeVtpbnB1dEhpc3RvcnkubGVuZ3RoIC0gYXJnXSB8fCAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0UGhDaGFybGlzdChwYXJhbSkge1xuICB2YXIgbWF0Y2hlcyA9IC9eKC4pLSguKSQvLmV4ZWMocGFyYW0pLCB0ZXh0ID0gJycsIGZyb20sIHRvLCBjb2RlLCBzdGVwO1xuICBpZiAoIW1hdGNoZXMpIHsgcmV0dXJuIG51bGw7IH1cbiAgZnJvbSA9IG1hdGNoZXNbMV0uY2hhckNvZGVBdCgwKTtcbiAgdG8gPSBtYXRjaGVzWzJdLmNoYXJDb2RlQXQoMCk7XG4gIHN0ZXAgPSBmcm9tIDwgdG8gPyAxIDogLTE7XG4gIGZvciAoY29kZSA9IGZyb207IGNvZGUgIT09IHRvICsgc3RlcDsgY29kZSArPSBzdGVwKSB7IHRleHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTsgfVxuICByZXR1cm4gdGV4dDtcbn1cblxuLy8gY21kIFwiYXJnXCIgXCIgYSByIGcgXCIgXCJcIiAnYVwiclwiZycgXCJhXCJcInJnXCIgXCJhcmdcbmZ1bmN0aW9uIHBhcnNlQ2woY2wpIHtcbiAgdmFyIHJlVG9rZW4gPSBuZXcgUmVnRXhwKC8oXFxzKikoPzooXCJ8JykoLio/KSg/OlxcMnwkKXwoXFxTKykpL2cpLCBtYXRjaGVzLFxuICAgIHRha2VuID0gJycsIGFyZ3MgPSBbXSwgcGFydDtcbiAgY2wgPSBjbC50cmltKCk7XG4gIHdoaWxlICgobWF0Y2hlcyA9IHJlVG9rZW4uZXhlYyhjbCkpKSB7XG4gICAgcGFydCA9IG1hdGNoZXNbM10gfHwgbWF0Y2hlc1s0XSB8fCAnJztcbiAgICBpZiAobWF0Y2hlc1sxXSkge1xuICAgICAgYXJncy5wdXNoKHRha2VuKTtcbiAgICAgIHRha2VuID0gJyc7XG4gICAgfVxuICAgIHRha2VuICs9IHBhcnQ7XG4gIH1cbiAgaWYgKHRha2VuKSB7IGFyZ3MucHVzaCh0YWtlbik7IH1cbiAgcmV0dXJuIGFyZ3M7XG59XG5cbmZ1bmN0aW9uIHRvQm9vbChyZXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIChcbiAgICAob3B0aW9ucy50cnVlVmFsdWUubGVuZ3RoICYmXG4gICAgICBpc01hdGNoZWQocmVzLCBvcHRpb25zLnRydWVWYWx1ZSwgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSkgPyB0cnVlIDpcbiAgICAob3B0aW9ucy5mYWxzZVZhbHVlLmxlbmd0aCAmJlxuICAgICAgaXNNYXRjaGVkKHJlcywgb3B0aW9ucy5mYWxzZVZhbHVlLCBvcHRpb25zLmNhc2VTZW5zaXRpdmUpKSA/IGZhbHNlIDogcmVzKTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsaWRMaW5lKG9wdGlvbnMpIHtcbiAgdmFyIHJlcywgZm9yY2VOZXh0LCBsaW1pdE1lc3NhZ2UsXG4gICAgbWF0Y2hlcywgaGlzdElucHV0LCBhcmdzLCByZXNDaGVjaztcblxuICBmdW5jdGlvbiBfZ2V0UGhDb250ZW50KHBhcmFtKSB7IHJldHVybiBnZXRQaENvbnRlbnQocGFyYW0sIG9wdGlvbnMpOyB9XG4gIGZ1bmN0aW9uIGFkZERpc3BsYXkodGV4dCkgeyBvcHRpb25zLmRpc3BsYXkgKz0gKC9bXlxcclxcbl0kLy50ZXN0KG9wdGlvbnMuZGlzcGxheSkgPyAnXFxuJyA6ICcnKSArIHRleHQ7IH1cblxuICBvcHRpb25zLmxpbWl0U3JjID0gb3B0aW9ucy5saW1pdDtcbiAgb3B0aW9ucy5kaXNwbGF5U3JjID0gb3B0aW9ucy5kaXNwbGF5O1xuICBvcHRpb25zLmxpbWl0ID0gJyc7IC8vIGZvciByZWFkbGluZUV4dFxuICBvcHRpb25zLmRpc3BsYXkgPSByZXBsYWNlUGxhY2Vob2xkZXIob3B0aW9ucy5kaXNwbGF5ICsgJycsIF9nZXRQaENvbnRlbnQpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgcmVzID0gX3JlYWRsaW5lU3luYyhvcHRpb25zKTtcbiAgICBmb3JjZU5leHQgPSBmYWxzZTtcbiAgICBsaW1pdE1lc3NhZ2UgPSAnJztcblxuICAgIGlmIChvcHRpb25zLmRlZmF1bHRJbnB1dCAmJiAhcmVzKSB7IHJlcyA9IG9wdGlvbnMuZGVmYXVsdElucHV0OyB9XG5cbiAgICBpZiAob3B0aW9ucy5oaXN0b3J5KSB7XG4gICAgICBpZiAoKG1hdGNoZXMgPSAvXlxccypcXCEoPzpcXCF8LTEpKDpwKT9cXHMqJC8uZXhlYyhyZXMpKSkgeyAvLyBgISFgIGAhLTFgICtgOnBgXG4gICAgICAgIGhpc3RJbnB1dCA9IGlucHV0SGlzdG9yeVswXSB8fCAnJztcbiAgICAgICAgaWYgKG1hdGNoZXNbMV0pIHsgLy8gb25seSBkaXNwbGF5XG4gICAgICAgICAgZm9yY2VOZXh0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gcmVwbGFjZSBpbnB1dFxuICAgICAgICAgIHJlcyA9IGhpc3RJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG93IGl0IGV2ZW4gaWYgaXQgaXMgZW1wdHkgKE5MIG9ubHkpLlxuICAgICAgICBhZGREaXNwbGF5KGhpc3RJbnB1dCArICdcXG4nKTtcbiAgICAgICAgaWYgKCFmb3JjZU5leHQpIHsgLy8gTG9vcCBtYXkgYnJlYWtcbiAgICAgICAgICBvcHRpb25zLmRpc3BsYXlPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICBfcmVhZGxpbmVTeW5jKG9wdGlvbnMpO1xuICAgICAgICAgIG9wdGlvbnMuZGlzcGxheU9ubHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyZXMgJiYgcmVzICE9PSBpbnB1dEhpc3RvcnlbaW5wdXRIaXN0b3J5Lmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIGlucHV0SGlzdG9yeSA9IFtyZXNdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm9yY2VOZXh0ICYmIG9wdGlvbnMuY2QgJiYgcmVzKSB7XG4gICAgICBhcmdzID0gcGFyc2VDbChyZXMpO1xuICAgICAgc3dpdGNoIChhcmdzWzBdLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgY2FzZSAnY2QnOlxuICAgICAgICAgIGlmIChhcmdzWzFdKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBwcm9jZXNzLmNoZGlyKHJlcGxhY2VIb21lUGF0aChhcmdzWzFdLCB0cnVlKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGFkZERpc3BsYXkoZSArICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yY2VOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncHdkJzpcbiAgICAgICAgICBhZGREaXNwbGF5KHByb2Nlc3MuY3dkKCkpO1xuICAgICAgICAgIGZvcmNlTmV4dCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlTmV4dCAmJiBvcHRpb25zLnByZUNoZWNrKSB7XG4gICAgICByZXNDaGVjayA9IG9wdGlvbnMucHJlQ2hlY2socmVzLCBvcHRpb25zKTtcbiAgICAgIHJlcyA9IHJlc0NoZWNrLnJlcztcbiAgICAgIGlmIChyZXNDaGVjay5mb3JjZU5leHQpIHsgZm9yY2VOZXh0ID0gdHJ1ZTsgfSAvLyBEb24ndCBzd2l0Y2ggdG8gZmFsc2UuXG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZU5leHQpIHtcbiAgICAgIGlmICghb3B0aW9ucy5saW1pdFNyYy5sZW5ndGggfHxcbiAgICAgICAgaXNNYXRjaGVkKHJlcywgb3B0aW9ucy5saW1pdFNyYywgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSkgeyBicmVhazsgfVxuICAgICAgaWYgKG9wdGlvbnMubGltaXRNZXNzYWdlKSB7XG4gICAgICAgIGxpbWl0TWVzc2FnZSA9IHJlcGxhY2VQbGFjZWhvbGRlcihvcHRpb25zLmxpbWl0TWVzc2FnZSwgX2dldFBoQ29udGVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYWRkRGlzcGxheSgobGltaXRNZXNzYWdlID8gbGltaXRNZXNzYWdlICsgJ1xcbicgOiAnJykgK1xuICAgICAgcmVwbGFjZVBsYWNlaG9sZGVyKG9wdGlvbnMuZGlzcGxheVNyYyArICcnLCBfZ2V0UGhDb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIHRvQm9vbChyZXMsIG9wdGlvbnMpO1xufVxuXG4vLyBmb3IgZGV2XG5leHBvcnRzLl9EQkdfc2V0X3VzZUV4dCA9IGZ1bmN0aW9uKHZhbCkgeyBfREJHX3VzZUV4dCA9IHZhbDsgfTtcbmV4cG9ydHMuX0RCR19zZXRfY2hlY2tPcHRpb25zID0gZnVuY3Rpb24odmFsKSB7IF9EQkdfY2hlY2tPcHRpb25zID0gdmFsOyB9O1xuZXhwb3J0cy5fREJHX3NldF9jaGVja01ldGhvZCA9IGZ1bmN0aW9uKHZhbCkgeyBfREJHX2NoZWNrTWV0aG9kID0gdmFsOyB9O1xuZXhwb3J0cy5fREJHX2NsZWFySGlzdG9yeSA9IGZ1bmN0aW9uKCkgeyBsYXN0SW5wdXQgPSAnJzsgaW5wdXRIaXN0b3J5ID0gW107IH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLnNldERlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBkZWZhdWx0T3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh0cnVlLCBvcHRpb25zKTtcbiAgcmV0dXJuIG1hcmdlT3B0aW9ucyh0cnVlKTsgLy8gY29weVxufTtcblxuZXhwb3J0cy5xdWVzdGlvbiA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybiBnZXRWYWxpZExpbmUobWFyZ2VPcHRpb25zKG1hcmdlT3B0aW9ucyh0cnVlLCBvcHRpb25zKSwge1xuICAgIGRpc3BsYXk6ICAgICAgICAgICAgcXVlcnlcbiAgfSkpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG59O1xuXG5leHBvcnRzLnByb21wdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHRydWUsIG9wdGlvbnMpO1xuICByZWFkT3B0aW9ucy5kaXNwbGF5ID0gcmVhZE9wdGlvbnMucHJvbXB0O1xuICByZXR1cm4gZ2V0VmFsaWRMaW5lKHJlYWRPcHRpb25zKTtcbn07XG5cbmV4cG9ydHMua2V5SW4gPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMobWFyZ2VPcHRpb25zKHRydWUsIG9wdGlvbnMpLCB7XG4gICAgZGlzcGxheTogICAgICAgICAgICBxdWVyeSxcbiAgICBrZXlJbjogICAgICAgICAgICAgIHRydWUsXG4gICAga2VlcFdoaXRlc3BhY2U6ICAgICB0cnVlXG4gIH0pO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG5cbiAgLy8gY2hhciBsaXN0XG4gIHJlYWRPcHRpb25zLmxpbWl0U3JjID0gcmVhZE9wdGlvbnMubGltaXQuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInO1xuICB9KVxuICAubWFwKGZ1bmN0aW9uKHRleHQpIHsgcmV0dXJuIHJlcGxhY2VQbGFjZWhvbGRlcih0ZXh0ICsgJycsIGdldFBoQ2hhcmxpc3QpOyB9KTtcbiAgLy8gcGF0dGVyblxuICByZWFkT3B0aW9ucy5saW1pdCA9IGVzY2FwZVBhdHRlcm4ocmVhZE9wdGlvbnMubGltaXRTcmMuam9pbignJykpO1xuXG4gIFsndHJ1ZVZhbHVlJywgJ2ZhbHNlVmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICByZWFkT3B0aW9uc1tvcHRpb25OYW1lXSA9IHJlYWRPcHRpb25zW29wdGlvbk5hbWVdLnJlZHVjZShmdW5jdGlvbihjb21wcywgY29tcCkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgY29tcDtcbiAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb21wcyA9IGNvbXBzLmNvbmNhdCgoY29tcCArICcnKS5zcGxpdCgnJykpO1xuICAgICAgfSBlbHNlIHsgY29tcHMucHVzaChjb21wKTsgfVxuICAgICAgcmV0dXJuIGNvbXBzO1xuICAgIH0sIFtdKTtcbiAgfSk7XG5cbiAgcmVhZE9wdGlvbnMuZGlzcGxheSA9IHJlcGxhY2VQbGFjZWhvbGRlcihyZWFkT3B0aW9ucy5kaXNwbGF5ICsgJycsXG4gICAgZnVuY3Rpb24ocGFyYW0pIHsgcmV0dXJuIGdldFBoQ29udGVudChwYXJhbSwgcmVhZE9wdGlvbnMpOyB9KTtcblxuICByZXR1cm4gdG9Cb29sKF9yZWFkbGluZVN5bmMocmVhZE9wdGlvbnMpLCByZWFkT3B0aW9ucyk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5xdWVzdGlvbkVNYWlsID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnSW5wdXQgZS1tYWlsIGFkZHJlc3M6ICc7IH1cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuIGV4cG9ydHMucXVlc3Rpb24ocXVlcnksIG1hcmdlT3B0aW9ucyh7XG4gICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzc1xuICAgIGxpbWl0OiAgICAgICAgICAgICAgL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC8sXG4gICAgbGltaXRNZXNzYWdlOiAgICAgICAnSW5wdXQgdmFsaWQgZS1tYWlsIGFkZHJlc3MsIHBsZWFzZS4nLFxuICAgIHRydWVWYWx1ZTogICAgICAgICAgbnVsbCxcbiAgICBmYWxzZVZhbHVlOiAgICAgICAgIG51bGxcbiAgfSwgb3B0aW9ucywge1xuICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgIGtlZXBXaGl0ZXNwYWNlOiAgICAgZmFsc2UsXG4gICAgY2Q6ICAgICAgICAgICAgICAgICBmYWxzZVxuICB9KSk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbn07XG5cbmV4cG9ydHMucXVlc3Rpb25OZXdQYXNzd29yZCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZXNDaGFybGlzdCwgbWluLCBtYXgsXG4gICAgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgICAgaGlkZUVjaG9CYWNrOiAgICAgICB0cnVlLFxuICAgICAgbWFzazogICAgICAgICAgICAgICAnKicsXG4gICAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdJdCBjYW4gaW5jbHVkZTogJDxjaGFybGlzdD5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQW5kIHRoZSBsZW5ndGggbXVzdCBiZTogJDxsZW5ndGg+JyxcbiAgICAgIHRydWVWYWx1ZTogICAgICAgICAgbnVsbCxcbiAgICAgIGZhbHNlVmFsdWU6ICAgICAgICAgbnVsbCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgdHJ1ZVxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgICAgaGlzdG9yeTogICAgICAgICAgICBmYWxzZSxcbiAgICAgIGNkOiAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAvLyBsaW1pdCAoYnkgY2hhcmxpc3QgZXRjLiksXG4gICAgICBwaENvbnRlbnQ6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSA9PT0gJ2NoYXJsaXN0JyA/IHJlc0NoYXJsaXN0LnRleHQgOlxuICAgICAgICAgIHBhcmFtID09PSAnbGVuZ3RoJyA/IG1pbiArICcuLi4nICsgbWF4IDogbnVsbDtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBhZGRlZDogICAgIGNoYXJsaXN0LCBtaW4sIG1heCwgY29uZmlybU1lc3NhZ2UsIHVubWF0Y2hNZXNzYWdlXG4gICAgY2hhcmxpc3QsIGNvbmZpcm1NZXNzYWdlLCB1bm1hdGNoTWVzc2FnZSxcbiAgICBsaW1pdCwgbGltaXRNZXNzYWdlLCByZXMxLCByZXMyO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGNoYXJsaXN0ID0gcmVwbGFjZVBsYWNlaG9sZGVyKFxuICAgIG9wdGlvbnMuY2hhcmxpc3QgPyBvcHRpb25zLmNoYXJsaXN0ICsgJycgOiAnJDwhLX4+JywgZ2V0UGhDaGFybGlzdCk7XG4gIGlmIChpc05hTihtaW4gPSBwYXJzZUludChvcHRpb25zLm1pbiwgMTApKSB8fCB0eXBlb2YgbWluICE9PSAnbnVtYmVyJykgeyBtaW4gPSAxMjsgfVxuICBpZiAoaXNOYU4obWF4ID0gcGFyc2VJbnQob3B0aW9ucy5tYXgsIDEwKSkgfHwgdHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHsgbWF4ID0gMjQ7IH1cbiAgbGltaXQgPSBuZXcgUmVnRXhwKCdeWycgKyBlc2NhcGVQYXR0ZXJuKGNoYXJsaXN0KSArXG4gICAgJ117JyArIG1pbiArICcsJyArIG1heCArICd9JCcpO1xuICByZXNDaGFybGlzdCA9IGFycmF5MmNoYXJsaXN0KFtjaGFybGlzdF0sIHJlYWRPcHRpb25zLmNhc2VTZW5zaXRpdmUsIHRydWUpO1xuICByZXNDaGFybGlzdC50ZXh0ID0gam9pbkNodW5rcyhyZXNDaGFybGlzdC52YWx1ZXMsIHJlc0NoYXJsaXN0LnN1cHByZXNzZWQpO1xuXG4gIGNvbmZpcm1NZXNzYWdlID0gb3B0aW9ucy5jb25maXJtTWVzc2FnZSAhPSBudWxsID8gb3B0aW9ucy5jb25maXJtTWVzc2FnZSA6XG4gICAgJ1JlaW5wdXQgYSBzYW1lIG9uZSB0byBjb25maXJtIGl0OiAnO1xuICB1bm1hdGNoTWVzc2FnZSA9IG9wdGlvbnMudW5tYXRjaE1lc3NhZ2UgIT0gbnVsbCA/IG9wdGlvbnMudW5tYXRjaE1lc3NhZ2UgOlxuICAgICdJdCBkaWZmZXJzIGZyb20gZmlyc3Qgb25lLicgK1xuICAgICAgJyBIaXQgb25seSB0aGUgRW50ZXIga2V5IGlmIHlvdSB3YW50IHRvIHJldHJ5IGZyb20gZmlyc3Qgb25lLic7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnSW5wdXQgbmV3IHBhc3N3b3JkOiAnOyB9XG5cbiAgbGltaXRNZXNzYWdlID0gcmVhZE9wdGlvbnMubGltaXRNZXNzYWdlO1xuICB3aGlsZSAoIXJlczIpIHtcbiAgICByZWFkT3B0aW9ucy5saW1pdCA9IGxpbWl0O1xuICAgIHJlYWRPcHRpb25zLmxpbWl0TWVzc2FnZSA9IGxpbWl0TWVzc2FnZTtcbiAgICByZXMxID0gZXhwb3J0cy5xdWVzdGlvbihxdWVyeSwgcmVhZE9wdGlvbnMpO1xuXG4gICAgcmVhZE9wdGlvbnMubGltaXQgPSBbcmVzMSwgJyddO1xuICAgIHJlYWRPcHRpb25zLmxpbWl0TWVzc2FnZSA9IHVubWF0Y2hNZXNzYWdlO1xuICAgIHJlczIgPSBleHBvcnRzLnF1ZXN0aW9uKGNvbmZpcm1NZXNzYWdlLCByZWFkT3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gcmVzMTtcbn07XG5cbmZ1bmN0aW9uIF9xdWVzdGlvbk51bShxdWVyeSwgb3B0aW9ucywgcGFyc2VyKSB7XG4gIHZhciB2YWxpZFZhbHVlO1xuICBmdW5jdGlvbiBnZXRWYWxpZFZhbHVlKHZhbHVlKSB7XG4gICAgdmFsaWRWYWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gICAgcmV0dXJuICFpc05hTih2YWxpZFZhbHVlKSAmJiB0eXBlb2YgdmFsaWRWYWx1ZSA9PT0gJ251bWJlcic7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgZXhwb3J0cy5xdWVzdGlvbihxdWVyeSwgbWFyZ2VPcHRpb25zKHtcbiAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgbGltaXRNZXNzYWdlOiAgICAgICAnSW5wdXQgdmFsaWQgbnVtYmVyLCBwbGVhc2UuJ1xuICB9LCBvcHRpb25zLCB7XG4gICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgbGltaXQ6ICAgICAgICAgICAgICBnZXRWYWxpZFZhbHVlLFxuICAgIGNkOiAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAvLyB0cnVlVmFsdWUsIGZhbHNlVmFsdWUsIGNhc2VTZW5zaXRpdmUsIGtlZXBXaGl0ZXNwYWNlIGRvbid0IHdvcmsuXG4gIH0pKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm4gdmFsaWRWYWx1ZTtcbn1cbmV4cG9ydHMucXVlc3Rpb25JbnQgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gX3F1ZXN0aW9uTnVtKHF1ZXJ5LCBvcHRpb25zLCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTsgfSk7XG59O1xuZXhwb3J0cy5xdWVzdGlvbkZsb2F0ID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9xdWVzdGlvbk51bShxdWVyeSwgb3B0aW9ucywgcGFyc2VGbG9hdCk7XG59O1xuXG5leHBvcnRzLnF1ZXN0aW9uUGF0aCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciB2YWxpZFBhdGgsIGVycm9yID0gJycsXG4gICAgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICAgIGxpbWl0TWVzc2FnZTogICAgICAgJyQ8ZXJyb3IoXFxuKT5JbnB1dCB2YWxpZCBwYXRoLCBwbGVhc2UuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyQ8KCBNaW46KW1pbj4kPCggTWF4OiltYXg+JyxcbiAgICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZSxcbiAgICAgIGNkOiAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgICAga2VlcFdoaXRlc3BhY2U6ICAgICBmYWxzZSxcbiAgICAgIGxpbWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RzLCBzdGF0LCByZXM7XG4gICAgICAgIHZhbHVlID0gcmVwbGFjZUhvbWVQYXRoKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgZXJyb3IgPSAnJzsgLy8gZm9yIHZhbGlkYXRlXG4gICAgICAgIC8vIG1rZGlyIC1wXG4gICAgICAgIGZ1bmN0aW9uIG1rZGlyUGFyZW50cyhkaXJQYXRoKSB7XG4gICAgICAgICAgZGlyUGF0aC5zcGxpdCgvXFwvfFxcXFwvKS5yZWR1Y2UoZnVuY3Rpb24ocGFyZW50cywgZGlyKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhVdGlsLnJlc29sdmUoKHBhcmVudHMgKz0gZGlyICsgcGF0aFV0aWwuc2VwKSk7XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgICAgICAgICAgZnMubWtkaXJTeW5jKHBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghZnMuc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBkaXJlY3RvcnkgYWxyZWFkeSBleGlzdHM6ICcgKyBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXhpc3RzID0gZnMuZXhpc3RzU3luYyh2YWx1ZSk7XG4gICAgICAgICAgdmFsaWRQYXRoID0gZXhpc3RzID8gZnMucmVhbHBhdGhTeW5jKHZhbHVlKSA6IHBhdGhVdGlsLnJlc29sdmUodmFsdWUpO1xuICAgICAgICAgIC8vIG9wdGlvbnMuZXhpc3RzIGRlZmF1bHQ6IHRydWUsIG5vdC1ib29sOiBuby1jaGVja1xuICAgICAgICAgIGlmICghb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZXhpc3RzJykgJiYgIWV4aXN0cyB8fFxuICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5leGlzdHMgPT09ICdib29sZWFuJyAmJiBvcHRpb25zLmV4aXN0cyAhPT0gZXhpc3RzKSB7XG4gICAgICAgICAgICBlcnJvciA9IChleGlzdHMgPyAnQWxyZWFkeSBleGlzdHMnIDogJ05vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnknKSArXG4gICAgICAgICAgICAgICc6ICcgKyB2YWxpZFBhdGg7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZXhpc3RzICYmIG9wdGlvbnMuY3JlYXRlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pc0RpcmVjdG9yeSkge1xuICAgICAgICAgICAgICBta2RpclBhcmVudHModmFsaWRQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1rZGlyUGFyZW50cyhwYXRoVXRpbC5kaXJuYW1lKHZhbGlkUGF0aCkpO1xuICAgICAgICAgICAgICBmcy5jbG9zZVN5bmMoZnMub3BlblN5bmModmFsaWRQYXRoLCAndycpKTsgLy8gdG91Y2hcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkUGF0aCA9IGZzLnJlYWxwYXRoU3luYyh2YWxpZFBhdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZXhpc3RzICYmIChvcHRpb25zLm1pbiB8fCBvcHRpb25zLm1heCB8fFxuICAgICAgICAgICAgICBvcHRpb25zLmlzRmlsZSB8fCBvcHRpb25zLmlzRGlyZWN0b3J5KSkge1xuICAgICAgICAgICAgc3RhdCA9IGZzLnN0YXRTeW5jKHZhbGlkUGF0aCk7XG4gICAgICAgICAgICAvLyB0eXBlIGNoZWNrIGZpcnN0IChkaXJlY3RvcnkgaGFzIHplcm8gc2l6ZSlcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzRmlsZSAmJiAhc3RhdC5pc0ZpbGUoKSkge1xuICAgICAgICAgICAgICBlcnJvciA9ICdOb3QgZmlsZTogJyArIHZhbGlkUGF0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmlzRGlyZWN0b3J5ICYmICFzdGF0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSAnTm90IGRpcmVjdG9yeTogJyArIHZhbGlkUGF0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbiAmJiBzdGF0LnNpemUgPCArb3B0aW9ucy5taW4gfHxcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1heCAmJiBzdGF0LnNpemUgPiArb3B0aW9ucy5tYXgpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSAnU2l6ZSAnICsgc3RhdC5zaXplICsgJyBpcyBvdXQgb2YgcmFuZ2U6ICcgKyB2YWxpZFBhdGg7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgIChyZXMgPSBvcHRpb25zLnZhbGlkYXRlKHZhbGlkUGF0aCkpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ3N0cmluZycpIHsgZXJyb3IgPSByZXM7IH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlcnJvciA9IGUgKyAnJztcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgLy8gdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlLCBjYXNlU2Vuc2l0aXZlIGRvbid0IHdvcmsuXG4gICAgICBwaENvbnRlbnQ6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSA9PT0gJ2Vycm9yJyA/IGVycm9yIDpcbiAgICAgICAgICBwYXJhbSAhPT0gJ21pbicgJiYgcGFyYW0gIT09ICdtYXgnID8gbnVsbCA6XG4gICAgICAgICAgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkgPyBvcHRpb25zW3BhcmFtXSArICcnIDogJyc7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gYWRkZWQ6ICAgICBleGlzdHMsIGNyZWF0ZSwgbWluLCBtYXgsIGlzRmlsZSwgaXNEaXJlY3RvcnksIHZhbGlkYXRlXG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnSW5wdXQgcGF0aCAoeW91IGNhbiBcImNkXCIgYW5kIFwicHdkXCIpOiAnOyB9XG5cbiAgZXhwb3J0cy5xdWVzdGlvbihxdWVyeSwgcmVhZE9wdGlvbnMpO1xuICByZXR1cm4gdmFsaWRQYXRoO1xufTtcblxuLy8gcHJvcHM6IHByZUNoZWNrLCBhcmdzLCBoUmVzLCBsaW1pdFxuZnVuY3Rpb24gZ2V0Q2xIYW5kbGVyKGNvbW1hbmRIYW5kbGVyLCBvcHRpb25zKSB7XG4gIHZhciBjbEhhbmRsZXIgPSB7fSwgaEluZGV4ID0ge307XG4gIGlmICh0eXBlb2YgY29tbWFuZEhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXMoY29tbWFuZEhhbmRsZXIpLmZvckVhY2goZnVuY3Rpb24oY21kKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbW1hbmRIYW5kbGVyW2NtZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaEluZGV4W29wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IGNtZCA6IGNtZC50b0xvd2VyQ2FzZSgpXSA9IGNvbW1hbmRIYW5kbGVyW2NtZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgY2xIYW5kbGVyLnByZUNoZWNrID0gZnVuY3Rpb24ocmVzKSB7XG4gICAgICB2YXIgY21kS2V5O1xuICAgICAgY2xIYW5kbGVyLmFyZ3MgPSBwYXJzZUNsKHJlcyk7XG4gICAgICBjbWRLZXkgPSBjbEhhbmRsZXIuYXJnc1swXSB8fCAnJztcbiAgICAgIGlmICghb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSB7IGNtZEtleSA9IGNtZEtleS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICBjbEhhbmRsZXIuaFJlcyA9XG4gICAgICAgIGNtZEtleSAhPT0gJ18nICYmIGhJbmRleC5oYXNPd25Qcm9wZXJ0eShjbWRLZXkpID9cbiAgICAgICAgICBoSW5kZXhbY21kS2V5XS5hcHBseShyZXMsIGNsSGFuZGxlci5hcmdzLnNsaWNlKDEpKSA6XG4gICAgICAgIGhJbmRleC5oYXNPd25Qcm9wZXJ0eSgnXycpID8gaEluZGV4Ll8uYXBwbHkocmVzLCBjbEhhbmRsZXIuYXJncykgOiBudWxsO1xuICAgICAgcmV0dXJuIHtyZXM6IHJlcywgZm9yY2VOZXh0OiBmYWxzZX07XG4gICAgfTtcbiAgICBpZiAoIWhJbmRleC5oYXNPd25Qcm9wZXJ0eSgnXycpKSB7XG4gICAgICBjbEhhbmRsZXIubGltaXQgPSBmdW5jdGlvbigpIHsgLy8gSXQncyBjYWxsZWQgYWZ0ZXIgcHJlQ2hlY2suXG4gICAgICAgIHZhciBjbWRLZXkgPSBjbEhhbmRsZXIuYXJnc1swXSB8fCAnJztcbiAgICAgICAgaWYgKCFvcHRpb25zLmNhc2VTZW5zaXRpdmUpIHsgY21kS2V5ID0gY21kS2V5LnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgICAgcmV0dXJuIGhJbmRleC5oYXNPd25Qcm9wZXJ0eShjbWRLZXkpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY2xIYW5kbGVyLnByZUNoZWNrID0gZnVuY3Rpb24ocmVzKSB7XG4gICAgICBjbEhhbmRsZXIuYXJncyA9IHBhcnNlQ2wocmVzKTtcbiAgICAgIGNsSGFuZGxlci5oUmVzID0gdHlwZW9mIGNvbW1hbmRIYW5kbGVyID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgY29tbWFuZEhhbmRsZXIuYXBwbHkocmVzLCBjbEhhbmRsZXIuYXJncykgOiB0cnVlOyAvLyB0cnVlIGZvciBicmVhayBsb29wXG4gICAgICByZXR1cm4ge3JlczogcmVzLCBmb3JjZU5leHQ6IGZhbHNlfTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBjbEhhbmRsZXI7XG59XG5cbmV4cG9ydHMucHJvbXB0Q0wgPSBmdW5jdGlvbihjb21tYW5kSGFuZGxlciwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ1JlcXVlc3RlZCBjb21tYW5kIGlzIG5vdCBhdmFpbGFibGUuJyxcbiAgICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2UsXG4gICAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWVcbiAgICB9LCBvcHRpb25zKSxcbiAgICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgICAgLy8gdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlLCBrZWVwV2hpdGVzcGFjZSBkb24ndCB3b3JrLlxuICAgICAgLy8gcHJlQ2hlY2ssIGxpbWl0IChieSBjbEhhbmRsZXIpXG4gICAgY2xIYW5kbGVyID0gZ2V0Q2xIYW5kbGVyKGNvbW1hbmRIYW5kbGVyLCByZWFkT3B0aW9ucyk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgcmVhZE9wdGlvbnMubGltaXQgPSBjbEhhbmRsZXIubGltaXQ7XG4gIHJlYWRPcHRpb25zLnByZUNoZWNrID0gY2xIYW5kbGVyLnByZUNoZWNrO1xuICBleHBvcnRzLnByb21wdChyZWFkT3B0aW9ucyk7XG4gIHJldHVybiBjbEhhbmRsZXIuYXJncztcbn07XG5cbmV4cG9ydHMucHJvbXB0TG9vcCA9IGZ1bmN0aW9uKGlucHV0SGFuZGxlciwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgIHRydWVWYWx1ZTogICAgICAgICAgbnVsbCxcbiAgICBmYWxzZVZhbHVlOiAgICAgICAgIG51bGwsXG4gICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZSxcbiAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWVcbiAgfSwgb3B0aW9ucyk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgd2hpbGUgKHRydWUpIHsgaWYgKGlucHV0SGFuZGxlcihleHBvcnRzLnByb21wdChyZWFkT3B0aW9ucykpKSB7IGJyZWFrOyB9IH1cbiAgcmV0dXJuO1xufTtcblxuZXhwb3J0cy5wcm9tcHRDTExvb3AgPSBmdW5jdGlvbihjb21tYW5kSGFuZGxlciwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ1JlcXVlc3RlZCBjb21tYW5kIGlzIG5vdCBhdmFpbGFibGUuJyxcbiAgICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2UsXG4gICAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWVcbiAgICB9LCBvcHRpb25zKSxcbiAgICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgICAgLy8gdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlLCBrZWVwV2hpdGVzcGFjZSBkb24ndCB3b3JrLlxuICAgICAgLy8gcHJlQ2hlY2ssIGxpbWl0IChieSBjbEhhbmRsZXIpXG4gICAgY2xIYW5kbGVyID0gZ2V0Q2xIYW5kbGVyKGNvbW1hbmRIYW5kbGVyLCByZWFkT3B0aW9ucyk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgcmVhZE9wdGlvbnMubGltaXQgPSBjbEhhbmRsZXIubGltaXQ7XG4gIHJlYWRPcHRpb25zLnByZUNoZWNrID0gY2xIYW5kbGVyLnByZUNoZWNrO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGV4cG9ydHMucHJvbXB0KHJlYWRPcHRpb25zKTtcbiAgICBpZiAoY2xIYW5kbGVyLmhSZXMpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm47XG59O1xuXG5leHBvcnRzLnByb21wdFNpbVNoZWxsID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm4gZXhwb3J0cy5wcm9tcHQobWFyZ2VPcHRpb25zKHtcbiAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWVcbiAgfSwgb3B0aW9ucywge1xuICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgIHByb21wdDogICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIElTX1dJTiA/XG4gICAgICAgICckPGN3ZD4+JyA6XG4gICAgICAgIC8vICd1c2VyQGhvc3Q6Y3dkJCAnXG4gICAgICAgIChwcm9jZXNzLmVudi5VU0VSIHx8ICcnKSArXG4gICAgICAgIChwcm9jZXNzLmVudi5IT1NUTkFNRSA/XG4gICAgICAgICAgJ0AnICsgcHJvY2Vzcy5lbnYuSE9TVE5BTUUucmVwbGFjZSgvXFwuLiokLywgJycpIDogJycpICtcbiAgICAgICAgJzokPGN3ZEhvbWU+JCAnO1xuICAgIH0pKClcbiAgfSkpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG59O1xuXG5mdW5jdGlvbiBfa2V5SW5ZTihxdWVyeSwgb3B0aW9ucywgbGltaXQpIHtcbiAgdmFyIHJlcztcbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnQXJlIHlvdSBzdXJlPyAnOyB9XG4gIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucy5ndWlkZSAhPT0gZmFsc2UpICYmIChxdWVyeSArPSAnJykpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xccyo6P1xccyokLywgJycpICsgJyBbeS9uXTogJztcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXMgPSBleHBvcnRzLmtleUluKHF1ZXJ5LCBtYXJnZU9wdGlvbnMob3B0aW9ucywge1xuICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgbGltaXQ6ICAgICAgICAgICAgICBsaW1pdCxcbiAgICB0cnVlVmFsdWU6ICAgICAgICAgICd5JyxcbiAgICBmYWxzZVZhbHVlOiAgICAgICAgICduJyxcbiAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlXG4gICAgLy8gbWFzayBkb2Vzbid0IHdvcmsuXG4gIH0pKTtcbiAgLy8gYWRkZWQ6ICAgICBndWlkZVxuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybiB0eXBlb2YgcmVzID09PSAnYm9vbGVhbicgPyByZXMgOiAnJztcbn1cbmV4cG9ydHMua2V5SW5ZTiA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7IHJldHVybiBfa2V5SW5ZTihxdWVyeSwgb3B0aW9ucyk7IH07XG5leHBvcnRzLmtleUluWU5TdHJpY3QgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykgeyByZXR1cm4gX2tleUluWU4ocXVlcnksIG9wdGlvbnMsICd5bicpOyB9O1xuXG5leHBvcnRzLmtleUluUGF1c2UgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdDb250aW51ZS4uLic7IH1cbiAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zLmd1aWRlICE9PSBmYWxzZSkgJiYgKHF1ZXJ5ICs9ICcnKSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvXFxzKyQvLCAnJykgKyAnIChIaXQgYW55IGtleSknO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIGV4cG9ydHMua2V5SW4ocXVlcnksIG1hcmdlT3B0aW9ucyh7XG4gICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgIGxpbWl0OiAgICAgICAgICAgICAgbnVsbFxuICB9LCBvcHRpb25zLCB7XG4gICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICB0cnVlLFxuICAgIG1hc2s6ICAgICAgICAgICAgICAgJydcbiAgfSkpO1xuICAvLyBhZGRlZDogICAgIGd1aWRlXG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuO1xufTtcblxuZXhwb3J0cy5rZXlJblNlbGVjdCA9IGZ1bmN0aW9uKGl0ZW1zLCBxdWVyeSwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnMoe1xuICAgICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZVxuICAgIH0sIG9wdGlvbnMsIHtcbiAgICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgICAgdHJ1ZVZhbHVlOiAgICAgICAgICBudWxsLFxuICAgICAgZmFsc2VWYWx1ZTogICAgICAgICBudWxsLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZSxcbiAgICAgIC8vIGxpbWl0IChieSBpdGVtcyksXG4gICAgICBwaENvbnRlbnQ6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBwYXJhbSA9PT0gJ2l0ZW1zQ291bnQnID8gaXRlbXMubGVuZ3RoICsgJycgOlxuICAgICAgICAgIHBhcmFtID09PSAnZmlyc3RJdGVtJyA/IChpdGVtc1swXSArICcnKS50cmltKCkgOlxuICAgICAgICAgIHBhcmFtID09PSAnbGFzdEl0ZW0nID8gKGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdICsgJycpLnRyaW0oKSA6IG51bGw7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gYWRkZWQ6ICAgICBndWlkZSwgY2FuY2VsXG4gICAga2V5bGlzdCA9ICcnLCBrZXkyaSA9IHt9LCBjaGFyQ29kZSA9IDQ5IC8qICcxJyAqLywgZGlzcGxheSA9ICdcXG4nO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykgfHwgIWl0ZW1zLmxlbmd0aCB8fCBpdGVtcy5sZW5ndGggPiAzNSkge1xuICAgIHRocm93ICdgaXRlbXNgIG11c3QgYmUgQXJyYXkgKG1heCBsZW5ndGg6IDM1KS4nO1xuICB9XG5cbiAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgdmFyIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIGtleWxpc3QgKz0ga2V5O1xuICAgIGtleTJpW2tleV0gPSBpO1xuICAgIGRpc3BsYXkgKz0gJ1snICsga2V5ICsgJ10gJyArIChpdGVtICsgJycpLnRyaW0oKSArICdcXG4nO1xuICAgIGNoYXJDb2RlID0gY2hhckNvZGUgPT09IDU3IC8qICc5JyAqLyA/IDk3IC8qICdhJyAqLyA6IGNoYXJDb2RlICsgMTtcbiAgfSk7XG4gIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmNhbmNlbCAhPT0gZmFsc2UpIHtcbiAgICBrZXlsaXN0ICs9ICcwJztcbiAgICBrZXkyaVsnMCddID0gLTE7XG4gICAgZGlzcGxheSArPSAnWzBdICcgK1xuICAgICAgKG9wdGlvbnMgJiYgb3B0aW9ucy5jYW5jZWwgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0aW9ucy5jYW5jZWwgIT09ICdib29sZWFuJyA/XG4gICAgICAgIChvcHRpb25zLmNhbmNlbCArICcnKS50cmltKCkgOiAnQ0FOQ0VMJykgKyAnXFxuJztcbiAgfVxuICByZWFkT3B0aW9ucy5saW1pdCA9IGtleWxpc3Q7XG4gIGRpc3BsYXkgKz0gJ1xcbic7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnQ2hvb3NlIG9uZSBmcm9tIGxpc3Q6ICc7IH1cbiAgaWYgKChxdWVyeSArPSAnJykpIHtcbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5ndWlkZSAhPT0gZmFsc2UpIHtcbiAgICAgIHF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvXFxzKjo/XFxzKiQvLCAnJykgKyAnIFskPGxpbWl0Pl06ICc7XG4gICAgfVxuICAgIGRpc3BsYXkgKz0gcXVlcnk7XG4gIH1cblxuICByZXR1cm4ga2V5MmlbZXhwb3J0cy5rZXlJbihkaXNwbGF5LCByZWFkT3B0aW9ucykudG9Mb3dlckNhc2UoKV07XG59O1xuXG5leHBvcnRzLmdldFJhd0lucHV0ID0gZnVuY3Rpb24oKSB7IHJldHVybiByYXdJbnB1dDsgfTtcblxuLy8gPT09PT09PT0gREVQUkVDQVRFRCA9PT09PT09PVxuZnVuY3Rpb24gX3NldE9wdGlvbihvcHRpb25OYW1lLCBhcmdzKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoYXJncy5sZW5ndGgpIHsgb3B0aW9ucyA9IHt9OyBvcHRpb25zW29wdGlvbk5hbWVdID0gYXJnc1swXTsgfVxuICByZXR1cm4gZXhwb3J0cy5zZXREZWZhdWx0T3B0aW9ucyhvcHRpb25zKVtvcHRpb25OYW1lXTtcbn1cbmV4cG9ydHMuc2V0UHJpbnQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIF9zZXRPcHRpb24oJ3ByaW50JywgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMuc2V0UHJvbXB0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0T3B0aW9uKCdwcm9tcHQnLCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldE9wdGlvbignZW5jb2RpbmcnLCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5zZXRNYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0T3B0aW9uKCdtYXNrJywgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMuc2V0QnVmZmVyU2l6ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldE9wdGlvbignYnVmZmVyU2l6ZScsIGFyZ3VtZW50cyk7IH07XG4iLCIoZnVuY3Rpb24oKSB7XHJcblx0XHJcblx0Ly8gVkVSU0lPTlxyXG5cdHZhciB2ZXJzaW9uID0geyBtYWpvcjogMCwgbWlub3I6IDMsIHBhdGNoOiA0LCBzdGF0dXM6IFwiYmV0YVwiIH07XHJcblxyXG5cclxuXHJcblx0Ly8gSU8gRklMRSBTWVNURU1cclxuXHRcclxuXHQvLyBWaXJ0dWFsIGZpbGVcclxuXHRmdW5jdGlvbiBUYXVGaWxlKG5hbWUsIHR5cGUsIHBhcmVudCwgdGV4dCkge1xyXG5cdFx0dGV4dCA9IHRleHQgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiB0ZXh0O1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHRcdHRoaXMudHlwZSA9IHR5cGU7XHJcblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHRcdHRoaXMudGV4dCA9IHRleHQ7XHJcblx0XHR0aGlzLmNyZWF0ZWQgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuXHRcdHRoaXMubW9kaWZpZWQgPSB0aGlzLmNyZWF0ZWQ7XHJcblx0fVxyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihsZW5ndGgsIHBvc2l0aW9uKSB7XHJcblx0XHRpZihwb3NpdGlvbiA9PT0gdGhpcy50ZXh0Lmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gXCJlbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHR9IGVsc2UgaWYocG9zaXRpb24gPiB0aGlzLnRleHQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBcImVuZF9vZl9zdHJlYW1cIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRleHQuc3Vic3RyaW5nKHBvc2l0aW9uLCBwb3NpdGlvbitsZW5ndGgpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLmVvZiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcblx0XHRyZXR1cm4gcG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGg7XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24odGV4dCwgcG9zaXRpb24pIHtcclxuXHRcdGlmKHBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHR0aGlzLnRleHQgKz0gdGV4dDtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IGVsc2UgaWYocG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIHBvc2l0aW9uKSArIHRleHQgKyB0aGlzLnRleHQuc3Vic3RyaW5nKHBvc2l0aW9uK3RleHQubGVuZ3RoKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuZ2V0X2J5dGUgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG5cdFx0aWYocG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiKVxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKHBvc2l0aW9uLzIpO1xyXG5cdFx0aWYodGhpcy50ZXh0Lmxlbmd0aCA8PSBpbmRleClcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0dmFyIGNvZGUgPSBjb2RlUG9pbnRBdCh0aGlzLnRleHRbTWF0aC5mbG9vcihwb3NpdGlvbi8yKV0sIDApO1xyXG5cdFx0aWYocG9zaXRpb24gJSAyID09PSAwKVxyXG5cdFx0XHRyZXR1cm4gY29kZSAmIDB4ZmY7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiBjb2RlIC8gMjU2ID4+PiAwO1xyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLnB1dF9ieXRlID0gZnVuY3Rpb24oYnl0ZSwgcG9zaXRpb24pIHtcclxuXHRcdHZhciBpbmRleCA9IHBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiA/IHRoaXMudGV4dC5sZW5ndGggOiBNYXRoLmZsb29yKHBvc2l0aW9uLzIpO1xyXG5cdFx0aWYodGhpcy50ZXh0Lmxlbmd0aCA8IGluZGV4KVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBjb2RlID0gdGhpcy50ZXh0Lmxlbmd0aCA9PT0gaW5kZXggPyAtMSA6IGNvZGVQb2ludEF0KHRoaXMudGV4dFtNYXRoLmZsb29yKHBvc2l0aW9uLzIpXSwgMCk7XHJcblx0XHRpZihwb3NpdGlvbiAlIDIgPT09IDApIHtcclxuXHRcdFx0Y29kZSA9IGNvZGUgLyAyNTYgPj4+IDA7XHJcblx0XHRcdGNvZGUgPSAoKGNvZGUgJiAweGZmKSA8PCA4KSB8IChieXRlICYgMHhmZik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb2RlID0gY29kZSAmIDB4ZmY7XHJcblx0XHRcdGNvZGUgPSAoKGJ5dGUgJiAweGZmKSA8PCA4KSB8IChjb2RlICYgMHhmZik7XHJcblx0XHR9XHJcblx0XHRpZih0aGlzLnRleHQubGVuZ3RoID09PSBpbmRleClcclxuXHRcdFx0dGhpcy50ZXh0ICs9IGZyb21Db2RlUG9pbnQoY29kZSk7XHJcblx0XHRlbHNlIFxyXG5cdFx0XHR0aGlzLnRleHQgPSB0aGlzLnRleHQuc3Vic3RyaW5nKDAsIGluZGV4KSArIGZyb21Db2RlUG9pbnQoY29kZSkgKyB0aGlzLnRleHQuc3Vic3RyaW5nKGluZGV4KzEpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLm1vZGlmaWVkID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0Lmxlbmd0aDtcclxuXHR9O1xyXG5cclxuXHQvLyBWaXJ0dWFsIGRpcmVjdG9yeVxyXG5cdGZ1bmN0aW9uIFRhdURpcmVjdG9yeShuYW1lLCBwYXJlbnQpIHtcclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHRcdHRoaXMuZmlsZXMgPSB7fTtcclxuXHRcdHRoaXMubGVuZ3RoID0gMDtcclxuXHRcdHRoaXMuY3JlYXRlZCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG5cdFx0dGhpcy5tb2RpZmllZCA9IHRoaXMuY3JlYXRlZDtcclxuXHR9XHJcblxyXG5cdFRhdURpcmVjdG9yeS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24oZmlsZSkge1xyXG5cdFx0aWYodGhpcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShmaWxlKSlcclxuXHRcdFx0cmV0dXJuIHRoaXMuZmlsZXNbZmlsZV07XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHRUYXVEaXJlY3RvcnkucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihuYW1lLCBmaWxlKSB7XHJcblx0XHRpZighdGhpcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcclxuXHRcdFx0dGhpcy5sZW5ndGgrKztcclxuXHRcdHRoaXMuZmlsZXNbbmFtZV0gPSBmaWxlO1xyXG5cdFx0dGhpcy5tb2RpZmllZCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG5cdH07XHJcblxyXG5cdFRhdURpcmVjdG9yeS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0aWYodGhpcy5maWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG5cdFx0XHR0aGlzLmxlbmd0aC0tO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5maWxlc1tuYW1lXTtcclxuXHRcdFx0dGhpcy5tb2RpZmllZCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFRhdURpcmVjdG9yeS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMDtcclxuXHR9O1xyXG5cclxuXHRUYXVEaXJlY3RvcnkucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiA0MDk2O1xyXG5cdH07XHJcblxyXG5cdC8vIFZpcnR1YWwgZmlsZSBzeXN0ZW0gZm9yIGJyb3dzZXJcclxuXHR0YXVfZmlsZV9zeXN0ZW0gPSB7XHJcblx0XHQvLyBDdXJyZW50IGZpbGVzXHJcblx0XHRmaWxlczogbmV3IFRhdURpcmVjdG9yeShcIi9cIiwgXCIvXCIsIG51bGwpLFxyXG5cdFx0Ly8gT3BlbiBmaWxlXHJcblx0XHRvcGVuOiBmdW5jdGlvbihwYXRoLCB0eXBlLCBtb2RlKSB7XHJcblx0XHRcdHZhciBkaXJzID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIikuc3BsaXQoXCIvXCIpO1xyXG5cdFx0XHR2YXIgZGlyID0gdGF1X2ZpbGVfc3lzdGVtLmZpbGVzO1xyXG5cdFx0XHR2YXIgbmFtZSA9IGRpcnNbZGlycy5sZW5ndGgtMV07XHJcblx0XHRcdGZvcih2YXIgaSA9IDE7IGkgPCBkaXJzLmxlbmd0aC0xOyBpKyspIHtcclxuXHRcdFx0XHRkaXIgPSBkaXIubG9va3VwKGRpcnNbaV0pO1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2RpcmVjdG9yeShkaXIpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGZpbGUgPSBkaXIubG9va3VwKG5hbWUpO1xyXG5cdFx0XHRpZihmaWxlID09PSBudWxsKSB7XHJcblx0XHRcdFx0aWYobW9kZSA9PT0gXCJyZWFkXCIpXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRmaWxlID0gbmV3IFRhdUZpbGUobmFtZSwgdHlwZSwgZGlyKTtcclxuXHRcdFx0XHRkaXIucHVzaChuYW1lLCBmaWxlKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2ZpbGUoZmlsZSkpIHtcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihtb2RlID09PSBcIndyaXRlXCIpXHJcblx0XHRcdFx0ZmlsZS50ZXh0ID0gXCJcIjtcclxuXHRcdFx0cmV0dXJuIGZpbGU7XHJcblx0XHR9LFxyXG5cdFx0Ly8gR2V0IGl0ZW1cclxuXHRcdGdldDogZnVuY3Rpb24ocGF0aCkge1xyXG5cdFx0XHR2YXIgZGlycyA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuXHRcdFx0dmFyIGZpbGUgPSB0YXVfZmlsZV9zeXN0ZW0uZmlsZXM7XHJcblx0XHRcdGZvcih2YXIgaSA9IDE7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfZGlyZWN0b3J5KGZpbGUpKVxyXG5cdFx0XHRcdFx0ZmlsZSA9IGZpbGUubG9va3VwKGRpcnNbaV0pO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRyZXR1cm4gZmlsZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIGlucHV0IGZvciBicm93c2VyXHJcblx0dGF1X3VzZXJfaW5wdXQgPSB7XHJcblx0XHRidWZmZXI6IFwiXCIsXHJcblx0XHRnZXQ6IGZ1bmN0aW9uKCBsZW5ndGgsIF8gKSB7XHJcblx0XHRcdHZhciB0ZXh0O1xyXG5cdFx0XHR3aGlsZSggdGF1X3VzZXJfaW5wdXQuYnVmZmVyLmxlbmd0aCA8IGxlbmd0aCApIHtcclxuXHRcdFx0XHR0ZXh0ID0gd2luZG93LnByb21wdCgpO1xyXG5cdFx0XHRcdGlmKCB0ZXh0Lmxlbmd0aCA9PT0gMCApXHJcblx0XHRcdFx0XHRyZXR1cm4gXCJlbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0aWYoIHRleHQgKSB7XHJcblx0XHRcdFx0XHR0YXVfdXNlcl9pbnB1dC5idWZmZXIgKz0gdGV4dDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGV4dCA9IHRhdV91c2VyX2lucHV0LmJ1ZmZlci5zdWJzdHIoIDAsIGxlbmd0aCApO1xyXG5cdFx0XHR0YXVfdXNlcl9pbnB1dC5idWZmZXIgPSB0YXVfdXNlcl9pbnB1dC5idWZmZXIuc3Vic3RyKCBsZW5ndGggKTtcclxuXHRcdFx0cmV0dXJuIHRleHQ7XHJcblx0XHR9LFxyXG5cdFx0ZW9mOiBmdW5jdGlvbihfKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIG91dHB1dCBmb3IgYnJvd3NlclxyXG5cdHRhdV91c2VyX291dHB1dCA9IHtcclxuXHRcdHB1dDogZnVuY3Rpb24oIHRleHQsIF8gKSB7XHJcblx0XHRcdGNvbnNvbGUubG9nKCB0ZXh0ICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdGZsdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IFxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgZXJyb3IgZm9yIGJyb3dzZXJcclxuXHR0YXVfdXNlcl9lcnJvciA9IHtcclxuXHRcdHB1dDogZnVuY3Rpb24oIHRleHQsIF8gKSB7XHJcblx0XHRcdChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKSggdGV4dCApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRmbHVzaDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBcclxuXHR9O1xyXG5cclxuXHQvLyBWaXJ0dWFsIGZpbGUgc3lzdGVtIGZvciBOb2RlLmpzXHJcblx0bm9kZWpzX2ZpbGVfc3lzdGVtID0ge1xyXG5cdFx0Ly8gT3BlbiBmaWxlXHJcblx0XHRvcGVuOiBmdW5jdGlvbiggcGF0aCwgdHlwZSwgbW9kZSApIHtcclxuXHRcdFx0dmFyIGZkLCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XHJcblx0XHRcdGlmKCBtb2RlID09PSBcInJlYWRcIiAmJiAhZnMuZXhpc3RzU3luYyggcGF0aCApIClcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRmZCA9IGZzLm9wZW5TeW5jKCBwYXRoLCBtb2RlWzBdICk7XHJcblx0XHRcdH0gY2F0Y2goZXgpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCBsZW5ndGgsIHBvc2l0aW9uICkge1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIoIGxlbmd0aCApO1xyXG5cdFx0XHRcdFx0ZnMucmVhZFN5bmMoIGZkLCBidWZmZXIsIDAsIGxlbmd0aCwgcG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdHZhciBlbmRfb2ZfZmlsZSA9IHRydWU7XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IGJ1ZmZlci50b1N0cmluZygpO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbmd0aCAmJiBlbmRfb2ZfZmlsZTsgaSsrKVxyXG5cdFx0XHRcdFx0XHRlbmRfb2ZfZmlsZSA9IHRleHRbaV0gPT09IFwiXFx1MDAwMFwiO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVuZF9vZl9maWxlID8gXCJlbmRfb2Zfc3RyZWFtXCIgOiBidWZmZXIudG9TdHJpbmcoKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGVvZjogZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0cyA9IGZzLnN0YXRTeW5jKHBhdGgpXHJcblx0XHRcdFx0XHRyZXR1cm4gcG9zaXRpb24gPT09IHN0YXRzW1wic2l6ZVwiXTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHB1dDogZnVuY3Rpb24oIHRleHQsIHBvc2l0aW9uICkge1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCB0ZXh0ICk7XHJcblx0XHRcdFx0XHRpZiggcG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiIClcclxuXHRcdFx0XHRcdFx0ZnMud3JpdGVTeW5jKCBmZCwgYnVmZmVyICk7XHJcblx0XHRcdFx0XHRlbHNlIGlmKCBwb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiApXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRmcy53cml0ZVN5bmMoIGZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGdldF9ieXRlOiBmdW5jdGlvbiggcG9zaXRpb24gKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHR2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEpO1xyXG5cdFx0XHRcdFx0XHR2YXIgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZmZlciwgMCwgMSwgcG9zaXRpb24pO1xyXG5cdFx0XHRcdFx0XHQvL3ZhciBfdGV4dCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgMCwgYnl0ZXNSZWFkKTtcclxuXHRcdFx0XHRcdFx0dmFyIGVuZF9vZl9maWxlID0gYnl0ZXNSZWFkIDwgMTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGVuZF9vZl9maWxlID8gXCJlbmRfb2Zfc3RyZWFtXCIgOiBidWZmZXIucmVhZFVJbnQ4KDApO1xyXG5cdFx0XHRcdFx0fSBjYXRjaChleCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCJlbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRwdXRfYnl0ZTogZnVuY3Rpb24oYnl0ZSwgcG9zaXRpb24pIHtcclxuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbShbYnl0ZV0pO1xyXG5cdFx0XHRcdFx0aWYocG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiKVxyXG5cdFx0XHRcdFx0XHRmcy53cml0ZVN5bmMoZmQsIGJ1ZmZlcik7XHJcblx0XHRcdFx0XHRlbHNlIGlmKHBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0ZnMud3JpdGVTeW5jKGZkLCBidWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGgsIHBvc2l0aW9uKTtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Zmx1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRjbG9zZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRmcy5jbG9zZVN5bmMoIGZkICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBpbnB1dCBmb3IgTm9kZS5qc1xyXG5cdG5vZGVqc191c2VyX2lucHV0ID0ge1xyXG5cdFx0YnVmZmVyOiBcIlwiLFxyXG5cdFx0Z2V0OiBmdW5jdGlvbiggbGVuZ3RoLCBfICkge1xyXG5cdFx0XHR2YXIgdGV4dDtcclxuXHRcdFx0dmFyIHJlYWRsaW5lU3luYyA9IHJlcXVpcmUoJ3JlYWRsaW5lLXN5bmMnKTtcclxuXHRcdFx0d2hpbGUoIG5vZGVqc191c2VyX2lucHV0LmJ1ZmZlci5sZW5ndGggPCBsZW5ndGggKVxyXG5cdFx0XHRcdG5vZGVqc191c2VyX2lucHV0LmJ1ZmZlciArPSByZWFkbGluZVN5bmMucXVlc3Rpb24oXCJcIiwge2tlZXBXaGl0ZXNwYWNlOiB0cnVlfSkgKyBcIlxcblwiO1xyXG5cdFx0XHR0ZXh0ID0gbm9kZWpzX3VzZXJfaW5wdXQuYnVmZmVyLnN1YnN0ciggMCwgbGVuZ3RoICk7XHJcblx0XHRcdG5vZGVqc191c2VyX2lucHV0LmJ1ZmZlciA9IG5vZGVqc191c2VyX2lucHV0LmJ1ZmZlci5zdWJzdHIoIGxlbmd0aCApO1xyXG5cdFx0XHRyZXR1cm4gdGV4dDtcclxuXHRcdH0sXHJcblx0XHRlb2Y6IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBvdXRwdXQgZm9yIE5vZGUuanNcclxuXHRub2RlanNfdXNlcl9vdXRwdXQgPSB7XHJcblx0XHRwdXQ6IGZ1bmN0aW9uKCB0ZXh0LCBfICkge1xyXG5cdFx0XHRwcm9jZXNzLnN0ZG91dC53cml0ZSggdGV4dCApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRmbHVzaDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgZXJyb3IgZm9yIE5vZGUuanNcclxuXHRub2RlanNfdXNlcl9lcnJvciA9IHtcclxuXHRcdHB1dDogZnVuY3Rpb24oIHRleHQsIF8gKSB7XHJcblx0XHRcdHByb2Nlc3Muc3RkZXJyLndyaXRlKCB0ZXh0ICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdGZsdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IFxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQ09NUEFUSVRCSUxJVFlcclxuXHRcclxuXHR2YXIgaW5kZXhPZjtcclxuXHRpZighQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcclxuXHRcdGluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgZWxlbSkge1xyXG5cdFx0XHR2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZihlbGVtID09PSBhcnJheVtpXSkgcmV0dXJuIGk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBlbGVtKSB7XHJcblx0XHRcdHJldHVybiBhcnJheS5pbmRleE9mKGVsZW0pO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHZhciByZWR1Y2UgPSBmdW5jdGlvbihhcnJheSwgZm4pIHtcclxuXHRcdGlmKGFycmF5Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdHZhciBlbGVtID0gYXJyYXlbMF07XHJcblx0XHR2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0Zm9yKHZhciBpID0gMTsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGVsZW0gPSBmbihlbGVtLCBhcnJheVtpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZWxlbTtcclxuXHR9O1xyXG5cclxuXHR2YXIgbWFwO1xyXG5cdGlmKCFBcnJheS5wcm90b3R5cGUubWFwKSB7XHJcblx0XHRtYXAgPSBmdW5jdGlvbihhcnJheSwgZm4pIHtcclxuXHRcdFx0dmFyIGEgPSBbXTtcclxuXHRcdFx0dmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0YS5wdXNoKCBmbihhcnJheVtpXSkgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdG1hcCA9IGZ1bmN0aW9uKGFycmF5LCBmbikge1xyXG5cdFx0XHRyZXR1cm4gYXJyYXkubWFwKGZuKTtcclxuXHRcdH07XHJcblx0fVxyXG5cdFxyXG5cdHZhciBmaWx0ZXI7XHJcblx0aWYoIUFycmF5LnByb3RvdHlwZS5maWx0ZXIpIHtcclxuXHRcdGZpbHRlciA9IGZ1bmN0aW9uKGFycmF5LCBmbikge1xyXG5cdFx0XHR2YXIgYSA9IFtdO1xyXG5cdFx0XHR2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZihmbihhcnJheVtpXSkpXHJcblx0XHRcdFx0XHRhLnB1c2goIGFycmF5W2ldICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmaWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgZm4pIHtcclxuXHRcdFx0cmV0dXJuIGFycmF5LmZpbHRlcihmbik7XHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgY29kZVBvaW50QXQ7XHJcblx0aWYoIVN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQpIHtcclxuXHRcdGNvZGVQb2ludEF0ID0gZnVuY3Rpb24oc3RyLCBpKSB7XHJcblx0XHRcdHJldHVybiBzdHIuY2hhckNvZGVBdChpKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGNvZGVQb2ludEF0ID0gZnVuY3Rpb24oc3RyLCBpKSB7XHJcblx0XHRcdHJldHVybiBzdHIuY29kZVBvaW50QXQoaSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZnJvbUNvZGVQb2ludDtcclxuXHRpZighU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcclxuXHRcdGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGZyb21Db2RlUG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dmFyIHN0cmluZ0xlbmd0aDtcclxuXHR2YXIgcmVnZXhBc3RyYWxTeW1ib2xzID0gL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZztcclxuXHRpZihBcnJheS5mcm9tKVxyXG5cdFx0c3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKHN0cikubGVuZ3RoO1xyXG5cdFx0fTtcclxuXHRlbHNlXHJcblx0XHRzdHJpbmdMZW5ndGggPSBmdW5jdGlvbihzdHIpIHtcclxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4QXN0cmFsU3ltYm9scywgJ18nKS5sZW5ndGg7XHJcblx0XHR9O1xyXG5cclxuXHRcclxuXHRcclxuXHQvLyBQQVJTRVJcclxuXHJcblx0dmFyIEVSUk9SID0gMDtcclxuXHR2YXIgU1VDQ0VTUyA9IDE7XHJcblxyXG5cdHZhciByZWdleF9lc2NhcGUgPSAvKFxcXFxhKXwoXFxcXGIpfChcXFxcZCl8KFxcXFxlKXwoXFxcXGYpfChcXFxcbil8KFxcXFxyKXwoXFxcXHMpfChcXFxcdCl8KFxcXFx2KXxcXFxceChbMC05YS1mQS1GXSspXFxcXHxcXFxcKFswLTddKylcXFxcfChcXFxcXFxcXCl8KFxcXFwnKXwoJycpfChcXFxcXCIpfChcXFxcYCl8KFxcXFwuKXwoLikvZztcclxuXHR2YXIgZXNjYXBlX21hcCA9IHtcIlxcXFxhXCI6IDcsIFwiXFxcXGJcIjogOCwgXCJcXFxcZFwiOiAxMjcsIFwiXFxcXGVcIjogMjcsIFwiXFxcXGZcIjogMTIsIFwiXFxcXG5cIjogMTAsIFwiXFxcXHJcIjogMTMsIFwiXFxcXHNcIjogMzIsIFwiXFxcXHRcIjogOSwgXCJcXFxcdlwiOiAxMX07XHJcblx0ZnVuY3Rpb24gZXNjYXBlKHN0cikge1xyXG5cdFx0dmFyIHN0YWNrID0gW107XHJcblx0XHR2YXIgX2Vycm9yID0gZmFsc2U7XHJcblx0XHRzdHIucmVwbGFjZShyZWdleF9lc2NhcGUsIGZ1bmN0aW9uKG1hdGNoLCBhLCBiLCBkLCBlLCBmLCBuLCByLCBzLCB0LCB2LCBoZXgsIG9jdGFsLCBiYWNrLCBzaW5nbGUsIGRzaW5nbGUsIGRvdWJsZSwgYmFja3F1b3RlLCBlcnJvciwgY2hhcikge1xyXG5cdFx0XHRzd2l0Y2godHJ1ZSkge1xyXG5cdFx0XHRcdGNhc2UgaGV4ICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKCBwYXJzZUludChoZXgsIDE2KSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRcdFx0Y2FzZSBvY3RhbCAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdFx0c3RhY2sucHVzaCggcGFyc2VJbnQob2N0YWwsIDgpICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0XHRjYXNlIGJhY2sgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRjYXNlIHNpbmdsZSAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdGNhc2UgZHNpbmdsZSAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdGNhc2UgZG91YmxlICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0Y2FzZSBiYWNrcXVvdGUgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIGNvZGVQb2ludEF0KG1hdGNoLnN1YnN0cigxKSwwKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRcdFx0Y2FzZSBjaGFyICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKCBjb2RlUG9pbnRBdChjaGFyLDApICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0XHRjYXNlIGVycm9yICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0XHRfZXJyb3IgPSB0cnVlO1xyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKGVzY2FwZV9tYXBbbWF0Y2hdKTtcclxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGlmKF9lcnJvcilcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRyZXR1cm4gc3RhY2s7XHJcblx0fVxyXG5cclxuXHQvLyBFc2NhcGUgYXRvbXNcclxuXHRmdW5jdGlvbiBlc2NhcGVBdG9tKHN0ciwgcXVvdGUpIHtcclxuXHRcdHZhciBhdG9tID0gJyc7XHJcblx0XHRpZiggc3RyID09PSBcIlxcXFxcIiApIHJldHVybiBudWxsO1xyXG5cdFx0aWYoIHN0ci5sZW5ndGggPCAyICkgcmV0dXJuIHN0cjtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKC8oKD86XFxcXFxcXFwpKyl8XFxcXChbMC03XSspXFxcXC9nLCBmdW5jdGlvbihtYXRjaCwgZzEsIGcyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGcxIHx8IGZyb21Db2RlUG9pbnQocGFyc2VJbnQoZzIsIDgpKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKC8oKD86XFxcXFxcXFwpKyl8XFxcXHgoWzAtOWEtZkEtRl0rKVxcXFwvZywgZnVuY3Rpb24obWF0Y2gsIGcxLCBnMikge1xyXG5cdFx0XHRcdHJldHVybiBnMSB8fCBmcm9tQ29kZVBvaW50KHBhcnNlSW50KGcyLCAxNikpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoLygoPzpcXFxcXFxcXCkrKXxcXFxcdShbMC05YS1mQS1GXXs0fSkvZywgZnVuY3Rpb24obWF0Y2gsIGcxLCBnMikge1xyXG5cdFx0XHRcdHJldHVybiBnMSB8fCBmcm9tQ29kZVBvaW50KHBhcnNlSW50KGcyLCAxNikpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gY2F0Y2goZXJyb3IpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgYSA9IHN0ci5jaGFyQXQoaSk7XHJcblx0XHRcdHZhciBiID0gc3RyLmNoYXJBdChpKzEpO1xyXG5cdFx0XHRpZiggYSA9PT0gcXVvdGUgJiYgYiA9PT0gcXVvdGUgKSB7XHJcblx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdGF0b20gKz0gcXVvdGU7XHJcblx0XHRcdH0gZWxzZSBpZiggYSA9PT0gJ1xcXFwnICkge1xyXG5cdFx0XHRcdGlmKCBbJ2EnLCdiJywnZicsJ24nLCdyJywndCcsJ3YnLFwiJ1wiLCdcIicsJ1xcXFwnLCdcXGEnLCdcXGInLCdcXGYnLCdcXG4nLCdcXHInLCdcXHQnLCdcXHYnXS5pbmRleE9mKGIpICE9PSAtMSApIHtcclxuXHRcdFx0XHRcdGkgKz0gMTtcclxuXHRcdFx0XHRcdHN3aXRjaCggYiApIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYSc6IGF0b20gKz0gJ1xcYSc7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdiJzogYXRvbSArPSAnXFxiJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2YnOiBhdG9tICs9ICdcXGYnOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnbic6IGF0b20gKz0gJ1xcbic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdyJzogYXRvbSArPSAnXFxyJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3QnOiBhdG9tICs9ICdcXHQnOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAndic6IGF0b20gKz0gJ1xcdic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiJ1wiOiBhdG9tICs9IFwiJ1wiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnXCInOiBhdG9tICs9ICdcIic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdcXFxcJzogYXRvbSArPSAnXFxcXCc7IGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YXRvbSArPSBhO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXRvbTtcclxuXHR9XHJcblx0XHJcblx0Ly8gUmVkbyBlc2NhcGVcclxuXHRmdW5jdGlvbiByZWRvRXNjYXBlKHN0cikge1xyXG5cdFx0dmFyIGF0b20gPSAnJztcclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHN3aXRjaCggc3RyLmNoYXJBdChpKSApIHtcclxuXHRcdFx0XHRjYXNlIFwiJ1wiOiBhdG9tICs9IFwiXFxcXCdcIjsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFxcXCc6IGF0b20gKz0gJ1xcXFxcXFxcJzsgYnJlYWs7XHJcblx0XHRcdFx0Ly9jYXNlICdcXGEnOiBhdG9tICs9ICdcXFxcYSc7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcYic6IGF0b20gKz0gJ1xcXFxiJzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFxmJzogYXRvbSArPSAnXFxcXGYnOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXG4nOiBhdG9tICs9ICdcXFxcbic7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xccic6IGF0b20gKz0gJ1xcXFxyJzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFx0JzogYXRvbSArPSAnXFxcXHQnOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXHYnOiBhdG9tICs9ICdcXFxcdic7IGJyZWFrO1xyXG5cdFx0XHRcdGRlZmF1bHQ6IGF0b20gKz0gc3RyLmNoYXJBdChpKTsgYnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhdG9tO1xyXG5cdH1cclxuXHJcblx0Ly8gU3RyaW5nIHRvIG51bVxyXG5cdGZ1bmN0aW9uIGNvbnZlcnROdW0obnVtKSB7XHJcblx0XHR2YXIgbiA9IG51bS5zdWJzdHIoMik7XHJcblx0XHRzd2l0Y2gobnVtLnN1YnN0cigwLDIpLnRvTG93ZXJDYXNlKCkpIHtcclxuXHRcdFx0Y2FzZSBcIjB4XCI6XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG4sIDE2KTtcclxuXHRcdFx0Y2FzZSBcIjBiXCI6XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG4sIDIpO1xyXG5cdFx0XHRjYXNlIFwiMG9cIjpcclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQobiwgOCk7XHJcblx0XHRcdGNhc2UgXCIwJ1wiOlxyXG5cdFx0XHRcdHJldHVybiBlc2NhcGUobilbMF07XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlRmxvYXQobnVtKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIElzIGdyYXBoaWMgdG9rZW5cclxuXHRmdW5jdGlvbiBpc19ncmFwaGljX3Rva2VuKHN0cmluZykge1xyXG5cdFx0cmV0dXJuIC9eWyNcXCRcXCZcXCpcXCtcXC1cXC5cXC9cXDpcXDxcXD1cXD5cXD9cXEBcXF5cXH5cXFxcXSsvLnRlc3Qoc3RyaW5nKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHRva2Vuc1xyXG5cdHZhciBydWxlcyA9IHtcclxuXHRcdHdoaXRlc3BhY2U6IC9eXFxzKig/Oig/OiUuKil8KD86XFwvXFwqKD86XFxufFxccnwuKSo/KD86XFwqXFwvfCQpKXwoPzpcXHMrKSlcXHMqLyxcclxuXHRcdHZhcmlhYmxlOiAvXig/OltBLVpfXVthLXpBLVowLTlfXSopLyxcclxuXHRcdGF0b206IC9eKFxcIXwsfDt8W2Etel1bMC05YS16QS1aX10qfFsjXFwkXFwmXFwqXFwrXFwtXFwuXFwvXFw6XFw8XFw9XFw+XFw/XFxAXFxeXFx+XFxcXF0rfCcoPzooPzonJyl8KD86XFxcXFxcXFwpfCg/OlxcXFwnKXxbXiddKSonKS8sXHJcblx0XHRudW1iZXI6IC9eKD86MG9bMC03XSt8MHhbMC05YS1mQS1GXSt8MGJbMDFdK3wwJyg/OicnfFxcXFxbYWJkZWZucnN0dlxcXFwnXCJgXXxcXFxceD9cXGQrXFxcXHxbXlxcXFxdKXxcXGQrKD86XFwuXFxkKyg/OltlRV1bKy1dP1xcZCspPyk/KS8sXHJcblx0XHRzdHJpbmc6IC9eKD86XCIoW15cIl18XCJcInxcXFxcXCIpKlwifGAoW15gXXxgYHxcXFxcYCkqYCkvLFxyXG5cdFx0bF9icmFjZTogL14oPzpcXFspLyxcclxuXHRcdHJfYnJhY2U6IC9eKD86XFxdKS8sXHJcblx0XHRsX2JyYWNrZXQ6IC9eKD86XFx7KS8sXHJcblx0XHRyX2JyYWNrZXQ6IC9eKD86XFx9KS8sXHJcblx0XHRiYXI6IC9eKD86XFx8KS8sXHJcblx0XHRsX3BhcmVuOiAvXig/OlxcKCkvLFxyXG5cdFx0cl9wYXJlbjogL14oPzpcXCkpL1xyXG5cdH07XHJcblxyXG5cdC8vIFJlcGxhY2UgY2hhcnMgb2YgY2hhcl9jb252ZXJzaW9uIHNlc3Npb25cclxuXHRmdW5jdGlvbiByZXBsYWNlKCB0aHJlYWQsIHRleHQgKSB7XHJcblx0XHRpZiggdGhyZWFkLmdldF9mbGFnKCBcImNoYXJfY29udmVyc2lvblwiICkuaWQgPT09IFwib25cIiApIHtcclxuXHRcdFx0cmV0dXJuIHRleHQucmVwbGFjZSgvLi9nLCBmdW5jdGlvbihjaGFyKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRocmVhZC5nZXRfY2hhcl9jb252ZXJzaW9uKCBjaGFyICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRleHQ7XHJcblx0fVxyXG5cclxuXHQvLyBUb2tlbml6ZSBzdHJpbmdzXHJcblx0ZnVuY3Rpb24gVG9rZW5pemVyKHRocmVhZCkge1xyXG5cdFx0dGhpcy50aHJlYWQgPSB0aHJlYWQ7XHJcblx0XHR0aGlzLnRleHQgPSBcIlwiOyAvLyBDdXJyZW50IHRleHQgdG8gYmUgYW5hbGl6ZWRcclxuXHRcdHRoaXMudG9rZW5zID0gW107IC8vIENvbnN1bWVkIHRva2Vuc1xyXG5cdH1cclxuXHJcblx0VG9rZW5pemVyLnByb3RvdHlwZS5zZXRfbGFzdF90b2tlbnMgPSBmdW5jdGlvbih0b2tlbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRva2VucyA9IHRva2VucztcclxuXHR9O1xyXG5cclxuXHRUb2tlbml6ZXIucHJvdG90eXBlLm5ld190ZXh0ID0gZnVuY3Rpb24odGV4dCkge1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHRcdHRoaXMudG9rZW5zID0gW107XHJcblx0fTtcclxuXHJcblx0VG9rZW5pemVyLnByb3RvdHlwZS5nZXRfdG9rZW5zID0gZnVuY3Rpb24oaW5pdCkge1xyXG5cdFx0dmFyIHRleHQ7XHJcblx0XHR2YXIgbGVuID0gMDsgLy8gVG90YWwgbGVuZ3RoIHJlc3BlY3QgdG8gdGV4dFxyXG5cdFx0dmFyIGxpbmUgPSAwO1xyXG5cdFx0dmFyIHN0YXJ0ID0gMDtcclxuXHRcdHZhciB0b2tlbnMgPSBbXTtcclxuXHRcdHZhciBsYXN0X2lzX2JsYW5rO1xyXG5cclxuXHRcdGlmKGluaXQpIHtcclxuXHRcdFx0dmFyIHRva2VuID0gdGhpcy50b2tlbnNbaW5pdC0xXTtcclxuXHRcdFx0bGVuID0gdG9rZW4ubGVuO1xyXG5cdFx0XHR0ZXh0ID0gcmVwbGFjZSggdGhpcy50aHJlYWQsIHRoaXMudGV4dC5zdWJzdHIodG9rZW4ubGVuKSApO1xyXG5cdFx0XHRsaW5lID0gdG9rZW4ubGluZTtcclxuXHRcdFx0c3RhcnQgPSB0b2tlbi5zdGFydDtcclxuXHRcdH1cclxuXHRcdGVsc2VcclxuXHRcdFx0dGV4dCA9IHRoaXMudGV4dDtcclxuXHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUgaXMgbm90aGluZyB0byBiZSBhbmFsaXplZCwgcmV0dXJuIG51bGxcclxuXHRcdGlmKC9eXFxzKiQvLnRlc3QodGV4dCkpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdHdoaWxlKHRleHQgIT09IFwiXCIpIHtcclxuXHRcdFx0dmFyIG1hdGNoZXMgPSBbXTtcclxuXHRcdFx0bGFzdF9pc19ibGFuayA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYoL15cXG4vLmV4ZWModGV4dCkgIT09IG51bGwpIHtcclxuXHRcdFx0XHRsaW5lKys7XHJcblx0XHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0XHRcdGxlbisrO1xyXG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi8sIFwiXCIpO1xyXG5cdFx0XHRcdGxhc3RfaXNfYmxhbmsgPSB0cnVlO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IodmFyIHJ1bGUgaW4gcnVsZXMpIHtcclxuXHRcdFx0XHRpZihydWxlcy5oYXNPd25Qcm9wZXJ0eShydWxlKSkge1xyXG5cdFx0XHRcdFx0dmFyIG1hdGNocyA9IHJ1bGVzW3J1bGVdLmV4ZWMoIHRleHQgKTtcclxuXHRcdFx0XHRcdGlmKG1hdGNocykge1xyXG5cdFx0XHRcdFx0XHRtYXRjaGVzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBtYXRjaHNbMF0sXHJcblx0XHRcdFx0XHRcdFx0bmFtZTogcnVsZSxcclxuXHRcdFx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaHNcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBMZXhpY2FsIGVycm9yXHJcblx0XHRcdGlmKCFtYXRjaGVzLmxlbmd0aClcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zZXRfbGFzdF90b2tlbnMoIFt7IHZhbHVlOiB0ZXh0LCBtYXRjaGVzOiBbXSwgbmFtZTogXCJsZXhpY2FsXCIsIGxpbmU6IGxpbmUsIHN0YXJ0OiBzdGFydCB9XSApO1xyXG5cclxuXHRcdFx0dmFyIHRva2VuID0gcmVkdWNlKCBtYXRjaGVzLCBmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRcdFx0cmV0dXJuIGEudmFsdWUubGVuZ3RoID49IGIudmFsdWUubGVuZ3RoID8gYSA6IGI7XHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHRcdHRva2VuLnN0YXJ0ID0gc3RhcnQ7XHJcblx0XHRcdHRva2VuLmxpbmUgPSBsaW5lO1xyXG5cclxuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSh0b2tlbi52YWx1ZSwgXCJcIik7XHJcblx0XHRcdHN0YXJ0ICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcclxuXHRcdFx0bGVuICs9IHRva2VuLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdHZhciBubCA9ICh0b2tlbi52YWx1ZS5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XHJcblx0XHRcdGxpbmUgKz0gbmw7XHJcblx0XHRcdGlmKG5sID4gMCkgXHJcblx0XHRcdFx0c3RhcnQgPSB0b2tlbi52YWx1ZS5sZW5ndGggLSB0b2tlbi52YWx1ZS5sYXN0SW5kZXhPZihcIlxcblwiKSAtIDE7XHJcblx0XHRcdHRva2VuLmxpbmVfY291bnQgPSBsaW5lO1xyXG5cdFx0XHR0b2tlbi5saW5lX3Bvc2l0aW9uID0gc3RhcnQ7XHJcblxyXG5cdFx0XHRzd2l0Y2godG9rZW4ubmFtZSkge1xyXG5cdFx0XHRcdGNhc2UgXCJhdG9tXCI6XHJcblx0XHRcdFx0XHR0b2tlbi5yYXcgPSB0b2tlbi52YWx1ZTtcclxuXHRcdFx0XHRcdGlmKHRva2VuLnZhbHVlLmNoYXJBdCgwKSA9PT0gXCInXCIpIHtcclxuXHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBlc2NhcGVBdG9tKCB0b2tlbi52YWx1ZS5zdWJzdHJpbmcoMSwgdG9rZW4udmFsdWUubGVuZ3RoIC0gMSksIFwiJ1wiICk7XHJcblx0XHRcdFx0XHRcdGlmKCB0b2tlbi52YWx1ZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0XHR0b2tlbi5uYW1lID0gXCJsZXhpY2FsXCI7XHJcblx0XHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSB0b2tlbi5yYXc7XHJcblx0XHRcdFx0XHRcdFx0dG9rZW4uZXJyb3IgPSBcInVua25vd25fZXNjYXBlX3NlcXVlbmNlXCI7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJudW1iZXJcIjpcclxuXHRcdFx0XHRcdHZhciBzdWJzdHIgPSB0b2tlbi52YWx1ZS5zdWJzdHJpbmcoMCwyKTtcclxuXHRcdFx0XHRcdHRva2VuLnJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdFx0XHRcdFx0dG9rZW4uZmxvYXQgPSBzdWJzdHIgIT09IFwiMHhcIiAmJiBzdWJzdHIgIT09IFwiMCdcIiAmJiB0b2tlbi52YWx1ZS5tYXRjaCgvWy5lRV0vKSAhPT0gbnVsbDtcclxuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gY29udmVydE51bSggdG9rZW4udmFsdWUgKTtcclxuXHRcdFx0XHRcdHRva2VuLmJsYW5rID0gbGFzdF9pc19ibGFuaztcclxuXHRcdFx0XHRcdGlmKCF0b2tlbi5mbG9hdCAmJiBwbC5mbGFnLmJvdW5kZWQudmFsdWUuaW5kaWNhdG9yID09PSBcInRydWUvMFwiICYmIHRva2VuLnZhbHVlID4gcGwuZmxhZy5tYXhfaW50ZWdlci52YWx1ZS52YWx1ZSkge1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5uYW1lID0gXCJsZXhpY2FsXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdG9rZW4ucmF3O1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5lcnJvciA9IFwiaW50X292ZXJmbG93XCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XHJcblx0XHRcdFx0XHR2YXIgZGVsID0gdG9rZW4udmFsdWUuY2hhckF0KDApO1xyXG5cdFx0XHRcdFx0dG9rZW4ucmF3ID0gdG9rZW4udmFsdWU7XHJcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IGVzY2FwZUF0b20oIHRva2VuLnZhbHVlLnN1YnN0cmluZygxLCB0b2tlbi52YWx1ZS5sZW5ndGggLSAxKSwgZGVsICk7XHJcblx0XHRcdFx0XHRpZiggdG9rZW4udmFsdWUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRva2VuLm5hbWUgPSBcImxleGljYWxcIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSB0b2tlbi5yYXc7XHJcblx0XHRcdFx0XHRcdHRva2VuLmVycm9yID0gXCJ1bmtub3duX2VzY2FwZV9zZXF1ZW5jZVwiXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwid2hpdGVzcGFjZVwiOlxyXG5cdFx0XHRcdFx0dmFyIGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXTtcclxuXHRcdFx0XHRcdGlmKGxhc3QpIGxhc3Quc3BhY2UgPSB0cnVlO1xyXG5cdFx0XHRcdFx0bGFzdF9pc19ibGFuayA9IHRydWU7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRjYXNlIFwicl9icmFja2V0XCI6XHJcblx0XHRcdFx0XHRpZiggdG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0ubmFtZSA9PT0gXCJsX2JyYWNrZXRcIiApIHtcclxuXHRcdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMucG9wKCk7XHJcblx0XHRcdFx0XHRcdHRva2VuLm5hbWUgPSBcImF0b21cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBcInt9XCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnJhdyA9IFwie31cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4uc3BhY2UgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJyX2JyYWNlXCI6XHJcblx0XHRcdFx0XHRpZiggdG9rZW5zLmxlbmd0aCA+IDAgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0ubmFtZSA9PT0gXCJsX2JyYWNlXCIgKSB7XHJcblx0XHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5uYW1lID0gXCJhdG9tXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gXCJbXVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5yYXcgPSBcIltdXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnNwYWNlID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHR0b2tlbi5sZW4gPSBsZW47XHJcblx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xyXG5cdFx0XHRsYXN0X2lzX2JsYW5rID0gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHQgPSB0aGlzLnNldF9sYXN0X3Rva2VucyggdG9rZW5zICk7XHJcblx0XHRyZXR1cm4gdC5sZW5ndGggPT09IDAgPyBudWxsIDogdDtcclxuXHR9O1xyXG5cclxuXHQvLyBQYXJzZSBhbiBleHByZXNzaW9uXHJcblx0ZnVuY3Rpb24gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgcHJpb3JpdHksIHRvcGxldmVsKSB7XHJcblx0XHRpZighdG9rZW5zW3N0YXJ0XSkgcmV0dXJuIHt0eXBlOiBFUlJPUiwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQtMV0sIFwiZXhwcmVzc2lvbiBleHBlY3RlZFwiLCB0cnVlKX07XHJcblx0XHR2YXIgZXJyb3I7XHJcblxyXG5cdFx0aWYocHJpb3JpdHkgPT09IFwiMFwiKSB7XHJcblx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tzdGFydF07XHJcblx0XHRcdHN3aXRjaCh0b2tlbi5uYW1lKSB7XHJcblx0XHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0KzEsIHZhbHVlOiBuZXcgcGwudHlwZS5OdW0odG9rZW4udmFsdWUsIHRva2VuLmZsb2F0KX07XHJcblx0XHRcdFx0Y2FzZSBcInZhcmlhYmxlXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQrMSwgdmFsdWU6IG5ldyBwbC50eXBlLlZhcih0b2tlbi52YWx1ZSl9O1xyXG5cdFx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcclxuXHRcdFx0XHRcdHZhciBzdHI7XHJcblx0XHRcdFx0XHRzd2l0Y2goIHRocmVhZC5nZXRfZmxhZyggXCJkb3VibGVfcXVvdGVzXCIgKS5pZCApIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSBcImF0b21cIjo7XHJcblx0XHRcdFx0XHRcdFx0c3RyID0gbmV3IFRlcm0oIHRva2VuLnZhbHVlLCBbXSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiY29kZXNcIjpcclxuXHRcdFx0XHRcdFx0XHRzdHIgPSBuZXcgVGVybSggXCJbXVwiLCBbXSApO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IHRva2VuLnZhbHVlLmxlbmd0aC0xOyBpID49IDA7IGktLSApXHJcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgcGwudHlwZS5OdW0oIGNvZGVQb2ludEF0KHRva2VuLnZhbHVlLGkpLCBmYWxzZSApLCBzdHJdICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJjaGFyc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHN0ciA9IG5ldyBUZXJtKCBcIltdXCIsIFtdICk7XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gdG9rZW4udmFsdWUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tIClcclxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBwbC50eXBlLlRlcm0oIHRva2VuLnZhbHVlLmNoYXJBdChpKSwgW10gKSwgc3RyXSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0KzEsIHZhbHVlOiBzdHJ9O1xyXG5cdFx0XHRcdGNhc2UgXCJsX3BhcmVuXCI6XHJcblx0XHRcdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQrMSwgdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmKGV4cHIudHlwZSAhPT0gU1VDQ0VTUykgcmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRpZih0b2tlbnNbZXhwci5sZW5dICYmIHRva2Vuc1tleHByLmxlbl0ubmFtZSA9PT0gXCJyX3BhcmVuXCIpIHtcclxuXHRcdFx0XHRcdFx0ZXhwci5sZW4rKztcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tleHByLmxlbl0gPyB0b2tlbnNbZXhwci5sZW5dIDogdG9rZW5zW2V4cHIubGVuLTFdLCBcIikgb3Igb3BlcmF0b3IgZXhwZWN0ZWRcIiwgIXRva2Vuc1tleHByLmxlbl0pfVxyXG5cdFx0XHRcdGNhc2UgXCJsX2JyYWNrZXRcIjpcclxuXHRcdFx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCsxLCB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCksIHRydWUpO1xyXG5cdFx0XHRcdFx0aWYoZXhwci50eXBlICE9PSBTVUNDRVNTKSByZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdGlmKHRva2Vuc1tleHByLmxlbl0gJiYgdG9rZW5zW2V4cHIubGVuXS5uYW1lID09PSBcInJfYnJhY2tldFwiKSB7XHJcblx0XHRcdFx0XHRcdGV4cHIubGVuKys7XHJcblx0XHRcdFx0XHRcdGV4cHIudmFsdWUgPSBuZXcgVGVybSggXCJ7fVwiLCBbZXhwci52YWx1ZV0gKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tleHByLmxlbl0gPyB0b2tlbnNbZXhwci5sZW5dIDogdG9rZW5zW2V4cHIubGVuLTFdLCBcIn0gb3Igb3BlcmF0b3IgZXhwZWN0ZWRcIiwgIXRva2Vuc1tleHByLmxlbl0pfVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIENvbXBvdW5kIHRlcm1cclxuXHRcdFx0dmFyIHJlc3VsdCA9IHBhcnNlVGVybSh0aHJlYWQsIHRva2Vucywgc3RhcnQsIHRvcGxldmVsKTtcclxuXHRcdFx0aWYocmVzdWx0LnR5cGUgPT09IFNVQ0NFU1MgfHwgcmVzdWx0LmRlcml2ZWQpXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0Ly8gTGlzdFxyXG5cdFx0XHRyZXN1bHQgPSBwYXJzZUxpc3QodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KTtcclxuXHRcdFx0aWYocmVzdWx0LnR5cGUgPT09IFNVQ0NFU1MgfHwgcmVzdWx0LmRlcml2ZWQpXHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdFx0Ly8gVW5leHBlY3RlZFxyXG5cdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiBmYWxzZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdLCB0b2tlbi5lcnJvciB8fCBcInVuZXhwZWN0ZWQgdG9rZW5cIil9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtYXhfcHJpb3JpdHkgPSB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCk7XHJcblx0XHR2YXIgbmV4dF9wcmlvcml0eSA9IHRocmVhZC5fX2dldF9uZXh0X3ByaW9yaXR5KHByaW9yaXR5KTtcclxuXHRcdHZhciBhdXhfc3RhcnQgPSBzdGFydDtcclxuXHRcdFxyXG5cdFx0Ly8gUHJlZml4IG9wZXJhdG9yc1xyXG5cdFx0aWYodG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnQrMV0gJiYgKHRva2Vuc1tzdGFydF0uc3BhY2UgfHwgdG9rZW5zW3N0YXJ0KzFdLm5hbWUgIT09IFwibF9wYXJlblwiKSkge1xyXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbc3RhcnQrK107XHJcblx0XHRcdHZhciBjbGFzc2VzID0gdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIHRva2VuLnZhbHVlKTtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEFzc29jaWF0aXZlIHByZWZpeCBvcGVyYXRvclxyXG5cdFx0XHRpZihjbGFzc2VzICYmIGNsYXNzZXMuaW5kZXhPZihcImZ5XCIpID4gLTEpIHtcclxuXHRcdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQsIHByaW9yaXR5LCB0b3BsZXZlbCk7XHJcblx0XHRcdFx0aWYoZXhwci50eXBlICE9PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0aWYoIHRva2VuLnZhbHVlID09PSBcIi1cIiAmJiAhdG9rZW4uc3BhY2UgJiYgcGwudHlwZS5pc19udW1iZXIoIGV4cHIudmFsdWUgKSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuTnVtKC1leHByLnZhbHVlLnZhbHVlLCBleHByLnZhbHVlLmlzX2Zsb2F0KSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IGV4cHIubGVuLFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBleHByLmxlbixcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGVycm9yID0gZXhwcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdC8vIE5vbi1hc3NvY2lhdGl2ZSBwcmVmaXggb3BlcmF0b3JcclxuXHRcdFx0fSBlbHNlIGlmKGNsYXNzZXMgJiYgY2xhc3Nlcy5pbmRleE9mKFwiZnhcIikgPiAtMSkge1xyXG5cdFx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgbmV4dF9wcmlvcml0eSwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRcdGlmKGV4cHIudHlwZSAhPT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRsZW46IGV4cHIubGVuLFxyXG5cdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRlcnJvciA9IGV4cHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhcnQgPSBhdXhfc3RhcnQ7XHJcblx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQsIG5leHRfcHJpb3JpdHksIHRvcGxldmVsKTtcclxuXHRcdGlmKGV4cHIudHlwZSA9PT0gU1VDQ0VTUykge1xyXG5cdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbc3RhcnRdO1xyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIChcclxuXHRcdFx0XHR0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCB0b2tlbi52YWx1ZSkgfHxcclxuXHRcdFx0XHR0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYmFyXCIgJiYgdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIFwifFwiKVxyXG5cdFx0XHQpICkge1xyXG5cdFx0XHRcdHZhciBuZXh0X3ByaW9yaXR5X2x0ID0gbmV4dF9wcmlvcml0eTtcclxuXHRcdFx0XHR2YXIgbmV4dF9wcmlvcml0eV9lcSA9IHByaW9yaXR5O1xyXG5cdFx0XHRcdHZhciBjbGFzc2VzID0gdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIHRva2VuLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0aWYoY2xhc3Nlcy5pbmRleE9mKFwieGZcIikgPiAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdGxlbjogKytleHByLmxlbixcclxuXHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoY2xhc3Nlcy5pbmRleE9mKFwieGZ4XCIpID4gLTEpIHtcclxuXHRcdFx0XHRcdHZhciBleHByMiA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQgKyAxLCBuZXh0X3ByaW9yaXR5X2x0LCB0b3BsZXZlbCk7XHJcblx0XHRcdFx0XHRpZihleHByMi50eXBlID09PSBTVUNDRVNTKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlLCBleHByMi52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogZXhwcjIubGVuLFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGV4cHIyLmRlcml2ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKGNsYXNzZXMuaW5kZXhPZihcInhmeVwiKSA+IC0xKSB7XHJcblx0XHRcdFx0XHR2YXIgZXhwcjIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0ICsgMSwgbmV4dF9wcmlvcml0eV9lcSwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRcdFx0aWYoZXhwcjIudHlwZSA9PT0gU1VDQ0VTUykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZSwgZXhwcjIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IGV4cHIyLmxlbixcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRleHByMi5kZXJpdmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHIyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZihleHByLnR5cGUgIT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHR3aGlsZSh0cnVlKSB7XHJcblx0XHRcdFx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdFx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tzdGFydF07XHJcblx0XHRcdFx0XHRcdGlmKHRva2VuICYmIHRva2VuLm5hbWUgPT09IFwiYXRvbVwiICYmIHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCB0b2tlbi52YWx1ZSkpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCB0b2tlbi52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoIGNsYXNzZXMuaW5kZXhPZihcInlmXCIpID4gLTEgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRleHByID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGVuOiArK3N0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiggY2xhc3Nlcy5pbmRleE9mKFwieWZ4XCIpID4gLTEgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXhwcjIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsICsrc3RhcnQsIG5leHRfcHJpb3JpdHlfbHQsIHRvcGxldmVsKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKGV4cHIyLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGV4cHIyLmRlcml2ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjI7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IGV4cHIyLmxlbjtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cHIgPSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZSwgZXhwcjIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGVuOiBzdGFydCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgeyBicmVhazsgfVxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgeyBicmVhazsgfVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRlcnJvciA9IHt0eXBlOiBFUlJPUiwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbZXhwci5sZW4tMV0sIFwib3BlcmF0b3IgZXhwZWN0ZWRcIil9O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV4cHI7XHJcblx0fVxyXG5cclxuXHQvLyBQYXJzZSBhIGNvbXBvdW5kIHRlcm1cclxuXHRmdW5jdGlvbiBwYXJzZVRlcm0odGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCB0b3BsZXZlbCkge1xyXG5cdFx0aWYoIXRva2Vuc1tzdGFydF0gfHwgKHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0XS5yYXcgPT09IFwiLlwiICYmICF0b3BsZXZlbCAmJiAodG9rZW5zW3N0YXJ0XS5zcGFjZSB8fCAhdG9rZW5zW3N0YXJ0KzFdIHx8IHRva2Vuc1tzdGFydCsxXS5uYW1lICE9PSBcImxfcGFyZW5cIikpKVxyXG5cdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiBmYWxzZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQtMV0sIFwidW5mb3VuZGVkIHRva2VuXCIpfTtcclxuXHRcdHZhciBhdG9tID0gdG9rZW5zW3N0YXJ0XTtcclxuXHRcdHZhciBleHBycyA9IFtdO1xyXG5cdFx0aWYodG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnRdLnJhdyAhPT0gXCIsXCIpIHtcclxuXHRcdFx0c3RhcnQrKztcclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0LTFdLnNwYWNlKSByZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQsIHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKGF0b20udmFsdWUsIGV4cHJzKX07XHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImxfcGFyZW5cIikge1xyXG5cdFx0XHRcdGlmKHRva2Vuc1tzdGFydCsxXSAmJiB0b2tlbnNbc3RhcnQrMV0ubmFtZSA9PT0gXCJyX3BhcmVuXCIpIFxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQrMV0sIFwiYXJndW1lbnQgZXhwZWN0ZWRcIil9O1xyXG5cdFx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCArK3N0YXJ0LCBcIjk5OVwiLCB0cnVlKTtcclxuXHRcdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRpZiggZXhwci5kZXJpdmVkIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSA/IHRva2Vuc1tzdGFydF0gOiB0b2tlbnNbc3RhcnQtMV0sIFwiYXJndW1lbnQgZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydF0pfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZXhwcnMucHVzaChleHByLnZhbHVlKTtcclxuXHRcdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHRcdHdoaWxlKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnRdLnZhbHVlID09PSBcIixcIikge1xyXG5cdFx0XHRcdFx0ZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQrMSwgXCI5OTlcIiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRcdGlmKCBleHByLmRlcml2ZWQgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQrMV0gPyB0b2tlbnNbc3RhcnQrMV0gOiB0b2tlbnNbc3RhcnRdLCBcImFyZ3VtZW50IGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnQrMV0pfTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGV4cHJzLnB1c2goZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJyX3BhcmVuXCIpIHN0YXJ0Kys7XHJcblx0XHRcdFx0ZWxzZSByZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0gPyB0b2tlbnNbc3RhcnRdIDogdG9rZW5zW3N0YXJ0LTFdLCBcIiwgb3IgKSBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0XSl9O1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCwgdmFsdWU6IG5ldyBwbC50eXBlLlRlcm0oYXRvbS52YWx1ZSwgZXhwcnMpfTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IGZhbHNlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0sIFwidGVybSBleHBlY3RlZFwiKX07XHJcblx0fVxyXG5cclxuXHQvLyBQYXJzZSBhIGxpc3RcclxuXHRmdW5jdGlvbiBwYXJzZUxpc3QodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KSB7XHJcblx0XHRpZighdG9rZW5zW3N0YXJ0XSkgXHJcblx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IGZhbHNlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydC0xXSwgXCJbIGV4cGVjdGVkXCIpfTtcclxuXHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImxfYnJhY2VcIikge1xyXG5cdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2VucywgKytzdGFydCwgXCI5OTlcIiwgdHJ1ZSk7XHJcblx0XHRcdHZhciBleHBycyA9IFtleHByLnZhbHVlXTtcclxuXHRcdFx0dmFyIGNvbnMgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwicl9icmFjZVwiKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQrMSwgdmFsdWU6IG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSl9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0sIFwiXSBleHBlY3RlZFwiKX07XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblxyXG5cdFx0XHR3aGlsZSh0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0XS52YWx1ZSA9PT0gXCIsXCIpIHtcclxuXHRcdFx0XHRleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCsxLCBcIjk5OVwiLCB0cnVlKTtcclxuXHRcdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRpZiggZXhwci5kZXJpdmVkIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0KzFdID8gdG9rZW5zW3N0YXJ0KzFdIDogdG9rZW5zW3N0YXJ0XSwgXCJhcmd1bWVudCBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0KzFdKX07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGV4cHJzLnB1c2goZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgYmFyID0gZmFsc2VcclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYmFyXCIpIHtcclxuXHRcdFx0XHRiYXIgPSB0cnVlO1xyXG5cdFx0XHRcdGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KzEsIFwiOTk5XCIsIHRydWUpO1xyXG5cdFx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdGlmKCBleHByLmRlcml2ZWQgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQrMV0gPyB0b2tlbnNbc3RhcnQrMV0gOiB0b2tlbnNbc3RhcnRdLCBcImFyZ3VtZW50IGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnQrMV0pfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y29ucyA9IGV4cHIudmFsdWU7XHJcblx0XHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJyX2JyYWNlXCIpXHJcblx0XHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0KzEsIHZhbHVlOiBhcnJheVRvTGlzdChleHBycywgY29ucykgfTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSA/IHRva2Vuc1tzdGFydF0gOiB0b2tlbnNbc3RhcnQtMV0sIGJhciA/IFwiXSBleHBlY3RlZFwiIDogXCIsIG9yIHwgb3IgXSBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0XSl9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogZmFsc2UsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSwgXCJsaXN0IGV4cGVjdGVkXCIpfTtcclxuXHR9XHJcblxyXG5cdC8vIFBhcnNlIGEgcnVsZVxyXG5cdGZ1bmN0aW9uIHBhcnNlUnVsZSh0aHJlYWQsIHRva2Vucywgc3RhcnQpIHtcclxuXHRcdHZhciBsaW5lID0gdG9rZW5zW3N0YXJ0XS5saW5lO1xyXG5cdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCksIGZhbHNlKTtcclxuXHRcdHZhciBydWxlID0gbnVsbDtcclxuXHRcdHZhciBvYmo7XHJcblx0XHRpZihleHByLnR5cGUgIT09IEVSUk9SKSB7XHJcblx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnRdLnJhdyA9PT0gXCIuXCIpIHtcclxuXHRcdFx0XHRzdGFydCsrO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oZXhwci52YWx1ZSkgKSB7XHJcblx0XHRcdFx0XHRpZihleHByLnZhbHVlLmluZGljYXRvciA9PT0gXCI6LS8yXCIpIHtcclxuXHRcdFx0XHRcdFx0cnVsZSA9IG5ldyBwbC50eXBlLlJ1bGUoZXhwci52YWx1ZS5hcmdzWzBdLCBib2R5X2NvbnZlcnNpb24oZXhwci52YWx1ZS5hcmdzWzFdKSk7XHJcblx0XHRcdFx0XHRcdG9iaiA9IHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogcnVsZSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihleHByLnZhbHVlLmluZGljYXRvciA9PT0gXCItLT4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdHJ1bGUgPSBuZXcgcGwudHlwZS5SdWxlKGV4cHIudmFsdWUuYXJnc1swXSwgYm9keV9jb252ZXJzaW9uKGV4cHIudmFsdWUuYXJnc1sxXSkpO1xyXG5cdFx0XHRcdFx0XHRydWxlID0gcnVsZV90b19kY2cocnVsZSwgdGhyZWFkKTtcclxuXHRcdFx0XHRcdFx0cnVsZS5ib2R5ID0gYm9keV9jb252ZXJzaW9uKHJ1bGUuYm9keSk7XHJcblx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3J1bGUocnVsZSkpXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBydWxlLFxyXG5cdFx0XHRcdFx0XHRcdFx0bGVuOiBzdGFydCxcclxuXHRcdFx0XHRcdFx0XHRcdHR5cGU6IEVSUk9SXHJcblx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0b2JqID0ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBydWxlLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogcGwudHlwZS5pc19ydWxlKCBydWxlICkgPyBTVUNDRVNTIDogRVJST1JcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJ1bGUgPSBuZXcgcGwudHlwZS5SdWxlKGV4cHIudmFsdWUsIG51bGwpO1xyXG5cdFx0XHRcdFx0XHRvYmogPSB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHJ1bGUsXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBzdGFydCxcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggcnVsZSApIHtcclxuXHRcdFx0XHRcdFx0dmFyIHNpbmdsZXRvbiA9IHJ1bGUuc2luZ2xldG9uX3ZhcmlhYmxlcygpO1xyXG5cdFx0XHRcdFx0XHRpZiggc2luZ2xldG9uLmxlbmd0aCA+IDAgKVxyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC53YXJuaW5nLnNpbmdsZXRvbiggc2luZ2xldG9uLCBydWxlLmhlYWQuaW5kaWNhdG9yLCBsaW5lICkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBvYmo7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiB7IHR5cGU6IEVSUk9SLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0sIFwiY2FsbGFibGUgZXhwZWN0ZWRcIikgfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHsgdHlwZTogRVJST1IsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSA/IHRva2Vuc1tzdGFydF0gOiB0b2tlbnNbc3RhcnQtMV0sIFwiLiBvciBvcGVyYXRvciBleHBlY3RlZFwiKSB9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXhwcjtcclxuXHR9XHJcblxyXG5cdC8vIFBhcnNlIGEgcHJvZ3JhbVxyXG5cdGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbSh0aHJlYWQsIHN0cmluZywgb3B0aW9ucykge1xyXG5cdFx0dmFyIG9wdHMgPSB7fTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xyXG5cdFx0b3B0cy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzID8gb3B0aW9ucy5zdWNjZXNzIDogZnVuY3Rpb24oKXt9O1xyXG5cdFx0b3B0cy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgPyBvcHRpb25zLmVycm9yIDogZnVuY3Rpb24oKXt9O1xyXG5cdFx0b3B0cy5mcm9tID0gb3B0aW9ucy5mcm9tID8gb3B0aW9ucy5mcm9tIDogXCIkdGF1LWpzXCI7XHJcblx0XHRvcHRzLnJlY29uc3VsdCA9IG9wdGlvbnMucmVjb25zdWx0ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlY29uc3VsdCA6IHRydWU7XHJcblx0XHRvcHRzLnJlY29uc3VsdGVkID0gb3B0aW9ucy5yZWNvbnN1bHRlZCA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zLnJlY29uc3VsdGVkO1xyXG5cdFx0b3B0cy5jb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdG9wdHMuaW5pdGlhbGl6YXRpb24gPSBvcHRpb25zLmluaXRpYWxpemF0aW9uID09PSB1bmRlZmluZWQgPyBbXSA6IG9wdGlvbnMuaW5pdGlhbGl6YXRpb247XHJcblx0XHRvcHRzLmN1cnJlbnRfdG9rZW4gPSBvcHRpb25zLmN1cnJlbnRfdG9rZW4gPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmN1cnJlbnRfdG9rZW47XHJcblx0XHRvcHRzLnRva2VuaXplciA9IG9wdGlvbnMudG9rZW5pemVyID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy50b2tlbml6ZXI7XHJcblx0XHRvcHRzLnRva2VucyA9IG9wdGlvbnMudG9rZW5zID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy50b2tlbnM7XHJcblx0XHRvcHRzLnN0cmluZyA9IHN0cmluZztcclxuXHRcdG9wdHMudGVybV9leHBhbnNpb24gPSBmYWxzZTtcclxuXHRcdHZhciByZWNvbnN1bHRlZCA9IG9wdHMucmVjb25zdWx0ZWQ7XHJcblx0XHR2YXIgdG9rZW5pemVyID0gb3B0cy50b2tlbml6ZXI7XHJcblx0XHR2YXIgdG9rZW5zID0gb3B0cy50b2tlbnM7XHJcblx0XHRpZih0b2tlbml6ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0dG9rZW5pemVyID0gbmV3IFRva2VuaXplcih0aHJlYWQpO1xyXG5cdFx0XHR0b2tlbml6ZXIubmV3X3RleHQoc3RyaW5nKTtcclxuXHRcdFx0b3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XHJcblx0XHRcdHRva2VucyA9IHRva2VuaXplci5nZXRfdG9rZW5zKDApO1xyXG5cdFx0XHRvcHRzLnRva2VucyA9IHRva2VucztcclxuXHRcdH1cclxuXHRcdHZhciBuID0gb3B0cy5jdXJyZW50X3Rva2VuO1xyXG5cdFx0d2hpbGUodG9rZW5zICE9PSBudWxsICYmIHRva2Vuc1tuXSkge1xyXG5cdFx0XHR2YXIgZXhwciA9IHBhcnNlUnVsZSh0aHJlYWQsIHRva2Vucywgbik7XHJcblx0XHRcdG9wdHMuY3VycmVudF90b2tlbiA9IGV4cHIubGVuO1xyXG5cdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0aWYob3B0cy5lcnJvciAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdG9wdHMuZXJyb3IobmV3IFRlcm0oXCJ0aHJvd1wiLCBbZXhwci52YWx1ZV0pKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gVGVybSBleHBhbnNpb25cclxuXHRcdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBvcHRzLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHRcdHZhciB0ZXJtX2V4cGFuc2lvbiA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdLnJ1bGVzW1widGVybV9leHBhbnNpb24vMlwiXTtcclxuXHRcdFx0XHRpZih0ZXJtX2V4cGFuc2lvbiAmJiB0ZXJtX2V4cGFuc2lvbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRvcHRzLnRlcm1fZXhwYW5zaW9uID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHZhciBuX3RocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0XHRcdFx0dmFyIHRlcm0gPSBleHByLnZhbHVlLmJvZHkgPyBuZXcgVGVybShcIjotXCIsIFtleHByLnZhbHVlLmhlYWQsIGV4cHIudmFsdWUuYm9keV0pIDogZXhwci52YWx1ZS5oZWFkO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHRcdHRlcm0gPSB0ZXJtLnJlbmFtZSh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRcdFx0XHRuX3RocmVhZC5xdWVyeShjb250ZXh0X21vZHVsZSArIFwiOnRlcm1fZXhwYW5zaW9uKFwiICsgdGVybS50b1N0cmluZyh7cXVvdGVkOiB0cnVlfSkgKyBcIiwgWCkuXCIpO1xyXG5cdFx0XHRcdFx0bl90aHJlYWQuYW5zd2VyKChmdW5jdGlvbih0aHJlYWQsIG9wdHMsIHJlY29uc3VsdGVkLCBleHByKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihhbnN3ZXIgJiYgIXBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSAmJiBwbC50eXBlLmlzX3Rlcm0oYW5zd2VyLmxpbmtzWydYJ10pKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdGVybSA9IGFuc3dlci5saW5rc1snWCddO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJ1bGUgPSB0ZXJtLmluZGljYXRvciA9PT0gXCI6LS8yXCIgPyBuZXcgUnVsZSh0ZXJtLmFyZ3NbMF0sIHRlcm0uYXJnc1sxXSkgOiBuZXcgUnVsZSh0ZXJtLCBudWxsKTtcclxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlUHJvZ3JhbUV4cGFuc2lvbih0aHJlYWQsIG9wdHMsIHJlY29uc3VsdGVkLCB7dmFsdWU6IHJ1bGUsIGxlbjogZXhwci5sZW4sIHR5cGU6IGV4cHIudHlwZX0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRwYXJzZVByb2dyYW1FeHBhbnNpb24odGhyZWFkLCBvcHRzLCByZWNvbnN1bHRlZCwgZXhwcik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KSh0aHJlYWQsIG9wdHMsIHJlY29uc3VsdGVkLCBleHByKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG9wdHMudGVybV9leHBhbnNpb24gPSBmYWxzZTtcclxuXHRcdFx0XHRcdHZhciBhc3luYyA9IHBhcnNlUHJvZ3JhbUV4cGFuc2lvbih0aHJlYWQsIG9wdHMsIHJlY29uc3VsdGVkLCBleHByKTtcclxuXHRcdFx0XHRcdGlmKGFzeW5jKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRuID0gZXhwci5sZW47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvLyBydW4gZ29hbHMgZnJvbSBpbml0aWFsaXphdGlvbi8xIGRpcmVjdGl2ZVxyXG5cdFx0dmFyIGNhbGxiYWNrID0gb3B0cy5zdWNjZXNzO1xyXG5cdFx0dmFyIG50aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdGZvcih2YXIgaSA9IG9wdHMuaW5pdGlhbGl6YXRpb24ubGVuZ3RoLTE7IGkgPiAwOyBpLS0pIHtcclxuXHRcdFx0dmFyIG5leHRfY2FsbGJhY2sgPSAoZnVuY3Rpb24oaW5pdCwgY2FsbGJhY2spIHtcclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdFx0XHRpZihhbnN3ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0bnRocmVhZC5hbnN3ZXIoKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikpIHtcclxuXHRcdFx0XHRcdFx0b3B0cy5lcnJvcihhbnN3ZXIpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0bnRocmVhZC5hZGRfZ29hbChpbml0KTtcclxuXHRcdFx0XHRcdFx0bnRocmVhZC5hbnN3ZXIoY2FsbGJhY2spO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pKG9wdHMuaW5pdGlhbGl6YXRpb25baV0sIGNhbGxiYWNrKTtcclxuXHRcdFx0Y2FsbGJhY2sgPSBuZXh0X2NhbGxiYWNrO1xyXG5cdFx0fVxyXG5cdFx0aWYob3B0cy5pbml0aWFsaXphdGlvbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdG50aHJlYWQuYWRkX2dvYWwob3B0cy5pbml0aWFsaXphdGlvblswXSk7XHJcblx0XHRcdG50aHJlYWQuYW5zd2VyKGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYXJzZUdvYWxFeHBhbnNpb24odGhyZWFkLCBvcHRpb25zLCBleHByKSB7XHJcblx0XHR2YXIgbl90aHJlYWQgPSBuZXcgVGhyZWFkKCB0aHJlYWQuc2Vzc2lvbiApO1xyXG5cdFx0bl90aHJlYWQuX19nb2FsX2V4cGFuc2lvbiA9IHRydWU7XHJcblx0XHR2YXIgdmFydGVybSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdHZhciB2YXJoZWFkID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0dmFyIGdvYWwgPSB2YXJoZWFkICsgXCIgPSBcIiArIGV4cHIudmFsdWUuaGVhZCArIFwiLCBnb2FsX2V4cGFuc2lvbihcIiArIGV4cHIudmFsdWUuYm9keS50b1N0cmluZyh7XHJcblx0XHRcdHF1b3RlZDogdHJ1ZVxyXG5cdFx0fSkgKyBcIiwgXCIgKyB2YXJ0ZXJtLnRvU3RyaW5nKHtcclxuXHRcdFx0cXVvdGVkOiB0cnVlXHJcblx0XHR9KSArIFwiKS5cIjtcclxuXHRcdG5fdGhyZWFkLnF1ZXJ5KGdvYWwpO1xyXG5cdFx0bl90aHJlYWQuYW5zd2VyKGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRpZihhbnN3ZXIgJiYgIXBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSAmJiBhbnN3ZXIubGlua3NbdmFydGVybV0pIHtcclxuXHRcdFx0XHRleHByLnZhbHVlLmhlYWQgPSBhbnN3ZXIubGlua3NbdmFyaGVhZF07XHJcblx0XHRcdFx0ZXhwci52YWx1ZS5ib2R5ID0gYm9keV9jb252ZXJzaW9uKGFuc3dlci5saW5rc1t2YXJ0ZXJtXSk7XHJcblx0XHRcdFx0cGFyc2VHb2FsRXhwYW5zaW9uKHRocmVhZCwgb3B0aW9ucywgZXhwcik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLmFkZF9ydWxlKGV4cHIudmFsdWUsIG9wdGlvbnMpO1xyXG5cdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYXJzZVF1ZXJ5RXhwYW5zaW9uKHRocmVhZCwgdGVybSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIG5fdGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRuX3RocmVhZC5fX2dvYWxfZXhwYW5zaW9uID0gdHJ1ZTtcclxuXHRcdHZhciB2YXJ0ZXJtID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0dmFyIGdvYWwgPSBcImdvYWxfZXhwYW5zaW9uKFwiICsgdGVybS50b1N0cmluZyh7XHJcblx0XHRcdHF1b3RlZDogdHJ1ZVxyXG5cdFx0fSkgKyBcIiwgXCIgKyB2YXJ0ZXJtLnRvU3RyaW5nKHtcclxuXHRcdFx0cXVvdGVkOiB0cnVlXHJcblx0XHR9KSArIFwiKS5cIjtcclxuXHRcdG5fdGhyZWFkLnF1ZXJ5KGdvYWwpO1xyXG5cdFx0dmFyIHZhcmlhYmxlcyA9IG5fdGhyZWFkLmhlYWRfcG9pbnQoKS5zdWJzdGl0dXRpb24uZG9tYWluKCk7XHJcblx0XHRuX3RocmVhZC5hbnN3ZXIoZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdGlmKGFuc3dlciAmJiAhcGwudHlwZS5pc19lcnJvcihhbnN3ZXIpICYmIGFuc3dlci5saW5rc1t2YXJ0ZXJtXSkge1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmKHZhcmlhYmxlc1tpXSAhPT0gdmFydGVybS5pZCAmJiBhbnN3ZXIubGlua3NbdmFyaWFibGVzW2ldXSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc3VicyA9IG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdFx0XHRcdFx0c3Vicy5saW5rc1thbnN3ZXIubGlua3NbdmFyaWFibGVzW2ldXV0gPSB2YXJpYWJsZXNbaV07XHJcblx0XHRcdFx0XHRcdGFuc3dlci5saW5rc1t2YXJ0ZXJtXSA9IGFuc3dlci5saW5rc1t2YXJ0ZXJtXS5hcHBseSggc3VicyApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwYXJzZVF1ZXJ5RXhwYW5zaW9uKHRocmVhZCwgYm9keV9jb252ZXJzaW9uKGFuc3dlci5saW5rc1t2YXJ0ZXJtXSksIG9wdGlvbnMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5hZGRfZ29hbCh0ZXJtKTtcclxuXHRcdFx0XHRvcHRpb25zLnN1Y2Nlc3ModGVybSk7XHJcblx0XHRcdFx0cGFyc2VRdWVyeSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBwYXJzZVByb2dyYW1FeHBhbnNpb24odGhyZWFkLCBvcHRpb25zLCByZWNvbnN1bHRlZCwgZXhwcikge1xyXG5cdFx0dmFyIGFzeW5jID0gb3B0aW9ucy50ZXJtX2V4cGFuc2lvbiA9PT0gdHJ1ZTtcclxuXHRcdGlmKGV4cHIudmFsdWUuYm9keSA9PT0gbnVsbCAmJiBleHByLnZhbHVlLmhlYWQuaW5kaWNhdG9yID09PSBcIj8tLzFcIikge1xyXG5cdFx0XHRhc3luYyA9IHRydWU7XHJcblx0XHRcdHZhciBuX3RocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0XHRuX3RocmVhZC5hZGRfZ29hbChleHByLnZhbHVlLmhlYWQuYXJnc1swXSk7XHJcblx0XHRcdG5fdGhyZWFkLmFuc3dlcihmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKGFuc3dlci5hcmdzWzBdKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYW5zd2VyID09PSBmYWxzZSB8fCBhbnN3ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLndhcm5pbmcuZmFpbGVkX2dvYWwoZXhwci52YWx1ZS5oZWFkLmFyZ3NbMF0sIGV4cHIubGVuKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYoZXhwci52YWx1ZS5ib2R5ID09PSBudWxsICYmIGV4cHIudmFsdWUuaGVhZC5pbmRpY2F0b3IgPT09IFwiOi0vMVwiKSB7XHJcblx0XHRcdHZhciByZXN1bHQgPSB0aHJlYWQucnVuX2RpcmVjdGl2ZShleHByLnZhbHVlLmhlYWQuYXJnc1swXSwgb3B0aW9ucyk7XHJcblx0XHRcdGFzeW5jID0gYXN5bmMgfHwgKHJlc3VsdCA9PT0gdHJ1ZSk7XHJcblx0XHRcdGlmKGFzeW5jKVxyXG5cdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdHZhciBpbmRpY2F0b3IgPSBleHByLnZhbHVlLmhlYWQuaW5kaWNhdG9yO1xyXG5cdFx0XHRpZihleHByLnZhbHVlLmhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBleHByLnZhbHVlLmhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRpbmRpY2F0b3IgPSBleHByLnZhbHVlLmhlYWQuYXJnc1sxXS5pbmRpY2F0b3I7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXJlY29uc3VsdGVkLmhhc093blByb3BlcnR5KGNvbnRleHRfbW9kdWxlKSlcclxuXHRcdFx0XHRyZWNvbnN1bHRlZFtjb250ZXh0X21vZHVsZV0gPSB7fTtcclxuXHRcdFx0aWYob3B0aW9ucy5yZWNvbnN1bHQgIT09IGZhbHNlICYmIHJlY29uc3VsdGVkW2NvbnRleHRfbW9kdWxlXVtpbmRpY2F0b3JdICE9PSB0cnVlICYmICF0aHJlYWQuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZShpbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXTtcclxuXHRcdFx0XHRpZihjb250ZXh0X21vZHVsZSAhPT0gXCJzeXN0ZW1cIiAmJiBnZXRfbW9kdWxlICYmIGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXSkge1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdID0gZmlsdGVyKGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXSwgZnVuY3Rpb24ocnVsZSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcnVsZS5keW5hbWljO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZWNvbnN1bHRlZFtjb250ZXh0X21vZHVsZV1baW5kaWNhdG9yXSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGdvYWxfZXhwYW5zaW9uID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlcy51c2VyLnJ1bGVzW1wiZ29hbF9leHBhbnNpb24vMlwiXTtcclxuXHRcdFx0aWYoZXhwci52YWx1ZS5ib2R5ICE9PSBudWxsICYmIGdvYWxfZXhwYW5zaW9uICYmIGdvYWxfZXhwYW5zaW9uLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRhc3luYyA9IHRydWU7XHJcblx0XHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHR2YXIgb3JpZ2luID0ge1xyXG5cdFx0XHRcdFx0aGVhZDogZnVuY3Rpb24oKSB7IHJldHVybiBleHByLnZhbHVlLmhlYWQ7IH0sXHJcblx0XHRcdFx0XHR0ZXJtOiBmdW5jdGlvbigpIHsgcmV0dXJuIGV4cHIudmFsdWUuYm9keTsgfSxcclxuXHRcdFx0XHRcdHNldDogZnVuY3Rpb24oaCwgcCl7XHJcblx0XHRcdFx0XHRcdGV4cHIudmFsdWUuaGVhZCA9IGg7XHJcblx0XHRcdFx0XHRcdGV4cHIudmFsdWUuYm9keSA9IHA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRwYXJzZUdvYWxFeHBhbnNpb24odGhyZWFkLCBvcHRpb25zLCBleHByLCBib2R5X2NvbnZlcnNpb24oZXhwci52YWx1ZS5ib2R5KSwgb3JpZ2luLnNldCwgb3JpZ2luKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuYWRkX3J1bGUoZXhwci52YWx1ZSwgb3B0aW9ucyk7XHJcblx0XHRcdFx0aWYoYXN5bmMpXHJcblx0XHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhc3luYztcclxuXHR9XHJcblx0XHJcblx0Ly8gUGFyc2UgYSBxdWVyeVxyXG5cdGZ1bmN0aW9uIHBhcnNlUXVlcnkodGhyZWFkLCBzdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvcHRzID0ge307XHJcblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucyA6IGZ1bmN0aW9uKCl7fTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogb3B0aW9ucztcclxuXHRcdG9wdHMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyA9PT0gdW5kZWZpbmVkID8gY2FsbGJhY2sgOiBvcHRpb25zLnN1Y2Nlc3M7XHJcblx0XHRvcHRzLmVycm9yID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gY2FsbGJhY2sgOiBvcHRpb25zLmVycm9yO1xyXG5cdFx0b3B0cy50b2tlbml6ZXIgPSBvcHRpb25zLnRva2VuaXplciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMudG9rZW5pemVyO1xyXG5cdFx0b3B0cy5jdXJyZW50X3Rva2VuID0gb3B0aW9ucy5jdXJyZW50X3Rva2VuID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jdXJyZW50X3Rva2VuO1xyXG5cdFx0b3B0cy5zdHJpbmcgPSBzdHJpbmc7XHJcblx0XHR2YXIgdG9rZW5pemVyID0gb3B0cy50b2tlbml6ZXI7XHJcblx0XHR2YXIgbiA9IG9wdHMuY3VycmVudF90b2tlbjtcclxuXHRcdGlmKHRva2VuaXplciA9PT0gbnVsbCkge1xyXG5cdFx0XHR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRocmVhZCk7XHJcblx0XHRcdG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xyXG5cdFx0XHR0b2tlbml6ZXIubmV3X3RleHQoc3RyaW5nKTtcclxuXHRcdH1cclxuXHRcdGRvIHtcclxuXHRcdFx0dmFyIHRva2VucyA9IHRva2VuaXplci5nZXRfdG9rZW5zKG4pO1xyXG5cdFx0XHRpZih0b2tlbnMgPT09IG51bGwpXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCAwLCB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCksIGZhbHNlKTtcclxuXHRcdFx0aWYoZXhwci50eXBlICE9PSBFUlJPUikge1xyXG5cdFx0XHRcdHZhciBleHByX3Bvc2l0aW9uID0gZXhwci5sZW47XHJcblx0XHRcdFx0biA9IGV4cHIubGVuICsgMTtcclxuXHRcdFx0XHRvcHRzLmN1cnJlbnRfdG9rZW4gPSBuO1xyXG5cdFx0XHRcdGlmKHRva2Vuc1tleHByX3Bvc2l0aW9uXSAmJiB0b2tlbnNbZXhwcl9wb3NpdGlvbl0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW2V4cHJfcG9zaXRpb25dLnJhdyA9PT0gXCIuXCIpIHtcclxuXHRcdFx0XHRcdGV4cHIudmFsdWUgPSBib2R5X2NvbnZlcnNpb24oZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0XHQvLyBHb2FsIGV4cGFuc2lvblxyXG5cdFx0XHRcdFx0dmFyIGdvYWxfZXhwYW5zaW9uID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlcy51c2VyLnJ1bGVzW1wiZ29hbF9leHBhbnNpb24vMlwiXTtcclxuXHRcdFx0XHRcdGlmKCF0aHJlYWQuX19nb2FsX2V4cGFuc2lvbiAmJiBnb2FsX2V4cGFuc2lvbiAmJiBnb2FsX2V4cGFuc2lvbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0XHRcdHBhcnNlUXVlcnlFeHBhbnNpb24odGhyZWFkLCBleHByLnZhbHVlLCBvcHRzKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmFkZF9nb2FsKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRvcHRzLnN1Y2Nlc3MoZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tleHByX3Bvc2l0aW9uXTtcclxuXHRcdFx0XHRcdG9wdHMuZXJyb3IoXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidGhyb3dcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdHBsLmVycm9yLnN5bnRheChcclxuXHRcdFx0XHRcdFx0XHRcdHRva2VuID8gdG9rZW4gOiB0b2tlbnNbZXhwcl9wb3NpdGlvbi0xXSxcclxuXHRcdFx0XHRcdFx0XHRcdHRva2VuICYmIHRva2VuLmVycm9yID8gdG9rZW4uZXJyb3IgOiBcIi4gb3Igb3BlcmF0b3IgZXhwZWN0ZWRcIixcclxuXHRcdFx0XHRcdFx0XHRcdCF0b2tlblxyXG5cdFx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9wdHMuZXJyb3IobmV3IFRlcm0oXCJ0aHJvd1wiLCBbZXhwci52YWx1ZV0pKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH0gd2hpbGUodHJ1ZSk7XHJcblx0fVxyXG5cclxuXHJcblx0XHJcblx0Ly8gVVRJTFNcclxuXHJcblx0Ly8gUnVsZSB0byBEQ0dcclxuXHRmdW5jdGlvbiBydWxlX3RvX2RjZyhydWxlLCB0aHJlYWQpIHtcclxuXHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRydWxlID0gcnVsZS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdHZhciBiZWdpbiA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdHZhciBkY2cgPSBib2R5X3RvX2RjZyggcnVsZS5ib2R5LCBiZWdpbiwgdGhyZWFkICk7XHJcblx0XHRpZiggZGNnLmVycm9yIClcclxuXHRcdFx0cmV0dXJuIGRjZy52YWx1ZTtcclxuXHRcdHJ1bGUuYm9keSA9IGRjZy52YWx1ZTtcclxuXHRcdC8vIHB1c2gtYmFjayBsaXN0c1xyXG5cdFx0aWYocnVsZS5oZWFkLmluZGljYXRvciA9PT0gXCIsLzJcIikge1xyXG5cdFx0XHR2YXIgdGVybWluYWxzID0gcnVsZS5oZWFkLmFyZ3NbMV07XHJcblx0XHRcdHJ1bGUuaGVhZCA9IHJ1bGUuaGVhZC5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgbGFzdCA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSB0ZXJtaW5hbHM7XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX2xpc3QocG9pbnRlcikpIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IudHlwZShcImxpc3RcIiwgcG9pbnRlciwgXCJEQ0cvMFwiKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwb2ludGVyLmluZGljYXRvciA9PT0gXCJbXS8wXCIpIHtcclxuXHRcdFx0XHR0ZXJtaW5hbHMgPSBkY2cudmFyaWFibGU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0d2hpbGUocG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgJiYgcGwudHlwZS5pc19saXN0KHBvaW50ZXIpICYmIHBvaW50ZXIuYXJnc1sxXS5pbmRpY2F0b3IgIT09IFwiW10vMFwiKSB7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLmluc3RhbnRpYXRpb24oXCJEQ0cvMFwiKTtcclxuXHRcdFx0XHRlbHNlIGlmKCFwbC50eXBlLmlzX2xpc3QocG9pbnRlcikpXHJcblx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IudHlwZShcImxpc3RcIiwgdGVybWluYWxzLCBcIkRDRy8wXCIpO1xyXG5cdFx0XHRcdHBvaW50ZXIuYXJnc1sxXSA9IGRjZy52YXJpYWJsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRydWxlLmJvZHkgPSBuZXcgVGVybShcIixcIiwgW3J1bGUuYm9keSwgbmV3IFRlcm0oXCI9XCIsIFtsYXN0LCB0ZXJtaW5hbHNdKV0pO1xyXG5cdFx0XHRydWxlLmhlYWQgPSBuZXcgVGVybShydWxlLmhlYWQuaWQsIHJ1bGUuaGVhZC5hcmdzLmNvbmNhdChbYmVnaW4sIGxhc3RdKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyByZXBsYWNlIGZpcnN0IGFzc2lnbm1lbnRcclxuXHRcdFx0dmFyIGZpcnN0X2Fzc2lnbiA9IHJ1bGUuYm9keTtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGZpcnN0X2Fzc2lnbikgJiYgZmlyc3RfYXNzaWduLmluZGljYXRvciA9PT0gXCIsLzJcIilcclxuXHRcdFx0XHRmaXJzdF9hc3NpZ24gPSBmaXJzdF9hc3NpZ24uYXJnc1swXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGZpcnN0X2Fzc2lnbikgJiYgZmlyc3RfYXNzaWduLmluZGljYXRvciA9PT0gXCI9LzJcIiAmJlxyXG5cdFx0XHQgICBwbC50eXBlLmlzX3ZhcmlhYmxlKGZpcnN0X2Fzc2lnbi5hcmdzWzBdKSAmJiBmaXJzdF9hc3NpZ24uYXJnc1swXSA9PT0gYmVnaW4pIHtcclxuXHRcdFx0XHRiZWdpbiA9IGZpcnN0X2Fzc2lnbi5hcmdzWzFdO1xyXG5cdFx0XHRcdHJ1bGUuYm9keSA9IHJ1bGUuYm9keS5yZXBsYWNlKG51bGwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGFkZCBmaXJzdCBhbmQgbGFzdCB2YXJpYWJsZXMgdG8gdGhlIGhlYWRcclxuXHRcdFx0aWYocnVsZS5oZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIilcclxuXHRcdFx0XHRydWxlLmhlYWQgPSBuZXcgVGVybShcIjpcIiwgW1xyXG5cdFx0XHRcdFx0bmV3IFRlcm0ocnVsZS5oZWFkLmFyZ3NbMF0uaWQsIFtdKSxcclxuXHRcdFx0XHRcdG5ldyBUZXJtKHJ1bGUuaGVhZC5hcmdzWzFdLmlkLCBydWxlLmhlYWQuYXJnc1sxXS5hcmdzLmNvbmNhdChbYmVnaW4sIGRjZy52YXJpYWJsZV0pKVxyXG5cdFx0XHRcdF0pO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cnVsZS5oZWFkID0gbmV3IFRlcm0ocnVsZS5oZWFkLmlkLCBydWxlLmhlYWQuYXJncy5jb25jYXQoW2JlZ2luLCBkY2cudmFyaWFibGVdKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcnVsZTtcclxuXHR9XHJcblxyXG5cdC8vIEJvZHkgdG8gRENHXHJcblx0ZnVuY3Rpb24gYm9keV90b19kY2coZXhwciwgbGFzdCwgdGhyZWFkKSB7XHJcblx0XHR2YXIgZnJlZTtcclxuXHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBleHByLmluZGljYXRvciA9PT0gXCIhLzBcIiApIHtcclxuXHRcdFx0ZnJlZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCIsXCIsIFtleHByLCBuZXcgVGVybShcIj1cIiwgW2xhc3QsIGZyZWVdKV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmcmVlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBleHByLmluZGljYXRvciA9PT0gXCI6LzJcIiApIHtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzFdLCBsYXN0LCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggcmlnaHQuZXJyb3IgKSByZXR1cm4gcmlnaHQ7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiOlwiLCBbZXhwci5hcmdzWzBdLCByaWdodC52YWx1ZV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiByaWdodC52YXJpYWJsZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwiXFxcXCsvMVwiICkge1xyXG5cdFx0XHR2YXIgbGVmdCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1swXSwgbGFzdCwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIGxlZnQuZXJyb3IgKSByZXR1cm4gbGVmdDtcclxuXHRcdFx0ZnJlZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShleHByLmlkLCBbbGVmdC52YWx1ZV0pLCBuZXcgVGVybShcIj1cIiwgW2xhc3QsIGZyZWVdKV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmcmVlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiAoZXhwci5pbmRpY2F0b3IgPT09IFwiLC8yXCIgfHwgZXhwci5pbmRpY2F0b3IgPT09IFwiLT4vMlwiKSApIHtcclxuXHRcdFx0dmFyIGxlZnQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMF0sIGxhc3QsIHRocmVhZCk7XHJcblx0XHRcdGlmKCBsZWZ0LmVycm9yICkgcmV0dXJuIGxlZnQ7XHJcblx0XHRcdHZhciByaWdodCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1sxXSwgbGVmdC52YXJpYWJsZSwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIHJpZ2h0LmVycm9yICkgcmV0dXJuIHJpZ2h0O1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShleHByLmlkLCBbbGVmdC52YWx1ZSwgcmlnaHQudmFsdWVdKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogcmlnaHQudmFyaWFibGUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIGV4cHIuaW5kaWNhdG9yID09PSBcIjsvMlwiICkge1xyXG5cdFx0XHR2YXIgbGVmdCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1swXSwgbGFzdCwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIGxlZnQuZXJyb3IgKSByZXR1cm4gbGVmdDtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzFdLCBsYXN0LCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggcmlnaHQuZXJyb3IgKSByZXR1cm4gcmlnaHQ7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI7XCIsIFtsZWZ0LnZhbHVlLCByaWdodC52YWx1ZV0pLCBuZXcgVGVybShcIj1cIiwgW2xlZnQudmFyaWFibGUsIHJpZ2h0LnZhcmlhYmxlXSldKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogcmlnaHQudmFyaWFibGUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIGV4cHIuaW5kaWNhdG9yID09PSBcInt9LzFcIiApIHtcclxuXHRcdFx0ZnJlZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCIsXCIsIFtleHByLmFyZ3NbMF0sIG5ldyBUZXJtKFwiPVwiLCBbbGFzdCwgZnJlZV0pXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IGZyZWUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggZXhwciApICkge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcInRydWVcIiwgW10pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBsYXN0LFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2xpc3QoIGV4cHIgKSApIHtcclxuXHRcdFx0ZnJlZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSBleHByO1xyXG5cdFx0XHR2YXIgcHJldjtcclxuXHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdHByZXYgPSBwb2ludGVyO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0dmFsdWU6IHBsLmVycm9yLmluc3RhbnRpYXRpb24oXCJEQ0cvMFwiKSxcclxuXHRcdFx0XHRcdHZhcmlhYmxlOiBsYXN0LFxyXG5cdFx0XHRcdFx0ZXJyb3I6IHRydWVcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0dmFsdWU6IHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGV4cHIsIFwiRENHLzBcIiksXHJcblx0XHRcdFx0XHR2YXJpYWJsZTogbGFzdCxcclxuXHRcdFx0XHRcdGVycm9yOiB0cnVlXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwcmV2LmFyZ3NbMV0gPSBmcmVlO1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCI9XCIsIFtsYXN0LCBleHByXSksXHJcblx0XHRcdFx0XHR2YXJpYWJsZTogZnJlZSxcclxuXHRcdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19jYWxsYWJsZSggZXhwciApICkge1xyXG5cdFx0XHRmcmVlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHRleHByID0gbmV3IFRlcm0oIGV4cHIuaWQsIGV4cHIuYXJncy5jb25jYXQoW2xhc3QsZnJlZV0pICk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IGV4cHIsXHJcblx0XHRcdFx0dmFyaWFibGU6IGZyZWUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBwbC5lcnJvci50eXBlKCBcImNhbGxhYmxlXCIsIGV4cHIsIFwiRENHLzBcIiApLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBsYXN0LFxyXG5cdFx0XHRcdGVycm9yOiB0cnVlXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdC8vIEJvZHkgY29udmVyc2lvblxyXG5cdGZ1bmN0aW9uIGJvZHlfY29udmVyc2lvbiggZXhwciApIHtcclxuXHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBleHByICkgKVxyXG5cdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiY2FsbFwiLCBbZXhwcl0gKTtcclxuXHRcdGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIFtcIiwvMlwiLCBcIjsvMlwiLCBcIi0+LzJcIl0uaW5kZXhPZihleHByLmluZGljYXRvcikgIT09IC0xIClcclxuXHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBleHByLmlkLCBbYm9keV9jb252ZXJzaW9uKCBleHByLmFyZ3NbMF0gKSwgYm9keV9jb252ZXJzaW9uKCBleHByLmFyZ3NbMV0gKV0gKTtcclxuXHRcdGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybShleHByKSAmJiBleHByLmluZGljYXRvciA9PT0gXCI6LzJcIiApIHtcclxuXHRcdFx0dmFyIGJvZHkgPSBib2R5X2NvbnZlcnNpb24oZXhwci5hcmdzWzFdKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBUZXJtKFwiOlwiLCBbZXhwci5hcmdzWzBdLCBib2R5XSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXhwcjtcclxuXHR9XHJcblx0XHJcblx0Ly8gTGlzdCB0byBQcm9sb2cgbGlzdFxyXG5cdGZ1bmN0aW9uIGFycmF5VG9MaXN0KCBhcnJheSwgY29ucyApIHtcclxuXHRcdHZhciBsaXN0ID0gY29ucyA/IGNvbnMgOiBuZXcgVGVybSggXCJbXVwiLCBbXSApO1xyXG5cdFx0Zm9yKHZhciBpID0gYXJyYXkubGVuZ3RoLTE7IGkgPj0gMDsgaS0tIClcclxuXHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW2FycmF5W2ldLCBsaXN0XSApO1xyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblx0fVxyXG5cclxuXHQvLyBBcnJheSBkaWZmZXJlbmNlXHJcblx0ZnVuY3Rpb24gZGlmZmVyZW5jZSh4cywgeXMpIHtcclxuXHRcdHZhciB6cyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGluZGV4T2YoenMsIHhzW2ldKSA9PT0gLTEgJiYgaW5kZXhPZih5cywgeHNbaV0pID09PSAtMSlcclxuXHRcdFx0XHR6cy5wdXNoKHhzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB6cztcclxuXHR9XHJcblx0XHJcblx0Ly8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBhcnJheVxyXG5cdGZ1bmN0aW9uIHJlbW92ZSggYXJyYXksIGVsZW1lbnQgKSB7XHJcblx0XHRmb3IoIHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdGlmKCBhcnJheVtpXSA9PT0gZWxlbWVudCApIHtcclxuXHRcdFx0XHRhcnJheS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZSBlbGVtZW50c1xyXG5cdGZ1bmN0aW9uIG51YiggYXJyYXkgKSB7XHJcblx0XHR2YXIgc2VlbiA9IHt9O1xyXG5cdFx0dmFyIHVuaXF1ZSA9IFtdO1xyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0aWYoICEoYXJyYXlbaV0gaW4gc2VlbikgKSB7XHJcblx0XHRcdFx0dW5pcXVlLnB1c2goIGFycmF5W2ldICk7XHJcblx0XHRcdFx0c2VlblthcnJheVtpXV0gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdW5pcXVlO1xyXG5cdH1cclxuXHJcblx0Ly8gUmV0cmFjdCBhIHJ1bGVcclxuXHRmdW5jdGlvbiByZXRyYWN0KHRocmVhZCwgcG9pbnQsIGluZGljYXRvciwgcnVsZSwgZ2V0X21vZHVsZSkge1xyXG5cdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdKSB7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl1baV0gPT09IHJ1bGUpIHtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXS5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Ly8gY2FsbC9uXHJcblx0ZnVuY3Rpb24gY2FsbE4obikge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNsb3N1cmUgPSBhdG9tLmFyZ3NbMF0sIGFyZ3MgPSBhdG9tLmFyZ3Muc2xpY2UoMSwgbik7XHJcblx0XHRcdHZhciBtb2R1bGVfYXRvbTtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGNsb3N1cmUpICYmIGNsb3N1cmUuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShjbG9zdXJlLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBjbG9zdXJlLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9hdG9tID0gY2xvc3VyZS5hcmdzWzBdO1xyXG5cdFx0XHRcdGNsb3N1cmUgPSBjbG9zdXJlLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShjbG9zdXJlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbG9zdXJlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xvc3VyZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZ29hbCA9IGJvZHlfY29udmVyc2lvbihuZXcgVGVybShjbG9zdXJlLmlkLCBjbG9zdXJlLmFyZ3MuY29uY2F0KGFyZ3MpKSk7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoZ29hbCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgZ29hbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYobW9kdWxlX2F0b20pXHJcblx0XHRcdFx0XHRnb2FsID0gbmV3IFRlcm0oXCI6XCIsIFttb2R1bGVfYXRvbSwgZ29hbF0pO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKGdvYWwpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHQvLyBTdHJpbmcgdG8gaW5kaWNhdG9yXHJcblx0ZnVuY3Rpb24gc3RyX2luZGljYXRvciggc3RyICkge1xyXG5cdFx0Zm9yKCB2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApXHJcblx0XHRcdGlmKCBzdHIuY2hhckF0KGkpID09PSBcIi9cIiApXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcIi9cIiwgW25ldyBUZXJtKCBzdHIuc3Vic3RyaW5nKDAsIGkpICksIG5ldyBOdW0oIHBhcnNlSW50KHN0ci5zdWJzdHJpbmcoaSsxKSksIGZhbHNlICldICk7XHJcblx0fVxyXG5cclxuXHQvLyBHcmVhdGVzdCBjb21tb24gZGl2aXNvclxyXG5cdGZ1bmN0aW9uIGdjZChhLCBiKSB7XHJcblx0XHRpZihiID09PSAwKVxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdHJldHVybiBNYXRoLmFicyhnY2QoYiwgYSAlIGIpKTtcclxuXHR9XHJcblx0XHJcblx0XHJcblxyXG5cdC8vIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0ZnVuY3Rpb24gVmFyKCBpZCApIHtcclxuXHRcdHRoaXMuaWQgPSBpZDtcclxuXHRcdHRoaXMuZ3JvdW5kID0gZmFsc2U7XHJcblx0fVxyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHRmdW5jdGlvbiBOdW0oIHZhbHVlLCBpc19mbG9hdCApIHtcclxuXHRcdHRoaXMuaXNfZmxvYXQgPSBpc19mbG9hdCAhPT0gdW5kZWZpbmVkID8gaXNfZmxvYXQgOiBNYXRoLnRydW5jKHZhbHVlKSAhPT0gdmFsdWU7XHJcblx0XHR0aGlzLnZhbHVlID0gdGhpcy5pc19mbG9hdCA/IHZhbHVlIDogTWF0aC50cnVuYyh2YWx1ZSk7XHJcblx0XHR0aGlzLmluZGV4ID0gdGhpcy52YWx1ZTtcclxuXHRcdHRoaXMuZ3JvdW5kID0gdHJ1ZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHR2YXIgdGVybV9yZWYgPSAwO1xyXG5cdGZ1bmN0aW9uIFRlcm0oIGlkLCBhcmdzLCByZWYgKSB7XHJcblx0XHR0ZXJtX3JlZisrO1xyXG5cdFx0dGhpcy5yZWYgPSByZWYgfHwgdGVybV9yZWY7XHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLmFyZ3MgPSBhcmdzIHx8IFtdO1xyXG5cdFx0dGhpcy5pbmRpY2F0b3IgPSBpZCArIFwiL1wiICsgdGhpcy5hcmdzLmxlbmd0aDtcclxuXHRcdHRoaXMuaW5kZXggPSB0aGlzLmluZGljYXRvcjtcclxuXHRcdHRoaXMuZ3JvdW5kID0gdHJ1ZTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYodGhpcy5hcmdzW2ldLmhhc093blByb3BlcnR5KFwiZ3JvdW5kXCIpICYmIHRoaXMuYXJnc1tpXS5ncm91bmQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0dGhpcy5ncm91bmQgPSBmYWxzZTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdHZhciBzdHJlYW1fcmVmID0gMDtcclxuXHRmdW5jdGlvbiBTdHJlYW0oIHN0cmVhbSwgbW9kZSwgYWxpYXMsIHR5cGUsIHJlcG9zaXRpb24sIGVvZl9hY3Rpb24gKSB7XHJcblx0XHR0aGlzLmlkID0gc3RyZWFtX3JlZisrO1xyXG5cdFx0dGhpcy5zdHJlYW0gPSBzdHJlYW07XHJcblx0XHR0aGlzLm1vZGUgPSBtb2RlOyAvLyBcInJlYWRcIiBvciBcIndyaXRlXCIgb3IgXCJhcHBlbmRcIlxyXG5cdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZSAhPT0gdW5kZWZpbmVkID8gdHlwZSA6IFwidGV4dFwiOyAvLyBcInRleHRcIiBvciBcImJpbmFyeVwiXHJcblx0XHR0aGlzLnJlcG9zaXRpb24gPSByZXBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyByZXBvc2l0aW9uIDogdHJ1ZTsgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cdFx0dGhpcy5lb2ZfYWN0aW9uID0gZW9mX2FjdGlvbiAhPT0gdW5kZWZpbmVkID8gZW9mX2FjdGlvbiA6IFwiZW9mX2NvZGVcIjsgLy8gXCJlcnJvclwiIG9yIFwiZW9mX2NvZGVcIiBvciBcInJlc2V0XCJcclxuXHRcdHRoaXMucG9zaXRpb24gPSB0aGlzLm1vZGUgPT09IFwiYXBwZW5kXCIgPyBcImVuZF9vZl9zdHJlYW1cIiA6IDA7XHJcblx0XHR0aGlzLm91dHB1dCA9IHRoaXMubW9kZSA9PT0gXCJ3cml0ZVwiIHx8IHRoaXMubW9kZSA9PT0gXCJhcHBlbmRcIjtcclxuXHRcdHRoaXMuaW5wdXQgPSB0aGlzLm1vZGUgPT09IFwicmVhZFwiO1xyXG5cdFx0dGhpcy5saW5lX3Bvc2l0aW9uID0gMDtcclxuXHRcdHRoaXMubGluZV9jb3VudCA9IDE7XHJcblx0XHR0aGlzLmNoYXJfY291bnQgPSAwO1xyXG5cdH1cclxuXHRcclxuXHQvLyBTdWJzdGl0dXRpb25zXHJcblx0ZnVuY3Rpb24gU3Vic3RpdHV0aW9uKCBsaW5rcywgYXR0cnMgKSB7XHJcblx0XHRsaW5rcyA9IGxpbmtzIHx8IHt9O1xyXG5cdFx0YXR0cnMgPSBhdHRycyB8fCB7fTtcclxuXHRcdHRoaXMubGlua3MgPSBsaW5rcztcclxuXHRcdHRoaXMuYXR0cnMgPSBhdHRycztcclxuXHR9XHJcblx0XHJcblx0Ly8gU3RhdGVzXHJcblx0ZnVuY3Rpb24gU3RhdGUoIGdvYWwsIHN1YnMsIHBhcmVudCApIHtcclxuXHRcdHN1YnMgPSBzdWJzIHx8IG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdHBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xyXG5cdFx0dGhpcy5nb2FsID0gZ29hbDtcclxuXHRcdHRoaXMuc3Vic3RpdHV0aW9uID0gc3VicztcclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cdH1cclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdGZ1bmN0aW9uIFJ1bGUoIGhlYWQsIGJvZHksIGR5bmFtaWMgKSB7XHJcblx0XHR0aGlzLmhlYWQgPSBoZWFkO1xyXG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcclxuXHRcdHRoaXMuZHluYW1pYyA9IGR5bmFtaWMgPyBkeW5hbWljIDogZmFsc2U7XHJcblx0fVxyXG5cclxuXHQvLyBTZXNzaW9uXHJcblx0ZnVuY3Rpb24gU2Vzc2lvbiggbGltaXQgKSB7XHJcblx0XHRsaW1pdCA9IHR5cGVvZiBsaW1pdCA9PT0gXCJudW1iZXJcIiAmJiBsaW1pdCA+IDAgPyBsaW1pdCA6IG51bGw7XHJcblx0XHR0aGlzLnJlbmFtZSA9IDA7XHJcblx0XHR0aGlzLm1vZHVsZXMgPSB7fTtcclxuXHRcdHRoaXMubW9kdWxlcy51c2VyID0gbmV3IE1vZHVsZShcInVzZXJcIiwge30sIFwiYWxsXCIsIHtcclxuXHRcdFx0c2Vzc2lvbjogdGhpcyxcclxuXHRcdFx0ZGVwZW5kZW5jaWVzOiBbXCJzeXN0ZW1cIl1cclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5tb2R1bGVzLnN5c3RlbSA9IHBsLm1vZHVsZXMuc3lzdGVtO1xyXG5cdFx0dGhpcy5ydWxlcyA9IHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzO1xyXG5cdFx0dGhpcy50b3RhbF90aHJlYWRzID0gMDtcclxuXHRcdHRoaXMucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdHRoaXMucHVibGljX3ByZWRpY2F0ZXMgPSB0aGlzLm1vZHVsZXMudXNlci5wdWJsaWNfcHJlZGljYXRlcztcclxuXHRcdHRoaXMubXVsdGlmaWxlX3ByZWRpY2F0ZXMgPSB0aGlzLm1vZHVsZXMudXNlci5tdWx0aWZpbGVfcHJlZGljYXRlcztcclxuXHRcdHRoaXMubGltaXQgPSBsaW1pdDtcclxuXHRcdHRoaXMuc3RyZWFtcyA9IHtcclxuXHRcdFx0XCJ1c2VyX2lucHV0XCI6IG5ldyBTdHJlYW0oXHJcblx0XHRcdFx0bm9kZWpzX2ZsYWcgPyBub2RlanNfdXNlcl9pbnB1dCA6IHRhdV91c2VyX2lucHV0LFxyXG5cdFx0XHRcdFwicmVhZFwiLCBcInVzZXJfaW5wdXRcIiwgXCJ0ZXh0XCIsIGZhbHNlLCBcInJlc2V0XCIgKSxcclxuXHRcdFx0XCJ1c2VyX291dHB1dFwiOiBuZXcgU3RyZWFtKFxyXG5cdFx0XHRcdG5vZGVqc19mbGFnID8gbm9kZWpzX3VzZXJfb3V0cHV0IDogdGF1X3VzZXJfb3V0cHV0LFxyXG5cdFx0XHRcdFwiYXBwZW5kXCIsIFwidXNlcl9vdXRwdXRcIiwgXCJ0ZXh0XCIsIGZhbHNlLCBcInJlc2V0XCIgKSxcclxuXHRcdFx0XCJ1c2VyX2Vycm9yXCI6IG5ldyBTdHJlYW0oXHJcblx0XHRcdFx0bm9kZWpzX2ZsYWcgPyBub2RlanNfdXNlcl9lcnJvciA6IHRhdV91c2VyX2Vycm9yLFxyXG5cdFx0XHRcdFwiYXBwZW5kXCIsIFwidXNlcl9lcnJvclwiLCBcInRleHRcIiwgZmFsc2UsIFwicmVzZXRcIiApLFxyXG5cdFx0fTtcclxuXHRcdHRoaXMuZmlsZV9zeXN0ZW0gPSBub2RlanNfZmxhZyA/IG5vZGVqc19maWxlX3N5c3RlbSA6IHRhdV9maWxlX3N5c3RlbTtcclxuXHRcdHRoaXMuc3RhbmRhcmRfaW5wdXQgPSB0aGlzLnN0cmVhbXNbXCJ1c2VyX2lucHV0XCJdO1xyXG5cdFx0dGhpcy5zdGFuZGFyZF9vdXRwdXQgPSB0aGlzLnN0cmVhbXNbXCJ1c2VyX291dHB1dFwiXTtcclxuXHRcdHRoaXMuc3RhbmRhcmRfZXJyb3IgPSB0aGlzLnN0cmVhbXNbXCJ1c2VyX2Vycm9yXCJdO1xyXG5cdFx0dGhpcy5jdXJyZW50X2lucHV0ID0gdGhpcy5zdHJlYW1zW1widXNlcl9pbnB1dFwiXTtcclxuXHRcdHRoaXMuY3VycmVudF9vdXRwdXQgPSB0aGlzLnN0cmVhbXNbXCJ1c2VyX291dHB1dFwiXTtcclxuXHRcdHRoaXMud29ya2luZ19kaXJlY3RvcnkgPSBcIi9cIjsgLy8gb25seSBmb3IgYnJvd3NlclxyXG5cdFx0dGhpcy5mb3JtYXRfc3VjY2VzcyA9IGZ1bmN0aW9uKCBzdGF0ZSApIHsgcmV0dXJuIHN0YXRlLnN1YnN0aXR1dGlvbjsgfTtcclxuXHRcdHRoaXMuZm9ybWF0X2Vycm9yID0gZnVuY3Rpb24oIHN0YXRlICkgeyByZXR1cm4gc3RhdGUuZ29hbDsgfTtcclxuXHRcdHRoaXMuZmxhZyA9IHtcdFxyXG5cdFx0XHRib3VuZGVkOiBwbC5mbGFnLmJvdW5kZWQudmFsdWUsXHJcblx0XHRcdG1heF9pbnRlZ2VyOiBwbC5mbGFnLm1heF9pbnRlZ2VyLnZhbHVlLFxyXG5cdFx0XHRtaW5faW50ZWdlcjogcGwuZmxhZy5taW5faW50ZWdlci52YWx1ZSxcclxuXHRcdFx0aW50ZWdlcl9yb3VuZGluZ19mdW5jdGlvbjogcGwuZmxhZy5pbnRlZ2VyX3JvdW5kaW5nX2Z1bmN0aW9uLnZhbHVlLFxyXG5cdFx0XHRjaGFyX2NvbnZlcnNpb246IHBsLmZsYWcuY2hhcl9jb252ZXJzaW9uLnZhbHVlLFxyXG5cdFx0XHRkZWJ1ZzogcGwuZmxhZy5kZWJ1Zy52YWx1ZSxcclxuXHRcdFx0bWF4X2FyaXR5OiBwbC5mbGFnLm1heF9hcml0eS52YWx1ZSxcclxuXHRcdFx0dW5rbm93bjogcGwuZmxhZy51bmtub3duLnZhbHVlLFxyXG5cdFx0XHRkb3VibGVfcXVvdGVzOiBwbC5mbGFnLmRvdWJsZV9xdW90ZXMudmFsdWUsXHJcblx0XHRcdG9jY3Vyc19jaGVjazogcGwuZmxhZy5vY2N1cnNfY2hlY2sudmFsdWUsXHJcblx0XHRcdGRpYWxlY3Q6IHBsLmZsYWcuZGlhbGVjdC52YWx1ZSxcclxuXHRcdFx0dmVyc2lvbl9kYXRhOiBwbC5mbGFnLnZlcnNpb25fZGF0YS52YWx1ZSxcclxuXHRcdFx0bm9kZWpzOiBwbC5mbGFnLm5vZGVqcy52YWx1ZSxcclxuXHRcdFx0YXJndjogcGwuZmxhZy5hcmd2LnZhbHVlXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5fX2xvYWRlZF9tb2R1bGVzID0gW107XHJcblx0XHR0aGlzLl9fY2hhcl9jb252ZXJzaW9uID0ge307XHJcblx0XHR0aGlzLl9fb3BlcmF0b3JzID0ge1xyXG5cdFx0XHQxMjAwOiB7IFwiOi1cIjogW1wiZnhcIiwgXCJ4ZnhcIl0sICBcIi0tPlwiOiBbXCJ4ZnhcIl0sIFwiPy1cIjogW1wiZnhcIl0gfSxcclxuXHRcdFx0MTE1MDogeyBcIm1ldGFfcHJlZGljYXRlXCI6IFtcImZ4XCJdIH0sXHJcblx0XHRcdDExMDA6IHsgXCI7XCI6IFtcInhmeVwiXSB9LFxyXG5cdFx0XHQxMDUwOiB7IFwiLT5cIjogW1wieGZ5XCJdLCBcIiotPlwiOiBbXCJ4ZnlcIl0gfSxcclxuXHRcdFx0MTAwMDogeyBcIixcIjogW1wieGZ5XCJdIH0sXHJcblx0XHRcdDkwMDogeyBcIlxcXFwrXCI6IFtcImZ5XCJdIH0sXHJcblx0XHRcdDcwMDoge1xyXG5cdFx0XHRcdFwiPVwiOiBbXCJ4ZnhcIl0sIFwiXFxcXD1cIjogW1wieGZ4XCJdLCBcIj09XCI6IFtcInhmeFwiXSwgXCJcXFxcPT1cIjogW1wieGZ4XCJdLFxyXG5cdFx0XHRcdFwiQDxcIjogW1wieGZ4XCJdLCBcIkA9PFwiOiBbXCJ4ZnhcIl0sIFwiQD5cIjogW1wieGZ4XCJdLCBcIkA+PVwiOiBbXCJ4ZnhcIl0sXHJcblx0XHRcdFx0XCI9Li5cIjogW1wieGZ4XCJdLCBcImlzXCI6IFtcInhmeFwiXSwgXCI9Oj1cIjogW1wieGZ4XCJdLCBcIj1cXFxcPVwiOiBbXCJ4ZnhcIl0sXHJcblx0XHRcdFx0XCI8XCI6IFtcInhmeFwiXSwgXCI9PFwiOiBbXCJ4ZnhcIl0sIFwiPlwiOiBbXCJ4ZnhcIl0sIFwiPj1cIjogW1wieGZ4XCJdXHJcblx0XHRcdH0sXHJcblx0XHRcdDYwMDogeyBcIjpcIjogW1wieGZ5XCJdIH0sXHJcblx0XHRcdDUwMDogeyBcIitcIjogW1wieWZ4XCJdLCBcIi1cIjogW1wieWZ4XCJdLCBcIi9cXFxcXCI6IFtcInlmeFwiXSwgXCJcXFxcL1wiOiBbXCJ5ZnhcIl0gfSxcclxuXHRcdFx0NDAwOiB7XHJcblx0XHRcdFx0XCIqXCI6IFtcInlmeFwiXSwgXCIvXCI6IFtcInlmeFwiXSwgXCIvL1wiOiBbXCJ5ZnhcIl0sIFwicmVtXCI6IFtcInlmeFwiXSxcclxuXHRcdFx0XHRcIm1vZFwiOiBbXCJ5ZnhcIl0sIFwiPDxcIjogW1wieWZ4XCJdLCBcIj4+XCI6IFtcInlmeFwiXSwgXCJkaXZcIjogW1wieWZ4XCJdXHJcblx0XHRcdH0sXHJcblx0XHRcdDIwMDogeyBcIioqXCI6IFtcInhmeFwiXSwgXCJeXCI6IFtcInhmeVwiXSwgXCItXCI6IFtcImZ5XCJdLCBcIitcIjogW1wiZnlcIl0sIFwiXFxcXFwiOiBbXCJmeVwiXSB9XHJcblx0XHR9O1xyXG5cdFx0dGhpcy50aHJlYWQgPSBuZXcgVGhyZWFkKCB0aGlzICk7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFRocmVhZHNcclxuXHRmdW5jdGlvbiBUaHJlYWQoIHNlc3Npb24gKSB7XHJcblx0XHR0aGlzLmVwb2NoID0gRGF0ZS5ub3coKTtcclxuXHRcdHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XHJcblx0XHR0aGlzLnNlc3Npb24udG90YWxfdGhyZWFkcysrO1xyXG5cdFx0dGhpcy5mb3JtYXRfc3VjY2VzcyA9IHNlc3Npb24uZm9ybWF0X3N1Y2Nlc3M7XHJcblx0XHR0aGlzLmZvcm1hdF9lcnJvciA9IHNlc3Npb24uZm9ybWF0X2Vycm9yO1xyXG5cdFx0dGhpcy50b3RhbF9zdGVwcyA9IDA7XHJcblx0XHR0aGlzLmNwdV90aW1lID0gMDtcclxuXHRcdHRoaXMucG9pbnRzID0gW107XHJcblx0XHR0aGlzLmRlYnVnZ2VyID0gZmFsc2U7XHJcblx0XHR0aGlzLmRlYnVnZ2VyX3N0YXRlcyA9IFtdO1xyXG5cdFx0dGhpcy5sZXZlbCA9IG5ldyBUZXJtKFwidG9wX2xldmVsXCIpO1xyXG5cdFx0dGhpcy5jdXJyZW50X2xpbWl0ID0gdGhpcy5zZXNzaW9uLmxpbWl0O1xyXG5cdFx0dGhpcy5oYXNfbGltaXQgPSB0aGlzLnNlc3Npb24ubGltaXQgIT09IG51bGw7XHJcblx0XHR0aGlzLndhcm5pbmdzID0gW107XHJcblx0XHR0aGlzLl9fY2FsbHMgPSBbXTtcclxuXHRcdHRoaXMuX19nb2FsX2V4cGFuc2lvbiA9IGZhbHNlO1xyXG5cdFx0dGhpcy5fX3N0YWNrcyA9IHt9O1xyXG5cdH1cclxuXHRcclxuXHQvLyBNb2R1bGVzXHJcblx0ZnVuY3Rpb24gTW9kdWxlKGlkLCBydWxlcywgZXhwb3J0cywgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXMgPSBvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXM7XHJcblx0XHRvcHRpb25zLm11bHRpZmlsZV9wcmVkaWNhdGVzID0gb3B0aW9ucy5tdWx0aWZpbGVfcHJlZGljYXRlcyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zLm11bHRpZmlsZV9wcmVkaWNhdGVzO1xyXG5cdFx0b3B0aW9ucy5tZXRhX3ByZWRpY2F0ZXMgPSBvcHRpb25zLm1ldGFfcHJlZGljYXRlcyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zLm1ldGFfcHJlZGljYXRlcztcclxuXHRcdG9wdGlvbnMuc2Vzc2lvbiA9IG9wdGlvbnMuc2Vzc2lvbiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuc2Vzc2lvbjtcclxuXHRcdG9wdGlvbnMuZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXMgPT09IHVuZGVmaW5lZCA/IFtdIDogb3B0aW9ucy5kZXBlbmRlbmNpZXM7XHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLnJ1bGVzID0gcnVsZXM7XHJcblx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlcyA9IHt9O1xyXG5cdFx0dGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXMgPSB7fTtcclxuXHRcdHRoaXMucHVibGljX3ByZWRpY2F0ZXMgPSBvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzO1xyXG5cdFx0dGhpcy5tdWx0aWZpbGVfcHJlZGljYXRlcyA9IG9wdGlvbnMubXVsdGlmaWxlX3ByZWRpY2F0ZXM7XHJcblx0XHR0aGlzLm1ldGFfcHJlZGljYXRlcyA9IG9wdGlvbnMubWV0YV9wcmVkaWNhdGVzO1xyXG5cdFx0dGhpcy5zcmNfcHJlZGljYXRlcyA9IHt9O1xyXG5cdFx0dGhpcy5kZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcclxuXHRcdHRoaXMuZXhwb3J0cyA9IGV4cG9ydHM7XHJcblx0XHR0aGlzLmlzX2xpYnJhcnkgPSBvcHRpb25zLnNlc3Npb24gPT09IG51bGw7XHJcblx0XHR0aGlzLm1vZHVsZXMgPSB7fTtcclxuXHRcdGlmKG9wdGlvbnMuc2Vzc2lvbikge1xyXG5cdFx0XHRvcHRpb25zLnNlc3Npb24ubW9kdWxlc1tpZF0gPSB0aGlzO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5kZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbGliID0gb3B0aW9ucy5kZXBlbmRlbmNpZXNbaV07XHJcblx0XHRcdFx0aWYoIW9wdGlvbnMuc2Vzc2lvbi5tb2R1bGVzLmhhc093blByb3BlcnR5KGxpYikpXHJcblx0XHRcdFx0XHRvcHRpb25zLnNlc3Npb24ubW9kdWxlc1tsaWJdID0gcGwubW9kdWxlc1tsaWJdO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwbC5tb2R1bGVzW2lkXSA9IHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZihleHBvcnRzICE9PSBcImFsbFwiKSB7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBleHBvcnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5wdWJsaWNfcHJlZGljYXRlc1tleHBvcnRzW2ldXSA9XHJcblx0XHRcdFx0XHRvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KGV4cG9ydHNbaV0pICYmXHJcblx0XHRcdFx0XHRvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzW2V4cG9ydHNbaV1dID09PSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLnVwZGF0ZV9pbmRpY2VzX2NsYXVzZXMoKTtcclxuXHR9XHJcblx0XHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgZXhwb3J0ZWRcclxuXHRNb2R1bGUucHJvdG90eXBlLmV4cG9ydHNfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5leHBvcnRzID09PSBcImFsbFwiIHx8IGluZGV4T2YodGhpcy5leHBvcnRzLCBpbmRpY2F0b3IpICE9PSAtMTtcclxuXHR9O1xyXG5cclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBwdWJsaWNcclxuXHRNb2R1bGUucHJvdG90eXBlLmlzX3B1YmxpY19wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IpIHtcclxuXHRcdHJldHVybiAhdGhpcy5wdWJsaWNfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpIHx8IHRoaXMucHVibGljX3ByZWRpY2F0ZXNbaW5kaWNhdG9yXSA9PT0gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIG11bHRpZmlsZVxyXG5cdE1vZHVsZS5wcm90b3R5cGUuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKCBpbmRpY2F0b3IgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aWZpbGVfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpICYmIHRoaXMubXVsdGlmaWxlX3ByZWRpY2F0ZXNbaW5kaWNhdG9yXSA9PT0gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBhIG1ldGEtcHJlZGljYXRlXHJcblx0TW9kdWxlLnByb3RvdHlwZS5pc19tZXRhX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKCBpbmRpY2F0b3IgKSB7XHJcblx0XHRpZih0aGlzLm1ldGFfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5tZXRhX3ByZWRpY2F0ZXNbaW5kaWNhdG9yXTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8vIFVwZGF0ZSBpbmRpY2VzIG9mIGFsbCBwcmVkaWNhdGVzXHJcblx0TW9kdWxlLnByb3RvdHlwZS51cGRhdGVfaW5kaWNlc19jbGF1c2VzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlcyA9IHt9O1xyXG5cdFx0dGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXMgPSB7fTtcclxuXHRcdGZvcih2YXIgaW5kaWNhdG9yIGluIHRoaXMucnVsZXMpXHJcblx0XHRcdHRoaXMudXBkYXRlX2luZGljZXNfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0fTtcclxuXHJcblx0Ly8gVXBkYXRlIGluZGljZXMgb2YgYSBwcmVkaWNhdGVcclxuXHRNb2R1bGUucHJvdG90eXBlLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvcikge1xyXG5cdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXSA9IHt9O1xyXG5cdFx0dGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0aWYoIUFycmF5LmlzQXJyYXkodGhpcy5ydWxlc1tpbmRpY2F0b3JdKSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXNbaW5kaWNhdG9yXS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgY2xhdXNlID0gdGhpcy5ydWxlc1tpbmRpY2F0b3JdW2ldO1xyXG5cdFx0XHR0aGlzLmFkZF9pbmRleF9wcmVkaWNhdGUoY2xhdXNlKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBBZGQgaW5kZXhlZCBjbHV1c2UgdG8gYSBwcmVkaWNhdGVcclxuXHRNb2R1bGUucHJvdG90eXBlLmFkZF9pbmRleF9wcmVkaWNhdGUgPSBmdW5jdGlvbihjbGF1c2UpIHtcclxuXHRcdHZhciBpbmRpY2F0b3IgPSBjbGF1c2UuaGVhZC5pbmRpY2F0b3I7XHJcblx0XHR2YXIgaW5kZXggPSBjbGF1c2UuaGVhZC5hcmdzLmxlbmd0aCA+IDAgPyBjbGF1c2UuaGVhZC5hcmdzWzBdLmluZGV4IDogdW5kZWZpbmVkO1xyXG5cdFx0aWYoaW5kZXgpIHtcclxuXHRcdFx0aWYoIXRoaXMuaW5kZXhlZF9jbGF1c2VzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpXHJcblx0XHRcdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXSA9IHt9O1xyXG5cdFx0XHRpZighdGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXS5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcclxuXHRcdFx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdW2luZGV4XSA9IFtdO1xyXG5cdFx0XHRcdGlmKHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpXHJcblx0XHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXS5sZW5ndGg7IGorKylcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXVtpbmRleF0ucHVzaCh0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdW2pdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdW2luZGV4XS5wdXNoKGNsYXVzZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZighdGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSlcclxuXHRcdFx0XHR0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdID0gW107XHJcblx0XHRcdHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl0ucHVzaChjbGF1c2UpO1xyXG5cdFx0XHRmb3IodmFyIGluZGV4IGluIHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl0pXHJcblx0XHRcdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXVtpbmRleF0ucHVzaChjbGF1c2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cclxuXHJcblx0Ly8gVU5JRlkgUFJPTE9HIE9CSkVDVFNcclxuXHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS51bmlmeSA9IGZ1bmN0aW9uKG9iaiwgb2NjdXJzX2NoZWNrKSB7XHJcblx0XHRpZihvY2N1cnNfY2hlY2sgJiYgaW5kZXhPZihvYmoudmFyaWFibGVzKCksIHRoaXMuaWQpICE9PSAtMSAmJiAhcGwudHlwZS5pc192YXJpYWJsZShvYmopKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0bGlua3NbdGhpcy5pZF0gPSBvYmo7XHJcblx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbihsaW5rcyk7XHJcblx0fTtcclxuXHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbihvYmosIG9jY3Vyc19jaGVjaykge1xyXG5cdFx0aWYocGwudHlwZS5pc19udW1iZXIob2JqKSAmJiB0aGlzLnZhbHVlID09PSBvYmoudmFsdWUgJiYgdGhpcy5pc19mbG9hdCA9PT0gb2JqLmlzX2Zsb2F0KVxyXG5cdFx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS51bmlmeSA9IGZ1bmN0aW9uKG9iaiwgb2NjdXJzX2NoZWNrKSB7XHJcblx0XHRpZighcGwudHlwZS5pc190ZXJtKG9iaikgJiYgb2JqLnVuaWZ5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0cmV0dXJuIG9iai51bmlmeSh0aGlzLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfdGVybShvYmopICYmIHRoaXMuaW5kaWNhdG9yID09PSBvYmouaW5kaWNhdG9yKSB7XHJcblx0XHRcdHZhciBzdWJzID0gbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KHRoaXMuYXJnc1tpXS5hcHBseShzdWJzKSwgb2JqLmFyZ3NbaV0uYXBwbHkoc3VicyksIG9jY3Vyc19jaGVjayk7XHJcblx0XHRcdFx0aWYobWd1ID09PSBudWxsKVxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0Zm9yKHZhciB4IGluIG1ndS5saW5rcylcclxuXHRcdFx0XHRcdHN1YnMubGlua3NbeF0gPSBtZ3UubGlua3NbeF07XHJcblx0XHRcdFx0c3VicyA9IHN1YnMuYXBwbHkobWd1KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3VicztcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLnVuaWZ5ID0gZnVuY3Rpb24ob2JqLCBfb2NjdXJzX2NoZWNrKSB7XHJcblx0XHRpZihwbC50eXBlLmlzX3N0cmVhbShvYmopICYmIHRoaXMuaWQgPT09IG9iai5pZClcclxuXHRcdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdFN0cmVhbS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0aWYodGhpcy5pZCA8IG9iai5pZClcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0ZWxzZSBpZih0aGlzLmlkID09PSBvYmouaWQpXHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cclxuXHQvLyBQUk9MT0cgT0JKRUNUUyBUTyBTVFJJTkdcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0aWYob3B0aW9ucy52YXJpYWJsZV9uYW1lcykge1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IG9wdGlvbnMudmFyaWFibGVfbmFtZXM7XHJcblx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdHZhciBoZWFkID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShoZWFkKSAmJiBoZWFkLmluZGljYXRvciA9PT0gXCI9LzJcIlxyXG5cdFx0XHRcdCYmIHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZC5hcmdzWzFdKSAmJiBoZWFkLmFyZ3NbMV0uaWQgPT09IHRoaXMuaWRcclxuXHRcdFx0XHQmJiBwbC50eXBlLmlzX2F0b20oaGVhZC5hcmdzWzBdKSlcclxuXHRcdFx0XHRcdHJldHVybiBoZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuaWQ7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBfICkge1xyXG5cdFx0dmFyIHN0ciA9IHRoaXMudmFsdWUudG9TdHJpbmcoKTtcclxuXHRcdHZhciBlID0gc3RyLmluZGV4T2YoXCJlXCIpO1xyXG5cdFx0aWYoZSAhPT0gLTEpIHtcclxuXHRcdFx0aWYoc3RyLmluZGV4T2YoXCIuXCIpICE9PSAtMSlcclxuXHRcdFx0XHRyZXR1cm4gc3RyO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKFwiZVwiLCBcIi4wZVwiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmlzX2Zsb2F0ICYmIGluZGV4T2Yoc3RyLCBcIi5cIikgPT09IC0xID8gdGhpcy52YWx1ZSArIFwiLjBcIiA6IHN0cjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucywgcHJpb3JpdHksIGZyb20gKSB7XHJcblx0XHRvcHRpb25zID0gIW9wdGlvbnMgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRvcHRpb25zLnF1b3RlZCA9IG9wdGlvbnMucXVvdGVkID09PSB1bmRlZmluZWQgPyBmYWxzZTogb3B0aW9ucy5xdW90ZWQ7XHJcblx0XHRvcHRpb25zLmlnbm9yZV9vcHMgPSBvcHRpb25zLmlnbm9yZV9vcHMgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5pZ25vcmVfb3BzO1xyXG5cdFx0b3B0aW9ucy5udW1iZXJ2YXJzID0gb3B0aW9ucy5udW1iZXJ2YXJzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMubnVtYmVydmFycztcclxuXHRcdG9wdGlvbnMudmFyaWFibGVfbmFtZXMgPSBvcHRpb25zLnZhcmlhYmxlX25hbWVzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMudmFyaWFibGVfbmFtZXM7XHJcblx0XHRwcmlvcml0eSA9IHByaW9yaXR5ID09PSB1bmRlZmluZWQgPyB7cHJpb3JpdHk6IDEyMDAsIGNsYXNzOiBcIlwiLCBpbmRpY2F0b3I6IFwiXCJ9IDogcHJpb3JpdHk7XHJcblx0XHRmcm9tID0gZnJvbSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGZyb207XHJcblx0XHR2YXIgYXJnX3ByaW9yaXR5ID0ge3ByaW9yaXR5OiA5OTksIGNsYXNzOiBcIlwiLCBpbmRpY2F0b3I6IFwiXCJ9O1xyXG5cdFx0aWYoIG9wdGlvbnMubnVtYmVydmFycyAmJiB0aGlzLmluZGljYXRvciA9PT0gXCIkVkFSLzFcIiAmJiBwbC50eXBlLmlzX2ludGVnZXIoIHRoaXMuYXJnc1swXSApICYmIHRoaXMuYXJnc1swXS52YWx1ZSA+PSAwICkge1xyXG5cdFx0XHR2YXIgaSA9IHRoaXMuYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0dmFyIG51bWJlciA9IE1hdGguZmxvb3IoIGkvMjYgKTtcclxuXHRcdFx0dmFyIGxldHRlciA9ICBpICUgMjY7XHJcblx0XHRcdHJldHVybiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCJbbGV0dGVyXSArIChudW1iZXIgIT09IDAgPyBudW1iZXIgOiBcIlwiKTtcclxuXHRcdH1cclxuXHRcdHN3aXRjaCggdGhpcy5pbmRpY2F0b3IgKXtcclxuXHRcdFx0Y2FzZSBcIltdLzBcIjpcclxuXHRcdFx0Y2FzZSBcInt9LzBcIjpcclxuXHRcdFx0Y2FzZSBcIiEvMFwiOlxyXG5cdFx0XHRcdHJldHVybiB0aGlzLmlkO1xyXG5cdFx0XHRjYXNlIFwie30vMVwiOlxyXG5cdFx0XHRcdGlmKCBvcHRpb25zLmlnbm9yZV9vcHMgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwie1wiICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIn1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwie30oXCIgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0Y2FzZSBcIi4vMlwiOlxyXG5cdFx0XHRcdGlmKCBvcHRpb25zLmlnbm9yZV9vcHMgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdFx0dmFyIGxpc3QgPSBcIltcIiArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucywgYXJnX3ByaW9yaXR5ICk7XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IHRoaXMuYXJnc1sxXTtcclxuXHRcdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0bGlzdCArPSBcIixcIiArIHBvaW50ZXIuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucywgYXJnX3ByaW9yaXR5ICk7XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0ICs9IFwifFwiICsgcG9pbnRlci50b1N0cmluZyggb3B0aW9ucywgYXJnX3ByaW9yaXR5ICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ICs9IFwiXVwiO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGxpc3Q7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHZhciBpZCA9IHRoaXMuaWQ7XHJcblx0XHRcdFx0dmFyIG9wZXJhdG9yID0gb3B0aW9ucy5zZXNzaW9uID8gb3B0aW9ucy5zZXNzaW9uLmxvb2t1cF9vcGVyYXRvciggdGhpcy5pZCwgdGhpcy5hcmdzLmxlbmd0aCApIDogbnVsbDtcclxuXHRcdFx0XHRpZiggb3B0aW9ucy5zZXNzaW9uID09PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5pZ25vcmVfb3BzIHx8IG9wZXJhdG9yID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0aWYoIG9wdGlvbnMucXVvdGVkICYmICghIC9eKCF8W2Etel1bMC05YS16QS1aX10qfFsjXFwkXFwmXFwqXFwrXFwtXFwuXFwvXFw6XFw8XFw9XFw+XFw/XFxAXFxeXFx+XFxcXF0rKSQvLnRlc3QoIGlkICkgJiYgaWQgIT09IFwie31cIiAmJiBpZCAhPT0gXCJbXVwiIHx8IGluZGV4T2YoW1wiLlwiLFwiLFwiLFwiO1wiXSwgaWQpICE9PSAtMSB8fCBpZC5zdWJzdHJpbmcoMCwyKSA9PT0gXCIvKlwiKSApXHJcblx0XHRcdFx0XHRcdGlkID0gXCInXCIgKyByZWRvRXNjYXBlKGlkKSArIFwiJ1wiO1xyXG5cdFx0XHRcdFx0aWYoIHRoaXMuYXJncy5sZW5ndGggPT09IDAgJiYgaXNfZ3JhcGhpY190b2tlbih0aGlzLmlkKSAmJiBwcmlvcml0eS5pbmRpY2F0b3IgIT09IFwiXCIpXHJcblx0XHRcdFx0XHRcdHJldHVybiBcIihcIiArIGlkICsgXCIpXCI7XHJcblx0XHRcdFx0XHRyZXR1cm4gaWQgKyAodGhpcy5hcmdzLmxlbmd0aCA+IDAgPyBcIihcIiArIG1hcCggdGhpcy5hcmdzLFxyXG5cdFx0XHRcdFx0XHRmdW5jdGlvbih4KSB7IHJldHVybiB4LnRvU3RyaW5nKG9wdGlvbnMsIGFyZ19wcmlvcml0eSk7IH1cclxuXHRcdFx0XHRcdCkuam9pbihcIixcIikgKyBcIilcIiA6IFwiXCIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgcHJpb3JpdHlfb3AgPSBwYXJzZUludChvcGVyYXRvci5wcmlvcml0eSk7XHJcblx0XHRcdFx0XHR2YXIgcHJpb3JpdHlfYXJnID0gcGFyc2VJbnQocHJpb3JpdHkucHJpb3JpdHkpO1xyXG5cdFx0XHRcdFx0dmFyIGNvbmQgPSBwcmlvcml0eV9vcCA+IHByaW9yaXR5X2FyZyB8fCBwcmlvcml0eV9vcCA9PT0gcHJpb3JpdHlfYXJnICYmIChcclxuXHRcdFx0XHRcdFx0b3BlcmF0b3IuY2xhc3MgPT09IFwieGZ4XCIgfHxcclxuXHRcdFx0XHRcdFx0b3BlcmF0b3IuY2xhc3MgPT09IFwieGZ5XCIgJiYgdGhpcy5pbmRpY2F0b3IgIT09IHByaW9yaXR5LmluZGljYXRvciB8fFxyXG5cdFx0XHRcdFx0XHRvcGVyYXRvci5jbGFzcyA9PT0gXCJ5ZnhcIiAmJiB0aGlzLmluZGljYXRvciAhPT0gcHJpb3JpdHkuaW5kaWNhdG9yIHx8XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yID09PSBwcmlvcml0eS5pbmRpY2F0b3IgJiYgb3BlcmF0b3IuY2xhc3MgPT09IFwieWZ4XCIgJiYgZnJvbSA9PT0gXCJyaWdodFwiIHx8XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yID09PSBwcmlvcml0eS5pbmRpY2F0b3IgJiYgb3BlcmF0b3IuY2xhc3MgPT09IFwieGZ5XCIgJiYgZnJvbSA9PT0gXCJsZWZ0XCIgfHxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3IgPT09IHByaW9yaXR5LmluZGljYXRvciAmJiBvcGVyYXRvci5jbGFzcyA9PT0gXCJ4ZlwiICYmIGZyb20gPT09IFwibGVmdFwiIHx8XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yID09PSBwcmlvcml0eS5pbmRpY2F0b3IgJiYgb3BlcmF0b3IuY2xhc3MgPT09IFwiZnhcIiAmJiBmcm9tID09PSBcInJpZ2h0XCIpO1xyXG5cdFx0XHRcdFx0b3BlcmF0b3IuaW5kaWNhdG9yID0gdGhpcy5pbmRpY2F0b3I7XHJcblx0XHRcdFx0XHR2YXIgbHBhciA9IGNvbmQgPyBcIihcIiA6IFwiXCI7XHJcblx0XHRcdFx0XHR2YXIgcnBhciA9IGNvbmQgPyBcIilcIiA6IFwiXCI7XHJcblx0XHRcdFx0XHR2YXIgc3BhY2UgPSAhKGlzX2dyYXBoaWNfdG9rZW4odGhpcy5pZCkgfHwgdGhpcy5pZCA9PT0gXCIsXCIgfHwgdGhpcy5pZCA9PT0gXCI7XCIpXHJcblx0XHRcdFx0XHRcdHx8IG9wZXJhdG9yLmNsYXNzLmxlbmd0aCA9PT0gMlxyXG5cdFx0XHRcdFx0XHR8fCBvcGVyYXRvci5jbGFzcy5sZW5ndGggPT09IDMgJiYgcGwudHlwZS5pc19udW1iZXIodGhpcy5hcmdzWzFdKSAmJiB0aGlzLmFyZ3NbMV0udmFsdWUgPCAwID8gXCIgXCIgOiBcIlwiO1xyXG5cdFx0XHRcdFx0aWYoIHRoaXMuYXJncy5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBscGFyICsgdGhpcy5pZCArIHJwYXI7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIFtcImZ5XCIsXCJmeFwiXS5pbmRleE9mKCBvcGVyYXRvci5jbGFzcykgIT09IC0xICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbHBhciArIGlkICsgc3BhY2UgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMsIG9wZXJhdG9yLCBcInJpZ2h0XCIgKSArIHJwYXI7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIFtcInlmXCIsXCJ4ZlwiXS5pbmRleE9mKCBvcGVyYXRvci5jbGFzcykgIT09IC0xICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbHBhciArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucywgb3BlcmF0b3IsIFwibGVmdFwiICkgKyBzcGFjZSArIGlkICsgcnBhcjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBscGFyICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zLCBvcGVyYXRvciwgXCJsZWZ0XCIgKSArIHNwYWNlICsgdGhpcy5pZCArIHNwYWNlICsgdGhpcy5hcmdzWzFdLnRvU3RyaW5nKCBvcHRpb25zLCBvcGVyYXRvciwgXCJyaWdodFwiICkgKyAgcnBhcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggXyApIHtcclxuXHRcdHJldHVybiBcIjxzdHJlYW0+KFwiICsgdGhpcy5pZCArIFwiKVwiO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3Vic3RpdHV0aW9uc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHRcdHZhciBzdHIgPSBcIntcIjtcclxuXHRcdGZvciggdmFyIGxpbmsgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpIGNvbnRpbnVlO1xyXG5cdFx0XHRpZiggc3RyICE9PSBcIntcIiApIHtcclxuXHRcdFx0XHRzdHIgKz0gXCIsIFwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0ciArPSBsaW5rICsgXCIvXCIgKyB0aGlzLmxpbmtzW2xpbmtdLnRvU3RyaW5nKCBvcHRpb25zICk7XHJcblx0XHR9XHJcblx0XHRzdHIgKz0gXCJ9XCI7XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3RhdGVzXHJcblx0U3RhdGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHRpZiggdGhpcy5nb2FsID09PSBudWxsICkge1xyXG5cdFx0XHRyZXR1cm4gXCI8XCIgKyB0aGlzLnN1YnN0aXR1dGlvbi50b1N0cmluZyggb3B0aW9ucyApICsgXCI+XCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gXCI8XCIgKyB0aGlzLmdvYWwudG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiLCBcIiArIHRoaXMuc3Vic3RpdHV0aW9uLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIj5cIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHRcdGlmKCAhdGhpcy5ib2R5ICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIi5cIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmhlYWQudG9TdHJpbmcoIG9wdGlvbnMsIDEyMDAsIFwibGVmdFwiICkgKyBcIiA6LSBcIiArIHRoaXMuYm9keS50b1N0cmluZyggb3B0aW9ucywgMTIwMCwgXCJyaWdodFwiICkgKyBcIi5cIjtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIFNlc3Npb25cclxuXHRTZXNzaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRmb3IodmFyIHByb3AgaW4gdGhpcy5tb2R1bGVzKSB7XHJcblx0XHRcdGlmKHRoaXMubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiB0aGlzLm1vZHVsZXNbcHJvcF0uaXNfbGlicmFyeSlcclxuXHRcdFx0XHRzdHIgKz0gXCI6LSB1c2VfbW9kdWxlKGxpYnJhcnkoXCIgKyB0aGlzLm1vZHVsZXNbcHJvcF0gKyBcIikpLlxcblwiO1xyXG5cdFx0fVxyXG5cdFx0c3RyICs9IFwiXFxuXCI7XHJcblx0XHRmb3IodmFyIGtleSBpbiB0aGlzLm1vZHVsZXMudXNlci5ydWxlcykge1xyXG5cdFx0XHRpZighdGhpcy5tb2R1bGVzLnVzZXIucnVsZXMuaGFzT3duUHJvcGVydHkoa2V5KSkgY29udGludWU7XHJcblx0XHRcdGZvcihpID0gMDsgaSA8IHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzW2tleV0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRzdHIgKz0gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXNba2V5XVtpXS50b1N0cmluZyhvcHRpb25zKTtcclxuXHRcdFx0XHRzdHIgKz0gXCJcXG5cIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIENMT05FIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBWYXIoIHRoaXMuaWQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IE51bSggdGhpcy52YWx1ZSwgdGhpcy5pc19mbG9hdCApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHRlcm0gPSBuZXcgVGVybSggdGhpcy5pZCwgbWFwKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBhcmcgKSB7XHJcblx0XHRcdHJldHVybiBhcmcuY2xvbmUoKTtcclxuXHRcdH0gKSApO1xyXG5cdFx0aWYodGhpcy5kZWZpbml0aW9uX21vZHVsZSlcclxuXHRcdFx0dGVybS5kZWZpbml0aW9uX21vZHVsZSA9IHRoaXMuZGVmaW5pdGlvbl9tb2R1bGU7XHJcblx0XHRyZXR1cm4gdGVybTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBTdHJlYW0oIHRoaXMuc3RyZWFtLCB0aGlzLm1vZGUsIHRoaXMuYWxpYXMsIHRoaXMudHlwZSwgdGhpcy5yZXBvc2l0aW9uLCB0aGlzLmVvZl9hY3Rpb24gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN1YnN0aXR1dGlvbnNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdHZhciBhdHRycyA9IHt9O1xyXG5cdFx0Zm9yKCB2YXIgbGluayBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSkgY29udGludWU7XHJcblx0XHRcdGxpbmtzW2xpbmtdID0gdGhpcy5saW5rc1tsaW5rXS5jbG9uZSgpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJzICkge1xyXG5cdFx0XHRpZighdGhpcy5hdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRycykpIGNvbnRpbnVlO1xyXG5cdFx0XHRhdHRyc1thdHRyXSA9IHt9O1xyXG5cdFx0XHRmb3IoIHZhciBtIGluIHRoaXMuYXR0cnNbYXR0cl0gKSB7XHJcblx0XHRcdFx0aWYoIXRoaXMuYXR0cnNbYXR0cl0uaGFzT3duUHJvcGVydHkobSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGF0dHJzW2F0dHJdW21dID0gdGhpcy5hdHRyc1thdHRyXVttXS5jbG9uZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbiggbGlua3MsIGF0dHJzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdGF0ZXNcclxuXHRTdGF0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgU3RhdGUoIHRoaXMuZ29hbC5jbG9uZSgpLCB0aGlzLnN1YnN0aXR1dGlvbi5jbG9uZSgpLCB0aGlzLnBhcmVudCApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBSdWxlKCB0aGlzLmhlYWQuY2xvbmUoKSwgdGhpcy5ib2R5ICE9PSBudWxsID8gdGhpcy5ib2R5LmNsb25lKCkgOiBudWxsICk7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBDT01QQVJFIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iaiApICYmIHRoaXMuaWQgPT09IG9iai5pZDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19udW1iZXIoIG9iaiApICYmIHRoaXMudmFsdWUgPT09IG9iai52YWx1ZSAmJiB0aGlzLmlzX2Zsb2F0ID09PSBvYmouaXNfZmxvYXQ7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRpZiggIXBsLnR5cGUuaXNfdGVybSggb2JqICkgfHwgdGhpcy5pbmRpY2F0b3IgIT09IG9iai5pbmRpY2F0b3IgKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRpZiggIXRoaXMuYXJnc1tpXS5lcXVhbHMoIG9iai5hcmdzW2ldICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfc3RyZWFtKCBvYmogKSAmJiB0aGlzLmlkID09PSBvYmouaWQ7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdWJzdGl0dXRpb25zXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdHZhciBsaW5rO1xyXG5cdFx0aWYoICFwbC50eXBlLmlzX3N1YnN0aXR1dGlvbiggb2JqICkgKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGZvciggbGluayBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSkgY29udGludWU7XHJcblx0XHRcdGlmKCAhb2JqLmxpbmtzW2xpbmtdIHx8ICF0aGlzLmxpbmtzW2xpbmtdLmVxdWFscyggb2JqLmxpbmtzW2xpbmtdICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRmb3IoIGxpbmsgaW4gb2JqLmxpbmtzICkge1xyXG5cdFx0XHRpZighb2JqLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKSBjb250aW51ZTtcclxuXHRcdFx0aWYoICF0aGlzLmxpbmtzW2xpbmtdICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdGF0ZXNcclxuXHRTdGF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX3N0YXRlKCBvYmogKSAmJiB0aGlzLmdvYWwuZXF1YWxzKCBvYmouZ29hbCApICYmIHRoaXMuc3Vic3RpdHV0aW9uLmVxdWFscyggb2JqLnN1YnN0aXR1dGlvbiApICYmIHRoaXMucGFyZW50ID09PSBvYmoucGFyZW50O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfcnVsZSggb2JqICkgJiYgdGhpcy5oZWFkLmVxdWFscyggb2JqLmhlYWQgKSAmJiAodGhpcy5ib2R5ID09PSBudWxsICYmIG9iai5ib2R5ID09PSBudWxsIHx8IHRoaXMuYm9keSAhPT0gbnVsbCAmJiB0aGlzLmJvZHkuZXF1YWxzKCBvYmouYm9keSApKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFJFTkFNRSBWQVJJQUJMRVMgT0YgUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRyZXR1cm4gdGhyZWFkLmdldF9mcmVlX3ZhcmlhYmxlKCB0aGlzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiggXyApIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0Ly8gZ3JvdW5kXHJcblx0XHRpZih0aGlzLmdyb3VuZClcclxuXHRcdFx0cmV0dXJuIG5ldyBUZXJtKHRoaXMuaWQsIHRoaXMuYXJncyk7XHJcblx0XHQvLyBsaXN0XHJcblx0XHRpZih0aGlzLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdHZhciBwb2ludGVyID0gdGhpcztcclxuXHRcdFx0d2hpbGUocG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgJiYgIXBvaW50ZXIuZ3JvdW5kKSB7XHJcblx0XHRcdFx0dmFyIGFwcCA9IHBvaW50ZXIuYXJnc1swXS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0XHRhcnIucHVzaChhcHApO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGxpc3QgPSBwb2ludGVyLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHRmb3IodmFyIGkgPSBhcnIubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxyXG5cdFx0XHRcdGxpc3QgPSBuZXcgVGVybShcIi5cIiwgW2FycltpXSwgbGlzdF0pO1xyXG5cdFx0XHRyZXR1cm4gbGlzdDtcclxuXHRcdH1cclxuXHRcdC8vIGNvbXBvdW5kIHRlcm1cclxuXHRcdHZhciBhcmdzID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBhcHAgPSB0aGlzLmFyZ3NbaV0ucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdGFyZ3MucHVzaChhcHApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBUZXJtKHRoaXMuaWQsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdHJldHVybiBuZXcgUnVsZSggdGhpcy5oZWFkLnJlbmFtZSggdGhyZWFkICksIHRoaXMuYm9keSAhPT0gbnVsbCA/IHRoaXMuYm9keS5yZW5hbWUoIHRocmVhZCApIDogbnVsbCApO1xyXG5cdH07XHJcblxyXG5cclxuXHJcblx0Ly8gQ0hFQ0sgSUYgUkVOQU1FXHJcblxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuaXNfcmVuYW1lID0gZnVuY3Rpb24ob2JqLCBsaW5rcykge1xyXG5cdFx0bGlua3MgPSBsaW5rcyB8fCB7fTtcclxuXHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKG9iailcclxuXHRcdHx8IGxpbmtzLmhhc093blByb3BlcnR5KHRoaXMuaWQpICYmIGxpbmtzW3RoaXMuaWRdICE9PSBvYmouaWRcclxuXHRcdHx8IGxpbmtzLmhhc093blByb3BlcnR5KG9iai5pZCkgJiYgbGlua3Nbb2JqLmlkXSAhPT0gdGhpcy5pZClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0bGlua3NbdGhpcy5pZF0gPSBvYmouaWQ7XHJcblx0XHRsaW5rc1tvYmouaWRdID0gdGhpcy5pZDtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuaXNfcmVuYW1lID0gZnVuY3Rpb24ob2JqLCBfbGlua3MpIHtcclxuXHRcdHJldHVybiB0aGlzLmVxdWFscyhvYmopO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5pc19yZW5hbWUgPSBmdW5jdGlvbihvYmosIGxpbmtzKSB7XHJcblx0XHRsaW5rcyA9IGxpbmtzIHx8IHt9O1xyXG5cdFx0aWYoIXBsLnR5cGUuaXNfdGVybShvYmopIHx8IHRoaXMuaW5kaWNhdG9yICE9PSBvYmouaW5kaWNhdG9yKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKCFwbC5pc19yZW5hbWUodGhpcy5hcmdzW2ldLCBvYmouYXJnc1tpXSwgbGlua3MpKVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLmlzX3JlbmFtZSA9IGZ1bmN0aW9uKG9iaiwgX2xpbmtzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHMob2JqKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIEdFVCBJRCBPRiBWQVJJQUJMRVMgRlJPTSBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuaWRdO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gW107XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5ncm91bmQpXHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdHJldHVybiBbXS5jb25jYXQuYXBwbHkoIFtdLCBtYXAoIHRoaXMuYXJncywgZnVuY3Rpb24oIGFyZyApIHtcclxuXHRcdFx0cmV0dXJuIGFyZy52YXJpYWJsZXMoKTtcclxuXHRcdH0gKSApO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKCB0aGlzLmJvZHkgPT09IG51bGwgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmhlYWQudmFyaWFibGVzKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLnZhcmlhYmxlcygpLmNvbmNhdCggdGhpcy5ib2R5LnZhcmlhYmxlcygpICk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBBUFBMWSBTVUJTVElUVVRJT05TIFRPIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBzdWJzICkge1xyXG5cdFx0aWYoIHN1YnMubG9va3VwKCB0aGlzLmlkICkgKSB7XHJcblx0XHRcdHJldHVybiBzdWJzLmxvb2t1cCggdGhpcy5pZCApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBfICkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIHN1YnMgKSB7XHJcblx0XHQvLyBncm91bmQgYXRvbVxyXG5cdFx0aWYodGhpcy5ncm91bmQpXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0Ly8gbGlzdFxyXG5cdFx0aWYodGhpcy5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXM7XHJcblx0XHRcdHdoaWxlKHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICYmICFwb2ludGVyLmdyb3VuZCkge1xyXG5cdFx0XHRcdHZhciBhcHAgPSBwb2ludGVyLmFyZ3NbMF0uYXBwbHkoc3Vicyk7XHJcblx0XHRcdFx0YXJyLnB1c2goYXBwKTtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsaXN0ID0gcG9pbnRlci5hcHBseShzdWJzKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gYXJyLmxlbmd0aC0xOyBpID49IDA7IGktLSlcclxuXHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oXCIuXCIsIFthcnJbaV0sIGxpc3RdKTtcclxuXHRcdFx0cmV0dXJuIGxpc3Q7XHJcblx0XHR9XHJcblx0XHQvLyBjb21wb3VuZCB0ZXJtXHJcblx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgYXBwID0gdGhpcy5hcmdzW2ldLmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRhcmdzLnB1c2goYXBwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVGVybSh0aGlzLmlkLCBhcmdzLCB0aGlzLnJlZik7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggXyApIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBzdWJzICkge1xyXG5cdFx0cmV0dXJuIG5ldyBSdWxlKCB0aGlzLmhlYWQuYXBwbHkoIHN1YnMgKSwgdGhpcy5ib2R5ICE9PSBudWxsID8gdGhpcy5ib2R5LmFwcGx5KCBzdWJzICkgOiBudWxsICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdWJzdGl0dXRpb25zXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBzdWJzICkge1xyXG5cdFx0dmFyIGxpbmssIGxpbmtzID0ge30sIGF0dHIsIGF0dHJzID0ge30sIG07XHJcblx0XHRmb3IoIGxpbmsgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpIGNvbnRpbnVlO1xyXG5cdFx0XHRsaW5rc1tsaW5rXSA9IHRoaXMubGlua3NbbGlua10uYXBwbHkoc3Vicyk7XHJcblx0XHR9XHJcblx0XHRmb3IoIGF0dHIgaW4gdGhpcy5hdHRycyApIHtcclxuXHRcdFx0aWYoIXRoaXMuYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cikpIGNvbnRpbnVlO1xyXG5cdFx0XHRhdHRyc1thdHRyXSA9IHt9O1xyXG5cdFx0XHRmb3IoIG0gaW4gdGhpcy5hdHRyc1thdHRyXSApIHtcclxuXHRcdFx0XHRpZighdGhpcy5hdHRyc1thdHRyXS5oYXNPd25Qcm9wZXJ0eShtKSkgY29udGludWU7XHJcblx0XHRcdFx0YXR0cnNbYXR0cl1bbV0gPSB0aGlzLmF0dHJzW2F0dHJdW21dLmFwcGx5KHN1YnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbiggbGlua3MsIGF0dHJzICk7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBTRUxFQ1RJT04gRlVOQ1RJT05cclxuXHRcclxuXHQvLyBTZWxlY3QgdGVybVxyXG5cdFRlcm0ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHBvaW50ZXIgPSB0aGlzO1xyXG5cdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIiwvMlwiKVxyXG5cdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0cmV0dXJuIHBvaW50ZXI7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSZXBsYWNlIHRlcm1cclxuXHRUZXJtLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oIGV4cHIgKSB7XHJcblx0XHRpZiggdGhpcy5pbmRpY2F0b3IgPT09IFwiLC8yXCIgKSB7XHJcblx0XHRcdGlmKCB0aGlzLmFyZ3NbMF0uaW5kaWNhdG9yID09PSBcIiwvMlwiICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCIsXCIsIFt0aGlzLmFyZ3NbMF0ucmVwbGFjZSggZXhwciApLCB0aGlzLmFyZ3NbMV1dICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIGV4cHIgPT09IG51bGwgPyB0aGlzLmFyZ3NbMV0gOiBuZXcgVGVybSggXCIsXCIsIFtleHByLCB0aGlzLmFyZ3NbMV1dICk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFNlYXJjaCB0ZXJtXHJcblx0VGVybS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24oIGV4cHIgKSB7XHJcblx0XHRpZih0aGlzID09IGV4cHIgfHwgdGhpcy5yZWYgPT09IGV4cHIucmVmKVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrIClcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggdGhpcy5hcmdzW2ldICkgJiYgdGhpcy5hcmdzW2ldLnNlYXJjaCggZXhwciApIClcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFBST0xPRyBTRVNTSU9OUyBBTkQgVEhSRUFEU1xyXG5cclxuXHQvLyBQdXNoIHRvIGEgZ2xvYmFsIHN0YWNrXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUucHVzaF9nbG9iYWxfc3RhY2sgPSBmdW5jdGlvbihzdGFjaywgdmFsdWUpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5wdXNoX2dsb2JhbF9zdGFjayhzdGFjaywgdmFsdWUpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5wdXNoX2dsb2JhbF9zdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCB2YWx1ZSkge1xyXG5cdFx0aWYoIXRoaXMuX19zdGFja3MuaGFzT3duUHJvcGVydHkoc3RhY2spKVxyXG5cdFx0XHR0aGlzLl9fc3RhY2tzW3N0YWNrXSA9IFtdO1xyXG5cdFx0dGhpcy5fX3N0YWNrc1tzdGFja10ucHVzaCh2YWx1ZSk7XHJcblx0fTtcclxuXHJcblx0Ly8gUG9wIGFsbCBmcm9tIGEgZ2xvYmFsIHN0YWNrXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZmx1c2hfZ2xvYmFsX3N0YWNrID0gZnVuY3Rpb24oc3RhY2ssIHRhaWwpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5wdXNoX2dsb2JhbF9zdGFjayhzdGFjaywgdGFpbCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmZsdXNoX2dsb2JhbF9zdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCB0YWlsKSB7XHJcblx0XHR2YXIgbGlzdCA9IHRhaWwgfHwgbmV3IFRlcm0oXCJbXVwiLCBbXSk7XHJcblx0XHRpZih0aGlzLl9fc3RhY2tzLmhhc093blByb3BlcnR5KHN0YWNrKSkge1xyXG5cdFx0XHR3aGlsZSh0aGlzLl9fc3RhY2tzW3N0YWNrXS5sZW5ndGggPiAwKVxyXG5cdFx0XHRcdGxpc3QgPSBuZXcgVGVybShcIi5cIiwgW3RoaXMuX19zdGFja3Nbc3RhY2tdLnBvcCgpLCBsaXN0XSk7XHJcblx0XHRcdGRlbGV0ZSB0aGlzLl9fc3RhY2tzW3N0YWNrXTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH07XHJcblxyXG5cdC8vIFNldCBtYXggaW5mZXJlbmNlc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLnNldE1heEluZmVyZW5jZXMgPSBmdW5jdGlvbihtYXgpIHtcclxuXHRcdHRoaXMubGltaXQgPSB0eXBlb2YgbWF4ID09PSBcIm51bWJlclwiICYmIG1heCA+IDAgPyBtYXggOiBudWxsO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5zZXRNYXhJbmZlcmVuY2VzID0gZnVuY3Rpb24obWF4KSB7XHJcblx0XHR0aGlzLnNlc3Npb24uc2V0TWF4SW5mZXJlbmNlcyhtYXgpO1xyXG5cdFx0dGhpcy5jdXJyZW50X2xpbWl0ID0gdGhpcy5zZXNzaW9uLmxpbWl0O1xyXG5cdFx0dGhpcy5oYXNfbGltaXQgPSB0aGlzLnNlc3Npb24ubGltaXQgIT09IG51bGw7XHJcblx0fTtcclxuXHJcblx0Ly8gRm9ybWF0IGFuc3dlclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmZvcm1hdF9hbnN3ZXIgPSBmdW5jdGlvbihhbnN3ZXIsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5mb3JtYXRfYW5zd2VyKGFuc3dlciwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmZvcm1hdF9hbnN3ZXIgPSBmdW5jdGlvbihhbnN3ZXIsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBwbC5mb3JtYXRfYW5zd2VyKGFuc3dlciwgdGhpcywgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IGN1cnJlbnQgaW5wdXRcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfY3VycmVudF9pbnB1dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudF9pbnB1dDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X2N1cnJlbnRfaW5wdXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZ2V0X2N1cnJlbnRfaW5wdXQoKTtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgY3VycmVudCBvdXRwdXRcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfY3VycmVudF9vdXRwdXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRfb3V0cHV0O1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfY3VycmVudF9vdXRwdXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZ2V0X2N1cnJlbnRfb3V0cHV0KCk7XHJcblx0fTtcclxuXHJcblx0Ly8gU2V0IGN1cnJlbnQgaW5wdXRcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5zZXRfY3VycmVudF9pbnB1dCA9IGZ1bmN0aW9uKCBpbnB1dCApIHtcclxuXHRcdHRoaXMuY3VycmVudF9pbnB1dCA9IGlucHV0O1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5zZXRfY3VycmVudF9pbnB1dCA9IGZ1bmN0aW9uKCBpbnB1dCApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uc2V0X2N1cnJlbnRfaW5wdXQoIGlucHV0ICk7XHJcblx0fTtcclxuXHJcblx0Ly8gU2V0IGN1cnJlbnQgb3V0cHV0XHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuc2V0X2N1cnJlbnRfb3V0cHV0ID0gZnVuY3Rpb24oIG91dHB1dCApIHtcclxuXHRcdHRoaXMuY3VycmVudF9vdXRwdXQgPSBvdXRwdXQ7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnNldF9jdXJyZW50X291dHB1dCA9IGZ1bmN0aW9uKCBvdXRwdXQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLnNldF9jdXJyZW50X291dHB1dCggb3V0cHV0KTtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgc3RyZWFtIGJ5IGFsaWFzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X3N0cmVhbV9ieV9hbGlhcyA9IGZ1bmN0aW9uKCBhbGlhcyApIHtcclxuXHRcdHJldHVybiB0aGlzLnN0cmVhbXNbYWxpYXNdO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfc3RyZWFtX2J5X2FsaWFzID0gZnVuY3Rpb24oIGFsaWFzICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRfc3RyZWFtX2J5X2FsaWFzKCBhbGlhcyApO1xyXG5cdH07XHJcblxyXG5cdC8vIE9wZW4gZmlsZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmZpbGVfc3lzdGVtX29wZW4gPSBmdW5jdGlvbiggcGF0aCwgdHlwZSwgbW9kZSApIHtcclxuXHRcdGlmKHRoaXMuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcImZhbHNlLzBcIilcclxuXHRcdFx0cGF0aCA9IHRoaXMuYWJzb2x1dGVfZmlsZV9uYW1lKHBhdGgpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZmlsZV9zeXN0ZW0ub3BlbiggcGF0aCwgdHlwZSwgbW9kZSApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5maWxlX3N5c3RlbV9vcGVuID0gZnVuY3Rpb24oIHBhdGgsIHR5cGUsIG1vZGUgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmZpbGVfc3lzdGVtX29wZW4oIHBhdGgsIHR5cGUsIG1vZGUgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBBYnNvbHV0ZSBmaWxlIG5hbWVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hYnNvbHV0ZV9maWxlX25hbWUgPSBmdW5jdGlvbihmaWxlbmFtZSkge1xyXG5cdFx0dmFyIGFic29sdXRlO1xyXG5cdFx0Ly8gbm9kZS5qc1xyXG5cdFx0aWYodGhpcy5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCIpIHtcclxuXHRcdFx0dmFyIHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcclxuXHRcdFx0YWJzb2x1dGUgPSBmaWxlbmFtZTtcclxuXHRcdFx0Zm9yKHZhciBwcm9wIGluIHByb2Nlc3MuZW52KSB7XHJcblx0XHRcdFx0aWYoIXByb2Nlc3MuZW52Lmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0YWJzb2x1dGUgPSBhYnNvbHV0ZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxcJFwiICsgcHJvcCwgXCJnXCIpLCBwcm9jZXNzLmVudltwcm9wXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHBhdGgucmVzb2x2ZShhYnNvbHV0ZSk7XHJcblx0XHQvLyBicm93c2VyXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgY3dkID0gdGhpcy53b3JraW5nX2RpcmVjdG9yeTtcclxuXHRcdFx0aWYoZmlsZW5hbWVbMF0gPT09IFwiL1wiKVxyXG5cdFx0XHRcdGFic29sdXRlID0gZmlsZW5hbWU7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRhYnNvbHV0ZSA9IGN3ZCArIChjd2RbY3dkLmxlbmd0aC0xXSA9PT0gXCIvXCIgPyBmaWxlbmFtZSA6IFwiL1wiICsgZmlsZW5hbWUpO1xyXG5cdFx0XHRhYnNvbHV0ZSA9IGFic29sdXRlLnJlcGxhY2UoL1xcL1xcLlxcLy9nLCBcIi9cIik7XHJcblx0XHRcdHZhciBkaXJzID0gYWJzb2x1dGUuc3BsaXQoXCIvXCIpO1xyXG5cdFx0XHR2YXIgZGlyczIgPSBbXTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZihkaXJzW2ldICE9PSBcIi4uXCIpIHtcclxuXHRcdFx0XHRcdGRpcnMyLnB1c2goZGlyc1tpXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKGRpcnMyLmxlbmd0aCAhPT0gMClcclxuXHRcdFx0XHRcdFx0ZGlyczIucG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGFic29sdXRlID0gZGlyczIuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwuJC8sIFwiL1wiKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhYnNvbHV0ZTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuYWJzb2x1dGVfZmlsZV9uYW1lID0gZnVuY3Rpb24ocGF0aCwgY3dkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmFic29sdXRlX2ZpbGVfbmFtZShwYXRoLCBjd2QpO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBjb252ZXJzaW9uIG9mIHRoZSBjaGFyXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2NoYXJfY29udmVyc2lvbiA9IGZ1bmN0aW9uKCBjaGFyICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX19jaGFyX2NvbnZlcnNpb25bY2hhcl0gfHwgY2hhcjtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X2NoYXJfY29udmVyc2lvbiA9IGZ1bmN0aW9uKCBjaGFyICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRfY2hhcl9jb252ZXJzaW9uKCBjaGFyICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBQYXJzZSBhbiBleHByZXNzaW9uXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggc3RyaW5nICkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnBhcnNlKCBzdHJpbmcgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiggc3RyaW5nICkge1xyXG5cdFx0dmFyIHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoIHRoaXMgKTtcclxuXHRcdHRva2VuaXplci5uZXdfdGV4dCggc3RyaW5nICk7XHJcblx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemVyLmdldF90b2tlbnMoKTtcclxuXHRcdGlmKCB0b2tlbnMgPT09IG51bGwgKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aGlzLCB0b2tlbnMsIDAsIHRoaXMuX19nZXRfbWF4X3ByaW9yaXR5KCksIGZhbHNlKTtcclxuXHRcdGlmKCBleHByLmxlbiAhPT0gdG9rZW5zLmxlbmd0aCApXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdHJldHVybiB7IHZhbHVlOiBleHByLnZhbHVlLCBleHByOiBleHByLCB0b2tlbnM6IHRva2VucyB9O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IGZsYWcgdmFsdWVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfZmxhZyA9IGZ1bmN0aW9uKCBmbGFnICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZmxhZ1tmbGFnXTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X2ZsYWcgPSBmdW5jdGlvbiggZmxhZyApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZ2V0X2ZsYWcoIGZsYWcgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBBZGQgYSBydWxlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYWRkX3J1bGUgPSBmdW5jdGlvbihydWxlLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuYWRkX3J1bGUocnVsZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmFkZF9ydWxlID0gZnVuY3Rpb24ocnVsZSwgb3B0aW9ucykge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XHJcblx0XHRvcHRpb25zLmZyb20gPSBvcHRpb25zLmZyb20gPyBvcHRpb25zLmZyb20gOiBcIiR0YXUtanNcIjtcclxuXHRcdHZhciBtb2R1bGVfaWQsIGdldF9tb2R1bGU7XHJcblx0XHRpZihwbC50eXBlLmlzX3Rlcm0ocnVsZS5oZWFkKSAmJiBydWxlLmhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20ocnVsZS5oZWFkLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0dGhpcy50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgcnVsZS5oZWFkLmFyZ3NbMF0sIFwidG9wX2xldmVsLzBcIikpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRtb2R1bGVfaWQgPSBydWxlLmhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0cnVsZS5oZWFkID0gcnVsZS5oZWFkLmFyZ3NbMV07XHJcblx0XHR9XHJcblx0XHRpZihtb2R1bGVfaWQpIHtcclxuXHRcdFx0Z2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdGdldF9tb2R1bGUgPSBuZXcgTW9kdWxlKG1vZHVsZV9pZCwge30sIFwiYWxsXCIsIHtzZXNzaW9uOiB0aGlzLnNlc3Npb259KTtcclxuXHRcdFx0XHR0aGlzLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdID0gZ2V0X21vZHVsZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Z2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdO1xyXG5cdFx0fVxyXG5cdFx0Z2V0X21vZHVsZS5zcmNfcHJlZGljYXRlc1tydWxlLmhlYWQuaW5kaWNhdG9yXSA9IG9wdGlvbnMuZnJvbTtcclxuXHRcdGlmKCFnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHJ1bGUuaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdGdldF9tb2R1bGUucnVsZXNbcnVsZS5oZWFkLmluZGljYXRvcl0gPSBbXTtcclxuXHRcdH1cclxuXHRcdGdldF9tb2R1bGUucnVsZXNbcnVsZS5oZWFkLmluZGljYXRvcl0ucHVzaChydWxlKTtcclxuXHRcdGlmKCFnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KHJ1bGUuaGVhZC5pbmRpY2F0b3IpKVxyXG5cdFx0XHRnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW3J1bGUuaGVhZC5pbmRpY2F0b3JdID0gZmFsc2U7XHJcblx0XHQvLyB1cGRhdGUgdGVybSBpbmRleGluZ1xyXG5cdFx0Z2V0X21vZHVsZS5hZGRfaW5kZXhfcHJlZGljYXRlKHJ1bGUpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0Ly8gUnVuIGEgZGlyZWN0aXZlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUucnVuX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnJ1bl9kaXJlY3RpdmUoZGlyZWN0aXZlLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUucnVuX2RpcmVjdGl2ZSA9IGZ1bmN0aW9uKGRpcmVjdGl2ZSwgb3B0aW9ucykge1xyXG5cdFx0aWYocGwudHlwZS5pc19kaXJlY3RpdmUoZGlyZWN0aXZlKSkge1xyXG5cdFx0XHRpZihwbC5kaXJlY3RpdmVbZGlyZWN0aXZlLmluZGljYXRvcl0pXHJcblx0XHRcdFx0cmV0dXJuIHBsLmRpcmVjdGl2ZVtkaXJlY3RpdmUuaW5kaWNhdG9yXSh0aGlzLCBkaXJlY3RpdmUsIG9wdGlvbnMpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIHBsLmRpcmVjdGl2ZVtkaXJlY3RpdmUuaWQgKyBcIi8qXCJdKHRoaXMsIGRpcmVjdGl2ZSwgb3B0aW9ucyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgbWF4aW11bSBwcmlvcml0eSBvZiB0aGUgb3BlcmF0b3JzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuX19nZXRfbWF4X3ByaW9yaXR5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gXCIxMjAwXCI7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLl9fZ2V0X21heF9wcmlvcml0eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5fX2dldF9tYXhfcHJpb3JpdHkoKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBuZXh0IHByaW9yaXR5IG9mIHRoZSBvcGVyYXRvcnNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5fX2dldF9uZXh0X3ByaW9yaXR5ID0gZnVuY3Rpb24oIHByaW9yaXR5ICkge1xyXG5cdFx0dmFyIG1heCA9IDA7XHJcblx0XHRwcmlvcml0eSA9IHBhcnNlSW50KCBwcmlvcml0eSApO1xyXG5cdFx0Zm9yKCB2YXIga2V5IGluIHRoaXMuX19vcGVyYXRvcnMgKSB7XHJcblx0XHRcdGlmKCAhdGhpcy5fX29wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpICkgY29udGludWU7XHJcblx0XHRcdHZhciBuID0gcGFyc2VJbnQoa2V5KTtcclxuXHRcdFx0aWYoIG4gPiBtYXggJiYgbiA8IHByaW9yaXR5ICkgbWF4ID0gbjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtYXgudG9TdHJpbmcoKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuX19nZXRfbmV4dF9wcmlvcml0eSA9IGZ1bmN0aW9uKCBwcmlvcml0eSApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uX19nZXRfbmV4dF9wcmlvcml0eSggcHJpb3JpdHkgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBjbGFzc2VzIG9mIGFuIG9wZXJhdG9yXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuX19sb29rdXBfb3BlcmF0b3JfY2xhc3NlcyA9IGZ1bmN0aW9uKCBwcmlvcml0eSwgb3BlcmF0b3IgKSB7XHJcblx0XHRpZiggdGhpcy5fX29wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eSggcHJpb3JpdHkgKSAmJiB0aGlzLl9fb3BlcmF0b3JzW3ByaW9yaXR5XVtvcGVyYXRvcl0gaW5zdGFuY2VvZiBBcnJheSApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuX19vcGVyYXRvcnNbcHJpb3JpdHldW29wZXJhdG9yXSAgfHwgZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMgPSBmdW5jdGlvbiggcHJpb3JpdHksIG9wZXJhdG9yICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKCBwcmlvcml0eSwgb3BlcmF0b3IgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgb3BlcmF0b3JcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5sb29rdXBfb3BlcmF0b3IgPSBmdW5jdGlvbiggbmFtZSwgYXJpdHkgKSB7XHJcblx0XHRmb3IodmFyIHAgaW4gdGhpcy5fX29wZXJhdG9ycylcclxuXHRcdFx0aWYodGhpcy5fX29wZXJhdG9yc1twXVtuYW1lXSlcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fX29wZXJhdG9yc1twXVtuYW1lXS5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdGlmKCB0aGlzLl9fb3BlcmF0b3JzW3BdW25hbWVdW2ldLmxlbmd0aCA9PT0gYXJpdHkrMSApXHJcblx0XHRcdFx0XHRcdHJldHVybiB7cHJpb3JpdHk6IHAsIGNsYXNzOiB0aGlzLl9fb3BlcmF0b3JzW3BdW25hbWVdW2ldfTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5sb29rdXBfb3BlcmF0b3IgPSBmdW5jdGlvbiggbmFtZSwgYXJpdHkgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmxvb2t1cF9vcGVyYXRvciggbmFtZSwgYXJpdHkgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRocm93IGEgd2FybmluZ1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLnRocm93X3dhcm5pbmcgPSBmdW5jdGlvbiggd2FybmluZyApIHtcclxuXHRcdHRoaXMudGhyZWFkLnRocm93X3dhcm5pbmcoIHdhcm5pbmcgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUudGhyb3dfd2FybmluZyA9IGZ1bmN0aW9uKCB3YXJuaW5nICkge1xyXG5cdFx0dGhpcy53YXJuaW5ncy5wdXNoKCB3YXJuaW5nICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgd2FybmluZ3NcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfd2FybmluZ3MgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5nZXRfd2FybmluZ3MoKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X3dhcm5pbmdzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy53YXJuaW5ncztcclxuXHR9O1xyXG5cclxuXHQvLyBBZGQgYSBnb2FsXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYWRkX2dvYWwgPSBmdW5jdGlvbiggZ29hbCwgdW5pcXVlICkge1xyXG5cdFx0dGhpcy50aHJlYWQuYWRkX2dvYWwoIGdvYWwsIHVuaXF1ZSApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hZGRfZ29hbCA9IGZ1bmN0aW9uKCBnb2FsLCB1bmlxdWUsIHBhcmVudCApIHtcclxuXHRcdHBhcmVudCA9IHBhcmVudCA/IHBhcmVudCA6IG51bGw7XHJcblx0XHRpZiggdW5pcXVlID09PSB0cnVlIClcclxuXHRcdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHRcdHZhciB2YXJzID0gZ29hbC52YXJpYWJsZXMoKTtcclxuXHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrIClcclxuXHRcdFx0bGlua3NbdmFyc1tpXV0gPSBuZXcgVmFyKHZhcnNbaV0pO1xyXG5cdFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFN0YXRlKCBnb2FsLCBuZXcgU3Vic3RpdHV0aW9uKGxpbmtzKSwgcGFyZW50ICkgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBDb25zdWx0IGEgcHJvZ3JhbSBmcm9tIGEgc3RyaW5nXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuY29uc3VsdCA9IGZ1bmN0aW9uKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5jb25zdWx0KHByb2dyYW0sIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5jb25zdWx0ID0gZnVuY3Rpb24ocHJvZ3JhbSwgb3B0aW9ucykge1xyXG5cdFx0dmFyIHN0cmluZyA9IFwiXCIsIHN1Y2Nlc3MgPSBmYWxzZTtcclxuXHRcdHZhciBvcHRzID0ge307XHJcblx0XHR2YXIgY2FsbGJhY2sgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucyA6IGZ1bmN0aW9uKCl7fTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IHt9IDogb3B0aW9ucztcclxuXHRcdG9wdHMuY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRvcHRzLnRleHQgPSBvcHRpb25zLnRleHQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnRleHQ7XHJcblx0XHRvcHRzLmh0bWwgPSBvcHRpb25zLmh0bWwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmh0bWw7XHJcblx0XHRvcHRzLnVybCA9IG9wdGlvbnMudXJsID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy51cmw7XHJcblx0XHRvcHRzLmZpbGUgPSBvcHRpb25zLmZpbGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmZpbGU7XHJcblx0XHRvcHRzLnNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5zY3JpcHQ7XHJcblx0XHRvcHRzLnN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrIDogb3B0aW9ucy5zdWNjZXNzO1xyXG5cdFx0b3B0cy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrIDogb3B0aW9ucy5lcnJvcjtcclxuXHRcdC8vIHN0cmluZ1xyXG5cdFx0aWYodHlwZW9mIHByb2dyYW0gPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0c3RyaW5nID0gcHJvZ3JhbTtcclxuXHRcdFx0Ly8gc2NyaXB0IGlkXHJcblx0XHRcdGlmKG9wdHMuc2NyaXB0ICYmIHRoaXMuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcImZhbHNlLzBcIiAmJiBwcm9ncmFtICE9IFwiXCIgJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3RyaW5nKSkge1xyXG5cdFx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHJpbmcpO1xyXG5cdFx0XHRcdHZhciB0eXBlID0gc2NyaXB0LmdldEF0dHJpYnV0ZShcInR5cGVcIik7XHJcblx0XHRcdFx0aWYodHlwZSAhPT0gbnVsbCAmJiB0eXBlLnJlcGxhY2UoLyAvZywgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0L3Byb2xvZ1wiKSB7XHJcblx0XHRcdFx0XHRzdHJpbmcgPSBzY3JpcHQudGV4dDtcclxuXHRcdFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBmaWxlIChub2RlLmpzKVxyXG5cdFx0XHRpZighc3VjY2VzcyAmJiBvcHRzLmZpbGUgJiYgdGhpcy5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCIpIHtcclxuXHRcdFx0XHR2YXIgZnMgPSByZXF1aXJlKFwiZnNcIik7XHJcblx0XHRcdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRcdFx0ZnMucmVhZEZpbGUocHJvZ3JhbSwgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcclxuXHRcdFx0XHRcdGlmKGVycm9yKSB7XHJcblx0XHRcdFx0XHRcdG9wdHMuZmlsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuY29uc3VsdChwcm9ncmFtLCBvcHRzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIGRhdGEudG9TdHJpbmcoKSwgb3B0cyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGh0dHAgcmVxdWVzdFxyXG5cdFx0XHRpZighc3VjY2VzcyAmJiB0aGlzLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJmYWxzZS8wXCIgJiYgb3B0cy51cmwgJiYgcHJvZ3JhbSAhPT0gXCJcIiAmJiAhKC9cXHMvLnRlc3QocHJvZ3JhbSkpKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHZhciB4aHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cdFx0XHRcdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRcdFx0XHR4aHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5yZWFkeVN0YXRlID09IDQpIHtcclxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLnN0YXR1cyA9PSAyMDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHN0cmluZyA9IHhodHRwLnJlc3BvbnNlVGV4dDtcclxuXHRcdFx0XHRcdFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgc3RyaW5nLCBvcHRzKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0b3B0cy51cmwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5jb25zdWx0KHByb2dyYW0sIG9wdHMpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0eGh0dHAub3BlbihcIkdFVFwiLCBwcm9ncmFtLCB0cnVlKTtcclxuXHRcdFx0XHRcdHhodHRwLnNlbmQoKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGNhdGNoKGV4KSB7XHJcblx0XHRcdFx0XHRvcHRzLmVycm9yKGV4KTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gdGV4dFxyXG5cdFx0XHRpZighc3VjY2VzcyAmJiBvcHRzLnRleHQpIHtcclxuXHRcdFx0XHRzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0Ly8gaHRtbFxyXG5cdFx0fSBlbHNlIGlmKG9wdHMuaHRtbCAmJiBwcm9ncmFtLm5vZGVOYW1lKSB7XHJcblx0XHRcdHN3aXRjaChwcm9ncmFtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcclxuXHRcdFx0XHRjYXNlIFwiaW5wdXRcIjpcclxuXHRcdFx0XHRjYXNlIFwidGV4dGFyZWFcIjpcclxuXHRcdFx0XHRcdHN0cmluZyA9IHByb2dyYW0udmFsdWU7XHJcblx0XHRcdFx0XHRzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRzdHJpbmcgPSBwcm9ncmFtLmlubmVySFRNTDtcclxuXHRcdFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9wdHMuZXJyb3IocGwuZXJyb3IuZXhpc3RlbmNlKFwic291cmNlX3NpbmtcIiwgbmV3IFRlcm0oc3RyaW5nKSwgXCJ0b3BfbGV2ZWwvMFwiKSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLndhcm5pbmdzID0gW107XHJcblx0XHRwYXJzZVByb2dyYW0odGhpcywgc3RyaW5nLCBvcHRzKTtcclxuXHR9O1xyXG5cclxuXHQvLyBRdWVyeSBnb2FsIGZyb20gYSBzdHJpbmcgKHdpdGhvdXQgPy0pXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5xdWVyeShzdHJpbmcsIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHRcdHRoaXMuZGVidWdnZXJfc3RhdGVzID0gW107XHJcblx0XHR0aGlzLmxldmVsID0gbmV3IFRlcm0oXCJ0b3BfbGV2ZWxcIik7XHJcblx0XHRyZXR1cm4gcGFyc2VRdWVyeSh0aGlzLCBzdHJpbmcsIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IGZpcnN0IGNob2ljZSBwb2ludFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmhlYWRfcG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5oZWFkX3BvaW50KCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmhlYWRfcG9pbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnBvaW50c1t0aGlzLnBvaW50cy5sZW5ndGgtMV07XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgZnJlZSB2YXJpYWJsZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9mcmVlX3ZhcmlhYmxlID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmdldF9mcmVlX3ZhcmlhYmxlKCB2YXJpYWJsZSApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfZnJlZV92YXJpYWJsZSA9IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuXHRcdHZhciB2YXJpYWJsZXMgPSBbXTtcclxuXHRcdGlmKCB2YXJpYWJsZS5pZCA9PT0gXCJfXCIgfHwgdGhpcy5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzW3ZhcmlhYmxlLmlkXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHR0aGlzLnNlc3Npb24ucmVuYW1lKys7XHJcblx0XHRcdGlmKCB0aGlzLmN1cnJlbnRfcG9pbnQgKVxyXG5cdFx0XHRcdHZhcmlhYmxlcyA9IHRoaXMuY3VycmVudF9wb2ludC5zdWJzdGl0dXRpb24uZG9tYWluKCk7XHJcblx0XHRcdHdoaWxlKCBpbmRleE9mKCB2YXJpYWJsZXMsIHBsLmZvcm1hdF92YXJpYWJsZSggdGhpcy5zZXNzaW9uLnJlbmFtZSwgdmFyaWFibGUuaWQgKSApICE9PSAtMSApIHtcclxuXHRcdFx0XHR0aGlzLnNlc3Npb24ucmVuYW1lKys7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHZhcmlhYmxlLmlkID09PSBcIl9cIiApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFZhciggcGwuZm9ybWF0X3ZhcmlhYmxlKCB0aGlzLnNlc3Npb24ucmVuYW1lLCB2YXJpYWJsZS5pZCApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzW3ZhcmlhYmxlLmlkXSA9IHBsLmZvcm1hdF92YXJpYWJsZSggdGhpcy5zZXNzaW9uLnJlbmFtZSwgdmFyaWFibGUuaWQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBWYXIoIHRoaXMuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlc1t2YXJpYWJsZS5pZF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBuZXh0IGZyZWUgdmFyaWFibGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5uZXh0X2ZyZWVfdmFyaWFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUubmV4dF9mcmVlX3ZhcmlhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLnNlc3Npb24ucmVuYW1lKys7XHJcblx0XHR2YXIgdmFyaWFibGVzID0gW107XHJcblx0XHRpZiggdGhpcy5jdXJyZW50X3BvaW50IClcclxuXHRcdFx0dmFyaWFibGVzID0gdGhpcy5jdXJyZW50X3BvaW50LnN1YnN0aXR1dGlvbi5kb21haW4oKTtcclxuXHRcdHdoaWxlKCBpbmRleE9mKCB2YXJpYWJsZXMsIHBsLmZvcm1hdF92YXJpYWJsZSggdGhpcy5zZXNzaW9uLnJlbmFtZSApICkgIT09IC0xICkge1xyXG5cdFx0XHR0aGlzLnNlc3Npb24ucmVuYW1lKys7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFZhciggcGwuZm9ybWF0X3ZhcmlhYmxlKCB0aGlzLnNlc3Npb24ucmVuYW1lICkgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIHB1YmxpY1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmlzX3B1YmxpY19wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0bW9kdWxlX2lkID0gbW9kdWxlX2lkID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG1vZHVsZV9pZDtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX21vZHVsZSh0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXSkgJiYgdGhpcy5tb2R1bGVzW21vZHVsZV9pZF0uaXNfcHVibGljX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5pc19wdWJsaWNfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uaXNfcHVibGljX3ByZWRpY2F0ZShpbmRpY2F0b3IsIG1vZHVsZV9pZCk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBtdWx0aWZpbGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5pc19tdWx0aWZpbGVfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdG1vZHVsZV9pZCA9IG1vZHVsZV9pZCA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBtb2R1bGVfaWQ7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19tb2R1bGUodGhpcy5tb2R1bGVzW21vZHVsZV9pZF0pICYmIHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdLmlzX211bHRpZmlsZV9wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmlzX211bHRpZmlsZV9wcmVkaWNhdGUoaW5kaWNhdG9yLCBtb2R1bGVfaWQpO1xyXG5cdH07XHJcblxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIGEgbWV0YS1wcmVkaWNhdGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5pc19tZXRhX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRtb2R1bGVfaWQgPSBtb2R1bGVfaWQgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogbW9kdWxlX2lkO1xyXG5cdFx0aWYocGwudHlwZS5pc19tb2R1bGUodGhpcy5tb2R1bGVzW21vZHVsZV9pZF0pKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5tb2R1bGVzW21vZHVsZV9pZF0uaXNfbWV0YV9wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5pc19tZXRhX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmlzX21ldGFfcHJlZGljYXRlKGluZGljYXRvciwgbW9kdWxlX2lkKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEluc2VydCBzdGF0ZXMgYXQgdGhlIGJlZ2lubmluZ1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiggc3RhdGVzICkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oIHN0YXRlcyApIHtcclxuXHRcdGZvcih2YXIgaSA9IHN0YXRlcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pXHJcblx0XHRcdHRoaXMucG9pbnRzLnB1c2goIHN0YXRlc1tpXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUmVtb3ZlIHRoZSBzZWxlY3RlZCB0ZXJtIGFuZCBwcmVwZW5kIHRoZSBjdXJyZW50IHN0YXRlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuc3VjY2VzcyA9IGZ1bmN0aW9uKCBwb2ludCwgcGFyZW50ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnN1Y2Nlc3MoIHBvaW50LCBwYXJlbnQgKTtcclxuXHR9XHJcblx0VGhyZWFkLnByb3RvdHlwZS5zdWNjZXNzID0gZnVuY3Rpb24oIHBvaW50LCBwYXJlbnQgKSB7XHJcblx0XHR2YXIgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IHBvaW50IDogcGFyZW50O1xyXG5cdFx0dGhpcy5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG51bGwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwYXJlbnQgKSBdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUaHJvdyBlcnJvclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnRocm93X2Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC50aHJvd19lcnJvcihlcnJvcik7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnRocm93X2Vycm9yID0gZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZXJyb3IpKVxyXG5cdFx0XHRlcnJvciA9IHBsLmVycm9yLmluc3RhbnRpYXRpb24odGhpcy5sZXZlbC5pbmRpY2F0b3IpO1xyXG5cdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRuZXcgVGVybShcInRocm93XCIsIFtlcnJvcl0pLFxyXG5cdFx0XHRuZXcgU3Vic3RpdHV0aW9uKCksXHJcblx0XHRcdG51bGxcclxuXHRcdCk7XHJcblx0XHRzdGF0ZS5lcnJvciA9IHRydWU7XHJcblx0XHR0aGlzLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgdGhlIG1vZHVsZSBvZiBhIHByZWRpY2F0ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmxvb2t1cF9tb2R1bGUgPSBmdW5jdGlvbihhdG9tLCBjb250ZXh0X21vZHVsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmxvb2t1cF9tb2R1bGUoYXRvbSwgY29udGV4dF9tb2R1bGUpO1xyXG5cdH1cclxuXHRUaHJlYWQucHJvdG90eXBlLmxvb2t1cF9tb2R1bGUgPSBmdW5jdGlvbihhdG9tLCBjb250ZXh0X21vZHVsZSkge1xyXG5cdFx0dmFyIGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV07XHJcblx0XHRpZighcGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpXHJcblx0XHRcdGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlcy51c2VyO1xyXG5cdFx0aWYoZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShhdG9tLmluZGljYXRvcikgJiYgKFxyXG5cdFx0XHRnZXRfbW9kdWxlLmV4cG9ydHNfcHJlZGljYXRlKGF0b20uaW5kaWNhdG9yKSB8fFxyXG5cdFx0XHRnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHRoaXMubGV2ZWwuaW5kaWNhdG9yKSB8fFxyXG5cdFx0XHRjb250ZXh0X21vZHVsZSA9PT0gZ2V0X21vZHVsZS5pZCkpXHJcblx0XHRcdFx0cmV0dXJuIGdldF9tb2R1bGU7XHJcblx0XHRnZXRfbW9kdWxlLm1vZHVsZXMuc3lzdGVtID0gcGwubW9kdWxlcy5zeXN0ZW07XHJcblx0XHRnZXRfbW9kdWxlLm1vZHVsZXMudXNlciA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzLnVzZXI7XHJcblx0XHRmb3IodmFyIHByb3AgaW4gZ2V0X21vZHVsZS5tb2R1bGVzKSB7XHJcblx0XHRcdGlmKCF0aGlzLnNlc3Npb24ubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlc1twcm9wXTtcclxuXHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShhdG9tLmluZGljYXRvcikgJiYgKFxyXG5cdFx0XHRcdGdldF9tb2R1bGUuZXhwb3J0c19wcmVkaWNhdGUoYXRvbS5pbmRpY2F0b3IpIHx8XHJcblx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxldmVsLmluZGljYXRvcikgfHxcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9PT0gZ2V0X21vZHVsZS5pZCkpXHJcblx0XHRcdFx0XHRyZXR1cm4gZ2V0X21vZHVsZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8vIEV4cGFuZCBhIG1ldGEtcHJlZGljYXRlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZXhwYW5kX21ldGFfcHJlZGljYXRlID0gZnVuY3Rpb24oYXRvbSwgZGVmaW5pdGlvbl9tb2R1bGUsIGNvbnRleHRfbW9kdWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuZXhwYW5kX21ldGFfcHJlZGljYXRlKGF0b20sIGRlZmluaXRpb25fbW9kdWxlLCBjb250ZXh0X21vZHVsZSk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmV4cGFuZF9tZXRhX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGF0b20sIGRlZmluaXRpb25fbW9kdWxlLCBjb250ZXh0X21vZHVsZSkge1xyXG5cdFx0dmFyIGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlc1tkZWZpbml0aW9uX21vZHVsZV07XHJcblx0XHRpZighZ2V0X21vZHVsZSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0dmFyIG1ldGEgPSBnZXRfbW9kdWxlLmlzX21ldGFfcHJlZGljYXRlKGF0b20uaW5kaWNhdG9yKTtcclxuXHRcdGlmKCFtZXRhKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWV0YS5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfaW50ZWdlcihtZXRhLmFyZ3NbaV0pIHx8IHBsLnR5cGUuaXNfYXRvbShtZXRhLmFyZ3NbaV0pICYmIGluZGV4T2YoW1wiOlwiXSwgbWV0YS5hcmdzW2ldLmlkKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc190ZXJtKGF0b20uYXJnc1tpXSkgfHwgYXRvbS5hcmdzW2ldLmluZGljYXRvciAhPT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdFx0YXRvbS5hcmdzW2ldID0gbmV3IFRlcm0oXCI6XCIsIFtuZXcgVGVybShjb250ZXh0X21vZHVsZSksIGF0b20uYXJnc1tpXV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfYXRvbShtZXRhLmFyZ3NbaV0pICYmIG1ldGEuYXJnc1tpXS5pZCA9PT0gXCJeXCIpIHtcclxuXHRcdFx0XHR2YXIgcG9pbnRlcl9sYXN0ID0gYXRvbTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlcl9pbmRleCA9IGk7XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBhdG9tLmFyZ3NbaV07XHJcblx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIl4vMlwiKSB7XHJcblx0XHRcdFx0XHRwb2ludGVyX2xhc3QgPSBwb2ludGVyO1xyXG5cdFx0XHRcdFx0cG9pbnRlcl9pbmRleCA9IDE7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpIHx8IHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0XHRwb2ludGVyX2xhc3QuYXJnc1twb2ludGVyX2luZGV4XSA9IG5ldyBUZXJtKFwiOlwiLCBbbmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLCBwb2ludGVyXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBSZXNvbHV0aW9uIHN0ZXBcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuc3RlcCgpO1xyXG5cdH1cclxuXHRUaHJlYWQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgYXN5biA9IGZhbHNlO1xyXG5cdFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHMucG9wKCk7XHJcblx0XHR0aGlzLmN1cnJlbnRfcG9pbnQgPSBwb2ludDtcclxuXHRcdGlmKHRoaXMuZGVidWdnZXIpXHJcblx0XHRcdHRoaXMuZGVidWdnZXJfc3RhdGVzLnB1c2gocG9pbnQpO1xyXG5cdFx0dmFyIGF0b20gPSBwbC50eXBlLmlzX3Rlcm0ocG9pbnQuZ29hbCkgPyBwb2ludC5nb2FsLnNlbGVjdCgpIDogcG9pbnQuZ29hbDtcclxuXHRcdGlmKHBsLnR5cGUuaXNfdGVybShhdG9tKSAmJiAoYXRvbS5pbmRpY2F0b3IgIT09IFwiOi8yXCIgfHwgcGwudHlwZS5pc190ZXJtKGF0b20uYXJnc1sxXSkpKSB7XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IG51bGw7XHJcblx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0aWYoYXRvbSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdHRoaXMudG90YWxfc3RlcHMrKztcclxuXHRcdFx0XHR2YXIgbGV2ZWwgPSBwb2ludDtcclxuXHRcdFx0XHR3aGlsZShsZXZlbC5wYXJlbnQgIT09IG51bGwgJiYgbGV2ZWwucGFyZW50LmdvYWwuc2VhcmNoKGF0b20pKVxyXG5cdFx0XHRcdFx0bGV2ZWwgPSBsZXZlbC5wYXJlbnQ7XHJcblx0XHRcdFx0aWYobGV2ZWwucGFyZW50ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aGlzLmxldmVsID0gbmV3IFRlcm0oXCJ0b3BfbGV2ZWxcIik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMubGV2ZWwgPSBsZXZlbC5wYXJlbnQuZ29hbC5zZWxlY3QoKTtcclxuXHRcdFx0XHRcdGlmKHRoaXMubGV2ZWwuaW5kaWNhdG9yID09PSBcIjovMlwiKVxyXG5cdFx0XHRcdFx0XHR0aGlzLmxldmVsID0gdGhpcy5sZXZlbC5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oYXRvbSkgJiYgYXRvbS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0YXRvbSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20oY29udGV4dF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBjb250ZXh0X21vZHVsZSwgdGhpcy5sZXZlbC5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBjb250ZXh0X21vZHVsZS5pZDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYodGhpcy5sZXZlbC5kZWZpbml0aW9uX21vZHVsZSkge1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IHRoaXMubGV2ZWwuZGVmaW5pdGlvbl9tb2R1bGU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IFwidXNlclwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRhdG9tLmNvbnRleHRfbW9kdWxlID0gY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdFx0aWYoYXRvbS5pbmRpY2F0b3IgPT09IFwiLC8yXCIpIHtcclxuXHRcdFx0XHRcdHRoaXMucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIjpcIiwgW25ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSwgYXRvbS5hcmdzWzBdXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI6XCIsIFtuZXcgVGVybShjb250ZXh0X21vZHVsZSksIGF0b20uYXJnc1sxXV0pXSkpLFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpXSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRoaXMuX19jYWxsX2luZGljYXRvciA9IGF0b20uaW5kaWNhdG9yO1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhpcy5sb29rdXBfbW9kdWxlKGF0b20sIGNvbnRleHRfbW9kdWxlKTtcclxuXHRcdFx0XHRhdG9tLmRlZmluaXRpb25fbW9kdWxlID0gcGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkgPyBnZXRfbW9kdWxlLmlkIDogXCJ1c2VyXCI7XHJcblx0XHRcdFx0dGhpcy5leHBhbmRfbWV0YV9wcmVkaWNhdGUoYXRvbSwgYXRvbS5kZWZpbml0aW9uX21vZHVsZSwgY29udGV4dF9tb2R1bGUpO1xyXG5cdFx0XHRcdHZhciBjbGF1c2VzID0gbnVsbDtcclxuXHRcdFx0XHRpZihnZXRfbW9kdWxlICYmIGF0b20uYXJncy5sZW5ndGggPiAwICYmIGF0b20uYXJnc1swXS5pbmRleCAmJiBnZXRfbW9kdWxlLmluZGV4ZWRfY2xhdXNlcy5oYXNPd25Qcm9wZXJ0eShhdG9tLmluZGljYXRvcikgJiYgZ2V0X21vZHVsZS5pbmRleGVkX2NsYXVzZXNbYXRvbS5pbmRpY2F0b3JdLmhhc093blByb3BlcnR5KGF0b20uYXJnc1swXS5pbmRleCkpXHJcblx0XHRcdFx0XHRjbGF1c2VzID0gZ2V0X21vZHVsZS5pbmRleGVkX2NsYXVzZXNbYXRvbS5pbmRpY2F0b3JdW2F0b20uYXJnc1swXS5pbmRleF07XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Y2xhdXNlcyA9IGdldF9tb2R1bGUgPT09IG51bGwgPyBudWxsIDogZ2V0X21vZHVsZS5ydWxlc1thdG9tLmluZGljYXRvcl07XHJcblx0XHRcdFx0aWYoY2xhdXNlcyA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0aWYoIXRoaXMuc2Vzc2lvbi5tb2R1bGVzLnVzZXIucnVsZXMuaGFzT3duUHJvcGVydHkoYXRvbS5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuZ2V0X2ZsYWcoXCJ1bmtub3duXCIpLmlkID09PSBcImVycm9yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwicHJvY2VkdXJlXCIsIGF0b20uaW5kaWNhdG9yLCB0aGlzLmxldmVsLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYodGhpcy5nZXRfZmxhZyhcInVua25vd25cIikuaWQgPT09IFwid2FybmluZ1wiKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy50aHJvd193YXJuaW5nKFwidW5rbm93biBwcm9jZWR1cmUgXCIgKyBhdG9tLmluZGljYXRvciArIFwiIChmcm9tIFwiICsgdGhpcy5sZXZlbC5pbmRpY2F0b3IgKyBcIilcIik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoY2xhdXNlcyBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcblx0XHRcdFx0XHRhc3luID0gY2xhdXNlcyh0aGlzLCBwb2ludCwgYXRvbSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIEdvYWwgZXhwYW5zaW9uXHJcblx0XHRcdFx0XHRpZih0aGlzLl9fZ29hbF9leHBhbnNpb24gJiYgYXRvbS5pbmRpY2F0b3IgPT09IFwiZ29hbF9leHBhbnNpb24vMlwiKVxyXG5cdFx0XHRcdFx0XHRjbGF1c2VzID0gY2xhdXNlcy5jb25jYXQocGwuYnVpbHRpbi5ydWxlc1tcImdvYWxfZXhwYW5zaW9uLzJcIl0pO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNsYXVzZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0XHRcdHZhciBjbGF1c2UgPSBjbGF1c2VzW2ldLnJlbmFtZSh0aGlzKTtcclxuXHRcdFx0XHRcdFx0dmFyIG9jY3Vyc19jaGVjayA9IHRoaXMuZ2V0X2ZsYWcoXCJvY2N1cnNfY2hlY2tcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiO1xyXG5cdFx0XHRcdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkoYXRvbSwgY2xhdXNlLmhlYWQsIG9jY3Vyc19jaGVjayk7XHJcblx0XHRcdFx0XHRcdGlmKG1ndSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLmdvYWwgPSBwb2ludC5nb2FsLnJlcGxhY2UoY2xhdXNlLmJvZHkpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHN0YXRlLmdvYWwgIT09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5nb2FsID0gc3RhdGUuZ29hbC5hcHBseShtZ3UpO1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnN1YnN0aXR1dGlvbiA9IHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseShtZ3UpO1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnBhcmVudCA9IHBvaW50O1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKHN0YXRlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgdGVybSA9IHBsLnR5cGUuaXNfdGVybShhdG9tKSAmJiBhdG9tLmluZGljYXRvciA9PT0gXCI6LzJcIiA/IGF0b20uYXJnc1sxXSA6IGF0b207XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodGVybSkpXHJcblx0XHRcdFx0dGhpcy50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKHRoaXMubGV2ZWwuaW5kaWNhdG9yKSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHR0aGlzLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCB0ZXJtLCB0aGlzLmxldmVsLmluZGljYXRvcikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFzeW47XHJcblx0fTtcclxuXHRcclxuXHQvLyBGaW5kIG5leHQgY29tcHV0ZWQgYW5zd2VyXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYW5zd2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmFuc3dlcihvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuYW5zd2VyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0dmFyIG9wdHMgPSB7fTtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGZ1bmN0aW9uKCkge307XHJcblx0XHRpZih0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdG9wdHMgPSB7XHJcblx0XHRcdFx0c3VjY2Vzczogb3B0aW9ucyxcclxuXHRcdFx0XHRlcnJvcjogb3B0aW9ucyxcclxuXHRcdFx0XHRmYWlsOiBvcHRpb25zLFxyXG5cdFx0XHRcdGxpbWl0OiBvcHRpb25zXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvcHRzLnN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uKCkge30gOiBvcHRpb25zLnN1Y2Nlc3M7XHJcblx0XHRcdG9wdHMuZXJyb3IgPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbigpIHt9IDogb3B0aW9ucy5lcnJvcjtcclxuXHRcdFx0b3B0cy5mYWlsID0gb3B0aW9ucy5mYWlsID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbigpIHt9IDogb3B0aW9ucy5mYWlsO1xyXG5cdFx0XHRvcHRzLmxpbWl0ID0gb3B0aW9ucy5saW1pdCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24oKSB7fSA6IG9wdGlvbnMubGltaXQ7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9fY2FsbHMucHVzaChvcHRzKTtcclxuXHRcdGlmKCB0aGlzLl9fY2FsbHMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5hZ2FpbigpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gRmluZCBhbGwgY29tcHV0ZWQgYW5zd2Vyc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFuc3dlcnMgPSBmdW5jdGlvbiggY2FsbGJhY2ssIG1heCwgYWZ0ZXIgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuYW5zd2VycyggY2FsbGJhY2ssIG1heCwgYWZ0ZXIgKTtcclxuXHR9XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hbnN3ZXJzID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBtYXgsIGFmdGVyICkge1xyXG5cdFx0dmFyIGFuc3dlcnMgPSBtYXggPT09IHVuZGVmaW5lZCA/IDEwMDAgOiBtYXg7XHJcblx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdGlmKCBhbnN3ZXJzIDw9IDAgKSB7XHJcblx0XHRcdGlmKGFmdGVyKVxyXG5cdFx0XHRcdGFmdGVyKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMuYW5zd2VyKCBmdW5jdGlvbiggYW5zd2VyICkge1xyXG5cdFx0XHRjYWxsYmFjayggYW5zd2VyICk7XHJcblx0XHRcdGlmKCBhbnN3ZXIgIT09IGZhbHNlICkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLmFuc3dlcnMoIGNhbGxiYWNrLCBhbnN3ZXJzLTEsIGFmdGVyICk7XHJcblx0XHRcdFx0fSwgMCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoYWZ0ZXIpIHtcclxuXHRcdFx0XHRhZnRlcigpO1xyXG5cdFx0XHR9XHJcblx0XHR9ICk7XHJcblx0fTtcclxuXHJcblx0Ly8gQWdhaW4gZmluZGluZyBuZXh0IGNvbXB1dGVkIGFuc3dlclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFnYWluID0gZnVuY3Rpb24ocmVzZXRfbGltaXQpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5hZ2FpbihyZXNldF9saW1pdCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmFnYWluID0gZnVuY3Rpb24ocmVzZXRfbGltaXQpIHtcclxuXHRcdHdoaWxlKHRoaXMuX19jYWxscy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHRoaXMud2FybmluZ3MgPSBbXTtcclxuXHRcdFx0aWYocmVzZXRfbGltaXQgIT09IGZhbHNlKVxyXG5cdFx0XHRcdHRoaXMuY3VycmVudF9saW1pdCA9IHRoaXMuc2Vzc2lvbi5saW1pdDtcclxuXHRcdFx0d2hpbGUoKCF0aGlzLmhhc19saW1pdCB8fCB0aGlzLmN1cnJlbnRfbGltaXQgPiAwKSAmJiB0aGlzLnBvaW50cy5sZW5ndGggPiAwICYmIHRoaXMuaGVhZF9wb2ludCgpLmdvYWwgIT09IG51bGwgJiYgIXBsLnR5cGUuaXNfZXJyb3Jfc3RhdGUodGhpcy5oZWFkX3BvaW50KCkpKSB7XHJcblx0XHRcdFx0aWYodGhpcy5oYXNfbGltaXQpXHJcblx0XHRcdFx0XHR0aGlzLmN1cnJlbnRfbGltaXQtLTtcclxuXHRcdFx0XHR2YXIgdDAgPSBEYXRlLm5vdygpO1xyXG5cdFx0XHRcdHZhciBhc3luID0gdGhpcy5zdGVwKCk7XHJcblx0XHRcdFx0dmFyIHQxID0gRGF0ZS5ub3coKTtcclxuXHRcdFx0XHR0aGlzLmNwdV90aW1lICs9IHQxLXQwO1xyXG5cdFx0XHRcdGlmKGFzeW4gPT09IHRydWUpXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGNhbGwgPSB0aGlzLl9fY2FsbHMuc2hpZnQoKTtcclxuXHRcdFx0Ly8gbGltaXQgb2YgaW5mZXJlbmNlc1xyXG5cdFx0XHRpZih0aGlzLmhhc19saW1pdCAmJiB0aGlzLmN1cnJlbnRfbGltaXQgPD0gMCkge1xyXG5cdFx0XHRcdChmdW5jdGlvbihjYWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbC5saW1pdChudWxsKTtcclxuXHRcdFx0XHRcdH0sIDApO1xyXG5cdFx0XHRcdH0pKGNhbGwpO1xyXG5cdFx0XHQvLyBubyBhbnN3ZXJcclxuXHRcdFx0fSBlbHNlIGlmKHRoaXMucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdChmdW5jdGlvbihjYWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbC5mYWlsKGZhbHNlKTtcclxuXHRcdFx0XHRcdH0sIDApO1xyXG5cdFx0XHRcdH0pKGNhbGwpO1xyXG5cdFx0XHQvLyBlcnJvclxyXG5cdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19lcnJvcih0aGlzLmhlYWRfcG9pbnQoKS5nb2FsKSkge1xyXG5cdFx0XHRcdHZhciBlcnJvciA9IHRoaXMuZm9ybWF0X2Vycm9yKHRoaXMucG9pbnRzLnBvcCgpKTtcclxuXHRcdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0XHRcdChmdW5jdGlvbihlcnJvciwgY2FsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGNhbGwuZXJyb3IoZXJyb3IpO1xyXG5cdFx0XHRcdFx0fSwgMCk7XHJcblx0XHRcdFx0fSkoZXJyb3IsIGNhbGwpO1xyXG5cdFx0XHQvLyBjb21wdXRlZCBhbnN3ZXJcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aGlzLmRlYnVnZ2VyKVxyXG5cdFx0XHRcdFx0dGhpcy5kZWJ1Z2dlcl9zdGF0ZXMucHVzaCh0aGlzLmhlYWRfcG9pbnQoKSk7XHJcblx0XHRcdFx0dmFyIGFuc3dlciA9IHRoaXMuZm9ybWF0X3N1Y2Nlc3ModGhpcy5wb2ludHMucG9wKCkpO1xyXG5cdFx0XHRcdChmdW5jdGlvbihhbnN3ZXIsIGNhbGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsLnN1Y2Nlc3MoYW5zd2VyKTtcclxuXHRcdFx0XHRcdH0sIDApO1xyXG5cdFx0XHRcdH0pKGFuc3dlciwgY2FsbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIFVuZm9sZGluZyB0cmFuc2Zvcm1hdGlvblxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnVuZm9sZCA9IGZ1bmN0aW9uKCBydWxlICkge1xyXG5cdFx0aWYocnVsZS5ib2R5ID09PSBudWxsKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR2YXIgaGVhZCA9IHJ1bGUuaGVhZDtcclxuXHRcdHZhciBib2R5ID0gcnVsZS5ib2R5O1xyXG5cdFx0dmFyIGF0b20gPSBib2R5LnNlbGVjdCgpO1xyXG5cdFx0dmFyIHRocmVhZCA9IG5ldyBUaHJlYWQoIHRoaXMgKTtcclxuXHRcdHZhciB1bmZvbGRlZCA9IFtdO1xyXG5cdFx0dGhyZWFkLmFkZF9nb2FsKCBhdG9tICk7XHJcblx0XHR0aHJlYWQuc3RlcCgpO1xyXG5cdFx0Zm9yKCB2YXIgaSA9IHRocmVhZC5wb2ludHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHR2YXIgcG9pbnQgPSB0aHJlYWQucG9pbnRzW2ldO1xyXG5cdFx0XHR2YXIgaGVhZDIgPSBoZWFkLmFwcGx5KCBwb2ludC5zdWJzdGl0dXRpb24gKTtcclxuXHRcdFx0dmFyIGJvZHkyID0gYm9keS5yZXBsYWNlKCBwb2ludC5nb2FsICk7XHJcblx0XHRcdGlmKCBib2R5MiAhPT0gbnVsbCApXHJcblx0XHRcdFx0Ym9keTIgPSBib2R5Mi5hcHBseSggcG9pbnQuc3Vic3RpdHV0aW9uICk7XHJcblx0XHRcdHVuZm9sZGVkLnB1c2goIG5ldyBSdWxlKCBoZWFkMiwgYm9keTIgKSApO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHJ1bGVzID0gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXNbaGVhZC5pbmRpY2F0b3JdO1xyXG5cdFx0dmFyIGluZGV4ID0gaW5kZXhPZiggcnVsZXMsIHJ1bGUgKTtcclxuXHRcdGlmKCB1bmZvbGRlZC5sZW5ndGggPiAwICYmIGluZGV4ICE9PSAtMSApIHtcclxuXHRcdFx0cnVsZXMuc3BsaWNlLmFwcGx5KCBydWxlcywgW2luZGV4LCAxXS5jb25jYXQodW5mb2xkZWQpICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS51bmZvbGQgPSBmdW5jdGlvbihydWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLnVuZm9sZChydWxlKTtcclxuXHR9O1xyXG5cclxuXHRcclxuXHRcclxuXHQvLyBJTlRFUlBSRVQgRVhQUkVTU0lPTlNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmludGVycHJldCA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRyZXR1cm4gcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggdGhyZWFkLmxldmVsLmluZGljYXRvciApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuaW50ZXJwcmV0ID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5pbnRlcnByZXQgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0aWYoIHBsLnR5cGUuaXNfdW5pdGFyeV9saXN0KCB0aGlzICkgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmFyZ3NbMF0uaW50ZXJwcmV0KCB0aHJlYWQgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBwbC5vcGVyYXRlKCB0aHJlYWQsIHRoaXMgKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIENPTVBBUkUgUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0aWYoIHRoaXMuaWQgPCBvYmouaWQgKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH0gZWxzZSBpZiggdGhpcy5pZCA+IG9iai5pZCApIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0aWYoIHRoaXMudmFsdWUgPT09IG9iai52YWx1ZSAmJiB0aGlzLmlzX2Zsb2F0ID09PSBvYmouaXNfZmxvYXQgKSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fSBlbHNlIGlmKCB0aGlzLnZhbHVlIDwgb2JqLnZhbHVlIHx8IHRoaXMudmFsdWUgPT09IG9iai52YWx1ZSAmJiB0aGlzLmlzX2Zsb2F0ICYmICFvYmouaXNfZmxvYXQgKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH0gZWxzZSBpZiggdGhpcy52YWx1ZSA+IG9iai52YWx1ZSApIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0aWYoIHRoaXMuYXJncy5sZW5ndGggPCBvYmouYXJncy5sZW5ndGggfHwgdGhpcy5hcmdzLmxlbmd0aCA9PT0gb2JqLmFyZ3MubGVuZ3RoICYmIHRoaXMuaWQgPCBvYmouaWQgKSB7XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH0gZWxzZSBpZiggdGhpcy5hcmdzLmxlbmd0aCA+IG9iai5hcmdzLmxlbmd0aCB8fCB0aGlzLmFyZ3MubGVuZ3RoID09PSBvYmouYXJncy5sZW5ndGggJiYgdGhpcy5pZCA+IG9iai5pZCApIHtcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHR2YXIgYXJnID0gcGwuY29tcGFyZSggdGhpcy5hcmdzW2ldLCBvYmouYXJnc1tpXSApO1xyXG5cdFx0XHRcdGlmKCBhcmcgIT09IDAgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gYXJnO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cclxuXHRcclxuXHQvLyBTVUJTVElUVVRJT05TXHJcblx0XHJcblx0Ly8gTG9va3VwIHZhcmlhYmxlXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcblx0XHRpZiggdGhpcy5saW5rc1t2YXJpYWJsZV0gKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmxpbmtzW3ZhcmlhYmxlXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gRmlsdGVyIHZhcmlhYmxlc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oIHByZWRpY2F0ZSApIHtcclxuXHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0Zm9yKCB2YXIgaWQgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkoaWQpKSBjb250aW51ZTtcclxuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5saW5rc1tpZF07XHJcblx0XHRcdGlmKCBwcmVkaWNhdGUoIGlkLCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdGxpbmtzW2lkXSA9IHZhbHVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbiggbGlua3MsIHRoaXMuYXR0cnMgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEV4Y2x1ZGUgdmFyaWFibGVzXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5leGNsdWRlID0gZnVuY3Rpb24oIHZhcmlhYmxlcyApIHtcclxuXHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0Zm9yKCB2YXIgdmFyaWFibGUgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkodmFyaWFibGUpKSBjb250aW51ZTtcclxuXHRcdFx0aWYoIGluZGV4T2YoIHZhcmlhYmxlcywgdmFyaWFibGUgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0bGlua3NbdmFyaWFibGVdID0gdGhpcy5saW5rc1t2YXJpYWJsZV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCBsaW5rcywgdGhpcy5hdHRycyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gQWRkIGxpbmtcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCB2YXJpYWJsZSwgdmFsdWUgKSB7XHJcblx0XHR0aGlzLmxpbmtzW3ZhcmlhYmxlXSA9IHZhbHVlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IGRvbWFpblxyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZG9tYWluID0gZnVuY3Rpb24oIHBsYWluICkge1xyXG5cdFx0dmFyIGYgPSBwbGFpbiA9PT0gdHJ1ZSA/IGZ1bmN0aW9uKHgpe3JldHVybiB4O30gOiBmdW5jdGlvbih4KXtyZXR1cm4gbmV3IFZhcih4KTt9O1xyXG5cdFx0dmFyIHZhcnMgPSBbXTtcclxuXHRcdGZvciggdmFyIHggaW4gdGhpcy5saW5rcyApXHJcblx0XHRcdHZhcnMucHVzaCggZih4KSApO1xyXG5cdFx0cmV0dXJuIHZhcnM7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IGFuIGF0dHJpYnV0ZVxyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0X2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKCB2YXJpYWJsZSwgbW9kdWxlICkge1xyXG5cdFx0aWYoIHRoaXMuYXR0cnNbdmFyaWFibGVdIClcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXR0cnNbdmFyaWFibGVdW21vZHVsZV07XHJcblx0fVxyXG5cclxuXHQvLyBTZXQgYW4gYXR0cmlidXRlIChpbiBhIG5ldyBzdWJzdGl0dXRpb24pXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5zZXRfYXR0cmlidXRlID0gZnVuY3Rpb24oIHZhcmlhYmxlLCBtb2R1bGUsIHZhbHVlICkge1xyXG5cdFx0dmFyIHN1YnMgPSBuZXcgU3Vic3RpdHV0aW9uKCB0aGlzLmxpbmtzICk7XHJcblx0XHRmb3IoIHZhciB2IGluIHRoaXMuYXR0cnMgKSB7XHJcblx0XHRcdGlmKCB2ID09PSB2YXJpYWJsZSApIHtcclxuXHRcdFx0XHRzdWJzLmF0dHJzW3ZdID0ge307XHJcblx0XHRcdFx0Zm9yKCB2YXIgbSBpbiB0aGlzLmF0dHJzW3ZdICkge1xyXG5cdFx0XHRcdFx0c3Vicy5hdHRyc1t2XVttXSA9IHRoaXMuYXR0cnNbdl1bbV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN1YnMuYXR0cnNbdl0gPSB0aGlzLmF0dHJzW3ZdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiggIXN1YnMuYXR0cnNbdmFyaWFibGVdICkge1xyXG5cdFx0XHRzdWJzLmF0dHJzW3ZhcmlhYmxlXSA9IHt9O1xyXG5cdFx0fVxyXG5cdFx0c3Vicy5hdHRyc1t2YXJpYWJsZV1bbW9kdWxlXSA9IHZhbHVlO1xyXG5cdFx0cmV0dXJuIHN1YnM7XHJcblx0fVxyXG5cclxuXHQvLyBDaGVjayBpZiBhIHZhcmlhYmxlcyBoYXMgYXR0cmlidXRlc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuaGFzX2F0dHJpYnV0ZXMgPSBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5hdHRyc1t2YXJpYWJsZV0gJiYgdGhpcy5hdHRyc1t2YXJpYWJsZV0gIT09IHt9O1xyXG5cdH1cclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBHRU5FUkFURSBKQVZBU0NSSVBUIENPREUgRlJPTSBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICduZXcgcGwudHlwZS5WYXIoXCInICsgdGhpcy5pZC50b1N0cmluZygpICsgJ1wiKSc7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ25ldyBwbC50eXBlLk51bSgnICsgdGhpcy52YWx1ZS50b1N0cmluZygpICsgJywgJyArIHRoaXMuaXNfZmxvYXQudG9TdHJpbmcoKSArICcpJztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICduZXcgcGwudHlwZS5UZXJtKFwiJyArIHRoaXMuaWQucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpICsgJ1wiLCBbJyArIG1hcCggdGhpcy5hcmdzLCBmdW5jdGlvbiggYXJnICkge1xyXG5cdFx0XHRyZXR1cm4gYXJnLmNvbXBpbGUoKTtcclxuXHRcdH0gKSArICddKSc7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnbmV3IHBsLnR5cGUuUnVsZSgnICsgdGhpcy5oZWFkLmNvbXBpbGUoKSArICcsICcgKyAodGhpcy5ib2R5ID09PSBudWxsID8gJ251bGwnIDogdGhpcy5ib2R5LmNvbXBpbGUoKSkgKyAnKSc7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTZXNzaW9uc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBzdHIsIG9iaiA9IFtdLCBydWxlcztcclxuXHRcdGZvciggdmFyIF9pbmRpY2F0b3IgaW4gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXMgKSB7XHJcblx0XHRcdGlmKCF0aGlzLm1vZHVsZXMudXNlci5ydWxlcy5oYXNPd25Qcm9wZXJ0eShfaW5kaWNhdG9yKSkgY29udGludWU7XHJcblx0XHRcdHZhciBpbmRpY2F0b3IgPSB0aGlzLm1vZHVsZXMudXNlci5ydWxlc1tfaW5kaWNhdG9yXTtcclxuXHRcdFx0cnVsZXMgPSBbXTtcclxuXHRcdFx0c3RyID0gXCJcXFwiXCIgKyBfaW5kaWNhdG9yICsgXCJcXFwiOiBbXCI7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpbmRpY2F0b3IubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRydWxlcy5wdXNoKGluZGljYXRvcltpXS5jb21waWxlKCkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0ciArPSBydWxlcy5qb2luKCk7XHJcblx0XHRcdHN0ciArPSBcIl1cIjtcclxuXHRcdFx0b2JqLnB1c2goIHN0ciApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFwie1wiICsgb2JqLmpvaW4oKSArIFwifTtcIjtcclxuXHR9O1xyXG5cclxuXHQvLyBNb2R1bGVcclxuXHRNb2R1bGUucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBsZW5ndGggPSAwO1xyXG5cdFx0dmFyIGRlcGVuZGVuY2llcyA9IDA7XHJcblx0XHR2YXIgc3RyID0gXCJ2YXIgcGw7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCIoZnVuY3Rpb24ocGwpIHtcXG5cIjtcclxuXHRcdC8vIG5hbWVcclxuXHRcdHN0ciArPSBcIlxcdHZhciBuYW1lID0gXFxcIlwiICsgdGhpcy5pZCArIFwiXFxcIjtcXG5cIjtcclxuXHRcdC8vIHByZWRpY2F0ZXNcclxuXHRcdHN0ciArPSBcIlxcdHZhciBwcmVkaWNhdGVzID0gZnVuY3Rpb24oKSB7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRyZXR1cm4ge1xcblwiO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIHRoaXMucnVsZXMpIHtcclxuXHRcdFx0aWYobGVuZ3RoID4gMClcclxuXHRcdFx0XHRzdHIgKz0gXCIsXFxuXCI7XHJcblx0XHRcdHN0ciArPSBcIlxcdFxcdFxcdFxcXCJcIiArIHByb3AgKyBcIlxcXCI6IFwiO1xyXG5cdFx0XHRpZih0eXBlb2YgdGhpcy5ydWxlc1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0c3RyICs9IHRoaXMucnVsZXNbcHJvcF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyICs9IFwiW1xcblwiO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzW3Byb3BdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRzdHIgKz0gXCJcXHRcXHRcXHRcXHRcIiArIHRoaXMucnVsZXNbcHJvcF1baV0uY29tcGlsZSgpO1xyXG5cdFx0XHRcdFx0aWYoaSA8IHRoaXMucnVsZXNbcHJvcF0ubGVuZ3RoLTEpXHJcblx0XHRcdFx0XHRcdHN0ciArPSBcIixcIjtcclxuXHRcdFx0XHRcdHN0ciArPSBcIlxcblwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdHIgKz0gXCJcXHRcXHRcXHRdXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0bGVuZ3RoKys7XHJcblx0XHR9XHJcblx0XHRzdHIgKz0gXCJcXG5cXHRcXHR9O1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0fTtcXG5cIjtcclxuXHRcdC8vIGV4cG9ydHNcclxuXHRcdHN0ciArPSBcIlxcdHZhciBleHBvcnRzID0gW1wiO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZXhwb3J0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihpID4gMClcclxuXHRcdFx0XHRzdHIgKz0gXCIsIFwiO1xyXG5cdFx0XHRzdHIgKz0gXCJcXFwiXCIgKyB0aGlzLmV4cG9ydHNbaV0gKyBcIlxcXCJcIjtcclxuXHRcdH1cclxuXHRcdHN0ciArPSBcIl07XFxuXCI7XHJcblx0XHQvLyBvcHRpb25zXHJcblx0XHRzdHIgKz0gXCJcXHR2YXIgb3B0aW9ucyA9IGZ1bmN0aW9uKCkge1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0cmV0dXJuIHtcXG5cIjtcclxuXHRcdC8vIGRlcGVuZGVuY2llc1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0XFx0ZGVwZW5kZW5jaWVzOiBbXCI7XHJcblx0XHRmb3IodmFyIHByb3AgaW4gdGhpcy5tb2R1bGVzKSB7XHJcblx0XHRcdGlmKGRlcGVuZGVuY2llcyA+IDApXHJcblx0XHRcdFx0c3RyICs9IFwiLCBcIjtcclxuXHRcdFx0c3RyICs9IFwiXFxcIlwiICsgcHJvcCArIFwiXFxcIlwiO1xyXG5cdFx0XHRkZXBlbmRlbmNpZXMrKztcclxuXHRcdH1cclxuXHRcdHN0ciArPSBcIl1cXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdH07XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJ9O1xcblwiO1xyXG5cdFx0Ly8gZml4ZWQgY29kZVxyXG5cdFx0c3RyICs9IFwiXFx0aWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocCkge1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0XFx0cGwgPSBwO1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0XFx0bmV3IHBsLnR5cGUuTW9kdWxlKG5hbWUsIHByZWRpY2F0ZXMoKSwgZXhwb3J0cywgb3B0aW9ucygpKTtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdH07XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHR9IGVsc2Uge1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0bmV3IHBsLnR5cGUuTW9kdWxlKG5hbWUsIHByZWRpY2F0ZXMoKSwgZXhwb3J0cywgb3B0aW9ucygpKTtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdH1cXG5cIjtcclxuXHRcdHN0ciArPSBcIn0pKHBsKTtcXG5cIjtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBQUk9MT0cgVE8gSkFWQVNDUklQVFxyXG5cdFZhci5wcm90b3R5cGUudG9KYXZhU2NyaXB0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUudG9KYXZhU2NyaXB0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUudG9KYXZhU2NyaXB0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdFx0Ly8gQXRvbSA9PiBTdHJpbmdcclxuXHRcdGlmKCB0aGlzLmFyZ3MubGVuZ3RoID09PSAwICYmIHRoaXMuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcob3B0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfbGlzdCggdGhpcyApICkge1xyXG5cdFx0XHQvLyBMaXN0ID0+IEFycmF5XHJcblx0XHRcdHZhciBhbGxfb2JqID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHR2YXIgb2JqID0ge307XHJcblx0XHRcdHZhciBwb2ludGVyID0gdGhpcztcclxuXHRcdFx0dmFyIHZhbHVlO1xyXG5cdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0dmFsdWUgPSBwb2ludGVyLmFyZ3NbMF0udG9KYXZhU2NyaXB0KG9wdGlvbnMpO1xyXG5cdFx0XHRcdGFyci5wdXNoKCB2YWx1ZSApO1xyXG5cdFx0XHRcdGFsbF9vYmogPSBhbGxfb2JqICYmIHBsLnR5cGUuaXNfdGVybShwb2ludGVyLmFyZ3NbMF0pICYmIHBvaW50ZXIuYXJnc1swXS5pbmRpY2F0b3IgPT09IFwiLS8yXCIgJiYgcGwudHlwZS5pc19hdG9tKHBvaW50ZXIuYXJnc1swXS5hcmdzWzBdKTtcclxuXHRcdFx0XHRpZihhbGxfb2JqKVxyXG5cdFx0XHRcdFx0b2JqW3BvaW50ZXIuYXJnc1swXS5hcmdzWzBdLmlkXSA9IHBvaW50ZXIuYXJnc1swXS5hcmdzWzFdLnRvSmF2YVNjcmlwdChvcHRpb25zKTtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCJbXS8wXCIgKVxyXG5cdFx0XHRcdHJldHVybiBhbGxfb2JqICYmIGFyci5sZW5ndGggPiAwID8gb2JqIDogYXJyO1xyXG5cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKG9wdGlvbnMpO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gUlVMRVNcclxuXHRcclxuXHQvLyBSZXR1cm4gc2luZ2xldG9uIHZhcmlhYmxlcyBpbiB0aGUgc2Vzc2lvblxyXG5cdFJ1bGUucHJvdG90eXBlLnNpbmdsZXRvbl92YXJpYWJsZXMgPSBmdW5jdGlvbihpbmNsdWRlX25hbWVkKSB7XHJcblx0XHRpbmNsdWRlX25hbWVkID0gaW5jbHVkZV9uYW1lZCB8fCBmYWxzZTtcclxuXHRcdHZhciB2YXJpYWJsZXMgPSB0aGlzLmhlYWQudmFyaWFibGVzKCk7XHJcblx0XHR2YXIgY291bnQgPSB7fTtcclxuXHRcdHZhciBzaW5nbGV0b24gPSBbXTtcclxuXHRcdGlmKHRoaXMuYm9keSAhPT0gbnVsbClcclxuXHRcdFx0dmFyaWFibGVzID0gdmFyaWFibGVzLmNvbmNhdCh0aGlzLmJvZHkudmFyaWFibGVzKCkpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihjb3VudFt2YXJpYWJsZXNbaV1dID09PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0Y291bnRbdmFyaWFibGVzW2ldXSA9IDA7XHJcblx0XHRcdGNvdW50W3ZhcmlhYmxlc1tpXV0rKztcclxuXHRcdH1cclxuXHRcdGZvcih2YXIga2V5IGluIGNvdW50KSB7XHJcblx0XHRcdGlmKCFjb3VudC5oYXNPd25Qcm9wZXJ0eShrZXkpKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRpZihjb3VudFtrZXldID09PSAxKSB7XHJcblx0XHRcdFx0dmFyIGNoYXJjb2RlID0gY29kZVBvaW50QXQoa2V5LCAxKTtcclxuXHRcdFx0XHRpZighaW5jbHVkZV9uYW1lZCB8fCBrZXkgPT09IFwiX1wiKVxyXG5cdFx0XHRcdFx0aWYoa2V5ID09PSBcIl9cIiB8fCBrZXlbMF0gPT09IFwiX1wiICYmIChjaGFyY29kZSA9PT0gOTUgfHwgY2hhcmNvZGUgPj0gNjUgJiYgY2hhcmNvZGUgPD0gOTApKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRzaW5nbGV0b24ucHVzaChrZXkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc2luZ2xldG9uO1xyXG5cdH07XHJcblxyXG5cclxuXHJcblx0Ly8gTk9ERUpTXHJcblxyXG5cdHZhciBub2RlanNfZmxhZyA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhcHJvY2Vzcy5icm93c2VyXHJcblxyXG5cdHZhciBub2RlanNfYXJndW1lbnRzID0gbm9kZWpzX2ZsYWcgP1xyXG5cdFx0YXJyYXlUb0xpc3QoIG1hcChwcm9jZXNzLmFyZ3Yuc2xpY2UoMSksIGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gbmV3IFRlcm0oIGFyZyApOyB9KSkgOlxyXG5cdFx0bmV3IFRlcm0oXCJbXVwiLCBbXSk7XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gUFJPTE9HXHJcblxyXG5cdHZhciBwbCA9IHtcclxuXHRcdFxyXG5cdFx0Ly8gRW52aXJvbm1lbnRcclxuXHRcdF9fZW52OiBub2RlanNfZmxhZyA/IGdsb2JhbCA6IHdpbmRvdyxcclxuXHRcdFxyXG5cdFx0Ly8gTW9kdWxlc1xyXG5cdFx0bW9kdWxlczoge30sXHJcblx0XHRcclxuXHRcdC8vIFZlcnNpb25cclxuXHRcdHZlcnNpb246IHZlcnNpb24sXHJcblx0XHRcclxuXHRcdC8vIFBhcnNlclxyXG5cdFx0cGFyc2VyOiB7XHJcblx0XHRcdHRva2VuaXplcjogVG9rZW5pemVyLFxyXG5cdFx0XHRleHByZXNzaW9uOiBwYXJzZUV4cHJcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFV0aWxzXHJcblx0XHR1dGlsczoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU3RyaW5nIHRvIGluZGljYXRvclxyXG5cdFx0XHRzdHJfaW5kaWNhdG9yOiBzdHJfaW5kaWNhdG9yLFxyXG5cdFx0XHQvLyBDb2RlIHBvaW50IGF0XHJcblx0XHRcdGNvZGVQb2ludEF0OiBjb2RlUG9pbnRBdCxcclxuXHRcdFx0Ly8gRnJvbSBjb2RlIHBvaW50XHJcblx0XHRcdGZyb21Db2RlUG9pbnQ6IGZyb21Db2RlUG9pbnQsXHJcblx0XHRcdC8vIExlbmd0aCBvZiBzdHJpbmdcclxuXHRcdFx0c3RyaW5nTGVuZ3RoOiBzdHJpbmdMZW5ndGhcclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBTdGF0aXN0aWNzXHJcblx0XHRzdGF0aXN0aWNzOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBOdW1iZXIgb2YgY3JlYXRlZCB0ZXJtc1xyXG5cdFx0XHRnZXRDb3VudFRlcm1zOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGVybV9yZWY7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBKYXZhU2NyaXB0IHRvIFByb2xvZ1xyXG5cdFx0ZnJvbUphdmFTY3JpcHQ6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFR5cGUgdGVzdGluZ1xyXG5cdFx0XHR0ZXN0OiB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQm9vbGVhblxyXG5cdFx0XHRcdGJvb2xlYW46IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2U7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBOdW1iZXJcclxuXHRcdFx0XHRudW1iZXI6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIjtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFN0cmluZ1xyXG5cdFx0XHRcdHN0cmluZzogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gTGlzdFxyXG5cdFx0XHRcdGxpc3Q6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBWYXJpYWJsZVxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9iaiA9PT0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIE9iamVjdFxyXG5cdFx0XHRcdG9iamVjdDogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHRvYmogPSB0b2JqID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRvYmo7XHJcblx0XHRcdFx0XHRyZXR1cm4gdG9iaiAmJiAhKG9iaiBpbnN0YW5jZW9mIEFycmF5KSAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQW55XHJcblx0XHRcdFx0YW55OiBmdW5jdGlvbiggXywgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIEZ1bmN0aW9uIGNvbnZlcnNpb25cclxuXHRcdFx0Y29udmVyc2lvbjoge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEJvbGVhblxyXG5cdFx0XHRcdGJvb2xlYW46IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIG9iaiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBbXSApO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gTnVtYmVyXHJcblx0XHRcdFx0bnVtYmVyOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBOdW0oIG9iaiwgb2JqICUgMSAhPT0gMCApO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU3RyaW5nXHJcblx0XHRcdFx0c3RyaW5nOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBvYmosIFtdICk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBMaXN0XHJcblx0XHRcdFx0bGlzdDogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHRvYmogPSB0b2JqID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRvYmo7XHJcblx0XHRcdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdFx0XHR2YXIgZWxlbTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRlbGVtID0gcGwuZnJvbUphdmFTY3JpcHQuYXBwbHkoIG9ialtpXSwgdG9iaiApO1xyXG5cdFx0XHRcdFx0XHRpZiggZWxlbSA9PT0gdW5kZWZpbmVkIClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0XHRhcnIucHVzaCggZWxlbSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGFycmF5VG9MaXN0KCBhcnIgKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFZhcmlhYmxlXHJcblx0XHRcdFx0dmFyaWFibGU6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFZhciggXCJfXCIgKTtcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBPYmplY3RcclxuXHRcdFx0XHRvYmplY3Q6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHR0b2JqID0gdG9iaiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0b2JqO1xyXG5cdFx0XHRcdFx0dmFyIGxpc3QgPSBuZXcgVGVybShcIltdXCIsIFtdKTtcclxuXHRcdFx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0XHRcdGZvcih2YXIgcHJvcCBpbiBvYmopIHtcclxuXHRcdFx0XHRcdFx0aWYoIW9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdGFyci5wdXNoKG5ldyBUZXJtKFwiLVwiLCBbXHJcblx0XHRcdFx0XHRcdFx0cGwuZnJvbUphdmFTY3JpcHQuYXBwbHkocHJvcCwgdG9iaiksXHJcblx0XHRcdFx0XHRcdFx0cGwuZnJvbUphdmFTY3JpcHQuYXBwbHkob2JqW3Byb3BdLCB0b2JqKVxyXG5cdFx0XHRcdFx0XHRdKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gYXJyYXlUb0xpc3QoYXJyKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEFueVxyXG5cdFx0XHRcdGFueTogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVHJhbnNmb3JtIG9iamVjdFxyXG5cdFx0XHRhcHBseTogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHR0b2JqID0gdG9iaiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0b2JqO1xyXG5cdFx0XHRcdGZvciggdmFyIGkgaW4gcGwuZnJvbUphdmFTY3JpcHQudGVzdCApXHJcblx0XHRcdFx0XHRpZiggaSAhPT0gXCJhbnlcIiAmJiBwbC5mcm9tSmF2YVNjcmlwdC50ZXN0W2ldKCBvYmosIHRvYmogKSApXHJcblx0XHRcdFx0XHRcdHJldHVybiBwbC5mcm9tSmF2YVNjcmlwdC5jb252ZXJzaW9uW2ldKCBvYmosIHRvYmogKTtcclxuXHRcdFx0XHRyZXR1cm4gcGwuZnJvbUphdmFTY3JpcHQuY29udmVyc2lvbi5hbnkoIG9iaiwgdG9iaiApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBUeXBlc1xyXG5cdFx0dHlwZToge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gT2JqZWN0c1xyXG5cdFx0XHRWYXI6IFZhcixcclxuXHRcdFx0TnVtOiBOdW0sXHJcblx0XHRcdFRlcm06IFRlcm0sXHJcblx0XHRcdFJ1bGU6IFJ1bGUsXHJcblx0XHRcdFN0YXRlOiBTdGF0ZSxcclxuXHRcdFx0U3RyZWFtOiBTdHJlYW0sXHJcblx0XHRcdE1vZHVsZTogTW9kdWxlLFxyXG5cdFx0XHRUaHJlYWQ6IFRocmVhZCxcclxuXHRcdFx0U2Vzc2lvbjogU2Vzc2lvbixcclxuXHRcdFx0U3Vic3RpdHV0aW9uOiBTdWJzdGl0dXRpb24sXHJcblx0XHRcdEZpbGU6IFRhdUZpbGUsXHJcblx0XHRcdERpcmVjdG9yeTogVGF1RGlyZWN0b3J5LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gT3JkZXJcclxuXHRcdFx0b3JkZXI6IFtWYXIsIE51bSwgVGVybSwgU3RyZWFtXSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIENvbXBhcmUgdHlwZXNcclxuXHRcdFx0Y29tcGFyZTogZnVuY3Rpb24oIHgsIHkgKSB7XHJcblx0XHRcdFx0dmFyIG9yZF94ID0gaW5kZXhPZiggcGwudHlwZS5vcmRlciwgeC5jb25zdHJ1Y3RvciApO1xyXG5cdFx0XHRcdHZhciBvcmRfeSA9IGluZGV4T2YoIHBsLnR5cGUub3JkZXIsIHkuY29uc3RydWN0b3IgKTtcclxuXHRcdFx0XHRpZiggb3JkX3ggPCBvcmRfeSApIHtcclxuXHRcdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIG9yZF94ID4gb3JkX3kgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIHguY29uc3RydWN0b3IgPT09IE51bSApXHJcblx0XHRcdFx0XHRcdGlmKCB4LmlzX2Zsb2F0ICYmIHkuaXNfZmxvYXQgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmKCB4LmlzX2Zsb2F0IClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYoIHkuaXNfZmxvYXQgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBzdWJzdGl0dXRpb25cclxuXHRcdFx0aXNfc3Vic3RpdHV0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBTdWJzdGl0dXRpb247XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHN0YXRlXHJcblx0XHRcdGlzX3N0YXRlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBTdGF0ZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgcnVsZVxyXG5cdFx0XHRpc19ydWxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBSdWxlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSB2YXJpYWJsZVxyXG5cdFx0XHRpc192YXJpYWJsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVmFyO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBzdHJlYW1cclxuXHRcdFx0aXNfc3RyZWFtOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBTdHJlYW07XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBhbm9ueW1vdXMgdmFyaWFibGVcclxuXHRcdFx0aXNfYW5vbnltb3VzX3ZhcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVmFyICYmIG9iai5pZCA9PT0gXCJfXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGNhbGxhYmxlIHRlcm1cclxuXHRcdFx0aXNfY2FsbGFibGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm1cclxuXHRcdFx0XHQmJiAoaW5kZXhPZihbXCIsLzJcIixcIjsvMlwiLFwiLT4vMlwiXSwgb2JqLmluZGljYXRvcikgPT09IC0xXHJcblx0XHRcdFx0fHwgcGwudHlwZS5pc19jYWxsYWJsZShvYmouYXJnc1swXSkgJiYgcGwudHlwZS5pc19jYWxsYWJsZShvYmouYXJnc1sxXSkpXHJcblx0XHRcdFx0fHwgb2JqIGluc3RhbmNlb2YgVmFyO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBudW1iZXJcclxuXHRcdFx0aXNfbnVtYmVyOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW07XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBpbnRlZ2VyXHJcblx0XHRcdGlzX2ludGVnZXI6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiAhb2JqLmlzX2Zsb2F0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBmbG9hdFxyXG5cdFx0XHRpc19mbG9hdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmIG9iai5pc19mbG9hdDtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgdGVybVxyXG5cdFx0XHRpc190ZXJtOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gYXRvbVxyXG5cdFx0XHRpc19hdG9tOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzLmxlbmd0aCA9PT0gMDtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgZ3JvdW5kIHRlcm1cclxuXHRcdFx0aXNfZ3JvdW5kOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdGlmKCBvYmogaW5zdGFuY2VvZiBWYXIgKSByZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0aWYoIG9iaiBpbnN0YW5jZW9mIFRlcm0gKVxyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBvYmouYXJncy5sZW5ndGg7IGkrKyApXHJcblx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19ncm91bmQoIG9iai5hcmdzW2ldICkgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGF0b21pY1xyXG5cdFx0XHRpc19hdG9taWM6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3MubGVuZ3RoID09PSAwIHx8IG9iaiBpbnN0YW5jZW9mIE51bTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGNvbXBvdW5kXHJcblx0XHRcdGlzX2NvbXBvdW5kOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzLmxlbmd0aCA+IDA7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGxpc3RcclxuXHRcdFx0aXNfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiAob2JqLmluZGljYXRvciA9PT0gXCJbXS8wXCIgfHwgb2JqLmluZGljYXRvciA9PT0gXCIuLzJcIik7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBlbXB0eSBsaXN0XHJcblx0XHRcdGlzX2VtcHR5X2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCJbXS8wXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIG5vbiBlbXB0eSBsaXN0XHJcblx0XHRcdGlzX25vbl9lbXB0eV9saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiLi8yXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGZ1bGx5IGxpc3RcclxuXHRcdFx0aXNfZnVsbHlfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHR3aGlsZSggb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0b2JqID0gb2JqLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBWYXIgfHwgb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIltdLzBcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgaW5zdGFudGlhdGVkIGxpc3RcclxuXHRcdFx0aXNfaW5zdGFudGlhdGVkX2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0d2hpbGUoIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdG9iaiA9IG9iai5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIltdLzBcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIHVuaXRhcnkgbGlzdFxyXG5cdFx0XHRpc191bml0YXJ5X2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCIuLzJcIiAmJiBvYmouYXJnc1sxXSBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3NbMV0uaW5kaWNhdG9yID09PSBcIltdLzBcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgY2hhcmFjdGVyXHJcblx0XHRcdGlzX2NoYXJhY3RlcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJncy5sZW5ndGggPT09IDAgJiYgKG9iai5pZC5sZW5ndGggPT09IDEgfHwgb2JqLmlkLmxlbmd0aCA+IDAgJiYgb2JqLmlkLmxlbmd0aCA8PSAyICYmIGNvZGVQb2ludEF0KCBvYmouaWQsIDAgKSA+PSA2NTUzNik7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGluX2NoYXJhY3RlclxyXG5cdFx0XHRpc19pbl9jaGFyYWN0ZXI6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgKG9iai5pbmRpY2F0b3IgPT09IFwiZW5kX29mX2ZpbGUvMFwiXHJcblx0XHRcdFx0fHwgb2JqLmlkLmxlbmd0aCA9PT0gMVxyXG5cdFx0XHRcdHx8IG9iai5pZC5sZW5ndGggPiAwICYmIG9iai5pZC5sZW5ndGggPD0gMiAmJiBjb2RlUG9pbnRBdChvYmouaWQsIDApID49IDY1NTM2KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgY2hhcmFjdGVyX2NvZGVcclxuXHRcdFx0aXNfY2hhcmFjdGVyX2NvZGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiAhb2JqLmlzX2Zsb2F0ICYmIG9iai52YWx1ZSA+PSAwICYmIG9iai52YWx1ZSA8PSAxMTE0MTExO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBpbl9jaGFyYWN0ZXJfY29kZVxyXG5cdFx0XHRpc19pbl9jaGFyYWN0ZXJfY29kZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmICFvYmouaXNfZmxvYXQgJiYgb2JqLnZhbHVlID49IC0xICYmIG9iai52YWx1ZSA8PSAxMTE0MTExO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBieXRlXHJcblx0XHRcdGlzX2J5dGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiAhb2JqLmlzX2Zsb2F0ICYmIG9iai52YWx1ZSA+PSAwICYmIG9iai52YWx1ZSA8PSAyNTU7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIGluX2J5dGVcclxuXHRcdFx0aXNfaW5fYnl0ZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmICFvYmouaXNfZmxvYXQgJiYgb2JqLnZhbHVlID49IC0xICYmIG9iai52YWx1ZSA8PSAyNTU7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBvcGVyYXRvclxyXG5cdFx0XHRpc19vcGVyYXRvcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBwbC5hcml0aG1ldGljLmV2YWx1YXRpb25bb2JqLmluZGljYXRvcl07XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGRpcmVjdGl2ZVxyXG5cdFx0XHRpc19kaXJlY3RpdmU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgKHBsLmRpcmVjdGl2ZVtvYmouaW5kaWNhdG9yXSAhPT0gdW5kZWZpbmVkIHx8IHBsLmRpcmVjdGl2ZVtvYmouaWQgKyBcIi8qXCJdICE9PSB1bmRlZmluZWQpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBidWlsdC1pbiBwcmVkaWNhdGVcclxuXHRcdFx0aXNfYnVpbHRpbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBwbC5idWlsdGluLnJ1bGVzLmhhc093blByb3BlcnR5KG9iai5pbmRpY2F0b3IpICYmIG9iai5pbmRpY2F0b3IgIT09IFwiZ29hbF9leHBhbnNpb24vMlwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gZXJyb3JcclxuXHRcdFx0aXNfZXJyb3I6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCJ0aHJvdy8xXCI7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhbiBlcnJvciBzdGF0ZVxyXG5cdFx0XHRpc19lcnJvcl9zdGF0ZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc19zdGF0ZSggb2JqICkgJiYgb2JqLmVycm9yICYmIG9iai5lcnJvciA9PT0gdHJ1ZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgcHJlZGljYXRlIGluZGljYXRvclxyXG5cdFx0XHRpc19wcmVkaWNhdGVfaW5kaWNhdG9yOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiLy8yXCIgJiYgb2JqLmFyZ3NbMF0gaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzWzBdLmFyZ3MubGVuZ3RoID09PSAwICYmIG9iai5hcmdzWzFdIGluc3RhbmNlb2YgTnVtICYmIG9iai5hcmdzWzFdLmlzX2Zsb2F0ID09PSBmYWxzZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgZmxhZ1xyXG5cdFx0XHRpc19mbGFnOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzLmxlbmd0aCA9PT0gMCAmJiBwbC5mbGFnW29iai5pZF0gIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgdmFsaWQgdmFsdWUgZm9yIGEgZmxhZ1xyXG5cdFx0XHRpc192YWx1ZV9mbGFnOiBmdW5jdGlvbiggZmxhZywgb2JqICkge1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc19mbGFnKCBmbGFnICkgKSByZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0Zm9yKCB2YXIgdmFsdWUgaW4gcGwuZmxhZ1tmbGFnLmlkXS5hbGxvd2VkICkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLmZsYWdbZmxhZy5pZF0uYWxsb3dlZC5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aWYoIHBsLmZsYWdbZmxhZy5pZF0uYWxsb3dlZFt2YWx1ZV0uZXF1YWxzKCBvYmogKSApIHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIGlvIG1vZGVcclxuXHRcdFx0aXNfaW9fbW9kZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc19hdG9tKCBvYmogKSAmJiBbXCJyZWFkXCIsXCJ3cml0ZVwiLFwiYXBwZW5kXCJdLmluZGV4T2YoIG9iai5pZCApICE9PSAtMTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgc3RyZWFtIG9wdGlvblxyXG5cdFx0XHRpc19zdHJlYW1fb3B0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0oIG9iaiApICYmIChcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiYWxpYXMvMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicmVwb3NpdGlvbi8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInR5cGUvMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRleHRcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJiaW5hcnlcIikgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZW9mX2FjdGlvbi8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwiZXJyb3JcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJlb2ZfY29kZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcInJlc2V0XCIpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgc3RyZWFtIHBvc2l0aW9uXHJcblx0XHRcdGlzX3N0cmVhbV9wb3NpdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKG9iaikgJiYgKFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJlbmRfb2Zfc3RyZWFtLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW0vMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInBvc2l0aW9uLzNcIlxyXG5cdFx0XHRcdFx0XHQmJiBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMF0pXHJcblx0XHRcdFx0XHRcdCYmIHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1sxXSlcclxuXHRcdFx0XHRcdFx0JiYgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzJdKVxyXG5cdFx0XHRcdClcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgc3RyZWFtIHByb3BlcnR5XHJcblx0XHRcdGlzX3N0cmVhbV9wcm9wZXJ0eTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKCBvYmogKSAmJiAoXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImlucHV0LzBcIiB8fCBcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwib3V0cHV0LzBcIiB8fCBcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiYWxpYXMvMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbSggb2JqLmFyZ3NbMF0gKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZmlsZV9uYW1lLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20oIG9iai5hcmdzWzBdICkpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInJlcG9zaXRpb24vMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwidHlwZS8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidGV4dFwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImJpbmFyeVwiKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwibW9kZS8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwicmVhZFwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcIndyaXRlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiYXBwZW5kXCIpKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJlb2ZfYWN0aW9uLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJlcnJvclwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImVvZl9jb2RlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwicmVzZXRcIikpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImVuZF9vZl9zdHJlYW0vMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcImF0XCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwicGFzdFwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcIm5vdFwiKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicG9zaXRpb24vMVwiXHJcblx0XHRcdFx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKG9iai5hcmdzWzBdKSB8fCBwbC50eXBlLmlzX3Rlcm0ob2JqLmFyZ3NbMF0pICYmIG9iai5hcmdzWzBdLmluZGljYXRvciA9PT0gXCJwb3NpdGlvbi8zXCJcclxuXHRcdFx0XHRcdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShvYmouYXJnc1swXS5hcmdzWzBdKSB8fCBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMF0uYXJnc1swXSkpXHJcblx0XHRcdFx0XHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUob2JqLmFyZ3NbMF0uYXJnc1sxXSkgfHwgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzBdLmFyZ3NbMV0pKVxyXG5cdFx0XHRcdFx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKG9iai5hcmdzWzBdLmFyZ3NbMl0pIHx8IHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1swXS5hcmdzWzJdKSkpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgc3RyZWFtYWJsZSB0ZXJtXHJcblx0XHRcdGlzX3N0cmVhbWFibGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iai5fX3Byb3RvX18uc3RyZWFtICE9PSB1bmRlZmluZWQ7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHJlYWQgb3B0aW9uXHJcblx0XHRcdGlzX3JlYWRfb3B0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0oIG9iaiApICYmIFtcInZhcmlhYmxlcy8xXCIsXCJ2YXJpYWJsZV9uYW1lcy8xXCIsXCJzaW5nbGV0b25zLzFcIl0uaW5kZXhPZiggb2JqLmluZGljYXRvciApICE9PSAtMTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgd3JpdGUgb3B0aW9uXHJcblx0XHRcdGlzX3dyaXRlX29wdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKCBvYmogKSAmJiAoXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInF1b3RlZC8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImlnbm9yZV9vcHMvMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJudW1iZXJ2YXJzLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIikgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwidmFyaWFibGVfbmFtZXMvMVwiICYmIHBsLnR5cGUuaXNfZnVsbHlfbGlzdChvYmouYXJnc1swXSlcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBjbG9zZSBvcHRpb25cclxuXHRcdFx0aXNfY2xvc2Vfb3B0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0oIG9iaiApICYmXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImZvcmNlLzFcIiAmJlxyXG5cdFx0XHRcdFx0cGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJlxyXG5cdFx0XHRcdFx0KG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgbW9kaWZpYWJsZSBmbGFnXHJcblx0XHRcdGlzX21vZGlmaWFibGVfZmxhZzogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc19mbGFnKCBvYmogKSAmJiBwbC5mbGFnW29iai5pZF0uY2hhbmdlYWJsZTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgbW9kdWxlXHJcblx0XHRcdGlzX21vZHVsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTW9kdWxlO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSB2aXJ0dWFsIGZpbGVcclxuXHRcdFx0aXNfZmlsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGF1RmlsZTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgdmlydHVhbCBkaXJlY3RvcnlcclxuXHRcdFx0aXNfZGlyZWN0b3J5OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUYXVEaXJlY3Rvcnk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHByZWRpY2F0ZSBwcm9wZXJ0eVxyXG5cdFx0XHRpc19wcmVkaWNhdGVfcHJvcGVydHk6IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0ob2JqKSAmJiAoXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImJ1aWx0X2luLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJzdGF0aWMvMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImR5bmFtaWMvMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm5hdGl2ZV9jb2RlLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJtdWx0aWZpbGUvMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm1ldGFfcHJlZGljYXRlLzFcIlxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIG1ldGEtYXJndW1lbnQgc3BlY2lmaWVyXHJcblx0XHRcdGlzX21ldGFfYXJndW1lbnRfc3BlY2lmaWVyOiBmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc19pbnRlZ2VyKG9iaikgJiYgb2JqLnZhbHVlID49IDAgfHxcclxuXHRcdFx0XHRcdHBsLnR5cGUuaXNfYXRvbShvYmopICYmIGluZGV4T2YoW1wiK1wiLCBcIi1cIiwgXCI/XCIsIFwiKlwiLCBcIl5cIiwgXCI6XCIsIFwiLy9cIl0sIG9iai5pZCkgIT09IC0xO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSB0aW1lIHByb3BlcnR5XHJcblx0XHRcdGlzX3RpbWVfcHJvcGVydHk6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybShvYmopICYmIG9iai5hcmdzLmxlbmd0aCA9PT0gMSBcclxuXHRcdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShvYmouYXJnc1swXSkgfHwgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzBdKSlcclxuXHRcdFx0XHQmJiBpbmRleE9mKFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIiwgXCJ3ZWVrZGF5XCJdLCBvYmouaWQpICE9PSAtMTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEFyaXRobWV0aWMgZnVuY3Rpb25zXHJcblx0XHRhcml0aG1ldGljOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBFdmFsdWF0aW9uXHJcblx0XHRcdGV2YWx1YXRpb246IHtcclxuXHRcdFx0XHRcImUvMFwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggXyApIHsgcmV0dXJuIE1hdGguRTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJwaS8wXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCBfICkgeyByZXR1cm4gTWF0aC5QSTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJ0YXUvMFwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggXyApIHsgcmV0dXJuIDIqTWF0aC5QSTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJlcHNpbG9uLzBcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIF8gKSB7IHJldHVybiBOdW1iZXIuRVBTSUxPTjsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIrLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiB4OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIi0vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIC14OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIlxcXFwvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gfng7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYWJzLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmFicyggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInNpZ24vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguc2lnbiggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImZsb2F0X2ludGVnZXJfcGFydC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIHBhcnNlSW50KCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZmxvYXRfZnJhY3Rpb25hbF9wYXJ0LzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiB4IC0gcGFyc2VJbnQoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJmbG9hdC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gcGFyc2VGbG9hdCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImZsb29yLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5mbG9vciggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInRydW5jYXRlLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gcGFyc2VJbnQoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJyb3VuZC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGgucm91bmQoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJjZWlsaW5nLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5jZWlsKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwic2luLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnNpbiggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImNvcy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5jb3MoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJ0YW4vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGgudGFuKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYXNpbi8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiBNYXRoLmFicyh4KSA8PSAxID8gTWF0aC5hc2luKHgpIDogcGwuZXJyb3IuZXZhbHVhdGlvbihcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcik7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYWNvcy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiBNYXRoLmFicyh4KSA8PSAxID8gTWF0aC5hY29zKHgpIDogcGwuZXJyb3IuZXZhbHVhdGlvbihcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcik7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYXRhbi8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5hdGFuKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYXRhbjIvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geCA9PT0gMCAmJiB5ID09PSAwID8gcGwuZXJyb3IuZXZhbHVhdGlvbihcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcikgOiBNYXRoLmF0YW4yKHgsIHkpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImFjb3NoLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIHggPj0gMSA/IE1hdGguYWNvc2goeCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhc2luaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5hc2luaCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImF0YW5oLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIE1hdGguYWJzKHgpIDwgMSA/IE1hdGguYXRhbmgoeCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJjb3NoLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmNvc2goIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJzaW5oLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnNpbmgoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJ0YW5oLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnRhbmgoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJleHAvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguZXhwKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwic3FydC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiB4ID49IDAgPyBNYXRoLnNxcnQoIHggKSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibG9nLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIHggPiAwID8gTWF0aC5sb2coIHggKSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibG9nLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHggPiAwICYmIHkgPiAwID8gTWF0aC5sb2coeSkvTWF0aC5sb2coeCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImxvZzEwLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIHggPiAwID8gTWF0aC5sb2coeCkvTWF0aC5sb2coMTApIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIrLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4ICsgeTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCItLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogIGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCAtIHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiKi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCAqIHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiLy8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB5ID8geCAvIHkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIi8vLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geSA/IE1hdGgudHJ1bmMoIHggLyB5ICkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImRpdi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHkgPyBNYXRoLmZsb29yKCB4IC8geSApIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIqKi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB4ID09IDAgJiYgeSA8IDAgPyBwbC5lcnJvci5ldmFsdWF0aW9uKFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKSA6IE1hdGgucG93KHgsIHkpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIl4vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geCA9PSAwICYmIHkgPCAwID8gcGwuZXJyb3IuZXZhbHVhdGlvbihcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcikgOiBNYXRoLnBvdyh4LCB5KTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCI8PC8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4IDw8IHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiPj4vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCA+PiB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIi9cXFxcLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggJiB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIlxcXFwvLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggfCB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInhvci8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4IF4geTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJyZW0vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB5ID8geCAlIHkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIm1vZC8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHkgPyB4IC0gTWF0aC5mbG9vciggeCAvIHkgKSAqIHkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIm1heC8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4gTWF0aC5tYXgoIHgsIHkgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJtaW4vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIE1hdGgubWluKCB4LCB5ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZ2NkLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIGdjZCh4LCB5KTsgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIERpcmVjdGl2ZXNcclxuXHRcdGRpcmVjdGl2ZToge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gZHluYW1pYy8xXHJcblx0XHRcdFwiZHluYW1pYy8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIGF0b20sIG9wdGlvbnMgKSB7XHJcblx0XHRcdFx0dmFyIGluZGljYXRvcnMgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbGlzdChpbmRpY2F0b3JzKSlcclxuXHRcdFx0XHRcdGluZGljYXRvcnMgPSBhcnJheVRvTGlzdChbaW5kaWNhdG9yc10pO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gaW5kaWNhdG9ycztcclxuXHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdGluZGljYXRvciA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY29tcG91bmQoIGluZGljYXRvciApIHx8IGluZGljYXRvci5pbmRpY2F0b3IgIT09IFwiLy8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgaW5kaWNhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvci5hcmdzWzBdICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggaW5kaWNhdG9yLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBpbmRpY2F0b3IuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBpbmRpY2F0b3IuYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGluZGljYXRvci5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR2YXIga2V5ID0gaW5kaWNhdG9yLmFyZ3NbMF0uaWQgKyBcIi9cIiArIGluZGljYXRvci5hcmdzWzFdLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV07XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNba2V5XSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdGlmKCAhZ2V0X21vZHVsZS5ydWxlc1trZXldIClcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1trZXldID0gW107XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpIHx8IHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIikge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwicHJlZGljYXRlX2luZGljYXRvclwiLCBpbmRpY2F0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBkeW5hbWljL1syLi5dXHJcblx0XHRcdFwiZHluYW1pYy8qXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIGF0b20gKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGF0b20uYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0cGwuZGlyZWN0aXZlW1wiZHluYW1pYy8xXCJdKHRocmVhZCwgbmV3IFRlcm0oXCJkeW5hbWljXCIsIFthdG9tLmFyZ3NbaV1dKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gbXVsdGlmaWxlLzFcclxuXHRcdFx0XCJtdWx0aWZpbGUvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBhdG9tLCBvcHRpb25zICkge1xyXG5cdFx0XHRcdHZhciBpbmRpY2F0b3IgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NvbXBvdW5kKCBpbmRpY2F0b3IgKSB8fCBpbmRpY2F0b3IuaW5kaWNhdG9yICE9PSBcIi8vMlwiICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwicHJlZGljYXRlX2luZGljYXRvclwiLCBpbmRpY2F0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvci5hcmdzWzBdICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBpbmRpY2F0b3IuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBpbmRpY2F0b3IuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggaW5kaWNhdG9yLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgaW5kaWNhdG9yLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHByZWRpY2F0ZV9pbmRpY2F0b3IgPSBhdG9tLmFyZ3NbMF0uYXJnc1swXS5pZCArIFwiL1wiICsgYXRvbS5hcmdzWzBdLmFyZ3NbMV0udmFsdWU7XHJcblx0XHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV07XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLm11bHRpZmlsZV9wcmVkaWNhdGVzW3ByZWRpY2F0ZV9pbmRpY2F0b3JdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmKCFnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHByZWRpY2F0ZV9pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbcHJlZGljYXRlX2luZGljYXRvcl0gPSBbXTtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1twcmVkaWNhdGVfaW5kaWNhdG9yXSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIG1ldGFfcHJlZGljYXRlLzFcclxuXHRcdFx0XCJtZXRhX3ByZWRpY2F0ZS8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgYXRvbSwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0XHRcdHZhciBoZWFkID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBoZWFkLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIGFyZyA9IGhlYWQuYXJnc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbWV0YV9hcmd1bWVudF9zcGVjaWZpZXIoYXJnKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJtZXRhX2FyZ3VtZW50X3NwZWNpZmllclwiLCBhcmcsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdLm1ldGFfcHJlZGljYXRlc1toZWFkLmluZGljYXRvcl0gPSBoZWFkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIHNldF9wcm9sb2dfZmxhZ1xyXG5cdFx0XHRcInNldF9wcm9sb2dfZmxhZy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIGF0b20gKSB7XHJcblx0XHRcdFx0dmFyIGZsYWcgPSBhdG9tLmFyZ3NbMF0sIHZhbHVlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBmbGFnICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggdmFsdWUgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ZsYWcoIGZsYWcgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5kb21haW4oIFwicHJvbG9nX2ZsYWdcIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbW9kaWZpYWJsZV9mbGFnKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJtb2RpZnlcIiwgXCJmbGFnXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhbHVlX2ZsYWcoIGZsYWcsIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuZG9tYWluKCBcImZsYWdfdmFsdWVcIiwgbmV3IFRlcm0oIFwiK1wiLCBbZmxhZywgdmFsdWVdICksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uZmxhZ1tmbGFnLmlkXSA9IHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIG1vZHVsZS8yXHJcblx0XHRcdFwibW9kdWxlLzJcIjogZnVuY3Rpb24odGhyZWFkLCBhdG9tLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRcdFx0b3B0aW9ucy5jb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdFx0XHR2YXIgbW9kdWxlX2lkID0gYXRvbS5hcmdzWzBdLCBleHBvcnRzID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUobW9kdWxlX2lkKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKGV4cG9ydHMpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2F0b20obW9kdWxlX2lkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImF0b21cIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19saXN0KGV4cG9ydHMpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwibGlzdFwiLCBleHBvcnRzLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWQuaW5kaWNhdG9yXSkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBleHBvcnRzO1xyXG5cdFx0XHRcdFx0XHR2YXIgaW5kaWNhdG9ycyA9IFtdO1xyXG5cdFx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcHJlZGljYXRlID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ByZWRpY2F0ZV9pbmRpY2F0b3IocHJlZGljYXRlKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgcHJlZGljYXRlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpbmRpY2F0b3JzLnB1c2gocHJlZGljYXRlLmFyZ3NbMF0uaWQgKyBcIi9cIiArIHByZWRpY2F0ZS5hcmdzWzFdLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfZW1wdHlfbGlzdChwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGV4cG9ydHMsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFyIG5ld19tb2R1bGUgPSBuZXcgTW9kdWxlKG1vZHVsZV9pZC5pZCwge30sIGluZGljYXRvcnMsIHtcclxuXHRcdFx0XHRcdFx0XHRzZXNzaW9uOiB0aHJlYWQuc2Vzc2lvblxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWQuaWRdID0gbmV3X21vZHVsZTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXS5tb2R1bGVzW21vZHVsZV9pZC5pZF0gPSBuZXdfbW9kdWxlO1xyXG5cdFx0XHRcdFx0XHRvcHRpb25zLmNvbnRleHRfbW9kdWxlID0gbW9kdWxlX2lkLmlkO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IucGVybWlzc2lvbihcImNyZWF0ZVwiLCBcIm1vZHVsZVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gdXNlX21vZHVsZS8xXHJcblx0XHRcdFwidXNlX21vZHVsZS8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgYXRvbSwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0XHRcdG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdFx0dmFyIG1vZHVsZV9pZCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKG1vZHVsZV9pZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShtb2R1bGVfaWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwidGVybVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKG1vZHVsZV9pZC5pbmRpY2F0b3IgPT09IFwibGlicmFyeS8xXCIpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBtb2R1bGVfaWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSBwbC5tb2R1bGVzW25hbWVdO1xyXG5cdFx0XHRcdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdLm1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbmFtZV0gPSBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXS5tb2R1bGVzW25hbWVdID0gZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBnZXRfbW9kdWxlLmRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgdGVybSA9IG5ldyBUZXJtKFwidXNlX21vZHVsZVwiLCBbbmV3IFRlcm0oXCJsaWJyYXJ5XCIsIFtuZXcgVGVybShnZXRfbW9kdWxlLmRlcGVuZGVuY2llc1tpXSldKV0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwbC5kaXJlY3RpdmVbXCJ1c2VfbW9kdWxlLzFcIl0odGhyZWFkLCB0ZXJtLCB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udGV4dF9tb2R1bGU6IG5hbWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmV4aXN0ZW5jZShcIm1vZHVsZVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gbW9kdWxlX2lkLmlkO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuY29uc3VsdChuYW1lLCB7XHJcblx0XHRcdFx0XHRcdFx0Y29udGV4dF9tb2R1bGU6IG9wdGlvbnMuY29udGV4dF9tb2R1bGUsXHJcblx0XHRcdFx0XHRcdFx0dGV4dDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLmVycm9yKHBsLmVycm9yLmV4aXN0ZW5jZShcIm1vZHVsZVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gY2hhcl9jb252ZXJzaW9uLzJcclxuXHRcdFx0XCJjaGFyX2NvbnZlcnNpb24vMlwiOiBmdW5jdGlvbih0aHJlYWQsIGF0b20sIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR2YXIgaW5jaGFyID0gYXRvbS5hcmdzWzBdLCBvdXRjaGFyID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaW5jaGFyKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKG91dGNoYXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NoYXJhY3RlcihpbmNoYXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwiY2hhcmFjdGVyXCIsIGluY2hhciwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2hhcmFjdGVyKG91dGNoYXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwiY2hhcmFjdGVyXCIsIG91dGNoYXIsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKGluY2hhci5pZCA9PT0gb3V0Y2hhci5pZCkge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhyZWFkLnNlc3Npb24uX19jaGFyX2NvbnZlcnNpb25baW5jaGFyLmlkXTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLl9fY2hhcl9jb252ZXJzaW9uW2luY2hhci5pZF0gPSBvdXRjaGFyLmlkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b3B0aW9ucy50b2tlbnMgPSBvcHRpb25zLnRva2VuaXplci5nZXRfdG9rZW5zKG9wdGlvbnMuY3VycmVudF90b2tlbik7XHJcblx0XHRcdFx0XHRvcHRpb25zLmN1cnJlbnRfdG9rZW4gPSAwO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gb3AvM1xyXG5cdFx0XHRcIm9wLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgYXRvbSApIHtcclxuXHRcdFx0XHR2YXIgcHJpb3JpdHkgPSBhdG9tLmFyZ3NbMF0sIHR5cGUgPSBhdG9tLmFyZ3NbMV0sIG9wZXJhdG9ycyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2F0b20ob3BlcmF0b3JzKSlcclxuXHRcdFx0XHRcdG9wZXJhdG9ycyA9IG5ldyBUZXJtKFwiLlwiLCBbb3BlcmF0b3JzLCBuZXcgVGVybShcIltdXCIpXSk7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByaW9yaXR5ICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggdHlwZSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIHByaW9yaXR5ICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCB0eXBlICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHR5cGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcGVyYXRvcnM7XHJcblx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG9wZXJhdG9yID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggb3BlcmF0b3IgKSApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIG9wZXJhdG9yICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIHByaW9yaXR5LnZhbHVlIDwgMCB8fCBwcmlvcml0eS52YWx1ZSA+IDEyMDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9wcmlvcml0eVwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcIixcIiApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwibW9kaWZ5XCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJ7fVwiICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwiW11cIiApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcInxcIiAmJiBwcmlvcml0eS52YWx1ZSAhPT0gMCAmJiAocHJpb3JpdHkudmFsdWUgPCAxMDAxIHx8IHR5cGUuaWQubGVuZ3RoICE9PSAzICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBbXCJmeVwiLCBcImZ4XCIsIFwieWZcIiwgXCJ4ZlwiLCBcInhmeFwiLCBcInlmeFwiLCBcInhmeVwiXS5pbmRleE9mKCB0eXBlLmlkICkgPT09IC0xICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3Jfc3BlY2lmaWVyXCIsIHR5cGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZml4ID0geyBwcmVmaXg6IG51bGwsIGluZml4OiBudWxsLCBwb3N0Zml4OiBudWxsIH07XHJcblx0XHRcdFx0XHRcdFx0Zm9yKCB2YXIgcCBpbiB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9ycyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3BdW29wZXJhdG9yLmlkXTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBjbGFzc2VzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJmeFwiICkgIT09IC0xICkgeyBmaXgucHJlZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwiZnlcIiApICE9PSAtMSApIHsgZml4LnByZWZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwiZnlcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmXCIgKSAhPT0gLTEgKSB7IGZpeC5wb3N0Zml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZlwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieWZcIiApICE9PSAtMSApIHsgZml4LnBvc3RmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInlmXCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZnhcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmeVwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmeVwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieWZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieWZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudF9jbGFzcztcclxuXHRcdFx0XHRcdFx0XHRzd2l0Y2goIHR5cGUuaWQgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwiZnlcIjogY2FzZSBcImZ4XCI6IGN1cnJlbnRfY2xhc3MgPSBcInByZWZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJ5ZlwiOiBjYXNlIFwieGZcIjogY3VycmVudF9jbGFzcyA9IFwicG9zdGZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IGN1cnJlbnRfY2xhc3MgPSBcImluZml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihmaXguaW5maXggJiYgY3VycmVudF9jbGFzcyA9PT0gXCJwb3N0Zml4XCIgfHwgZml4LnBvc3RmaXggJiYgY3VycmVudF9jbGFzcyA9PT0gXCJpbmZpeFwiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggZml4W2N1cnJlbnRfY2xhc3NdICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZW1vdmUoIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdLCBmaXhbY3VycmVudF9jbGFzc10udHlwZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF0ubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIHByaW9yaXR5LnZhbHVlID4gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoICF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV0gKSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZS50b1N0cmluZygpXSA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0gKSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdID0gW107XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0ucHVzaCggdHlwZS5pZCApO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShwb2ludGVyKSB8fCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIGluaXRpYWxpemF0aW9uLzFcclxuXHRcdFx0XCJpbml0aWFsaXphdGlvbi8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgYXRvbSwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBnb2FsID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdG9wdGlvbnMuaW5pdGlhbGl6YXRpb24ucHVzaChnb2FsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEZsYWdzXHJcblx0XHRmbGFnOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBCb3VuZGVkIG51bWJlcnNcclxuXHRcdFx0Ym91bmRlZDoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJ0cnVlXCIgKSwgbmV3IFRlcm0oIFwiZmFsc2VcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwidHJ1ZVwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1heGltdW0gaW50ZWdlclxyXG5cdFx0XHRtYXhfaW50ZWdlcjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgTnVtKCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IE51bSggTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTWluaW11bSBpbnRlZ2VyXHJcblx0XHRcdG1pbl9pbnRlZ2VyOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBOdW0oIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgTnVtKCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBSb3VuZGluZyBmdW5jdGlvblxyXG5cdFx0XHRpbnRlZ2VyX3JvdW5kaW5nX2Z1bmN0aW9uOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcImRvd25cIiApLCBuZXcgVGVybSggXCJ0b3dhcmRfemVyb1wiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJ0b3dhcmRfemVyb1wiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIENoYXJhY3RlciBjb252ZXJzaW9uXHJcblx0XHRcdGNoYXJfY29udmVyc2lvbjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJvblwiICksIG5ldyBUZXJtKCBcIm9mZlwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJvblwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRGVidWdnZXJcclxuXHRcdFx0ZGVidWc6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwib25cIiApLCBuZXcgVGVybSggXCJvZmZcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwib2ZmXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiB0cnVlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBNYXhpbXVtIGFyaXR5IG9mIHByZWRpY2F0ZXNcclxuXHRcdFx0bWF4X2FyaXR5OiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcInVuYm91bmRlZFwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJ1bmJvdW5kZWRcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBVbmt3bm93IHByZWRpY2F0ZXMgYmVoYXZpb3JcclxuXHRcdFx0dW5rbm93bjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJlcnJvclwiICksIG5ldyBUZXJtKCBcImZhaWxcIiApLCBuZXcgVGVybSggXCJ3YXJuaW5nXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcImVycm9yXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiB0cnVlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBEb3VibGUgcXVvdGVzIGJlaGF2aW9yXHJcblx0XHRcdGRvdWJsZV9xdW90ZXM6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwiY2hhcnNcIiApLCBuZXcgVGVybSggXCJjb2Rlc1wiICksIG5ldyBUZXJtKCBcImF0b21cIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwiY2hhcnNcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE9jY3VycyBjaGVjayBiZWhhdmlvclxyXG5cdFx0XHRvY2N1cnNfY2hlY2s6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwiZmFsc2VcIiApLCBuZXcgVGVybSggXCJ0cnVlXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcImZhbHNlXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiB0cnVlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBEaWFsZWN0XHJcblx0XHRcdGRpYWxlY3Q6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwidGF1XCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcInRhdVwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFZlcnNpb25cclxuXHRcdFx0dmVyc2lvbl9kYXRhOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcInRhdVwiLCBbbmV3IE51bSh2ZXJzaW9uLm1ham9yLGZhbHNlKSwgbmV3IE51bSh2ZXJzaW9uLm1pbm9yLGZhbHNlKSwgbmV3IE51bSh2ZXJzaW9uLnBhdGNoLGZhbHNlKSwgbmV3IFRlcm0odmVyc2lvbi5zdGF0dXMpXSApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwidGF1XCIsIFtuZXcgTnVtKHZlcnNpb24ubWFqb3IsZmFsc2UpLCBuZXcgTnVtKHZlcnNpb24ubWlub3IsZmFsc2UpLCBuZXcgTnVtKHZlcnNpb24ucGF0Y2gsZmFsc2UpLCBuZXcgVGVybSh2ZXJzaW9uLnN0YXR1cyldICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE5vZGVKU1xyXG5cdFx0XHRub2RlanM6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwidHJ1ZVwiICksIG5ldyBUZXJtKCBcImZhbHNlXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBub2RlanNfZmxhZyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIEFyZ3VtZW50c1xyXG5cdFx0XHRhcmd2OiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25vZGVqc19hcmd1bWVudHNdLFxyXG5cdFx0XHRcdHZhbHVlOiBub2RlanNfYXJndW1lbnRzLFxyXG5cdFx0XHRcdGNoYW5nZWJsZTogZmFsc2VcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFVuaWZ5XHJcblx0XHR1bmlmeTogZnVuY3Rpb24odDEsIHQyLCBvY2N1cnNfY2hlY2spIHtcclxuXHRcdFx0b2NjdXJzX2NoZWNrID0gb2NjdXJzX2NoZWNrID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9jY3Vyc19jaGVjaztcclxuXHRcdFx0dmFyIGxlZnQgPSBBcnJheS5pc0FycmF5KHQxKSA/IHQxIDogW3QxXTtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gQXJyYXkuaXNBcnJheSh0MikgPyB0MiA6IFt0Ml07XHJcblx0XHRcdGlmKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdHZhciBzdWJzID0gbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0XHR3aGlsZShsZWZ0Lmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHR2YXIgcyA9IGxlZnQucG9wKCk7XHJcblx0XHRcdFx0dmFyIHQgPSByaWdodC5wb3AoKTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHMpKVxyXG5cdFx0XHRcdFx0cyA9IHMuYXBwbHkoc3Vicyk7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0KSlcclxuXHRcdFx0XHRcdHQgPSB0LmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRcdC8vIHNhbWUgb2JqZWN0XHJcblx0XHRcdFx0aWYocyA9PSB0KVxyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0Ly8gY29tcG91bmQgdGVybXNcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0ocykgJiYgcGwudHlwZS5pc190ZXJtKHQpKSB7XHJcblx0XHRcdFx0XHRpZihzLmluZGljYXRvciAhPT0gdC5pbmRpY2F0b3IpXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gcy5hcmdzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRcdFx0XHRsZWZ0LnB1c2gocy5hcmdzW2ldKTtcclxuXHRcdFx0XHRcdFx0cmlnaHQucHVzaCh0LmFyZ3NbaV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIG51bWJlcnNcclxuXHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19udW1iZXIocykgJiYgcGwudHlwZS5pc19udW1iZXIodCkpIHtcclxuXHRcdFx0XHRcdGlmKHMudmFsdWUgIT09IHQudmFsdWUgfHwgcy5pc19mbG9hdCAhPT0gdC5pc19mbG9hdClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0Ly8gdmFyaWFibGUgLSB0ZXJtXHJcblx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocykpIHtcclxuXHRcdFx0XHRcdHQgPSB0LmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRcdFx0Ly8geCA9IHhcclxuXHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodCkgJiYgcy5pZCA9PT0gdC5pZClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHQvLyBvY2N1cnMgY2hlY2tcclxuXHRcdFx0XHRcdGlmKG9jY3Vyc19jaGVjayA9PT0gdHJ1ZSAmJiBpbmRleE9mKHQudmFyaWFibGVzKCksIHMuaWQpICE9PSAtMSlcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHQvLyBhbm9ueW1vdXMgdmFyaWFibGVcclxuXHRcdFx0XHRcdGlmKHMuaWQgIT09IFwiX1wiKVxyXG5cdFx0XHRcdFx0XHRzdWJzLmFkZChzLmlkLCB0KTtcclxuXHRcdFx0XHQvLyB0ZXJtIC0gdmFyaWFibGVcclxuXHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc192YXJpYWJsZSh0KSkge1xyXG5cdFx0XHRcdFx0bGVmdC5wdXNoKHQpO1xyXG5cdFx0XHRcdFx0cmlnaHQucHVzaChzKTtcclxuXHRcdFx0XHQvLyB1c2VyLWRlZmluZWQgdGVybXNcclxuXHRcdFx0XHR9IGVsc2UgaWYocy51bmlmeSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHR2YXIgdXNlcl9zdWJzID0gcy5hcHBseShzdWJzKS51bmlmeSh0LmFwcGx5KHN1YnMpLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0XHRcdFx0aWYodXNlcl9zdWJzID09IG51bGwpXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpIGluIHVzZXJfc3Vicy5saW5rcylcclxuXHRcdFx0XHRcdFx0c3Vicy5hZGQoaSwgdXNlcl9zdWJzLmxpbmtzW2ldKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdWJzLmFwcGx5KHN1YnMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBJcyByZW5hbWVcclxuXHRcdGlzX3JlbmFtZTogZnVuY3Rpb24ob2JqMSwgb2JqMiwgbGlua3MpIHtcclxuXHRcdFx0bGlua3MgPSBsaW5rcyB8fCB7fTtcclxuXHRcdFx0aWYob2JqMS5pc19yZW5hbWUgJiYgb2JqMi5pc19yZW5hbWUpXHJcblx0XHRcdFx0cmV0dXJuIG9iajEuaXNfcmVuYW1lKG9iajIsIGxpbmtzKTtcclxuXHRcdFx0ZWxzZSBpZihvYmoxLmVxdWFscyAmJiBvYmoyLmVxdWFscylcclxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBDb21wYXJlXHJcblx0XHRjb21wYXJlOiBmdW5jdGlvbiggb2JqMSwgb2JqMiApIHtcclxuXHRcdFx0dmFyIHR5cGUgPSBwbC50eXBlLmNvbXBhcmUoIG9iajEsIG9iajIgKTtcclxuXHRcdFx0cmV0dXJuIHR5cGUgIT09IDAgPyB0eXBlIDogb2JqMS5jb21wYXJlKCBvYmoyICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBBcml0aG1ldGljIGNvbXBhcmlzb25cclxuXHRcdGFyaXRobWV0aWNfY29tcGFyZTogZnVuY3Rpb24oIHRocmVhZCwgb2JqMSwgb2JqMiApIHtcclxuXHRcdFx0dmFyIGV4cHIxID0gb2JqMS5pbnRlcnByZXQoIHRocmVhZCApO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCBleHByMSApICkge1xyXG5cdFx0XHRcdHJldHVybiBleHByMTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZXhwcjIgPSBvYmoyLmludGVycHJldCggdGhyZWFkICk7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggZXhwcjIgKSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBleHByMjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGV4cHIxLnZhbHVlIDwgZXhwcjIudmFsdWUgPyAtMSA6IChleHByMS52YWx1ZSA+IGV4cHIyLnZhbHVlID8gMSA6IDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gT3BlcmF0ZVxyXG5cdFx0b3BlcmF0ZTogZnVuY3Rpb24oIHRocmVhZCwgb2JqICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19vcGVyYXRvciggb2JqICkgKSB7XHJcblx0XHRcdFx0dmFyIG9wID0gcGwudHlwZS5pc19vcGVyYXRvciggb2JqICk7XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBbXSwgdmFsdWU7XHJcblx0XHRcdFx0dmFyIHR5cGUgPSBmYWxzZTtcclxuXHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IG9iai5hcmdzLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0dmFsdWUgPSBvYmouYXJnc1tpXS5pbnRlcnByZXQoIHRocmVhZCApO1xyXG5cdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggdmFsdWUgKSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBvcC50eXBlX2FyZ3MgIT09IG51bGwgJiYgdmFsdWUuaXNfZmxvYXQgIT09IG9wLnR5cGVfYXJncyApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLnR5cGUoIG9wLnR5cGVfYXJncyA/IFwiZmxvYXRcIiA6IFwiaW50ZWdlclwiLCB2YWx1ZSwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGFyZ3MucHVzaCggdmFsdWUudmFsdWUgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHR5cGUgPSB0eXBlIHx8IHZhbHVlLmlzX2Zsb2F0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRhcmdzLnB1c2goIHRocmVhZCApO1xyXG5cdFx0XHRcdHZhbHVlID0gcGwuYXJpdGhtZXRpYy5ldmFsdWF0aW9uW29iai5pbmRpY2F0b3JdLmZuLmFwcGx5KCB0aGlzLCBhcmdzICk7XHJcblx0XHRcdFx0aWYob2JqLmluZGljYXRvciA9PT0gXCJeLzJcIiAmJiAhdHlwZSAmJiB2YWx1ZSAhPT0gcGFyc2VJbnQodmFsdWUsIDEwKSlcclxuXHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci50eXBlKCBcImZsb2F0XCIsIG5ldyBOdW0oYXJnc1swXSxmYWxzZSksIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7XHJcblx0XHRcdFx0dHlwZSA9IG9wLnR5cGVfcmVzdWx0ID09PSBudWxsID8gdHlwZSA6IG9wLnR5cGVfcmVzdWx0O1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCB2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJmbG9hdF9vdmVyZmxvd1wiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggdHlwZSA9PT0gZmFsc2UgJiYgdGhyZWFkLmdldF9mbGFnKCBcImJvdW5kZWRcIiApLmlkID09PSBcInRydWVcIiAmJiAodmFsdWUgPiB0aHJlYWQuZ2V0X2ZsYWcoIFwibWF4X2ludGVnZXJcIiApLnZhbHVlIHx8IHZhbHVlIDwgdGhyZWFkLmdldF9mbGFnKCBcIm1pbl9pbnRlZ2VyXCIgKS52YWx1ZSkgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJpbnRfb3ZlcmZsb3dcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBOdW0oIHZhbHVlLCB0eXBlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBwbC5lcnJvci50eXBlKCBcImV2YWx1YWJsZVwiLCBzdHJfaW5kaWNhdG9yKG9iai5pbmRpY2F0b3IpLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBFcnJvcnNcclxuXHRcdGVycm9yOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBFeGlzdGVuY2UgZXJyb3JcclxuXHRcdFx0ZXhpc3RlbmNlOiBmdW5jdGlvbiggdHlwZSwgb2JqZWN0LCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0aWYoIHR5cGVvZiBvYmplY3QgPT09IFwic3RyaW5nXCIgKVxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gc3RyX2luZGljYXRvciggb2JqZWN0ICk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJleGlzdGVuY2VfZXJyb3JcIiwgW25ldyBUZXJtKCB0eXBlICksIG9iamVjdF0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBUeXBlIGVycm9yXHJcblx0XHRcdHR5cGU6IGZ1bmN0aW9uKCBleHBlY3RlZCwgZm91bmQsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInR5cGVfZXJyb3JcIiwgW25ldyBUZXJtKCBleHBlY3RlZCApLCBmb3VuZF0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJbnN0YW50YXRpb24gZXJyb3JcclxuXHRcdFx0aW5zdGFudGlhdGlvbjogZnVuY3Rpb24oIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcImluc3RhbnRpYXRpb25fZXJyb3JcIiApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFVuaW5zdGFudGF0aW9uIGVycm9yXHJcblx0XHRcdHVuaW5zdGFudGlhdGlvbjogZnVuY3Rpb24oIGZvdW5kLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJ1bmluc3RhbnRpYXRpb25fZXJyb3JcIiwgW25ldyBUZXJtKCBmb3VuZCApXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIERvbWFpbiBlcnJvclxyXG5cdFx0XHRkb21haW46IGZ1bmN0aW9uKCBleHBlY3RlZCwgZm91bmQsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcImRvbWFpbl9lcnJvclwiLCBbbmV3IFRlcm0oIGV4cGVjdGVkICksIGZvdW5kXSksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUmVwcmVzZW50YXRpb24gZXJyb3JcclxuXHRcdFx0cmVwcmVzZW50YXRpb246IGZ1bmN0aW9uKCBmbGFnLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJyZXByZXNlbnRhdGlvbl9lcnJvclwiLCBbbmV3IFRlcm0oIGZsYWcgKV0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBQZXJtaXNzaW9uIGVycm9yXHJcblx0XHRcdHBlcm1pc3Npb246IGZ1bmN0aW9uKCBvcGVyYXRpb24sIHR5cGUsIGZvdW5kLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJwZXJtaXNzaW9uX2Vycm9yXCIsIFtuZXcgVGVybSggb3BlcmF0aW9uICksIG5ldyBUZXJtKCB0eXBlICksIGZvdW5kXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIEV2YWx1YXRpb24gZXJyb3JcclxuXHRcdFx0ZXZhbHVhdGlvbjogZnVuY3Rpb24oIGVycm9yLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJldmFsdWF0aW9uX2Vycm9yXCIsIFtuZXcgVGVybSggZXJyb3IgKV0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTeW50YXggZXJyb3JcclxuXHRcdFx0c3ludGF4OiBmdW5jdGlvbiggdG9rZW4sIGV4cGVjdGVkLCBsYXN0ICkge1xyXG5cdFx0XHRcdHRva2VuID0gdG9rZW4gfHwge3ZhbHVlOiBcIlwiLCBsaW5lOiAwLCBjb2x1bW46IDAsIG1hdGNoZXM6IFtcIlwiXSwgc3RhcnQ6IDB9O1xyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGxhc3QgJiYgdG9rZW4ubWF0Y2hlcy5sZW5ndGggPiAwID8gdG9rZW4uc3RhcnQgKyB0b2tlbi5tYXRjaGVzWzBdLmxlbmd0aCA6IHRva2VuLnN0YXJ0O1xyXG5cdFx0XHRcdHZhciBmb3VuZCA9IGxhc3QgPyBuZXcgVGVybShcInRva2VuX25vdF9mb3VuZFwiKSA6IG5ldyBUZXJtKFwiZm91bmRcIiwgW25ldyBUZXJtKHRva2VuLnZhbHVlLnRvU3RyaW5nKCkpXSk7XHJcblx0XHRcdFx0dmFyIGluZm8gPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgVGVybSggXCJsaW5lXCIsIFtuZXcgTnVtKHRva2VuLmxpbmUrMSldICksIG5ldyBUZXJtKCBcIi5cIiwgW25ldyBUZXJtKCBcImNvbHVtblwiLCBbbmV3IE51bShwb3NpdGlvbildICksIG5ldyBUZXJtKCBcIi5cIiwgW2ZvdW5kLCBuZXcgVGVybSggXCJbXVwiLCBbXSApXSApXSApXSApO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwic3ludGF4X2Vycm9yXCIsIFtuZXcgVGVybSggZXhwZWN0ZWQgKV0gKSwgaW5mb10gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFN5bnRheCBlcnJvciBieSBwcmVkaWNhdGVcclxuXHRcdFx0c3ludGF4X2J5X3ByZWRpY2F0ZTogZnVuY3Rpb24oIGV4cGVjdGVkLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJzeW50YXhfZXJyb3JcIiwgW25ldyBUZXJtKCBleHBlY3RlZCApIF0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBXYXJuaW5nc1xyXG5cdFx0d2FybmluZzoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU2luZ2xldG9uIHZhcmlhYmxlc1xyXG5cdFx0XHRzaW5nbGV0b246IGZ1bmN0aW9uKCB2YXJpYWJsZXMsIHJ1bGUsIGxpbmUgKSB7XHJcblx0XHRcdFx0dmFyIGxpc3QgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IHZhcmlhYmxlcy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKVxyXG5cdFx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBWYXIodmFyaWFibGVzW2ldKSwgbGlzdF0gKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwid2FybmluZ1wiLCBbbmV3IFRlcm0oIFwic2luZ2xldG9uX3ZhcmlhYmxlc1wiLCBbbGlzdCwgc3RyX2luZGljYXRvcihydWxlKV0pLCBuZXcgVGVybShcIi5cIixbbmV3IFRlcm0oIFwibGluZVwiLCBbIG5ldyBOdW0oIGxpbmUsIGZhbHNlICkgXSksIG5ldyBUZXJtKFwiW11cIildKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIEZhaWxlZCBnb2FsXHJcblx0XHRcdGZhaWxlZF9nb2FsOiBmdW5jdGlvbiggZ29hbCwgbGluZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwid2FybmluZ1wiLCBbbmV3IFRlcm0oIFwiZmFpbGVkX2dvYWxcIiwgW2dvYWxdKSwgbmV3IFRlcm0oXCIuXCIsW25ldyBUZXJtKCBcImxpbmVcIiwgWyBuZXcgTnVtKCBsaW5lLCBmYWxzZSApIF0pLCBuZXcgVGVybShcIltdXCIpXSldICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBGb3JtYXQgb2YgcmVuYW1lZCB2YXJpYWJsZXNcclxuXHRcdGZvcm1hdF92YXJpYWJsZTogZnVuY3Rpb24oIGlkLCB2YXJpYWJsZSApIHtcclxuXHRcdFx0dmFyIGNoYXJjb2RlID0gdmFyaWFibGUgJiYgdmFyaWFibGUubGVuZ3RoID4gMCA/IGNvZGVQb2ludEF0KHZhcmlhYmxlLCAxKSA6IDA7XHJcblx0XHRcdGlmKHZhcmlhYmxlID09PSBcIl9cIiB8fCB2YXJpYWJsZSAmJiB2YXJpYWJsZVswXSA9PT0gXCJfXCIgJiYgKGNoYXJjb2RlID09PSA5NSB8fCBjaGFyY29kZSA+PSA2NSAmJiBjaGFyY29kZSA8PSA5MCkpXHJcblx0XHRcdFx0cmV0dXJuIFwiX19cIiArIGlkO1xyXG5cdFx0XHRyZXR1cm4gXCJfXCIgKyBpZDtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEZvcm1hdCBvZiBjb21wdXRlZCBhbnN3ZXJzXHJcblx0XHRmb3JtYXRfYW5zd2VyOiBmdW5jdGlvbiggYW5zd2VyLCB0aHJlYWQsIG9wdGlvbnMgKSB7XHJcblx0XHRcdGlmKCB0aHJlYWQgaW5zdGFuY2VvZiBTZXNzaW9uIClcclxuXHRcdFx0XHR0aHJlYWQgPSB0aHJlYWQudGhyZWFkO1xyXG5cdFx0XHR2YXIgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XHJcblx0XHRcdG9wdGlvbnMuc2Vzc2lvbiA9IHRocmVhZCA/IHRocmVhZC5zZXNzaW9uIDogdW5kZWZpbmVkO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19lcnJvciggYW5zd2VyICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwidW5jYXVnaHQgZXhjZXB0aW9uOiBcIiArIGFuc3dlci5hcmdzWzBdLnRvU3RyaW5nKG9wdGlvbnMpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGFuc3dlciA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiZmFsc2VcIjtcclxuXHRcdFx0fSBlbHNlIGlmKCBhbnN3ZXIgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0cmV0dXJuIFwibGltaXQgZXhjZWVkZWRcIjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaSA9IDA7XHJcblx0XHRcdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfc3Vic3RpdHV0aW9uKCBhbnN3ZXIgKSApIHtcclxuXHRcdFx0XHRcdHZhciBkb20gPSBhbnN3ZXIuZG9tYWluKCB0cnVlICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBsaW5rIGluIGFuc3dlci5saW5rcyApe1xyXG5cdFx0XHRcdFx0XHRpZiggIWFuc3dlci5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZShhbnN3ZXIubGlua3NbbGlua10pICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdGxpbmtzW2Fuc3dlci5saW5rc1tsaW5rXS5pZF0gPSBuZXcgVmFyKGxpbmspO1xyXG5cdFx0XHRcdFx0XHRcdGFuc3dlciA9IGFuc3dlci5hcHBseSggbmV3IFN1YnN0aXR1dGlvbihsaW5rcykgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YW5zd2VyID0gYW5zd2VyLmZpbHRlciggZnVuY3Rpb24oIGlkLCB2YWx1ZSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICFwbC50eXBlLmlzX3ZhcmlhYmxlKCB2YWx1ZSApIHx8XHJcblx0XHRcdFx0XHRcdFx0cGwudHlwZS5pc192YXJpYWJsZSggdmFsdWUgKSAmJiBhbnN3ZXIuaGFzX2F0dHJpYnV0ZXMoIGlkICkgfHxcclxuXHRcdFx0XHRcdFx0XHRpbmRleE9mKCBkb20sIHZhbHVlLmlkICkgIT09IC0xICYmIGlkICE9PSB2YWx1ZS5pZDtcclxuXHRcdFx0XHRcdH0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Zm9yKCB2YXIgbGluayBpbiBhbnN3ZXIubGlua3MgKSB7XHJcblx0XHRcdFx0XHRpZighYW5zd2VyLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhbnN3ZXIubGlua3NbbGlua10gKSAmJiBsaW5rID09PSBhbnN3ZXIubGlua3NbbGlua10uaWQgKSB7XHJcblx0XHRcdFx0XHRcdHZhciBhdHRycyA9IGFuc3dlci5hdHRyc1tsaW5rXTtcclxuXHRcdFx0XHRcdFx0Zm9yKCB2YXIgbW9kdWxlIGluIGF0dHJzICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFhdHRycy5oYXNPd25Qcm9wZXJ0eShtb2R1bGUpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBzdHIgIT09IFwiXCIgKVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9IFwiLCBcIjtcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gXCJwdXRfYXR0cihcIiArIGxpbmsgKyBcIiwgXCIgKyBtb2R1bGUgKyBcIiwgXCIgKyBhdHRyc1ttb2R1bGVdLnRvU3RyaW5nKG9wdGlvbnMpICsgXCIpXCI7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHRcdFx0aWYoIHN0ciAhPT0gXCJcIiApXHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IFwiLCBcIjtcclxuXHRcdFx0XHRcdFx0c3RyICs9IGxpbmsudG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiID0gXCIgK1xyXG5cdFx0XHRcdFx0XHRcdGFuc3dlci5saW5rc1tsaW5rXS50b1N0cmluZyggb3B0aW9ucywge3ByaW9yaXR5OiBcIjcwMFwiLCBjbGFzczogXCJ4ZnhcIiwgaW5kaWNhdG9yOiBcIj0vMlwifSwgXCJyaWdodFwiICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBpID09PSAwICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwidHJ1ZVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3RyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRmxhdHRlbiBkZWZhdWx0IGVycm9yc1xyXG5cdFx0ZmxhdHRlbl9lcnJvcjogZnVuY3Rpb24oIGVycm9yICkge1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfZXJyb3IoIGVycm9yICkgKSByZXR1cm4gbnVsbDtcclxuXHRcdFx0ZXJyb3IgPSBlcnJvci5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgb2JqID0ge307XHJcblx0XHRcdG9iai50eXBlID0gZXJyb3IuYXJnc1swXS5pZDtcclxuXHRcdFx0b2JqLnRocm93biA9IG9iai50eXBlID09PSBcInN5bnRheF9lcnJvclwiID8gbnVsbCA6IGVycm9yLmFyZ3NbMV0uaWQ7XHJcblx0XHRcdG9iai5leHBlY3RlZCA9IG51bGw7XHJcblx0XHRcdG9iai5mb3VuZCA9IG51bGw7XHJcblx0XHRcdG9iai5yZXByZXNlbnRhdGlvbiA9IG51bGw7XHJcblx0XHRcdG9iai5leGlzdGVuY2UgPSBudWxsO1xyXG5cdFx0XHRvYmouZXhpc3RlbmNlX3R5cGUgPSBudWxsO1xyXG5cdFx0XHRvYmoubGluZSA9IG51bGw7XHJcblx0XHRcdG9iai5jb2x1bW4gPSBudWxsO1xyXG5cdFx0XHRvYmoucGVybWlzc2lvbl9vcGVyYXRpb24gPSBudWxsO1xyXG5cdFx0XHRvYmoucGVybWlzc2lvbl90eXBlID0gbnVsbDtcclxuXHRcdFx0b2JqLmV2YWx1YXRpb25fdHlwZSA9IG51bGw7XHJcblx0XHRcdGlmKCBvYmoudHlwZSA9PT0gXCJ0eXBlX2Vycm9yXCIgfHwgb2JqLnR5cGUgPT09IFwiZG9tYWluX2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0b2JqLmV4cGVjdGVkID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdG9iai5mb3VuZCA9IGVycm9yLmFyZ3NbMF0uYXJnc1sxXS50b1N0cmluZygpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIG9iai50eXBlID09PSBcInN5bnRheF9lcnJvclwiICkge1xyXG5cdFx0XHRcdGlmKCBlcnJvci5hcmdzWzFdLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdG9iai5leHBlY3RlZCA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdG9iai5mb3VuZCA9IGVycm9yLmFyZ3NbMV0uYXJnc1sxXS5hcmdzWzFdLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRvYmouZm91bmQgPSBvYmouZm91bmQuaWQgPT09IFwidG9rZW5fbm90X2ZvdW5kXCIgPyBvYmouZm91bmQuaWQgOiBvYmouZm91bmQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdG9iai5saW5lID0gZXJyb3IuYXJnc1sxXS5hcmdzWzBdLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0XHRvYmouY29sdW1uID0gZXJyb3IuYXJnc1sxXS5hcmdzWzFdLmFyZ3NbMF0uYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0b2JqLnRocm93biA9IGVycm9yLmFyZ3NbMV0uaWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYoIG9iai50eXBlID09PSBcInBlcm1pc3Npb25fZXJyb3JcIiApIHtcclxuXHRcdFx0XHRvYmouZm91bmQgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMl0udG9TdHJpbmcoKTtcclxuXHRcdFx0XHRvYmoucGVybWlzc2lvbl9vcGVyYXRpb24gPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0b2JqLnBlcm1pc3Npb25fdHlwZSA9IGVycm9yLmFyZ3NbMF0uYXJnc1sxXS5pZDtcclxuXHRcdFx0fSBlbHNlIGlmKCBvYmoudHlwZSA9PT0gXCJldmFsdWF0aW9uX2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0b2JqLmV2YWx1YXRpb25fdHlwZSA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0fSBlbHNlIGlmKCBvYmoudHlwZSA9PT0gXCJyZXByZXNlbnRhdGlvbl9lcnJvclwiICkge1xyXG5cdFx0XHRcdG9iai5yZXByZXNlbnRhdGlvbiA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0fSBlbHNlIGlmKCBvYmoudHlwZSA9PT0gXCJleGlzdGVuY2VfZXJyb3JcIiApIHtcclxuXHRcdFx0XHRvYmouZXhpc3RlbmNlID0gZXJyb3IuYXJnc1swXS5hcmdzWzFdLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0b2JqLmV4aXN0ZW5jZV90eXBlID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBDcmVhdGUgbmV3IHNlc3Npb25cclxuXHRcdGNyZWF0ZTogZnVuY3Rpb24oIGxpbWl0ICkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IHBsLnR5cGUuU2Vzc2lvbiggbGltaXQgKTtcclxuXHRcdH1cclxuXHRcdFxyXG5cdH07XHJcblxyXG5cdC8vIEJ1aWx0LWluIHByZWRpY2F0ZXNcclxuXHRwbC5idWlsdGluID0gbmV3IE1vZHVsZShcInN5c3RlbVwiLCB7XHJcblxyXG5cdFx0Ly8gVEVSTSBBTkQgR09BTCBFWFBBTlNJT05cclxuXHJcblx0XHQvLyBnb2FsX2V4cGFuc2lvbi8yXHJcblx0XHRcImdvYWxfZXhwYW5zaW9uLzJcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcIixcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVmFyKFwiWF9cIiksbmV3IFZhcihcIllfXCIpXSldKSwgbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSksbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIllcIildKV0pXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiO1wiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIildKSxuZXcgVGVybShcIjtcIiwgW25ldyBWYXIoXCJYX1wiKSxuZXcgVmFyKFwiWV9cIildKV0pLCBuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSxuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWVwiKV0pXSldKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSldKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCItPlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIildKSxuZXcgVGVybShcIi0+XCIsIFtuZXcgVmFyKFwiWF9cIiksbmV3IFZhcihcIllfXCIpXSldKSwgbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSksbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIllcIildKV0pXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2F0Y2hcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJaXCIpXSksbmV3IFRlcm0oXCJjYXRjaFwiLCBbbmV3IFZhcihcIlhfXCIpLG5ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJaX1wiKV0pXSksIG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJaXCIpLG5ldyBWYXIoXCJaX1wiKV0pLG5ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIlpfXCIpLG5ldyBWYXIoXCJaXCIpXSldKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWF9cIiksbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWlwiKSxuZXcgVmFyKFwiWl9cIildKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcIlxcXFwrXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiXFxcXCtcIiwgW25ldyBWYXIoXCJYX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJub252YXJcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwib25jZVwiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcIm9uY2VcIiwgW25ldyBWYXIoXCJYX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJub252YXJcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIiksbmV3IFZhcihcIlpcIildKSxuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWlwiKV0pXSksIG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJzZXRvZlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIiksbmV3IFZhcihcIlpcIildKSxuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWlwiKV0pXSksIG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJiYWdvZlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIiksbmV3IFZhcihcIlpcIildKSxuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWlwiKV0pXSksIG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIm5vbnZhclwiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIiksbmV3IFZhcihcIkEzXCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEzXCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpLG5ldyBWYXIoXCJBM1wiKSxuZXcgVmFyKFwiQTRcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTNcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTRcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKSxuZXcgVmFyKFwiQTNcIiksbmV3IFZhcihcIkE0XCIpLG5ldyBWYXIoXCJBNVwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBM1wiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNVwiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIiksbmV3IFZhcihcIkEzXCIpLG5ldyBWYXIoXCJBNFwiKSxuZXcgVmFyKFwiQTVcIiksbmV3IFZhcihcIkE2XCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEzXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE0XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE1XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE2XCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpLG5ldyBWYXIoXCJBM1wiKSxuZXcgVmFyKFwiQTRcIiksbmV3IFZhcihcIkE1XCIpLG5ldyBWYXIoXCJBNlwiKSxuZXcgVmFyKFwiQTdcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTNcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTRcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTVcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTdcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKV0pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBTWVNURU0gUFJFRElDQVRFUyAoJClcclxuXHJcblx0XHQvLyAnJHB1c2hfZ2xvYmFsX3N0YWNrJy8yXHJcblx0XHRcIiRwdXNoX2dsb2JhbF9zdGFjay8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHN0YWNrID0gYXRvbS5hcmdzWzBdLCB2YWx1ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoc3RhY2spKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHVzaF9nbG9iYWxfc3RhY2soc3RhY2suaWQsIHZhbHVlKTtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gJyRmbHVzaF9nbG9iYWxfc3RhY2snLzNcclxuXHRcdFwiJGZsdXNoX2dsb2JhbF9zdGFjay8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHN0YWNrID0gYXRvbS5hcmdzWzBdLCBsaXN0ID0gYXRvbS5hcmdzWzFdLCB0YWlsID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShzdGFjaykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aHJlYWQuZmx1c2hfZ2xvYmFsX3N0YWNrKHN0YWNrLmlkLCB0YWlsKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbbGlzdCwgdmFsdWVzXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gJyRmcmVlX3ZhcmlhYmxlX3NldCcvM1xyXG5cdFx0XCIkZnJlZV92YXJpYWJsZV9zZXQvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBnb2FsX2luID0gYXRvbS5hcmdzWzBdLCBnb2FsX291dCA9IGF0b20uYXJnc1sxXSwgdmFycyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIGJ2ID0gW107XHJcblx0XHRcdHZhciBwb2ludGVyID0gZ29hbF9pbjtcclxuXHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIl4vMlwiKSB7XHJcblx0XHRcdFx0YnYgPSBidi5jb25jYXQocG9pbnRlci5hcmdzWzBdLnZhcmlhYmxlcygpKTtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBndiA9IHBvaW50ZXIudmFyaWFibGVzKCk7XHJcblx0XHRcdHZhciBmdiA9IGFycmF5VG9MaXN0KG1hcChkaWZmZXJlbmNlKGd2LCBidiksIGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFZhcih2KTtcclxuXHRcdFx0fSkpO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0bmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbZ29hbF9vdXQsIHBvaW50ZXJdKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFt2YXJzLCBmdl0pIFxyXG5cdFx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXHJcblx0XHRcdF0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyAnJG1lbWJlcicvMlxyXG5cdFx0XCIkbWVtYmVyLzJcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkbWVtYmVyXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJYXCIpLG5ldyBwbC50eXBlLlRlcm0oXCIuXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJYXCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKV0pLCBudWxsKSxcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJG1lbWJlclwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiWFwiKSxuZXcgcGwudHlwZS5UZXJtKFwiLlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiX1wiKSxuZXcgcGwudHlwZS5WYXIoXCJYc1wiKV0pXSksIG5ldyBwbC50eXBlLlRlcm0oXCIkbWVtYmVyXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJYXCIpLG5ldyBwbC50eXBlLlZhcihcIlhzXCIpXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vICckYmluZF9iYWdvZl9rZXlzLzInLzJcclxuXHRcdFwiJGJpbmRfYmFnb2Zfa2V5cy8yXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJGJpbmRfYmFnb2Zfa2V5c1wiLCBbbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksIG51bGwpLFxyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkYmluZF9iYWdvZl9rZXlzXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLlwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIktleVwiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiQmFnXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiVmFyc1wiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcInRlcm1fdmFyaWFibGVzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJLZXlcIiksbmV3IHBsLnR5cGUuVmFyKFwiVmFyc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIiRiaW5kX2JhZ29mX2tleXNcIiwgW25ldyBwbC50eXBlLlZhcihcIkJhZ1wiKSxuZXcgcGwudHlwZS5WYXIoXCJWYXJzXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gJyRmaW5kYWxsJy80XHJcblx0XHRcIiRmaW5kYWxsLzRcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkZmluZGFsbFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUwXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpLG5ldyBwbC50eXBlLlZhcihcIkluc3RhbmNlc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJUYWlsXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCI7XCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImNvcHlfdGVybVwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMFwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTFcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIildKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiY2FsbFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImNvcHlfdGVybVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUxXCIpLG5ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMlwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJHB1c2hfZ2xvYmFsX3N0YWNrXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJWYXJcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUyXCIpXSksbmV3IHBsLnR5cGUuVGVybShcImZhbHNlXCIsIFtdKV0pXSldKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIkZmx1c2hfZ2xvYmFsX3N0YWNrXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJWYXJcIiksbmV3IHBsLnR5cGUuVmFyKFwiSW5zdGFuY2VzXCIpLG5ldyBwbC50eXBlLlZhcihcIlRhaWxcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyAnJGJhZ29mJy8zXHJcblx0XHRcIiRiYWdvZi8zXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJGJhZ29mXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJcIildKSwgbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkZnJlZV92YXJpYWJsZV9zZXRcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJeXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKV0pLG5ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpLG5ldyBwbC50eXBlLlZhcihcIkZWXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiRlZcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIildKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRiaW5kX2JhZ29mX2tleXNcIiwgW25ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwia2V5Z3JvdXBcIiwgW25ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVmFyKFwiS2V5R3JvdXBzXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJrZXlzb3J0XCIsIFtuZXcgcGwudHlwZS5WYXIoXCJLZXlHcm91cHNcIiksbmV3IHBsLnR5cGUuVmFyKFwiS2V5U29ydGVkXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIiRtZW1iZXJcIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJGVlwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJcIildKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlTb3J0ZWRcIildKV0pXSldKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vICckc2V0b2YnLzNcclxuXHRcdFwiJHNldG9mLzNcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkc2V0b2ZcIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlclwiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRmcmVlX3ZhcmlhYmxlX3NldFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIl5cIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIiksbmV3IHBsLnR5cGUuVmFyKFwiRlZcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImZpbmRhbGxcIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJGVlwiKSxuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKV0pLG5ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJGJpbmRfYmFnb2Zfa2V5c1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJrZXlncm91cFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlHcm91cHNcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImtleXNvcnRcIiwgW25ldyBwbC50eXBlLlZhcihcIktleUdyb3Vwc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlTb3J0ZWRcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRtZW1iZXJcIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJGVlwiKSxuZXcgcGwudHlwZS5WYXIoXCJVbnNvcnRlZFwiKV0pLG5ldyBwbC50eXBlLlZhcihcIktleVNvcnRlZFwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCJzb3J0XCIsIFtuZXcgcGwudHlwZS5WYXIoXCJVbnNvcnRlZFwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJcIildKV0pXSldKV0pXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gJyRpZi8zJ1xyXG5cdFx0XCIkaWYvM1wiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRpZlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiSWZcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGhlblwiKSxuZXcgcGwudHlwZS5WYXIoXCJFbHNlXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCI7XCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImNhbGxcIiwgW25ldyBwbC50eXBlLlZhcihcIklmXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkcHVzaF9nbG9iYWxfc3RhY2tcIiwgW25ldyBwbC50eXBlLlZhcihcIlN0YWNrXCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSxuZXcgcGwudHlwZS5UZXJtKFwiY2FsbFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGhlblwiKV0pXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRmbHVzaF9nbG9iYWxfc3RhY2tcIiwgW25ldyBwbC50eXBlLlZhcihcIlN0YWNrXCIpLG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSksbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKV0pLG5ldyBwbC50eXBlLlRlcm0oXCJjYWxsXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJFbHNlXCIpXSldKV0pKVxyXG5cdFx0XSxcclxuXHJcblxyXG5cdFx0Ly8gQVRUUklCVVRFRCBWQVJJQUJMRVNcclxuXHRcdFxyXG5cdFx0Ly9wdXRfYXR0ci8zXHJcblx0XHRcInB1dF9hdHRyLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB2YXJpYWJsZSA9IGF0b20uYXJnc1swXSwgbW9kdWxlID0gYXRvbS5hcmdzWzFdLCB2YWx1ZSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKHZhcmlhYmxlKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwidmFyaWFibGVcIiwgdmFyaWFibGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKG1vZHVsZSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgbW9kdWxlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN1YnMgPSBwb2ludC5zdWJzdGl0dXRpb24uc2V0X2F0dHJpYnV0ZSggdmFyaWFibGUuaWQsIG1vZHVsZSwgdmFsdWUgKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKG51bGwpLCBzdWJzLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGdldF9hdHRyLzNcclxuXHRcdFwiZ2V0X2F0dHIvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHZhcmlhYmxlID0gYXRvbS5hcmdzWzBdLCBtb2R1bGUgPSBhdG9tLmFyZ3NbMV0sIHZhbHVlID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUodmFyaWFibGUpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJ2YXJpYWJsZVwiLCB2YXJpYWJsZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20obW9kdWxlKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBtb2R1bGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYXR0ciA9IHBvaW50LnN1YnN0aXR1dGlvbi5nZXRfYXR0cmlidXRlKCB2YXJpYWJsZS5pZCwgbW9kdWxlICk7XHJcblx0XHRcdFx0aWYoIGF0dHIgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybShcIj1cIiwgW3ZhbHVlLCBhdHRyXSkgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHRcdFxyXG5cdFx0Ly8gSU5QVVQgQU5EIE9VVFBVVFxyXG5cdFx0XHJcblx0XHQvLyBvcC8zXHJcblx0XHRcIm9wLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBwcmlvcml0eSA9IGF0b20uYXJnc1swXSwgdHlwZSA9IGF0b20uYXJnc1sxXSwgb3BlcmF0b3JzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX2F0b20ob3BlcmF0b3JzKSlcclxuXHRcdFx0XHRvcGVyYXRvcnMgPSBuZXcgVGVybShcIi5cIiwgW29wZXJhdG9ycywgbmV3IFRlcm0oXCJbXVwiKV0pO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJpb3JpdHkgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0eXBlICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggcHJpb3JpdHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIHR5cGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCB0eXBlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19lbXB0eV9saXN0KCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcGVyYXRvcnM7XHJcblx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHR2YXIgb3BlcmF0b3IgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wZXJhdG9yICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIG9wZXJhdG9yICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggcHJpb3JpdHkudmFsdWUgPCAwIHx8IHByaW9yaXR5LnZhbHVlID4gMTIwMCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3JfcHJpb3JpdHlcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCIsXCIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJtb2RpZnlcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcInt9XCIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcIltdXCIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcInxcIiAmJiBwcmlvcml0eS52YWx1ZSAhPT0gMCAmJiAocHJpb3JpdHkudmFsdWUgPCAxMDAxIHx8IHR5cGUuaWQubGVuZ3RoICE9PSAzICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIFtcImZ5XCIsIFwiZnhcIiwgXCJ5ZlwiLCBcInhmXCIsIFwieGZ4XCIsIFwieWZ4XCIsIFwieGZ5XCJdLmluZGV4T2YoIHR5cGUuaWQgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3NwZWNpZmllclwiLCB0eXBlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHZhciBmaXggPSB7IHByZWZpeDogbnVsbCwgaW5maXg6IG51bGwsIHBvc3RmaXg6IG51bGwgfTtcclxuXHRcdFx0XHRcdFx0Zm9yKCB2YXIgcCBpbiB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9ycyApIHtcclxuXHRcdFx0XHRcdFx0XHRpZighdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbGFzc2VzID0gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcF1bb3BlcmF0b3IuaWRdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBjbGFzc2VzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwiZnhcIiApICE9PSAtMSApIHsgZml4LnByZWZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwiZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJmeVwiICkgIT09IC0xICkgeyBmaXgucHJlZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJmeVwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmXCIgKSAhPT0gLTEgKSB7IGZpeC5wb3N0Zml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZlwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInlmXCIgKSAhPT0gLTEgKSB7IGZpeC5wb3N0Zml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ5ZlwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmeFwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmeVwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmeVwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInlmeFwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInlmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfY2xhc3M7XHJcblx0XHRcdFx0XHRcdHN3aXRjaCggdHlwZS5pZCApIHtcclxuXHRcdFx0XHRcdFx0XHRjYXNlIFwiZnlcIjogY2FzZSBcImZ4XCI6IGN1cnJlbnRfY2xhc3MgPSBcInByZWZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIFwieWZcIjogY2FzZSBcInhmXCI6IGN1cnJlbnRfY2xhc3MgPSBcInBvc3RmaXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY3VycmVudF9jbGFzcyA9IFwiaW5maXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoZml4LmluZml4ICYmIGN1cnJlbnRfY2xhc3MgPT09IFwicG9zdGZpeFwiIHx8IGZpeC5wb3N0Zml4ICYmIGN1cnJlbnRfY2xhc3MgPT09IFwiaW5maXhcIikge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRpZiggZml4W2N1cnJlbnRfY2xhc3NdICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmVtb3ZlKCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXSwgZml4W2N1cnJlbnRfY2xhc3NdLnR5cGUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXS5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGRlbGV0ZSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYoIHByaW9yaXR5LnZhbHVlID4gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCAhdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdICkgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWUudG9TdHJpbmcoKV0gPSB7fTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCAhdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXSApIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0ucHVzaCggdHlwZS5pZCApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShwb2ludGVyKSB8fCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjdXJyZW50X29wLzNcclxuXHRcdFwiY3VycmVudF9vcC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgcHJpb3JpdHkgPSBhdG9tLmFyZ3NbMF0sIHNwZWNpZmllciA9IGF0b20uYXJnc1sxXSwgb3BlcmF0b3IgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBwb2ludHMgPSBbXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcmlvcml0eSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIHByaW9yaXR5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIHByaW9yaXR5ICkgJiYgKCBwcmlvcml0eS52YWx1ZSA8IDAgfHwgcHJpb3JpdHkudmFsdWUgPiAxMjAwICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3JfcHJpb3JpdHlcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3BlY2lmaWVyICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3BlY2lmaWVyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgc3BlY2lmaWVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19hdG9tKCBzcGVjaWZpZXIgKSAmJiBpbmRleE9mKCBbXCJmeVwiLCBcImZ4XCIsIFwieWZcIiwgXCJ4ZlwiLCBcInhmeFwiLCBcInlmeFwiLCBcInhmeVwiXSwgc3BlY2lmaWVyLmlkICkgPT09IC0xICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3NwZWNpZmllclwiLCBzcGVjaWZpZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggb3BlcmF0b3IgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBvcGVyYXRvciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yKCB2YXIgcCBpbiB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9ycyApXHJcblx0XHRcdFx0XHRmb3IoIHZhciBvIGluIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3BdIClcclxuXHRcdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twXVtvXS5sZW5ndGg7IGkrKyApXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oIFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oIFwiPVwiLCBbbmV3IE51bSggcCwgZmFsc2UgKSwgcHJpb3JpdHldICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oIFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcF1bb11baV0sIFtdICksIHNwZWNpZmllcl0gKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBvLCBbXSApLCBvcGVyYXRvcl0gKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF0gKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRdIClcclxuXHRcdFx0XHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdCkgKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggcG9pbnRzICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHJcblxyXG5cclxuXHRcdC8vIExPR0lDIEFORCBDT05UUk9MIFNUUlVDVFVSRVNcclxuXHRcclxuXHRcdC8vIDsvMiAoZGlzanVuY3Rpb24pXHJcblx0XHRcIjsvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBsZWZ0ID0gYXRvbS5hcmdzWzBdLCByaWdodCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIGNvbnRleHRfbGVmdCA9IGxlZnQuYXJnc1swXTtcclxuXHRcdFx0dmFyIGZyZWVfbGVmdCA9IGxlZnQuaW5kaWNhdG9yID09PSBcIjovMlwiID8gbGVmdC5hcmdzWzFdIDogbGVmdDtcclxuXHRcdFx0Ly8gaWYgdGhlbiBlbHNlXHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShmcmVlX2xlZnQpICYmIGZyZWVfbGVmdC5pbmRpY2F0b3IgPT09IFwiLT4vMlwiKSB7XHJcblx0XHRcdFx0dmFyIGNvbmQgPSBsZWZ0LmluZGljYXRvciA9PT0gXCI6LzJcIiA/IG5ldyBUZXJtKFwiOlwiLCBbY29udGV4dF9sZWZ0LCBuZXcgVGVybShcImNhbGxcIiwgW2ZyZWVfbGVmdC5hcmdzWzBdXSldKSA6IGZyZWVfbGVmdC5hcmdzWzBdO1xyXG5cdFx0XHRcdHZhciB0aGVuID0gbGVmdC5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBuZXcgVGVybShcIjpcIiwgW2NvbnRleHRfbGVmdCwgZnJlZV9sZWZ0LmFyZ3NbMV1dKSA6IGZyZWVfbGVmdC5hcmdzWzFdO1xyXG5cdFx0XHRcdHZhciBvdGhlcndpc2UgPSByaWdodDtcclxuXHRcdFx0XHR2YXIgZ29hbF9mc3QgPSBwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oIFwiLFwiLCBbY29uZCwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIiFcIiksIHRoZW5dKV0gKSApO1xyXG5cdFx0XHRcdHZhciBnb2FsX3NuZCA9IHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybShcIiFcIiksIG90aGVyd2lzZV0pKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUoZ29hbF9mc3QsIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpLFxyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKGdvYWxfc25kLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KVxyXG5cdFx0XHRcdF0pO1xyXG5cdFx0XHQvLyBzb2Z0LWN1dFxyXG5cdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc190ZXJtKGZyZWVfbGVmdCkgJiYgZnJlZV9sZWZ0LmluZGljYXRvciA9PT0gXCIqLT4vMlwiKSB7XHJcblx0XHRcdFx0dmFyIGNvbmQgPSBsZWZ0LmluZGljYXRvciA9PT0gXCI6LzJcIiA/IG5ldyBUZXJtKFwiOlwiLCBbY29udGV4dF9sZWZ0LCBmcmVlX2xlZnQuYXJnc1swXV0pIDogZnJlZV9sZWZ0LmFyZ3NbMF07XHJcblx0XHRcdFx0dmFyIHRoZW4gPSBsZWZ0LmluZGljYXRvciA9PT0gXCI6LzJcIiA/IG5ldyBUZXJtKFwiOlwiLCBbY29udGV4dF9sZWZ0LCBmcmVlX2xlZnQuYXJnc1sxXV0pIDogZnJlZV9sZWZ0LmFyZ3NbMV07XHJcblx0XHRcdFx0dmFyIG90aGVyd2lzZSA9IHJpZ2h0O1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIkaWZcIiwgW2NvbmQsIHRoZW4sIG90aGVyd2lzZV0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHQvLyBvdGhlcndpc2VcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKGxlZnQpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSxcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UocmlnaHQpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KVxyXG5cdFx0XHRcdF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyAhLzAgKGN1dClcclxuXHRcdFwiIS8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgcGFyZW50X2N1dCwgbGFzdF9jdXQsIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRwYXJlbnRfY3V0ID0gcG9pbnQ7XHJcblx0XHRcdGxhc3RfY3V0ID0gbnVsbDtcclxuXHRcdFx0d2hpbGUoIHBhcmVudF9jdXQucGFyZW50ICE9PSBudWxsICYmIHBhcmVudF9jdXQucGFyZW50LmdvYWwuc2VhcmNoKCBhdG9tICkgKSB7XHJcblx0XHRcdFx0bGFzdF9jdXQgPSBwYXJlbnRfY3V0O1xyXG5cdFx0XHRcdHBhcmVudF9jdXQgPSBwYXJlbnRfY3V0LnBhcmVudDtcclxuXHRcdFx0XHRpZihwYXJlbnRfY3V0LmdvYWwgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHZhciBzZWxlY3RlZCA9IHBhcmVudF9jdXQuZ29hbC5zZWxlY3QoKTtcclxuXHRcdFx0XHRcdGlmKHNlbGVjdGVkICYmIHNlbGVjdGVkLmluZGljYXRvciA9PT0gXCI6LzJcIilcclxuXHRcdFx0XHRcdFx0c2VsZWN0ZWQgPSBzZWxlY3RlZC5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0aWYoIHNlbGVjdGVkICYmIHNlbGVjdGVkLmlkID09PSBcImNhbGxcIiAmJiBzZWxlY3RlZC5zZWFyY2goYXRvbSkgKSB7XHJcblx0XHRcdFx0XHRcdHBhcmVudF9jdXQgPSBsYXN0X2N1dDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBzZXR1cF9jYWxsX2NsZWFudXAgPSBudWxsO1xyXG5cdFx0XHRmb3IoIHZhciBpID0gdGhyZWFkLnBvaW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0dmFyIHN0YXRlID0gdGhyZWFkLnBvaW50c1tpXTtcclxuXHRcdFx0XHR2YXIgbm9kZSA9IHN0YXRlLnBhcmVudDtcclxuXHRcdFx0XHR3aGlsZSggbm9kZSAhPT0gbnVsbCAmJiBub2RlICE9PSBwYXJlbnRfY3V0LnBhcmVudCApIHtcclxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLnBhcmVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIG5vZGUgPT09IG51bGwgJiYgbm9kZSAhPT0gcGFyZW50X2N1dC5wYXJlbnQgKVxyXG5cdFx0XHRcdFx0c3RhdGVzLnB1c2goIHN0YXRlICk7XHJcblx0XHRcdFx0ZWxzZSBpZihzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfZ29hbClcclxuXHRcdFx0XHRcdHNldHVwX2NhbGxfY2xlYW51cCA9IHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF9nb2FsXHJcblx0XHRcdH1cclxuXHRcdFx0dGhyZWFkLnBvaW50cyA9IHN0YXRlcy5yZXZlcnNlKCk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKHNldHVwX2NhbGxfY2xlYW51cCksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFxcKyAobmVnYXRpb24pXHJcblx0XHRcIlxcXFwrLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBnb2FsID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZ29hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NhbGxhYmxlKCBnb2FsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNhbGxhYmxlXCIsIGdvYWwsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBUUkFOU1BBUkVOVCBWRVJTSU9OIE9GIFRIRSBORUdBVElPTlxyXG5cdFx0XHRcdC8qdmFyIG5lZ190aHJlYWQ7XHJcblx0XHRcdFx0aWYocG9pbnQubmVnYXRpb25fdGhyZWFkKSB7XHJcblx0XHRcdFx0XHRuZWdfdGhyZWFkID0gcG9pbnQubmVnYXRpb25fdGhyZWFkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRuZWdfdGhyZWFkID0gbmV3IFRocmVhZCggdGhyZWFkLnNlc3Npb24gKTtcclxuXHRcdFx0XHRcdG5lZ190aHJlYWQuYWRkX2dvYWwoIGdvYWwgKTtcclxuXHRcdFx0XHRcdHBvaW50Lm5lZ2F0aW9uX3RocmVhZCA9IG5lZ190aHJlYWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5lZ190aHJlYWQuYW5zd2VyKCBmdW5jdGlvbiggYW5zd2VyICkge1xyXG5cdFx0XHRcdFx0aWYoYW5zd2VyID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX2Vycm9yKCBhbnN3ZXIgKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGFuc3dlci5hcmdzWzBdICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoYW5zd2VyID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbcG9pbnRdICk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5jdXJyZW50X2xpbWl0ID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5hZ2FpbiggYW5zd2VyICE9PSBudWxsICk7XHJcblx0XHRcdFx0fSApO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlOyovXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gJ1xcKycoWCkgOi0gY2FsbChYKSwgISwgZmFpbC5cclxuXHRcdFx0XHQvLyAnXFwrJyhfKS5cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW1xyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcIixcIiwgWyBuZXcgVGVybSggXCJjYWxsXCIsIFtnb2FsXSApLCBuZXcgVGVybSggXCIhXCIsIFtdICkgXSApLCBuZXcgVGVybSggXCJmYWlsXCIsIFtdICkgXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSxcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBudWxsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKVxyXG5cdFx0XHRcdF0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gLT4vMiAoaW1wbGljYXRpb24pXHJcblx0XHRcIi0+LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjb25kID0gYXRvbS5hcmdzWzBdLCB0aGVuID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgZ29hbCA9IHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdG5ldyBUZXJtKFwiY2FsbFwiLCBbY29uZF0pLFxyXG5cdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCIhXCIpLCB0aGVuXSlcclxuXHRcdFx0XSkpO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggZ29hbCwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyAqLT4vMiAoc29mdC1jdXQpXHJcblx0XHRcIiotPi8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNvbmQgPSBhdG9tLmFyZ3NbMF0sIHRoZW4gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBnb2FsID0gcG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsXCIsIFtjb25kXSksIHRoZW5dKSk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoZ29hbCwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCldKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGZhaWwvMFxyXG5cdFx0XCJmYWlsLzBcIjogZnVuY3Rpb24oIF8xLCBfMiwgXzMgKSB7fSxcclxuXHRcdFxyXG5cdFx0Ly8gZmFsc2UvMFxyXG5cdFx0XCJmYWxzZS8wXCI6IGZ1bmN0aW9uKCBfMSwgXzIsIF8zICkge30sXHJcblx0XHRcclxuXHRcdC8vIHRydWUvMFxyXG5cdFx0XCJ0cnVlLzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIF8gKSB7XHJcblx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY2FsbC8xLi44XHJcblx0XHRcImNhbGwvMVwiOiBjYWxsTigxKSxcclxuXHRcdFwiY2FsbC8yXCI6IGNhbGxOKDIpLFxyXG5cdFx0XCJjYWxsLzNcIjogY2FsbE4oMyksXHJcblx0XHRcImNhbGwvNFwiOiBjYWxsTig0KSxcclxuXHRcdFwiY2FsbC81XCI6IGNhbGxOKDUpLFxyXG5cdFx0XCJjYWxsLzZcIjogY2FsbE4oNiksXHJcblx0XHRcImNhbGwvN1wiOiBjYWxsTig3KSxcclxuXHRcdFwiY2FsbC84XCI6IGNhbGxOKDgpLFxyXG5cdFx0XHJcblx0XHQvLyBvbmNlLzFcclxuXHRcdFwib25jZS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ29hbCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiY2FsbFwiLCBbZ29hbF0gKSwgbmV3IFRlcm0oIFwiIVwiLCBbXSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGZvcmFsbC8yXHJcblx0XHRcImZvcmFsbC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ2VuZXJhdGUgPSBhdG9tLmFyZ3NbMF0sIHRlc3QgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIlxcXFwrXCIsIFtuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCJjYWxsXCIsIFtnZW5lcmF0ZV0gKSwgbmV3IFRlcm0oIFwiXFxcXCtcIiwgW25ldyBUZXJtKCBcImNhbGxcIiwgW3Rlc3RdICldICldICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gcmVwZWF0LzBcclxuXHRcdFwicmVwZWF0LzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIF8gKSB7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG51bGwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApLCBwb2ludF0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gRVhDRVBUSU9OU1xyXG5cdFx0XHJcblx0XHQvLyB0aHJvdy8xXHJcblx0XHRcInRocm93LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBlcnJvciA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShlcnJvcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbih0aHJlYWQubGV2ZWwuaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRocmVhZC5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZSA9IHRocmVhZC5wb2ludHNbaV07XHJcblx0XHRcdFx0XHRpZihzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfY2F0Y2gpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnBvaW50cyA9IFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiY2F0Y2hcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfY2F0Y2gsXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBWYXIoXCJfXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInRocm93XCIsIFtlcnJvcl0pXHJcblx0XHRcdFx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidGhyb3dcIiwgW2Vycm9yXSlcclxuXHRcdFx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0KV07XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoZXJyb3IpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjYXRjaC8zXHJcblx0XHRcImNhdGNoLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgZ29hbCA9IGF0b20uYXJnc1swXSwgY2F0Y2hlciA9IGF0b20uYXJnc1sxXSwgcmVjb3ZlciA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIG50aHJlYWQ7XHJcblx0XHRcdGlmKCFwb2ludC5jYXRjaCkge1xyXG5cdFx0XHRcdG50aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdFx0XHRudGhyZWFkLmRlYnVnZ2VyID0gdGhyZWFkLmRlYnVnZ2VyO1xyXG5cdFx0XHRcdG50aHJlYWQuZm9ybWF0X3N1Y2Nlc3MgPSBmdW5jdGlvbihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc3Vic3RpdHV0aW9uOyB9O1xyXG5cdFx0XHRcdG50aHJlYWQuZm9ybWF0X2Vycm9yID0gZnVuY3Rpb24oc3RhdGUpIHsgcmV0dXJuIHN0YXRlLmdvYWw7IH07XHJcblx0XHRcdFx0bnRocmVhZC5hZGRfZ29hbChnb2FsLCB0cnVlLCBwb2ludCk7XHJcblx0XHRcdFx0cG9pbnQuY2F0Y2ggPSBudGhyZWFkO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG50aHJlYWQgPSBwb2ludC5jYXRjaDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikpIHtcclxuXHRcdFx0XHRcdHZhciBvY2N1cnNfY2hlY2sgPSB0aHJlYWQuZ2V0X2ZsYWcoXCJvY2N1cnNfY2hlY2tcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiO1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcblx0XHRcdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkoYW5zd2VyLmFyZ3NbMF0sIGNhdGNoZXIsIG9jY3Vyc19jaGVjayk7XHJcblx0XHRcdFx0XHRpZihtZ3UgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uID0gcG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KG1ndSk7XHJcblx0XHRcdFx0XHRcdHN0YXRlLmdvYWwgPSBwb2ludC5nb2FsLnJlcGxhY2UocmVjb3ZlcikuYXBwbHkobWd1KTtcclxuXHRcdFx0XHRcdFx0c3RhdGUucGFyZW50ID0gcG9pbnQ7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKGFuc3dlci5hcmdzWzBdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoYW5zd2VyICE9PSBmYWxzZSAmJiBhbnN3ZXIgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZSA9IGFuc3dlciA9PT0gbnVsbCA/IFtdIDogbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLmFwcGx5KGFuc3dlcikucmVwbGFjZShudWxsKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KGFuc3dlciksXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlLCBwb2ludF0pO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihhbnN3ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtwb2ludF0pO1xyXG5cdFx0XHRcdFx0aWYodGhyZWFkLmhhc19saW1pdClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmN1cnJlbnRfbGltaXQgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQuYWdhaW4oYW5zd2VyICE9PSBudWxsKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0bnRocmVhZC5hbnN3ZXIoY2FsbGJhY2spO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY2FsbF9jbGVhbnVwLzJcclxuXHRcdFwiY2FsbF9jbGVhbnVwLzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY2FsbCA9IGF0b20uYXJnc1swXSwgY2xlYW51cCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShjYWxsKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKGNsZWFudXApKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNhbGwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjYWxsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xlYW51cCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsZWFudXAsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIG50aHJlYWQsIGNhbGxiYWNrO1xyXG5cdFx0XHRcdGlmKHBvaW50Lmhhc093blByb3BlcnR5KFwic2V0dXBfY2FsbF9jbGVhbnVwX3RocmVhZFwiKSkge1xyXG5cdFx0XHRcdFx0bnRocmVhZCA9IHBvaW50LnNldHVwX2NhbGxfY2xlYW51cF90aHJlYWQ7XHJcblx0XHRcdFx0XHRjYWxsYmFjayA9IHBvaW50LnNldHVwX2NhbGxfY2xlYW51cF9jYWxsYmFjaztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybShcImNhbGxcIiwgW2NhbGxdKTtcclxuXHRcdFx0XHRcdG50aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdFx0XHRcdG50aHJlYWQuYWRkX2dvYWwoZ29hbCwgdHJ1ZSwgcG9pbnQpO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0XHRcdFx0aWYoYW5zd2VyID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbCxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfdGhyZWFkID0gbnRocmVhZDtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGVdKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKGFuc3dlciA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY2xlYW51cF9hbmRfZmFpbCA9IG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImNhbGxcIiwgW2NsZWFudXBdKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiZmFpbFwiKVxyXG5cdFx0XHRcdFx0XHRcdF0pO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShjbGVhbnVwX2FuZF9mYWlsKSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGVdKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbGVhbnVwX2FuZF90aHJvdyA9IG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImNhbGxcIiwgW2NsZWFudXBdKSxcclxuXHRcdFx0XHRcdFx0XHRcdGFuc3dlclxyXG5cdFx0XHRcdFx0XHRcdF0pO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShjbGVhbnVwX2FuZF90aHJvdyksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0aWYobnRocmVhZC5wb2ludHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImNhbGxcIiwgW2NsZWFudXBdKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHQpLmFwcGx5KGFuc3dlciksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseShhbnN3ZXIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUxID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLmFwcGx5KGFuc3dlcikucmVwbGFjZShudWxsKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KGFuc3dlciksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlMiA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlMi5zZXR1cF9jYWxsX2NsZWFudXBfdGhyZWFkID0gbnRocmVhZDtcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlMi5zZXR1cF9jYWxsX2NsZWFudXBfY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlMi5zZXR1cF9jYWxsX2NsZWFudXBfZ29hbCA9IGNsZWFudXAuYXBwbHkoYW5zd2VyKTtcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlMi5zZXR1cF9jYWxsX2NsZWFudXBfY2F0Y2ggPSBjbGVhbnVwO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlMSwgc3RhdGUyXSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRocmVhZC5hZ2FpbigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRudGhyZWFkLmFuc3dlcihjYWxsYmFjayk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc2V0dXBfY2FsbF9jbGVhbnVwLzNcclxuXHRcdFwic2V0dXBfY2FsbF9jbGVhbnVwLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgc2V0dXAgPSBhdG9tLmFyZ3NbMF0sIGNhbGwgPSBhdG9tLmFyZ3NbMV0sIGNsZWFudXAgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoc2V0dXApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoY2FsbCkgfHwgcGwudHlwZS5pc192YXJpYWJsZShjbGVhbnVwKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShzZXR1cCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIHNldHVwLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2FsbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNhbGwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbGVhbnVwKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xlYW51cCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwib25jZVwiLCBbc2V0dXBdKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsX2NsZWFudXBcIiwgW2NhbGwsIGNsZWFudXBdKVxyXG5cdFx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFVOSUZJQ0FUSU9OXHJcblx0XHRcclxuXHRcdC8vID0vMiAodW5pZmljYXRpb24pXHJcblx0XHRcIj0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9jY3Vyc19jaGVjayA9IHRocmVhZC5nZXRfZmxhZyggXCJvY2N1cnNfY2hlY2tcIiApLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIjtcclxuXHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcblx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0sIG9jY3Vyc19jaGVjayApO1xyXG5cdFx0XHRpZiggbWd1ICE9PSBudWxsICkge1xyXG5cdFx0XHRcdHN0YXRlLmdvYWwgPSBwb2ludC5nb2FsLmFwcGx5KCBtZ3UgKS5yZXBsYWNlKCBudWxsICk7XHJcblx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uID0gcG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KCBtZ3UgKTtcclxuXHRcdFx0XHRzdGF0ZS5wYXJlbnQgPSBwb2ludDtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW3N0YXRlXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyB1bmlmeV93aXRoX29jY3Vyc19jaGVjay8yXHJcblx0XHRcInVuaWZ5X3dpdGhfb2NjdXJzX2NoZWNrLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xyXG5cdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdLCB0cnVlICk7XHJcblx0XHRcdGlmKCBtZ3UgIT09IG51bGwgKSB7XHJcblx0XHRcdFx0c3RhdGUuZ29hbCA9IHBvaW50LmdvYWwuYXBwbHkoIG1ndSApLnJlcGxhY2UoIG51bGwgKTtcclxuXHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24gPSBwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoIG1ndSApO1xyXG5cdFx0XHRcdHN0YXRlLnBhcmVudCA9IHBvaW50O1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbc3RhdGVdICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFxcPS8yXHJcblx0XHRcIlxcXFw9LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvY2N1cnNfY2hlY2sgPSB0aHJlYWQuZ2V0X2ZsYWcoIFwib2NjdXJzX2NoZWNrXCIgKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCI7XHJcblx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0sIG9jY3Vyc19jaGVjayApO1xyXG5cdFx0XHRpZiggbWd1ID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBzdWJzdW1lc190ZXJtLzJcclxuXHRcdC8qXHJcblx0XHRzdWJzdW1lc190ZXJtKEdlbmVyYWwsIFNwZWNpZmljKSA6LVxyXG5cdFx0XHRcXCsgXFwrIChcclxuXHRcdFx0dGVybV92YXJpYWJsZXMoU3BlY2lmaWMsIFZhcnMxKSxcclxuXHRcdFx0dW5pZnlfd2l0aF9vY2N1cnNfY2hlY2soR2VuZXJhbCwgU3BlY2lmaWMpLFxyXG5cdFx0XHR0ZXJtX3ZhcmlhYmxlcyhWYXJzMSwgVmFyczIpLFxyXG5cdFx0XHRWYXJzMSA9PSBWYXJzMlxyXG5cdFx0KS5cclxuXHRcdCovXHJcblx0XHRcInN1YnN1bWVzX3Rlcm0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdlbmVyYWwgPSBhdG9tLmFyZ3NbMF0sIHNwZWNpZmljID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgdmFyczEgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHZhciB2YXJzMiA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJcXFxcK1wiLCBbXHJcblx0XHRcdFx0XHRuZXcgVGVybShcIlxcXFwrXCIsIFtcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInRlcm1fdmFyaWFibGVzXCIsIFtzcGVjaWZpYywgdmFyczFdKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ1bmlmeV93aXRoX29jY3Vyc19jaGVja1wiLCBbZ2VuZXJhbCwgc3BlY2lmaWNdKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidGVybV92YXJpYWJsZXNcIiwgW3ZhcnMxLCB2YXJzMl0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj09XCIsIFt2YXJzMSwgdmFyczJdKVxyXG5cdFx0XHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRdKSksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEFMTCBTT0xVVElPTlNcclxuXHJcblx0XHQvLyBmaW5kYWxsLzNcclxuXHRcdFwiZmluZGFsbC8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlbXBsYXRlID0gYXRvbS5hcmdzWzBdLCBnb2FsID0gYXRvbS5hcmdzWzFdLCBpbnN0YW5jZXMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciB0YWlsID0gbmV3IFRlcm0oXCJbXVwiLCBbXSk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbdGVtcGxhdGUsIGdvYWwsIGluc3RhbmNlcywgdGFpbF0pKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBmaW5kYWxsLzRcclxuXHRcdFwiZmluZGFsbC80XCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlbXBsYXRlID0gYXRvbS5hcmdzWzBdLCBnb2FsID0gYXRvbS5hcmdzWzFdLCBpbnN0YW5jZXMgPSBhdG9tLmFyZ3NbMl0sIHRhaWwgPSBhdG9tLmFyZ3NbM107XHJcblx0XHRcdHZhciBwcm9wZXJfZ29hbCA9IGdvYWw7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShnb2FsKSAmJiBnb2FsLmluZGljYXRvciA9PT0gXCI6LzJcIilcclxuXHRcdFx0XHRwcm9wZXJfZ29hbCA9IGdvYWwuYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJfZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUocHJvcGVyX2dvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBnb2FsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5zdGFuY2VzKSAmJiAhcGwudHlwZS5pc19saXN0KGluc3RhbmNlcykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImxpc3RcIiwgaW5zdGFuY2VzLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUodGFpbCkgJiYgIXBsLnR5cGUuaXNfbGlzdCh0YWlsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibGlzdFwiLCB0YWlsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIkZmluZGFsbFwiLCBbdGVtcGxhdGUsIGdvYWwsIGluc3RhbmNlcywgdGFpbF0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBiYWdvZi8zXHJcblx0XHRcImJhZ29mLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBhdG9tLmFyZ3NbMF0sIGdvYWwgPSBhdG9tLmFyZ3NbMV0sIGluc3RhbmNlcyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShnb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShnb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgZ29hbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluc3RhbmNlcykgJiYgIXBsLnR5cGUuaXNfbGlzdChpbnN0YW5jZXMpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKFwibGlzdFwiLCBpbnN0YW5jZXMsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIiRiYWdvZlwiLCBbdGVtcGxhdGUsIGdvYWwsIGluc3RhbmNlc10pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNldG9mLzNcclxuXHRcdFwic2V0b2YvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZW1wbGF0ZSA9IGF0b20uYXJnc1swXSwgZ29hbCA9IGF0b20uYXJnc1sxXSwgaW5zdGFuY2VzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGdvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGdvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBnb2FsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5zdGFuY2VzKSAmJiAhcGwudHlwZS5pc19saXN0KGluc3RhbmNlcykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGluc3RhbmNlcywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiJHNldG9mXCIsIFt0ZW1wbGF0ZSwgZ29hbCwgaW5zdGFuY2VzXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFRFUk0gQ1JFQVRJT04gQU5EIERFQ09NUE9TSVRJT05cclxuXHRcdFxyXG5cdFx0Ly8gZnVuY3Rvci8zXHJcblx0XHRcImZ1bmN0b3IvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN1YnM7XHJcblx0XHRcdHZhciB0ZXJtID0gYXRvbS5hcmdzWzBdLCBuYW1lID0gYXRvbS5hcmdzWzFdLCBhcml0eSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHRlcm0gKSAmJiAocGwudHlwZS5pc192YXJpYWJsZSggbmFtZSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGFyaXR5ICkpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhcml0eSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGFyaXR5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYXRvbS5hcmdzWzJdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG5hbWUgKSAmJiAhcGwudHlwZS5pc19hdG9taWMoIG5hbWUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHRlcm0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBuYW1lICkgJiYgcGwudHlwZS5pc19pbnRlZ2VyKCBhcml0eSApICYmIGFyaXR5LnZhbHVlID4gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0ZXJtICkgJiYgcGwudHlwZS5pc19pbnRlZ2VyKCBhcml0eSApICYmIGFyaXR5LnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgYXRvbS5hcmdzWzJdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggdGVybSApICkge1xyXG5cdFx0XHRcdGlmKCBhdG9tLmFyZ3NbMl0udmFsdWUgPj0gMCApIHtcclxuXHRcdFx0XHRcdHZhciBhcmdzID0gW107XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGFyaXR5LnZhbHVlOyBpKysgKVxyXG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goIHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKSApO1xyXG5cdFx0XHRcdFx0dmFyIGZ1bmN0b3IgPSBwbC50eXBlLmlzX251bWJlciggbmFtZSApID8gbmFtZSA6IG5ldyBUZXJtKCBuYW1lLmlkLCBhcmdzICk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFt0ZXJtLCBmdW5jdG9yXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGlkID0gcGwudHlwZS5pc19udW1iZXIoIHRlcm0gKSA/IHRlcm0gOiBuZXcgVGVybSggdGVybS5pZCwgW10gKTtcclxuXHRcdFx0XHR2YXIgbGVuZ3RoID0gcGwudHlwZS5pc19udW1iZXIoIHRlcm0gKSA/IG5ldyBOdW0oIDAsIGZhbHNlICkgOiBuZXcgTnVtKCB0ZXJtLmFyZ3MubGVuZ3RoLCBmYWxzZSApO1xyXG5cdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiPVwiLCBbaWQsIG5hbWVdICksIG5ldyBUZXJtKCBcIj1cIiwgW2xlbmd0aCwgYXJpdHldICldICk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGFyZy8zXHJcblx0XHRcImFyZy8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYXRvbS5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggYXRvbS5hcmdzWzBdLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgYXRvbS5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY29tcG91bmQoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjb21wb3VuZFwiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgbiA9IGF0b20uYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHRpZiggbiA+IDAgJiYgbiA8PSBhdG9tLmFyZ3NbMV0uYXJncy5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKCBcIj1cIiwgW2F0b20uYXJnc1sxXS5hcmdzW24tMV0sIGF0b20uYXJnc1syXV0gKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPS4uLzIgKHVuaXYpXHJcblx0XHRcIj0uLi8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdDtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMV0gKVxyXG5cdFx0XHR8fCBwbC50eXBlLmlzX25vbl9lbXB0eV9saXN0KCBhdG9tLmFyZ3NbMV0gKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMV0uYXJnc1swXSApKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19mdWxseV9saXN0KCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSAmJiBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vbl9lbXB0eV9saXN0XCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBhdG9tLmFyZ3NbMF0gKSAmJiBhdG9tLmFyZ3NbMF0uYXJncy5sZW5ndGggPiAwICkge1xyXG5cdFx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBhdG9tLmFyZ3NbMF0uYXJncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW2F0b20uYXJnc1swXS5hcmdzW2ldLCBsaXN0XSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBUZXJtKCBhdG9tLmFyZ3NbMF0uaWQgKSwgbGlzdF0gKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW2F0b20uYXJnc1swXSwgbmV3IFRlcm0oIFwiW11cIiApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsaXN0LCBhdG9tLmFyZ3NbMV1dICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0XHRcdGxpc3QgPSBhdG9tLmFyZ3NbMV0uYXJnc1sxXTtcclxuXHRcdFx0XHR3aGlsZSggbGlzdC5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRhcmdzLnB1c2goIGxpc3QuYXJnc1swXSApO1xyXG5cdFx0XHRcdFx0bGlzdCA9IGxpc3QuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDAgJiYgcGwudHlwZS5pc19jb21wb3VuZCggYXRvbS5hcmdzWzFdLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgYXRvbS5hcmdzWzFdLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIGFyZ3MubGVuZ3RoID4gMCAmJiAocGwudHlwZS5pc19jb21wb3VuZCggYXRvbS5hcmdzWzFdLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX251bWJlciggYXRvbS5hcmdzWzFdLmFyZ3NbMF0gKSkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tLmFyZ3NbMV0uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiggYXJncy5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2F0b20uYXJnc1sxXS5hcmdzWzBdLCBhdG9tLmFyZ3NbMF1dLCBwb2ludCApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBhdG9tLmFyZ3NbMV0uYXJnc1swXS5pZCwgYXJncyApLCBhdG9tLmFyZ3NbMF1dICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY29weV90ZXJtLzJcclxuXHRcdFwiY29weV90ZXJtLzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgb3JpZ2luYWxfdGVybSA9IGF0b20uYXJnc1swXSwgcmVuYW1lZF90ZXJtID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHR2YXIgbmV3X3Rlcm0gPSBvcmlnaW5hbF90ZXJtLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0bmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbcmVuYW1lZF90ZXJtLCBuZXdfdGVybV0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50KVxyXG5cdFx0XHRcdF1cclxuXHRcdFx0KTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHRlcm1fdmFyaWFibGVzLzJcclxuXHRcdFwidGVybV92YXJpYWJsZXMvMlwiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcInRlcm1fdmFyaWFibGVzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZXJtXCIpLG5ldyBwbC50eXBlLlZhcihcIlZhcnNcIildKSwgbmV3IHBsLnR5cGUuVGVybShcInRlcm1fdmFyaWFibGVzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZXJtXCIpLG5ldyBwbC50eXBlLlZhcihcIlZhcnNcIiksbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyB0ZXJtX3ZhcmlhYmxlcy8zXHJcblx0XHRcInRlcm1fdmFyaWFibGVzLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVybSA9IGF0b20uYXJnc1swXSwgdmFycyA9IGF0b20uYXJnc1sxXSwgdGFpbCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX2Z1bGx5X2xpc3QoIHZhcnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCB2YXJzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGxpc3QgPSBhcnJheVRvTGlzdChtYXAobnViKHRlcm0udmFyaWFibGVzKCkpLCBmdW5jdGlvbih2KSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFZhcih2KTtcclxuXHRcdFx0XHR9KSwgdGFpbCk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW3ZhcnMsIGxpc3RdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBudW1iZXJ2YXJzLzNcclxuXHRcdFwibnVtYmVydmFycy8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlcm0gPSBhdG9tLmFyZ3NbMF0sIHN0YXJ0ID0gYXRvbS5hcmdzWzFdLCBlbmQgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoc3RhcnQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2ludGVnZXIoc3RhcnQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIHN0YXJ0LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoZW5kKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKGVuZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgZW5kLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciB2YXJpYWJsZXMgPSBudWIodGVybS52YXJpYWJsZXMoKSk7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gc3RhcnQudmFsdWU7XHJcblx0XHRcdFx0dmFyIHVuaWZfYm9keSA9IG5ldyBUZXJtKFwidHJ1ZVwiKTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR1bmlmX2JvZHkgPSBuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBWYXIodmFyaWFibGVzW2ldKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIiRWQVJcIiwgW25ldyBOdW0odmFsdWUsIGZhbHNlKV0pXSksXHJcblx0XHRcdFx0XHRcdFx0dW5pZl9ib2R5XSk7XHJcblx0XHRcdFx0XHR2YWx1ZSsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgdW5pZl9lbmQgPSBuZXcgVGVybShcIj1cIiwgW2VuZCwgbmV3IE51bSh2YWx1ZSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShlbmQpIHx8IGVuZC52YWx1ZSA9PT0gdmFsdWUpIHtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW3VuaWZfYm9keSwgdW5pZl9lbmRdKSksXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCldKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIENMQVVTRSBSRVRSSUVWQUwgQU5EIElORk9STUFUSU9OXHJcblx0XHRcclxuXHRcdC8vIGNsYXVzZS8yXHJcblx0XHRcImNsYXVzZS8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGhlYWQgPSBhdG9tLmFyZ3NbMF0sIGJvZHkgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGhlYWQpICYmIGhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShoZWFkLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBoZWFkLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IGhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRoZWFkID0gaGVhZC5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoYm9keSkgJiYgIXBsLnR5cGUuaXNfY2FsbGFibGUoYm9keSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGJvZHksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZihoZWFkLmluZGljYXRvciA9PT0gXCIsLzJcIiB8fCB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcImFjY2Vzc1wiLCBcInByaXZhdGVfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkgJiYgZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0pIHtcclxuXHRcdFx0XHRpZihnZXRfbW9kdWxlLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0XHRpZih0eXBlb2YgZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgcnVsZSA9IGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdW2ldO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHRydWxlID0gcnVsZS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0XHRcdFx0aWYocnVsZS5ib2R5ID09PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRcdHJ1bGUuYm9keSA9IG5ldyBUZXJtKFwidHJ1ZVwiKTtcclxuXHRcdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcnVsZS5oZWFkLCBoZWFkXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtydWxlLmJvZHksIGJvZHldKVxyXG5cdFx0XHRcdFx0XHRdKTtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShnb2FsKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJhY2Nlc3NcIiwgXCJwcml2YXRlX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGN1cnJlbnRfcHJlZGljYXRlLzFcclxuXHRcdFwiY3VycmVudF9wcmVkaWNhdGUvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBpbmRpY2F0b3IgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQ7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShpbmRpY2F0b3IpICYmIGluZGljYXRvci5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKGluZGljYXRvci5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgaW5kaWNhdG9yLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IGluZGljYXRvci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGluZGljYXRvciA9IGluZGljYXRvci5hcmdzWzFdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IFwidXNlclwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvcikgJiYgKCFwbC50eXBlLmlzX2NvbXBvdW5kKGluZGljYXRvcikgfHwgaW5kaWNhdG9yLmluZGljYXRvciAhPT0gXCIvLzJcIikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZSggXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIGluZGljYXRvciwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IgKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IuYXJnc1swXSkgJiYgIXBsLnR5cGUuaXNfYXRvbShpbmRpY2F0b3IuYXJnc1swXSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGluZGljYXRvci5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IuYXJnc1sxXSkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlcihpbmRpY2F0b3IuYXJnc1sxXSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgaW5kaWNhdG9yLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IpICYmIHBsLnR5cGUuaXNfaW50ZWdlcihpbmRpY2F0b3IuYXJnc1sxXSkgJiYgaW5kaWNhdG9yLmFyZ3NbMV0udmFsdWUgPCAwKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmRvbWFpbihcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBpbmRpY2F0b3IuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRcdGZvcih2YXIgcHJvcCBpbiBnZXRfbW9kdWxlLnJ1bGVzKSB7XHJcblx0XHRcdFx0XHRcdGlmKCFnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR2YXIgcHJlZGljYXRlID0gc3RyX2luZGljYXRvcihwcm9wKTtcclxuXHRcdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybShcIj1cIiwgW3ByZWRpY2F0ZSwgaW5kaWNhdG9yXSk7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UoZ29hbCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGN1cnJlbnRfbW9kdWxlLzFcclxuXHRcdFwiY3VycmVudF9tb2R1bGUvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBtb2R1bGVfaWQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKG1vZHVsZV9pZCkgJiYgIXBsLnR5cGUuaXNfYXRvbShtb2R1bGVfaWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJhdG9tXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKG1vZHVsZV9pZCkpIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRcdGZvcih2YXIgcHJvcCBpbiB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzKSB7XHJcblx0XHRcdFx0XHRcdGlmKCF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbbW9kdWxlX2lkLCBuZXcgVGVybShwcm9wKV0pKSxcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZih0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLmhhc093blByb3BlcnR5KG1vZHVsZV9pZC5pZCkpXHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcHJlZGljYXRlX3Byb3BlcnR5LzJcclxuXHRcdFwicHJlZGljYXRlX3Byb3BlcnR5LzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgaGVhZCA9IGF0b20uYXJnc1swXSwgcHJvcGVydHkgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQ7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShoZWFkKSAmJiBoZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20oaGVhZC5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgaGVhZC5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBoZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aGVhZCA9IGhlYWQuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShoZWFkKSAmJiAhcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSAmJiAhcGwudHlwZS5pc19wcmVkaWNhdGVfcHJvcGVydHkocHJvcGVydHkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmRvbWFpbihcInByZWRpY2F0ZV9wcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IG1vZHVsZV9pZCA/IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSA6IHRocmVhZC5zZXNzaW9uLm1vZHVsZXMudXNlcjtcclxuXHRcdFx0XHR2YXIgcG9pbnRzID0gW107XHJcblx0XHRcdFx0Ly8gYWxsIHByZWRpY2F0ZXNcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHQvLyBidWlsdC1pbiBwcmVkaWNhdGVzIChidWlsdF9pbiArIHN0YXRpYyArIG5hdGl2ZV9jb2RlICsgbWV0YV9wcmVkaWNhdGU/KVxyXG5cdFx0XHRcdFx0aWYoIW1vZHVsZV9pZCkge1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIHByb3AgaW4gcGwuYnVpbHRpbi5ydWxlcykge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC5idWlsdGluLnJ1bGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGluZGljYXRvciA9IHN0cl9pbmRpY2F0b3IocHJvcCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaW5kaWNhdG9yLmFyZ3NbMV0udmFsdWU7IGkrKylcclxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MucHVzaCh0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCkpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB1bmlmX2hlYWQgPSBuZXcgVGVybShpbmRpY2F0b3IuYXJnc1swXS5pZCwgYXJncyk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfcHJvcGVydGllcyA9IFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwic3RhdGljXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJidWlsdF9pblwiKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwibmF0aXZlX2NvZGVcIilcclxuXHRcdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHBsLmJ1aWx0aW4ubWV0YV9wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJtZXRhX3ByZWRpY2F0ZVwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBsLmJ1aWx0aW4ubWV0YV9wcmVkaWNhdGVzW3Byb3BdXHJcblx0XHRcdFx0XHRcdFx0XHRdKSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYWxsIHByZWRpY2F0ZXMsIG9uZSBwcm9wZXJ0eSAvIGFsbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGN1cnJlbnRfcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkgfHwgY3VycmVudF9wcm9wZXJ0aWVzW2ldLmluZGljYXRvciA9PT0gcHJvcGVydHkuaW5kaWNhdG9yKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50cy5wdXNoKG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbaGVhZCwgdW5pZl9oZWFkXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3Byb3BlcnR5LCBjdXJyZW50X3Byb3BlcnRpZXNbaV1dKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyB1c2VyLWRlZmluZWQgcHJlZGljYXRlc1xyXG5cdFx0XHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBwcm9wIGluIGdldF9tb2R1bGUucnVsZXMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZighZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRpY2F0b3IgPSBzdHJfaW5kaWNhdG9yKHByb3ApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gW107XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGluZGljYXRvci5hcmdzWzFdLnZhbHVlOyBpKyspXHJcblx0XHRcdFx0XHRcdFx0XHRhcmdzLnB1c2godGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdW5pZl9oZWFkID0gbmV3IFRlcm0oaW5kaWNhdG9yLmFyZ3NbMF0uaWQsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50X3Byb3BlcnRpZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRpZih0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShwcm9wLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJkeW5hbWljXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcInN0YXRpY1wiKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1twcm9wXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJuYXRpdmVfY29kZVwiKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYodGhyZWFkLmlzX211bHRpZmlsZV9wcmVkaWNhdGUocHJvcCwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibXVsdGlmaWxlXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLm1ldGFfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibWV0YV9wcmVkaWNhdGVcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRnZXRfbW9kdWxlLm1ldGFfcHJlZGljYXRlc1twcm9wXVxyXG5cdFx0XHRcdFx0XHRcdFx0XSkpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGFsbCBwcmVkaWNhdGVzLCBvbmUgcHJvcGVydHkgLyBhbGwgcHJvcGVydGllc1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjdXJyZW50X3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpIHx8IGN1cnJlbnRfcHJvcGVydGllc1tpXS5pbmRpY2F0b3IgPT09IHByb3BlcnR5LmluZGljYXRvcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludHMucHVzaChuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2hlYWQsIHVuaWZfaGVhZF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtwcm9wZXJ0eSwgY3VycmVudF9wcm9wZXJ0aWVzW2ldXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIG9uZSBwcmVkaWNhdGVcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGJ1aWx0aW4gPSAhbW9kdWxlX2lkICYmIHBsLnR5cGUuaXNfYnVpbHRpbihoZWFkKTtcclxuXHRcdFx0XHRcdHZhciBwcmVkaWNhdGUgPSBidWlsdGluID8gcGwuYnVpbHRpbi5ydWxlc1toZWFkLmluZGljYXRvcl0gOiBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUgPSBidWlsdGluID8gcGwuYnVpbHRpbiA6IGdldF9tb2R1bGU7XHJcblx0XHRcdFx0XHRpZihwcmVkaWNhdGUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfcHJvcGVydGllcztcclxuXHRcdFx0XHRcdFx0aWYoYnVpbHRpbikge1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcyA9IFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwic3RhdGljXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJidWlsdF9pblwiKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwibmF0aXZlX2NvZGVcIilcclxuXHRcdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJkeW5hbWljXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcInN0YXRpY1wiKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYocHJlZGljYXRlIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm5hdGl2ZV9jb2RlXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0aHJlYWQuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibXVsdGlmaWxlXCIpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLm1ldGFfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpXHJcblx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJtZXRhX3ByZWRpY2F0ZVwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRnZXRfbW9kdWxlLm1ldGFfcHJlZGljYXRlc1toZWFkLmluZGljYXRvcl1cclxuXHRcdFx0XHRcdFx0XHRdKSk7XHJcblx0XHRcdFx0XHRcdHZhciBhcmdzID0gW107XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBoZWFkLmFyZ3MubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHRcdFx0YXJncy5wdXNoKHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKSk7XHJcblx0XHRcdFx0XHRcdHZhciB1bmlmX2hlYWQgPSBuZXcgVGVybShoZWFkLmlkLCBhcmdzKTtcclxuXHRcdFx0XHRcdFx0Ly8gb25lIHByZWRpY2F0ZSwgb25lIHByb3BlcnR5IC8gYWxsIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGN1cnJlbnRfcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpIHx8IGN1cnJlbnRfcHJvcGVydGllc1tpXS5pbmRpY2F0b3IgPT09IHByb3BlcnR5LmluZGljYXRvcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2gobmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2hlYWQsIHVuaWZfaGVhZF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcHJvcGVydHksIGN1cnJlbnRfcHJvcGVydGllc1tpXV0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKHBvaW50cyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbGlzdGluZy8wXHJcblx0XHRcImxpc3RpbmcvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gYXRvbS5jb250ZXh0X21vZHVsZSA/IGF0b20uY29udGV4dF9tb2R1bGUgOiBcInVzZXJcIjtcclxuXHRcdFx0dmFyIHJ1bGVzID0ge307XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdKSkge1xyXG5cdFx0XHRcdHJ1bGVzID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV0ucnVsZXM7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRcdGZvcih2YXIgaW5kaWNhdG9yIGluIHJ1bGVzKSB7XHJcblx0XHRcdFx0aWYoIXJ1bGVzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdHZhciBwcmVkaWNhdGUgPSBydWxlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdHN0ciArPSBcIiUgXCIgKyBpbmRpY2F0b3IgKyBcIlxcblwiO1xyXG5cdFx0XHRcdGlmKHByZWRpY2F0ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlZGljYXRlLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0XHRzdHIgKz0gcHJlZGljYXRlW2ldLnRvU3RyaW5nKCB7c2Vzc2lvbjogdGhyZWFkLnNlc3Npb259ICkgKyBcIlxcblwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHIgKz0gXCIvKlxcblwiICsgcHJlZGljYXRlLnRvU3RyaW5nKCkgKyBcIlxcbiovXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN0ciArPSBcIlxcblwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIndyaXRlXCIsIFtuZXcgVGVybShzdHIsIFtdKV0pKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbGlzdGluZy8xXHJcblx0XHRcImxpc3RpbmcvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGluZGljYXRvciA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKGluZGljYXRvci5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGluZGljYXRvci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGluZGljYXRvciA9IGluZGljYXRvci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfcHJlZGljYXRlX2luZGljYXRvcihpbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgaW5kaWNhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHJ1bGVzID0ge307XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV0pKSB7XHJcblx0XHRcdFx0XHRydWxlcyA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdLnJ1bGVzO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdFx0XHR2YXIgc3RyX2luZGljYXRvciA9IGluZGljYXRvci5hcmdzWzBdLmlkICsgXCIvXCIgKyBpbmRpY2F0b3IuYXJnc1sxXS52YWx1ZTtcclxuXHRcdFx0XHRpZihydWxlcy5oYXNPd25Qcm9wZXJ0eShzdHJfaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0dmFyIHByZWRpY2F0ZSA9IHJ1bGVzW3N0cl9pbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0aWYocHJlZGljYXRlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByZWRpY2F0ZS5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gcHJlZGljYXRlW2ldLnRvU3RyaW5nKCB7c2Vzc2lvbjogdGhyZWFkLnNlc3Npb259ICkgKyBcIlxcblwiO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3RyICs9IFwiLypcXG5cIiArIHByZWRpY2F0ZS50b1N0cmluZygpICsgXCJcXG4qL1wiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RyICs9IFwiXFxuXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwid3JpdGVcIiwgW25ldyBUZXJtKHN0ciwgW10pXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIExJU1QgT1BFUkFUSU9OU1xyXG5cclxuXHRcdC8vIHNvcnQvMlxyXG5cdFx0XCJzb3J0LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdLCBleHBlY3RlZCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZXhwZWN0ZWQgKSAmJiAhcGwudHlwZS5pc19mdWxseV9saXN0KCBleHBlY3RlZCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGV4cGVjdGVkLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRhcnIucHVzaCggcG9pbnRlci5hcmdzWzBdICk7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBzb3J0ZWRfYXJyID0gYXJyLnNvcnQoIHBsLmNvbXBhcmUgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBzb3J0ZWRfYXJyLmxlbmd0aC0xOyBpID4gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRpZiggc29ydGVkX2FycltpXS5lcXVhbHMoc29ydGVkX2FycltpLTFdKSApXHJcblx0XHRcdFx0XHRcdFx0c29ydGVkX2Fyci5zcGxpY2UoaSwxKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBzb3J0ZWRfbGlzdCA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBzb3J0ZWRfYXJyLmxlbmd0aC0xOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0c29ydGVkX2xpc3QgPSBuZXcgVGVybSggXCIuXCIsIFtzb3J0ZWRfYXJyW2ldLCBzb3J0ZWRfbGlzdF0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3NvcnRlZF9saXN0LCBleHBlY3RlZF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGtleXNvcnQvMlxyXG5cdFx0XCJrZXlzb3J0LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdLCBleHBlY3RlZCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZXhwZWN0ZWQgKSAmJiAhcGwudHlwZS5pc19mdWxseV9saXN0KCBleHBlY3RlZCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGV4cGVjdGVkLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRcdHZhciBlbGVtO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRlbGVtID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGVsZW0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdGVybSggZWxlbSApIHx8IGVsZW0uaW5kaWNhdG9yICE9PSBcIi0vMlwiICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwicGFpclwiLCBlbGVtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsZW0uYXJnc1swXS5wYWlyID0gZWxlbS5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0YXJyLnB1c2goIGVsZW0uYXJnc1swXSApO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShleHBlY3RlZCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBleHBlY3RlZDtcclxuXHRcdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGhlYWQgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkgJiYgKCFwbC50eXBlLmlzX3Rlcm0oaGVhZCkgfHwgaGVhZC5pbmRpY2F0b3IgIT09IFwiLS8yXCIpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwicGFpclwiLCBoZWFkLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikgJiYgIXBsLnR5cGUuaXNfZW1wdHlfbGlzdChwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGV4cGVjdGVkLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgc29ydGVkX2FyciA9IGFyci5zb3J0KCBwbC5jb21wYXJlICk7XHJcblx0XHRcdFx0XHR2YXIgc29ydGVkX2xpc3QgPSBuZXcgcGwudHlwZS5UZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBzb3J0ZWRfYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRzb3J0ZWRfbGlzdCA9IG5ldyBwbC50eXBlLlRlcm0oIFwiLlwiLCBbbmV3IHBsLnR5cGUuVGVybSggXCItXCIsIFtzb3J0ZWRfYXJyW2ldLCBzb3J0ZWRfYXJyW2ldLnBhaXJdICksIHNvcnRlZF9saXN0XSApO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgc29ydGVkX2FycltpXS5wYWlyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgcGwudHlwZS5TdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgcGwudHlwZS5UZXJtKCBcIj1cIiwgW3NvcnRlZF9saXN0LCBleHBlY3RlZF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGtleWdyb3VwXHJcblx0XHRcImtleWdyb3VwLzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXSwgZXhwZWN0ZWQgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUobGlzdCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoZXhwZWN0ZWQpICYmICFwbC50eXBlLmlzX2Z1bGx5X2xpc3QoZXhwZWN0ZWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGV4cGVjdGVkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBrZXlzID0gW107XHJcblx0XHRcdFx0dmFyIHZhbHVlcyA9IFtdO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdFxyXG5cdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0dmFyIGVsZW0gPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGVsZW0pKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKGVsZW0pIHx8IGVsZW0uaW5kaWNhdG9yICE9PSBcIi0vMlwiKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwicGFpclwiLCBlbGVtLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIga2V5ID0gZWxlbS5hcmdzWzBdLCB2YWx1ZSA9IGVsZW0uYXJnc1sxXTtcclxuXHRcdFx0XHRcdHZhciBpbmRleCA9IC0xO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYocGwuY29tcGFyZShrZXksIGtleXNbaV0pID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihpbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0aW5kZXggPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKFtdKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhbHVlc1tpbmRleF0ucHVzaCh2YWx1ZSk7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19lbXB0eV9saXN0KHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoZXhwZWN0ZWQpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwb2ludGVyID0gZXhwZWN0ZWQ7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBoZWFkID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpICYmICghcGwudHlwZS5pc190ZXJtKGhlYWQpIHx8IGhlYWQuaW5kaWNhdG9yICE9PSBcIi0vMlwiKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJwYWlyXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikgJiYgIXBsLnR5cGUuaXNfZW1wdHlfbGlzdChwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibGlzdFwiLCBleHBlY3RlZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGdyb3VwID0gbmV3IFRlcm0oXCJbXVwiLCBbXSk7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSBrZXlzLmxlbmd0aC0xOyBpID49IDA7IGktLSlcclxuXHRcdFx0XHRcdFx0Z3JvdXAgPSBuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwiLVwiLCBba2V5c1tpXSwgYXJyYXlUb0xpc3QodmFsdWVzW2ldKV0pLCBncm91cF0pO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdFx0XHRuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBwbC50eXBlLlRlcm0oXCI9XCIsIFtleHBlY3RlZCwgZ3JvdXBdKSksXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQ0xBVVNFIENSRUFUSU9OIEFORCBERVNUUlVDVElPTlxyXG5cdFx0XHJcblx0XHQvLyBhc3NlcnRhLzFcclxuXHRcdFwiYXNzZXJ0YS8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNsYXVzZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZCA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oY2xhdXNlKSAmJiBjbGF1c2UuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gY2xhdXNlLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0Y2xhdXNlID0gY2xhdXNlLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsYXVzZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaGVhZCwgYm9keSwgZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRpZihjbGF1c2UuaW5kaWNhdG9yID09PSBcIjotLzJcIikge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0Ym9keSA9IGJvZHlfY29udmVyc2lvbihjbGF1c2UuYXJnc1sxXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2U7XHJcblx0XHRcdFx0XHRib2R5ID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYm9keSAhPT0gbnVsbCAmJiAhcGwudHlwZS5pc19jYWxsYWJsZShib2R5KSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgYm9keSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoKCFwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0pXHJcblx0XHRcdFx0fHwgdGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0JiYgaGVhZC5pbmRpY2F0b3IgIT09IFwiLC8yXCJcclxuXHRcdFx0XHQmJiAhdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdKSkge1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVfaWQsIHt9LCBcImFsbFwiLCB7c2Vzc2lvbjogdGhyZWFkLnNlc3Npb259KTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdID0gZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1toZWFkLmluZGljYXRvcl0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPSBbbmV3IFJ1bGUoaGVhZCwgYm9keSwgdHJ1ZSldLmNvbmNhdChnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSk7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvcik7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGFzc2VydHovMVxyXG5cdFx0XCJhc3NlcnR6LzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY2xhdXNlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShjbGF1c2UpICYmIGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBjbGF1c2UuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRjbGF1c2UgPSBjbGF1c2UuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xhdXNlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBoZWFkLCBib2R5LCBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdGlmKGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi0vMlwiKSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRib2R5ID0gYm9keV9jb252ZXJzaW9uKGNsYXVzZS5hcmdzWzFdKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZTtcclxuXHRcdFx0XHRcdGJvZHkgPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihib2R5ICE9PSBudWxsICYmICFwbC50eXBlLmlzX2NhbGxhYmxlKGJvZHkpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBib2R5LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZigoIXBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSlcclxuXHRcdFx0XHR8fCB0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHQmJiBoZWFkLmluZGljYXRvciAhPT0gXCIsLzJcIlxyXG5cdFx0XHRcdCYmICF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0pKSB7XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUgPSBuZXcgTW9kdWxlKG1vZHVsZV9pZCwge30sIFwiYWxsXCIsIHtzZXNzaW9uOiB0aHJlYWQuc2Vzc2lvbn0pO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0gPSBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID09PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID0gW107XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW2hlYWQuaW5kaWNhdG9yXSA9IHRydWU7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXS5wdXNoKG5ldyBSdWxlKGhlYWQsIGJvZHksIHRydWUpKTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUudXBkYXRlX2luZGljZXNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yKTtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gcmV0cmFjdC8xXHJcblx0XHRcInJldHJhY3QvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjbGF1c2UgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbGF1c2UsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGhlYWQsIGJvZHksIG1vZHVsZV9hdG9tLCBtb2R1bGVfaWQ7XHJcblx0XHRcdFx0aWYoY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdFx0bW9kdWxlX2F0b20gPSBjbGF1c2UuYXJnc1swXTtcclxuXHRcdFx0XHRcdGNsYXVzZSA9IGNsYXVzZS5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShtb2R1bGVfYXRvbSkpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgbW9kdWxlX2F0b20sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bW9kdWxlX2F0b20gPSBuZXcgVGVybShcInVzZXJcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi0vMlwiKSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRib2R5ID0gY2xhdXNlLmFyZ3NbMV07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2U7XHJcblx0XHRcdFx0XHRib2R5ID0gbmV3IFRlcm0oXCJ0cnVlXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBtb2R1bGVfYXRvbS5pZDtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0aWYoIXBvaW50LnJldHJhY3QpIHtcclxuXHRcdFx0XHRcdGlmKHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBtb2R1bGVfaWQpXHJcblx0XHRcdFx0XHQmJiBoZWFkLmluZGljYXRvciAhPT0gXCIsLzJcIlxyXG5cdFx0XHRcdFx0JiYgIXRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHR5cGVvZiBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBvcnVsZSA9IGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJ1bGUgPSBvcnVsZS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHJ1bGUuYm9keSA9PT0gbnVsbClcclxuXHRcdFx0XHRcdFx0XHRcdFx0cnVsZS5ib2R5ID0gbmV3IFRlcm0oXCJ0cnVlXCIsIFtdKTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBvY2N1cnNfY2hlY2sgPSB0aHJlYWQuZ2V0X2ZsYWcoXCJvY2N1cnNfY2hlY2tcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KG5ldyBUZXJtKFwiLFwiLCBbaGVhZCwgYm9keV0pLCBuZXcgVGVybShcIixcIiwgW3J1bGUuaGVhZCwgcnVsZS5ib2R5XSksIG9jY3Vyc19jaGVjayk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihtZ3UgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI6XCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlX2F0b20sXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwicmV0cmFjdFwiLCBbbmV3IFRlcm0oXCI6LVwiLCBbaGVhZCwgYm9keV0pXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbaGVhZCwgcnVsZS5oZWFkXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbYm9keSwgcnVsZS5ib2R5XSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XSkpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUucmV0cmFjdCA9IG9ydWxlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChzdGF0ZSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0cmFjdCh0aHJlYWQsIHBvaW50LCBoZWFkLmluZGljYXRvciwgcG9pbnQucmV0cmFjdCwgZ2V0X21vZHVsZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyByZXRyYWN0YWxsLzFcclxuXHRcdFwicmV0cmFjdGFsbC8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGhlYWQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oaGVhZCkgJiYgaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRoZWFkID0gaGVhZC5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighdGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIGNvbnRleHRfbW9kdWxlKVxyXG5cdFx0XHR8fCBoZWFkLmluZGljYXRvciA9PT0gXCIsLzJcIlxyXG5cdFx0XHR8fCB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIjpcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInJldHJhY3RcIiwgW25ldyBwbC50eXBlLlRlcm0oXCI6LVwiLCBbaGVhZCwgbmV3IFZhcihcIl9cIildKV0pXHJcblx0XHRcdFx0XHRcdF0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcImZhaWxcIiwgW10pXHJcblx0XHRcdFx0XHRdKSksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpLFxyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShudWxsKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludClcclxuXHRcdFx0XHRdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBhYm9saXNoLzFcclxuXHRcdFwiYWJvbGlzaC8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHByZWRpY2F0ZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZDtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKHByZWRpY2F0ZSkgJiYgcHJlZGljYXRlLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20ocHJlZGljYXRlLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBwcmVkaWNhdGUuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gcHJlZGljYXRlLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0cHJlZGljYXRlID0gcHJlZGljYXRlLmFyZ3NbMV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gXCJ1c2VyXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcmVkaWNhdGUpIHx8IHBsLnR5cGUuaXNfdGVybShwcmVkaWNhdGUpICYmIHByZWRpY2F0ZS5pbmRpY2F0b3IgPT09IFwiLy8yXCJcclxuXHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUocHJlZGljYXRlLmFyZ3NbMF0pIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUocHJlZGljYXRlLmFyZ3NbMV0pKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKHByZWRpY2F0ZSkgfHwgcHJlZGljYXRlLmluZGljYXRvciAhPT0gXCIvLzJcIikge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwicHJlZGljYXRlX2luZGljYXRvclwiLCBwcmVkaWNhdGUsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19hdG9tKHByZWRpY2F0ZS5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiYXRvbVwiLCBwcmVkaWNhdGUuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2ludGVnZXIocHJlZGljYXRlLmFyZ3NbMV0pKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIHByZWRpY2F0ZS5hcmdzWzFdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYocHJlZGljYXRlLmFyZ3NbMV0udmFsdWUgPCAwKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmRvbWFpbihcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBwcmVkaWNhdGUuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfbnVtYmVyKHRocmVhZC5nZXRfZmxhZyhcIm1heF9hcml0eVwiKSkgJiYgcHJlZGljYXRlLmFyZ3NbMV0udmFsdWUgPiB0aHJlYWQuZ2V0X2ZsYWcoXCJtYXhfYXJpdHlcIikudmFsdWUpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucmVwcmVzZW50YXRpb24oXCJtYXhfYXJpdHlcIiwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdFx0dmFyIGluZGljYXRvciA9IHByZWRpY2F0ZS5hcmdzWzBdLmlkICsgXCIvXCIgKyBwcmVkaWNhdGUuYXJnc1sxXS52YWx1ZTtcclxuXHRcdFx0XHRcdGlmKHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGluZGljYXRvciwgbW9kdWxlX2lkKVxyXG5cdFx0XHRcdFx0JiYgaW5kaWNhdG9yICE9PSBcIiwvMlwiXHJcblx0XHRcdFx0XHQmJiAhdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2V0X21vZHVsZS5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdldF9tb2R1bGUubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBnZXRfbW9kdWxlLm11bHRpZmlsZV9wcmVkaWNhdGVzW2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBhdG9tLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEFUT00gUFJPQ0VTU0lOR1xyXG5cdFx0XHJcblx0XHQvLyBhdG9tX2xlbmd0aC8yXHJcblx0XHRcImF0b21fbGVuZ3RoLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzFdICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBhdG9tLmFyZ3NbMV0gKSAmJiBhdG9tLmFyZ3NbMV0udmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgbGVuZ3RoID0gbmV3IE51bSggc3RyaW5nTGVuZ3RoKGF0b20uYXJnc1swXS5pZCksIGZhbHNlICk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGVuZ3RoLCBhdG9tLmFyZ3NbMV1dICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9tX2NvbmNhdC8zXHJcblx0XHRcImF0b21fY29uY2F0LzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHIsIGdvYWwsIHN0YXJ0ID0gYXRvbS5hcmdzWzBdLCBlbmQgPSBhdG9tLmFyZ3NbMV0sIHdob2xlID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggd2hvbGUgKSAmJiAocGwudHlwZS5pc192YXJpYWJsZSggc3RhcnQgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBlbmQgKSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0YXJ0ICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RhcnQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBzdGFydCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBlbmQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBlbmQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBlbmQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggd2hvbGUgKSAmJiAhcGwudHlwZS5pc19hdG9tKCB3aG9sZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHdob2xlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHYxID0gcGwudHlwZS5pc192YXJpYWJsZSggc3RhcnQgKTtcclxuXHRcdFx0XHR2YXIgdjIgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBlbmQgKTtcclxuXHRcdFx0XHQvL3ZhciB2MyA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIHdob2xlICk7XHJcblx0XHRcdFx0aWYoICF2MSAmJiAhdjIgKSB7XHJcblx0XHRcdFx0XHRnb2FsID0gbmV3IFRlcm0oIFwiPVwiLCBbd2hvbGUsIG5ldyBUZXJtKCBzdGFydC5pZCArIGVuZC5pZCApXSApO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCB2MSAmJiAhdjIgKSB7XHJcblx0XHRcdFx0XHRzdHIgPSB3aG9sZS5pZC5zdWJzdHIoIDAsIHdob2xlLmlkLmxlbmd0aCAtIGVuZC5pZC5sZW5ndGggKTtcclxuXHRcdFx0XHRcdGlmKCBzdHIgKyBlbmQuaWQgPT09IHdob2xlLmlkICkge1xyXG5cdFx0XHRcdFx0XHRnb2FsID0gbmV3IFRlcm0oIFwiPVwiLCBbc3RhcnQsIG5ldyBUZXJtKCBzdHIgKV0gKTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKCB2MiAmJiAhdjEgKSB7XHJcblx0XHRcdFx0XHRzdHIgPSB3aG9sZS5pZC5zdWJzdHIoIHN0YXJ0LmlkLmxlbmd0aCApO1xyXG5cdFx0XHRcdFx0aWYoIHN0YXJ0LmlkICsgc3RyID09PSB3aG9sZS5pZCApIHtcclxuXHRcdFx0XHRcdFx0Z29hbCA9IG5ldyBUZXJtKCBcIj1cIiwgW2VuZCwgbmV3IFRlcm0oIHN0ciApXSApO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPD0gd2hvbGUuaWQubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdHZhciBhdG9tMSA9IG5ldyBUZXJtKCB3aG9sZS5pZC5zdWJzdHIoIDAsIGkgKSApO1xyXG5cdFx0XHRcdFx0XHR2YXIgYXRvbTIgPSBuZXcgVGVybSggd2hvbGUuaWQuc3Vic3RyKCBpICkgKTtcclxuXHRcdFx0XHRcdFx0Z29hbCA9IG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcIj1cIiwgW2F0b20xLCBzdGFydF0gKSwgbmV3IFRlcm0oIFwiPVwiLCBbYXRvbTIsIGVuZF0gKV0gKTtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goIG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gc3ViX2F0b20vNVxyXG5cdFx0XCJzdWJfYXRvbS81XCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgaSwgYXRvbTEgPSBhdG9tLmFyZ3NbMF0sIGJlZm9yZSA9IGF0b20uYXJnc1sxXSwgbGVuZ3RoID0gYXRvbS5hcmdzWzJdLCBhZnRlciA9IGF0b20uYXJnc1szXSwgc3ViYXRvbSA9IGF0b20uYXJnc1s0XTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tMSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBiZWZvcmUgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBiZWZvcmUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBiZWZvcmUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGVuZ3RoICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggbGVuZ3RoICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgbGVuZ3RoLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGFmdGVyICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggYWZ0ZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBhZnRlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggYmVmb3JlICkgJiYgYmVmb3JlLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgYmVmb3JlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBsZW5ndGggKSAmJiBsZW5ndGgudmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBsZW5ndGgsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGFmdGVyICkgJiYgYWZ0ZXIudmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBhZnRlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdWJhdG9tICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3ViYXRvbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHN1YmF0b20sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYnMgPSBbXSwgbHMgPSBbXSwgYXMgPSBbXTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYmVmb3JlICkgKSB7XHJcblx0XHRcdFx0XHRmb3IoIGkgPSAwOyBpIDw9IGF0b20xLmlkLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRicy5wdXNoKCBpICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGJzLnB1c2goIGJlZm9yZS52YWx1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbGVuZ3RoICkgKSB7XHJcblx0XHRcdFx0XHRmb3IoIGkgPSAwOyBpIDw9IGF0b20xLmlkLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRscy5wdXNoKCBpICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxzLnB1c2goIGxlbmd0aC52YWx1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYWZ0ZXIgKSApIHtcclxuXHRcdFx0XHRcdGZvciggaSA9IDA7IGkgPD0gYXRvbTEuaWQubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdGFzLnB1c2goIGkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YXMucHVzaCggYWZ0ZXIudmFsdWUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdGZvciggdmFyIF9pIGluIGJzICkge1xyXG5cdFx0XHRcdFx0aWYoIWJzLmhhc093blByb3BlcnR5KF9pKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRpID0gYnNbX2ldO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgX2ogaW4gbHMgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCFscy5oYXNPd25Qcm9wZXJ0eShfaikpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHR2YXIgaiA9IGxzW19qXTtcclxuXHRcdFx0XHRcdFx0dmFyIGsgPSBhdG9tMS5pZC5sZW5ndGggLSBpIC0gajtcclxuXHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGFzLCBrICkgIT09IC0xICkge1xyXG5cdFx0XHRcdFx0XHRpZiggaStqK2sgPT09IGF0b20xLmlkLmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzdHIgPSBhdG9tMS5pZC5zdWJzdHIoIGksIGogKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBhdG9tMS5pZCA9PT0gYXRvbTEuaWQuc3Vic3RyKCAwLCBpICkgKyBzdHIgKyBhdG9tMS5pZC5zdWJzdHIoIGkraiwgayApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGwxID0gbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHN0ciApLCBzdWJhdG9tXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGwyID0gbmV3IFRlcm0oIFwiPVwiLCBbYmVmb3JlLCBuZXcgTnVtKCBpICldICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwbDMgPSBuZXcgVGVybSggXCI9XCIsIFtsZW5ndGgsIG5ldyBOdW0oIGogKV0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHBsNCA9IG5ldyBUZXJtKCBcIj1cIiwgW2FmdGVyLCBuZXcgTnVtKCBrICldICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oIFwiLFwiLCBbIG5ldyBUZXJtKCBcIixcIiwgWyBuZXcgVGVybSggXCIsXCIsIFtwbDIsIHBsM10gKSwgcGw0XSApLCBwbDFdICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9tX2NoYXJzLzJcclxuXHRcdFwiYXRvbV9jaGFycy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgYXRvbTEgPSBhdG9tLmFyZ3NbMF0sIGxpc3QgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20xLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUobGlzdCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc19jaGFyYWN0ZXIocG9pbnRlci5hcmdzWzBdKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNoYXJhY3RlclwiLCBwb2ludGVyLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBsaXN0MSA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdHZhciB1bmlsZW4gPSBzdHJpbmdMZW5ndGgoYXRvbTEuaWQpO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHVuaWxlbi0xOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0bGlzdDEgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgVGVybSggYXRvbTEuaWQuY2hhckF0KCBpICkgKSwgbGlzdDFdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsaXN0LCBsaXN0MV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHRcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdHZhciB2ID0gcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKTtcclxuXHRcdFx0XHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgJiYgdiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNoYXJhY3RlclwiLCBwb2ludGVyLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IHBvaW50ZXIuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSAmJiB2ICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBzdHIgKSwgYXRvbTFdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbV9jb2Rlcy8yXHJcblx0XHRcImF0b21fY29kZXMvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGF0b20xID0gYXRvbS5hcmdzWzBdLCBsaXN0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tMSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGxpc3QpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfY2hhcmFjdGVyX2NvZGUocG9pbnRlci5hcmdzWzBdKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgcG9pbnRlci5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgbGlzdDEgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHR2YXIgdW5pbGVuID0gc3RyaW5nTGVuZ3RoKGF0b20xLmlkKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSB1bmlsZW4tMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QxID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IE51bSggY29kZVBvaW50QXQoYXRvbTEuaWQsaSksIGZhbHNlICksIGxpc3QxXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGlzdCwgbGlzdDFdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHR2YXIgdiA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICk7XHJcblx0XHRcdFx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2NoYXJhY3Rlcl9jb2RlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgJiYgdiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBmcm9tQ29kZVBvaW50KCBwb2ludGVyLmFyZ3NbMF0udmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSAmJiB2ICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBzdHIgKSwgYXRvbTFdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY2hhcl9jb2RlLzJcclxuXHRcdFwiY2hhcl9jb2RlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjaGFyID0gYXRvbS5hcmdzWzBdLCBjb2RlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggY2hhciApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY2hhciApICYmICFwbC50eXBlLmlzX2NoYXJhY3RlciggY2hhciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjaGFyYWN0ZXJcIiwgY2hhciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGNvZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICYmICFwbC50eXBlLmlzX2NoYXJhY3Rlcl9jb2RlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHRcdHZhciBjb2RlMSA9IG5ldyBOdW0oIGNvZGVQb2ludEF0KGNoYXIuaWQsMCApLCBmYWxzZSApO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbY29kZTEsIGNvZGVdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgY2hhcjEgPSBuZXcgVGVybSggZnJvbUNvZGVQb2ludCggY29kZS52YWx1ZSApICk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtjaGFyMSwgY2hhcl0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBudW1iZXJfY2hhcnMvMlxyXG5cdFx0XCJudW1iZXJfY2hhcnMvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0ciwgbnVtID0gYXRvbS5hcmdzWzBdLCBsaXN0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbnVtICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKSAmJiAhcGwudHlwZS5pc19udW1iZXIoIG51bSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJudW1iZXJcIiwgbnVtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSAmJiAhcGwudHlwZS5pc19saXN0KCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpc3ZhciA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApO1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1x0XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHR2YXIgdG90YWwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0c3RyID0gXCJcIjtcclxuXHRcdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2NoYXJhY3RlciggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG90YWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjaGFyYWN0ZXJcIiwgcG9pbnRlci5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBwb2ludGVyLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdGFsID0gdG90YWwgJiYgcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICk7XHJcblx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoICF0b3RhbCAmJiBpc3ZhciApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggdG90YWwgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgJiYgaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBleHByID0gdGhyZWFkLnBhcnNlKCBzdHIgKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbnVtMiA9IGV4cHIudmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggbnVtMiApIHx8IGV4cHIudG9rZW5zW2V4cHIudG9rZW5zLmxlbmd0aC0xXS5zcGFjZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3Iuc3ludGF4X2J5X3ByZWRpY2F0ZSggXCJwYXJzZWFibGVfbnVtYmVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbnVtLCBudW0yXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCAhaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRzdHIgPSBudW0udG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdHZhciBsaXN0MiA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QyID0gbmV3IFRlcm0oIFwiLlwiLCBbIG5ldyBUZXJtKCBzdHIuY2hhckF0KCBpICkgKSwgbGlzdDIgXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGlzdCwgbGlzdDJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gbnVtYmVyX2NvZGVzLzJcclxuXHRcdFwibnVtYmVyX2NvZGVzLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHIsIG51bSA9IGF0b20uYXJnc1swXSwgbGlzdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbnVtICkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKCBudW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibnVtYmVyXCIsIG51bSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgJiYgIXBsLnR5cGUuaXNfbGlzdCggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaXN2YXIgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKTtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcdFxyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0dmFyIHRvdGFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXJfY29kZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG90YWwgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gZnJvbUNvZGVQb2ludCggcG9pbnRlci5hcmdzWzBdLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdGFsID0gdG90YWwgJiYgcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICk7XHJcblx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoICF0b3RhbCAmJiBpc3ZhciApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggdG90YWwgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgJiYgaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBleHByID0gdGhyZWFkLnBhcnNlKCBzdHIgKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbnVtMiA9IGV4cHIudmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggbnVtMiApIHx8IGV4cHIudG9rZW5zW2V4cHIudG9rZW5zLmxlbmd0aC0xXS5zcGFjZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3Iuc3ludGF4X2J5X3ByZWRpY2F0ZSggXCJwYXJzZWFibGVfbnVtYmVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbnVtLCBudW0yXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCAhaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRzdHIgPSBudW0udG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdHZhciBsaXN0MiA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QyID0gbmV3IFRlcm0oIFwiLlwiLCBbIG5ldyBOdW0oIGNvZGVQb2ludEF0KHN0cixpKSwgZmFsc2UgKSwgbGlzdDIgXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGlzdCwgbGlzdDJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gdXBjYXNlX2F0b20vMlxyXG5cdFx0XCJ1cGNhc2VfYXRvbS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBhdG9tLmFyZ3NbMF0sIHVwY2FzZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG9yaWdpbmFsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggb3JpZ2luYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcmlnaW5hbCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCB1cGNhc2UgKSAmJiAhcGwudHlwZS5pc19hdG9tKCB1cGNhc2UgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCB1cGNhc2UsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFt1cGNhc2UsIG5ldyBUZXJtKCBvcmlnaW5hbC5pZC50b1VwcGVyQ2FzZSgpLCBbXSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gZG93bmNhc2VfYXRvbS8yXHJcblx0XHRcImRvd25jYXNlX2F0b20vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9yaWdpbmFsID0gYXRvbS5hcmdzWzBdLCBkb3duY2FzZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG9yaWdpbmFsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggb3JpZ2luYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcmlnaW5hbCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBkb3duY2FzZSApICYmICFwbC50eXBlLmlzX2F0b20oIGRvd25jYXNlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgZG93bmNhc2UsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtkb3duY2FzZSwgbmV3IFRlcm0oIG9yaWdpbmFsLmlkLnRvTG93ZXJDYXNlKCksIFtdICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9taWNfY29uY2F0LzNcclxuXHRcdFwiYXRvbWljX2NvbmNhdC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgYXRvbWljMSA9IGF0b20uYXJnc1swXSwgYXRvbWljMiA9IGF0b20uYXJnc1sxXSwgY29uY2F0ID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbWljMSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b21pYzIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9taWMoIGF0b21pYzEgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIGF0b21pYzEsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9taWMoIGF0b21pYzIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIGF0b21pYzIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29uY2F0ICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggY29uY2F0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgY29uY2F0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGlkID0gXCJcIjtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc19hdG9tKCBhdG9taWMxICkgKSB7XHJcblx0XHRcdFx0XHRpZCArPSBhdG9taWMxLmlkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZCArPSBcIlwiICsgYXRvbWljMS52YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbSggYXRvbWljMiApICkge1xyXG5cdFx0XHRcdFx0aWQgKz0gYXRvbWljMi5pZDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWQgKz0gXCJcIiArIGF0b21pYzIudmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBhdG9tID0gbmV3IFRlcm0oaWQsIFtdKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFthdG9tLCBjb25jYXRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGF0b21pY19saXN0X2NvbmNhdC8yXHJcblx0XHRcImF0b21pY19saXN0X2NvbmNhdC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXSwgY29uY2F0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJhdG9taWNfbGlzdF9jb25jYXRcIiwgW2xpc3QsIG5ldyBUZXJtKCBcIlwiLCBbXSApLCBjb25jYXRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbWljX2xpc3RfY29uY2F0LzNcclxuXHRcdFwiYXRvbWljX2xpc3RfY29uY2F0LzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdLCBzZXBhcmF0b3IgPSBhdG9tLmFyZ3NbMV0sIGNvbmNhdCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHNlcGFyYXRvciApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb25jYXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICYmICFwbC50eXBlLmlzX2xpc3QoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggc2VwYXJhdG9yICkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKCBzZXBhcmF0b3IgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIHNlcGFyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb25jYXQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBjb25jYXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBjb25jYXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaWQgPSBcIlwiO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKCBwb2ludGVyICkgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIHBvaW50ZXIuYXJnc1swXSApICYmICFwbC50eXBlLmlzX251bWJlciggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgcG9pbnRlci5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBpZCAhPT0gXCJcIiApXHJcblx0XHRcdFx0XHRcdGlkICs9IHNlcGFyYXRvci5pZDtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b20oIHBvaW50ZXIuYXJnc1swXSApIClcclxuXHRcdFx0XHRcdFx0aWQgKz0gcG9pbnRlci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRpZCArPSBcIlwiICsgcG9pbnRlci5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWQgPSBuZXcgVGVybSggaWQsIFtdICk7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdGVybSggcG9pbnRlciApIHx8IHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbaWQsIGNvbmNhdF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBURVJNIENPTVBBUklTT05cclxuXHRcdFxyXG5cdFx0XCJAPTwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgPD0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCI9PS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSA9PT0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCJcXFxcPT0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgIT09IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiQDwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcIkA+LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApID4gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCJAPj0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgPj0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCJjb21wYXJlLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvcmRlciA9IGF0b20uYXJnc1swXSwgbGVmdCA9IGF0b20uYXJnc1sxXSwgcmlnaHQgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggb3JkZXIgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBvcmRlciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9yZGVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19hdG9tKCBvcmRlciApICYmIFtcIjxcIiwgXCI+XCIsIFwiPVwiXS5pbmRleE9mKCBvcmRlci5pZCApID09PSAtMSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJvcmRlclwiLCBvcmRlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBjb21wYXJlID0gcGwuY29tcGFyZSggbGVmdCwgcmlnaHQgKTtcclxuXHRcdFx0XHRjb21wYXJlID0gY29tcGFyZSA9PT0gMCA/IFwiPVwiIDogKGNvbXBhcmUgPT09IC0xID8gXCI8XCIgOiBcIj5cIik7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbb3JkZXIsIG5ldyBUZXJtKCBjb21wYXJlLCBbXSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRVZBTFVBVElPTlxyXG5cdFx0XHJcblx0XHQvLyBpcy8yXHJcblx0XHRcImlzLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvcCA9IGF0b20uYXJnc1sxXS5pbnRlcnByZXQoIHRocmVhZCApO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCBvcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggb3AgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFthdG9tLmFyZ3NbMF0sIG9wXSwgYXRvbS5pbmRpY2F0b3IgKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGJldHdlZW4vM1xyXG5cdFx0XCJiZXR3ZWVuLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsb3dlciA9IGF0b20uYXJnc1swXSwgdXBwZXIgPSBhdG9tLmFyZ3NbMV0sIGJldCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxvd2VyICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggdXBwZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBsb3dlciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGxvd2VyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggdXBwZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCB1cHBlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBiZXQgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBiZXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBiZXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYmV0ICkgKSB7XHJcblx0XHRcdFx0XHRpZiggbG93ZXIudmFsdWUgPD0gdXBwZXIudmFsdWUgKSB7XHJcblx0XHRcdFx0XHRcdHZhciBzdGF0ZXMgPSBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2JldCwgbG93ZXJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXTtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goIG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJiZXR3ZWVuXCIsIFtuZXcgTnVtKCBsb3dlci52YWx1ZSsxLCBmYWxzZSApLCB1cHBlciwgYmV0XSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSApO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBsb3dlci52YWx1ZSA8PSBiZXQudmFsdWUgJiYgdXBwZXIudmFsdWUgPj0gYmV0LnZhbHVlICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBzdWNjLzJcclxuXHRcdFwic3VjYy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbiA9IGF0b20uYXJnc1swXSwgbSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG4gKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG4gKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBuICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgbiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBtICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIG0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbiApICYmIG4udmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBuLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG0gKSAmJiBtLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBtICkgfHwgbS52YWx1ZSA+IDAgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbiApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuLCBuZXcgTnVtKCBtLnZhbHVlLTEsIGZhbHNlICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbSwgbmV3IE51bSggbi52YWx1ZSsxLCBmYWxzZSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID06PS8yXHJcblx0XHRcIj06PS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wID09PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA9XFw9LzJcclxuXHRcdFwiPVxcXFw9LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgIT09IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIDwvMlxyXG5cdFx0XCI8LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA9PC8yXHJcblx0XHRcIj08LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgPD0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPi8yXHJcblx0XHRcIj4vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCA+IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID49LzJcclxuXHRcdFwiPj0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCA+PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBUWVBFIFRFU1RcclxuXHRcdFxyXG5cdFx0Ly8gdmFyLzFcclxuXHRcdFwidmFyLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbS8xXHJcblx0XHRcImF0b20vMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21pYy8xXHJcblx0XHRcImF0b21pYy8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19hdG9taWMoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjb21wb3VuZC8xXHJcblx0XHRcImNvbXBvdW5kLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2NvbXBvdW5kKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gaW50ZWdlci8xXHJcblx0XHRcImludGVnZXIvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfaW50ZWdlciggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGZsb2F0LzFcclxuXHRcdFwiZmxvYXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfZmxvYXQoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBudW1iZXIvMVxyXG5cdFx0XCJudW1iZXIvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfbnVtYmVyKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gbm9udmFyLzFcclxuXHRcdFwibm9udmFyLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGdyb3VuZC8xXHJcblx0XHRcImdyb3VuZC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggYXRvbS52YXJpYWJsZXMoKS5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGFjeWNsaWNfdGVybS8xXHJcblx0XHRcImFjeWNsaWNfdGVybS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdGVzdCA9IHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseSggcG9pbnQuc3Vic3RpdHV0aW9uICk7XHJcblx0XHRcdHZhciB2YXJpYWJsZXMgPSBhdG9tLmFyZ3NbMF0udmFyaWFibGVzKCk7XHJcblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrIClcclxuXHRcdFx0XHRpZiggcG9pbnQuc3Vic3RpdHV0aW9uLmxpbmtzW3ZhcmlhYmxlc1tpXV0gIT09IHVuZGVmaW5lZCAmJiAhcG9pbnQuc3Vic3RpdHV0aW9uLmxpbmtzW3ZhcmlhYmxlc1tpXV0uZXF1YWxzKCB0ZXN0LmxpbmtzW3ZhcmlhYmxlc1tpXV0gKSApXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY2FsbGFibGUvMVxyXG5cdFx0XCJjYWxsYWJsZS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY2FsbGFibGUgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShjYWxsYWJsZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBpc19saXN0LzFcclxuXHRcdFwiaXNfbGlzdC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybSggbGlzdCApICYmIGxpc3QuaW5kaWNhdG9yID09PSBcIi4vMlwiIClcclxuXHRcdFx0XHRsaXN0ID0gbGlzdC5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBsaXN0ICkgJiYgbGlzdC5pbmRpY2F0b3IgPT09IFwiW10vMFwiIClcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBTVFJFQU0gU0VMRUNUSU9OIEFORCBDT05UUk9MXHJcblxyXG5cdFx0Ly8gY3VycmVudF9pbnB1dC8xXHJcblx0XHRcImN1cnJlbnRfaW5wdXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoc3RyZWFtKVxyXG5cdFx0XHQmJiAoIXBsLnR5cGUuaXNfc3RyZWFtKHN0cmVhbSkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5hbGlhcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgICAmJiAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmlkKSlcclxuXHRcdFx0JiYgKCFwbC50eXBlLmlzX2F0b20oc3RyZWFtKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmlkKSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbihcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfYXRvbShzdHJlYW0pKVxyXG5cdFx0XHRcdFx0c3RyZWFtID0gdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmlkKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW3N0cmVhbSwgdGhyZWFkLmdldF9jdXJyZW50X2lucHV0KCldKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludClcclxuXHRcdFx0XHRdICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3VycmVudF9vdXRwdXQvMVxyXG5cdFx0XCJjdXJyZW50X291dHB1dC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShzdHJlYW0pXHJcblx0XHRcdCYmICghcGwudHlwZS5pc19zdHJlYW0oc3RyZWFtKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmFsaWFzKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgICYmICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uaWQpKVxyXG5cdFx0XHQmJiAoIXBsLnR5cGUuaXNfYXRvbShzdHJlYW0pIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uaWQpKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IpICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19hdG9tKHN0cmVhbSkpXHJcblx0XHRcdFx0XHRzdHJlYW0gPSB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFtzdHJlYW0sIHRocmVhZC5nZXRfY3VycmVudF9vdXRwdXQoKV0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50KVxyXG5cdFx0XHRcdF0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzZXRfaW5wdXQvMVxyXG5cdFx0XCJzZXRfaW5wdXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGlucHV0ID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gcGwudHlwZS5pc19zdHJlYW0oIGlucHV0ICkgPyBpbnB1dCA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBpbnB1dC5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW5wdXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIGlucHV0ICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggaW5wdXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgaW5wdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhpbnB1dC5hbGlhcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQmJiAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoaW5wdXQuaWQpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBpbnB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbS5vdXRwdXQgPT09IHRydWUgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIGlucHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnNldF9jdXJyZW50X2lucHV0KCBzdHJlYW0gKTtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzZXRfb3V0cHV0LzFcclxuXHRcdFwic2V0X291dHB1dC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gcGwudHlwZS5pc19zdHJlYW0oIG91dHB1dCApID8gb3V0cHV0IDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIG91dHB1dC5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggb3V0cHV0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBvdXRwdXQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBvdXRwdXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgb3V0cHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMob3V0cHV0LmFsaWFzKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCYmICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhvdXRwdXQuaWQpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBvdXRwdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0uaW5wdXQgPT09IHRydWUgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBvdXRwdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuc2V0X2N1cnJlbnRfb3V0cHV0KCBzdHJlYW0gKTtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBvcGVuLzNcclxuXHRcdFwib3Blbi8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZGVzdCA9IGF0b20uYXJnc1swXSwgbW9kZSA9IGF0b20uYXJnc1sxXSwgc3RyZWFtID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJvcGVuXCIsIFtkZXN0LCBtb2RlLCBzdHJlYW0sIG5ldyBUZXJtKFwiW11cIiwgW10pXSkpLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBvcGVuLzRcclxuXHRcdFwib3Blbi80XCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZGVzdCA9IGF0b20uYXJnc1swXSwgbW9kZSA9IGF0b20uYXJnc1sxXSwgc3RyZWFtID0gYXRvbS5hcmdzWzJdLCBvcHRpb25zID0gYXRvbS5hcmdzWzNdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZGVzdCApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG1vZGUgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG1vZGUgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBtb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgbW9kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudW5pbnN0YW50aWF0aW9uKCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBkZXN0ICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtYWJsZSggZGVzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInNvdXJjZV9zaW5rXCIsIGRlc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pb19tb2RlKCBtb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwiaW9fbW9kZVwiLCBtb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIG9ial9vcHRpb25zID0ge307XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcHRpb25zO1xyXG5cdFx0XHRcdHZhciBwcm9wZXJ0eTtcclxuXHRcdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtX29wdGlvbiggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29wdGlvblwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRvYmpfb3B0aW9uc1twcm9wZXJ0eS5pZF0gPSBwcm9wZXJ0eS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgYWxpYXMgPSBvYmpfb3B0aW9uc1tcImFsaWFzXCJdO1xyXG5cdFx0XHRcdFx0aWYoIGFsaWFzICYmIHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKGFsaWFzKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm9wZW5cIiwgXCJzb3VyY2Vfc2lua1wiLCBuZXcgVGVybShcImFsaWFzXCIsIFtuZXcgVGVybShhbGlhcywgW10pXSksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoICFvYmpfb3B0aW9uc1tcInR5cGVcIl0gKVxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1tcInR5cGVcIl0gPSBcInRleHRcIjtcclxuXHRcdFx0XHRcdHZhciBmaWxlO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbSggZGVzdCApIClcclxuXHRcdFx0XHRcdFx0ZmlsZSA9IHRocmVhZC5maWxlX3N5c3RlbV9vcGVuKCBkZXN0LmlkLCBvYmpfb3B0aW9uc1tcInR5cGVcIl0sIG1vZGUuaWQgKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0ZmlsZSA9IGRlc3Quc3RyZWFtKCBvYmpfb3B0aW9uc1tcInR5cGVcIl0sIG1vZGUuaWQgKTtcclxuXHRcdFx0XHRcdGlmKCBmaWxlID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm9wZW5cIiwgXCJzb3VyY2Vfc2lua1wiLCBkZXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggZmlsZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic291cmNlX3NpbmtcIiwgZGVzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgbmV3c3RyZWFtID0gbmV3IFN0cmVhbShcclxuXHRcdFx0XHRcdFx0ZmlsZSwgbW9kZS5pZCxcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbXCJhbGlhc1wiXSxcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbXCJ0eXBlXCJdLFxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1tcInJlcG9zaXRpb25cIl0gPT09IFwidHJ1ZVwiLFxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1tcImVvZl9hY3Rpb25cIl0gKTtcclxuXHRcdFx0XHRcdGlmKCBhbGlhcyApXHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnN0cmVhbXNbYWxpYXNdID0gbmV3c3RyZWFtO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zW25ld3N0cmVhbS5pZF0gPSBuZXdzdHJlYW07XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtzdHJlYW0sIG5ld3N0cmVhbV0gKSApLFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjbG9zZS8xXHJcblx0XHRcImNsb3NlLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcImNsb3NlXCIsIFtzdHJlYW0sIG5ldyBUZXJtKFwiW11cIiwgW10pXSkpLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjbG9zZS8yXHJcblx0XHRcImNsb3NlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIG9wdGlvbnMgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEdldCBvcHRpb25zXHJcblx0XHRcdFx0dmFyIG9ial9vcHRpb25zID0ge307XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcHRpb25zO1xyXG5cdFx0XHRcdHZhciBwcm9wZXJ0eTtcclxuXHRcdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY2xvc2Vfb3B0aW9uKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJjbG9zZV9vcHRpb25cIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b2JqX29wdGlvbnNbcHJvcGVydHkuaWRdID0gcHJvcGVydHkuYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCI7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKHN0cmVhbTIgPT09IHRocmVhZC5zZXNzaW9uLnN0YW5kYXJkX2lucHV0IHx8IHN0cmVhbTIgPT09IHRocmVhZC5zZXNzaW9uLnN0YW5kYXJkX291dHB1dCB8fCBzdHJlYW0yID09PSB0aHJlYWQuc2Vzc2lvbi5zdGFuZGFyZF9lcnJvcikge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yID09PSB0aHJlYWQuc2Vzc2lvbi5jdXJyZW50X2lucHV0ICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5jdXJyZW50X2lucHV0ID0gdGhyZWFkLnNlc3Npb24uc3RhbmRhcmRfaW5wdXQ7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIgPT09IHRocmVhZC5zZXNzaW9uLmN1cnJlbnRfb3V0cHV0ICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5jdXJyZW50X291dHB1dCA9IHRocmVhZC5zZXNzaW9uLnN0YW5kYXJkX291dHB1dDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBzdHJlYW0yLmFsaWFzICE9PSBudWxsICYmIHN0cmVhbTIuYWxpYXMgIT09IHVuZGVmaW5lZCApXHJcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zW3N0cmVhbTIuYWxpYXNdO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhyZWFkLnNlc3Npb24uc3RyZWFtc1tzdHJlYW0yLmlkXTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW0yLm91dHB1dCApXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIuc3RyZWFtLmZsdXNoKCk7XHJcblx0XHRcdFx0XHR2YXIgY2xvc2VkID0gc3RyZWFtMi5zdHJlYW0uY2xvc2UoKTtcclxuXHRcdFx0XHRcdHN0cmVhbTIuc3RyZWFtID0gbnVsbDtcclxuXHRcdFx0XHRcdGlmKCBvYmpfb3B0aW9ucy5mb3JjZSA9PT0gdHJ1ZSB8fCBjbG9zZWQgPT09IHRydWUgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBmbHVzaF9vdXRwdXQvMFxyXG5cdFx0XCJmbHVzaF9vdXRwdXQvMFwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZmx1c2hfb3V0cHV0XCIsIFtdKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwiZmx1c2hfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIGZsdXNoX291dHB1dC8xXHJcblx0XHRcImZsdXNoX291dHB1dC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLmlucHV0ID09PSB0cnVlICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RyZWFtMi5zdHJlYW0uZmx1c2goKTtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzdHJlYW1fcHJvcGVydHkvMlxyXG5cdFx0XCJzdHJlYW1fcHJvcGVydHkvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgcHJvcGVydHkgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAoIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcHJvcGVydHkgKSAmJiAhcGwudHlwZS5pc19zdHJlYW1fcHJvcGVydHkoIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX3Byb3BlcnR5XCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0dmFyIHByb3B2YXIgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KTtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIClcclxuXHRcdFx0XHRcdHN0cmVhbXMucHVzaCggc3RyZWFtMiApO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGZvciggdmFyIGtleSBpbiB0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zIClcclxuXHRcdFx0XHRcdFx0c3RyZWFtcy5wdXNoKCB0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zW2tleV0gKTtcclxuXHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHN0cmVhbXMubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHR2YXIgcHJvcGVydGllcyA9IFtdO1xyXG5cdFx0XHRcdFx0Ly8gZmlsZV9uYW1lLzFcclxuXHRcdFx0XHRcdGlmKCAocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwiZmlsZV9uYW1lLzFcIikgJiYgc3RyZWFtc1tpXS5maWxlbmFtZSApXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwiZmlsZV9uYW1lXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLmZpbGVfbmFtZSwgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyBtb2RlLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcIm1vZGUvMVwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcIm1vZGVcIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0ubW9kZSwgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyBpbnB1dC8wIG9yIG91dHB1dC8wXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJpbnB1dC8wXCIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcIm91dHB1dC8wXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIHN0cmVhbXNbaV0uaW5wdXQgPyBcImlucHV0XCIgOiBcIm91dHB1dFwiLCBbXSApICk7XHJcblx0XHRcdFx0XHQvLyBhbGlhcy8xXHJcblx0XHRcdFx0XHRpZiggKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcImFsaWFzLzFcIikgJiYgc3RyZWFtc1tpXS5hbGlhcyApXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwiYWxpYXNcIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0uYWxpYXMsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gcG9zaXRpb24vMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwicG9zaXRpb24vMVwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcInBvc2l0aW9uXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInBvc2l0aW9uXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBOdW0oc3RyZWFtc1tpXS5jaGFyX2NvdW50LCBmYWxzZSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgTnVtKHN0cmVhbXNbaV0ubGluZV9jb3VudCwgZmFsc2UpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE51bShzdHJlYW1zW2ldLmxpbmVfcG9zaXRpb24sIGZhbHNlKVxyXG5cdFx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRcdF0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gZW5kX29mX3N0cmVhbS8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJlbmRfb2Zfc3RyZWFtLzFcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJlbmRfb2Zfc3RyZWFtXCIsIFtuZXcgVGVybShcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW1zW2ldLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiB8fCBzdHJlYW1zW2ldLnN0cmVhbS5lb2YgJiYgc3RyZWFtc1tpXS5zdHJlYW0uZW9mKHN0cmVhbXNbaV0ucG9zaXRpb24pID8gXCJhdFwiIDpcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW1zW2ldLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiID8gXCJwYXN0XCIgOlxyXG5cdFx0XHRcdFx0XHRcdFwibm90XCIsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gZW9mX2FjdGlvbi8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJlb2ZfYWN0aW9uLzFcIilcdFxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcImVvZl9hY3Rpb25cIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0uZW9mX2FjdGlvbiwgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyByZXBvc2l0aW9uLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcInJlcG9zaXRpb24vMVwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcInJlcG9zaXRpb25cIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0ucmVwb3NpdGlvbiA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIHR5cGUvMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwidHlwZS8xXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwidHlwZVwiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS50eXBlLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGogPSAwOyBqIDwgcHJvcGVydGllcy5sZW5ndGg7IGorKyApIHtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goIG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHN0cmVhbTIsIHN0cmVhbXNbaV1dKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcHJvcGVydHksIHByb3BlcnRpZXNbal1dKV0pICksXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdCkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHN0cmVhbV9wb3NpdGlvbl9kYXRhXHJcblx0XHRcInN0cmVhbV9wb3NpdGlvbl9kYXRhLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgZmllbGQgPSBhdG9tLmFyZ3NbMF0sIHBvc2l0aW9uID0gYXRvbS5hcmdzWzFdLCB2YWx1ZSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb3NpdGlvbikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShwb3NpdGlvbikgfHwgcG9zaXRpb24uaW5kaWNhdG9yICE9PSBcInBvc2l0aW9uLzNcIikge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5kb21haW4oXCJzdHJlYW1fcG9zaXRpb25cIiwgcG9zaXRpb24sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShmaWVsZCkgJiYgIXBsLnR5cGUuaXNfYXRvbShmaWVsZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImF0b21cIiwgZmllbGQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZSh2YWx1ZSkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlcih2YWx1ZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgdmFsdWUsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGZpZWxkcyA9IFtcImNoYXJfY291bnRcIiwgXCJsaW5lX2NvdW50XCIsIFwibGluZV9wb3NpdGlvblwiXTtcclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0dmFyIGRhdGFfcG9zID0ge2NoYXJfY291bnQ6IDAsIGxpbmVfY291bnQ6IDEsIGxpbmVfcG9zaXRpb246IDJ9O1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZmllbGQpKSB7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbbmV3IFRlcm0oZmllbGRzW2ldKSwgZmllbGRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbdmFsdWUsIHBvc2l0aW9uLmFyZ3NbZGF0YV9wb3NbZmllbGRzW2ldXV1dKVxyXG5cdFx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRcdCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoZGF0YV9wb3MuaGFzT3duUHJvcGVydHkoZmllbGQuaWQpKSB7XHJcblx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3ZhbHVlLCBwb3NpdGlvbi5hcmdzW2RhdGFfcG9zW2ZpZWxkLmlkXV1dKVxyXG5cdFx0XHRcdFx0KSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGF0X2VuZF9vZl9zdHJlYW0vMFxyXG5cdFx0XCJhdF9lbmRfb2Zfc3RyZWFtLzBcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImF0X2VuZF9vZl9zdHJlYW1cIiwgW10pLCBuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJzdHJlYW1fcHJvcGVydHlcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBUZXJtKFwiZW5kX29mX3N0cmVhbVwiLCBbbmV3IFZhcihcIkVcIildKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCIhXCIsIFtdKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIkVcIiksbmV3IFRlcm0oXCJhdFwiLCBbXSldKSxuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJFXCIpLG5ldyBUZXJtKFwicGFzdFwiLCBbXSldKV0pXSldKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBhdF9lbmRfb2Zfc3RyZWFtLzFcclxuXHRcdFwiYXRfZW5kX29mX3N0cmVhbS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcInN0cmVhbV9wcm9wZXJ0eVwiLCBbc3RyZWFtMixuZXcgVGVybShcImVuZF9vZl9zdHJlYW1cIiwgW2VdKV0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiIVwiLCBbXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIj1cIiwgW2UsbmV3IFRlcm0oXCJhdFwiLCBbXSldKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtlLG5ldyBUZXJtKFwicGFzdFwiLCBbXSldKV0pXSldKVxyXG5cdFx0XHRcdFx0KSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzZXRfc3RyZWFtX3Bvc2l0aW9uLzJcclxuXHRcdFwic2V0X3N0cmVhbV9wb3NpdGlvbi8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBwb3NpdGlvbiA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb3NpdGlvbiApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW1fcG9zaXRpb24oIHBvc2l0aW9uICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX3Bvc2l0aW9uXCIsIHBvc2l0aW9uLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5yZXBvc2l0aW9uID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwicmVwb3NpdGlvblwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggcG9zaXRpb24uaW5kaWNhdG9yID09PSBcInBvc2l0aW9uLzNcIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBwb3NpdGlvbi5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50ID0gcG9zaXRpb24uYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCA9IHBvc2l0aW9uLmFyZ3NbMV0udmFsdWU7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSBwb3NpdGlvbi5hcmdzWzJdLnZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gcG9zaXRpb24uaWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gIENIQVJBQ1RFUiBJTlBVVCBPVVRQVVRcclxuXHRcdFxyXG5cdFx0Ly8gZ2V0X2NoYXIvMVxyXG5cdFx0XCJnZXRfY2hhci8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnZXRfY2hhclwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJnZXRfY2hhclwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBnZXRfY2hhci8yXHJcblx0XHRcImdldF9jaGFyLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNoYXIgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNoYXIgKSAmJiAhcGwudHlwZS5pc19pbl9jaGFyYWN0ZXIoIGNoYXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW5fY2hhcmFjdGVyXCIsIGNoYXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fY2hhcjtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2NoYXIgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9jaGFyID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0aWYoc3RyZWFtX2NoYXIgPT09IFwiXFxuXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQrKztcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSAwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybShzdHJlYW1fY2hhcixbXSksIGNoYXJdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBnZXRfY29kZS8xXHJcblx0XHRcImdldF9jb2RlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdldF9jb2RlXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcImdldF9jb2RlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIGdldF9jb2RlLzJcclxuXHRcdFwiZ2V0X2NvZGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY29kZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBjb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfaW5fY2hhcmFjdGVyX2NvZGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImluX2NoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2NvZGU7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSAtMTtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gLTE7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fY29kZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2NvZGUgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gLTE7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSBjb2RlUG9pbnRBdCggc3RyZWFtX2NvZGUsIDAgKTtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdGlmKHN0cmVhbV9jb2RlID09PSAxMCkge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IDA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBOdW0oc3RyZWFtX2NvZGUsIGZhbHNlKSwgY29kZV0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHBlZWtfY2hhci8xXHJcblx0XHRcInBlZWtfY2hhci8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwZWVrX2NoYXJcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicGVla19jaGFyXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHBlZWtfY2hhci8yXHJcblx0XHRcInBlZWtfY2hhci8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjaGFyID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjaGFyICkgJiYgIXBsLnR5cGUuaXNfaW5fY2hhcmFjdGVyKCBjaGFyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImluX2NoYXJhY3RlclwiLCBjaGFyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2NoYXI7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9jaGFyID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3RlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fY2hhciA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybShzdHJlYW1fY2hhcixbXSksIGNoYXJdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwZWVrX2NvZGUvMVxyXG5cdFx0XCJwZWVrX2NvZGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicGVla19jb2RlXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInBlZWtfY29kZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwZWVrX2NvZGUvMlxyXG5cdFx0XCJwZWVrX2NvZGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY29kZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBjb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfaW5fY2hhcmFjdGVyX2NvZGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImluX2NoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2NvZGU7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSAtMTtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9jb2RlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3RlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fY29kZSA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSAtMTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gY29kZVBvaW50QXQoIHN0cmVhbV9jb2RlLCAwICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgTnVtKHN0cmVhbV9jb2RlLCBmYWxzZSksIGNvZGVdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwdXRfY2hhci8xXHJcblx0XHRcInB1dF9jaGFyLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInB1dF9jaGFyXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwdXRfY2hhclwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwdXRfY2hhci8yXHJcblx0XHRcInB1dF9jaGFyLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNoYXIgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggY2hhciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NoYXJhY3RlciggY2hhciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjaGFyYWN0ZXJcIiwgY2hhciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5pbnB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5zdHJlYW0ucHV0KCBjaGFyLmlkLCBzdHJlYW0yLnBvc2l0aW9uICkgKSB7XHJcblx0XHRcdFx0XHRpZih0eXBlb2Ygc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdGlmKGNoYXIuaWQgPT09IFwiXFxuXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcHV0X2NvZGUvMVxyXG5cdFx0XCJwdXRfY29kZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwdXRfY29kZVwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicHV0X2NvZGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcHV0X2NvZGUvMlxyXG5cdFx0XCJwdXRfY29kZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjb2RlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgY29kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NoYXJhY3Rlcl9jb2RlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLmlucHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnN0cmVhbS5wdXQoIGZyb21Db2RlUG9pbnQoIGNvZGUudmFsdWUgKSwgc3RyZWFtMi5wb3NpdGlvbiApICkge1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIHN0cmVhbTIucG9zaXRpb24gPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRpZihjb2RlLnZhbHVlID09PSAxMCkge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQrKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBubC8wXHJcblx0XHRcIm5sLzBcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcIm5sXCIpLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwdXRfY2hhclwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFRlcm0oXCJcXG5cIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBubC8xXHJcblx0XHRcIm5sLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKFwicHV0X2NoYXJcIiwgW3N0cmVhbSwgbmV3IFRlcm0oXCJcXG5cIiwgW10pXSkgKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBCWVRFIElOUFVUL09VVFBVVFxyXG5cclxuXHRcdC8vIGdldF9ieXRlLzFcclxuXHRcdFwiZ2V0X2J5dGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ2V0X2J5dGVcIiwgW25ldyBWYXIoXCJCXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwiZ2V0X2J5dGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJCXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gZ2V0X2J5dGUvMlxyXG5cdFx0XCJnZXRfYnl0ZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBieXRlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBieXRlICkgJiYgIXBsLnR5cGUuaXNfaW5fYnl0ZSggYnl0ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbl9ieXRlXCIsIGJ5dGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJ0ZXh0XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwidGV4dF9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9ieXRlO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gLTE7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSBzdHJlYW0yLnN0cmVhbS5nZXRfYnl0ZSggc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9ieXRlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImJ5dGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2J5dGUgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gLTE7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgTnVtKHN0cmVhbV9ieXRlLGZhbHNlKSwgYnl0ZV0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBwZWVrX2J5dGUvMVxyXG5cdFx0XCJwZWVrX2J5dGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicGVla19ieXRlXCIsIFtuZXcgVmFyKFwiQlwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInBlZWtfYnl0ZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkJcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwZWVrX2J5dGUvMlxyXG5cdFx0XCJwZWVrX2J5dGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgYnl0ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYnl0ZSApICYmICFwbC50eXBlLmlzX2luX2J5dGUoIGJ5dGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW5fYnl0ZVwiLCBieXRlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwidGV4dFwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInRleHRfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fYnl0ZTtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gc3RyZWFtMi5zdHJlYW0uZ2V0X2J5dGUoIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fYnl0ZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJieXRlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9ieXRlID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IE51bShzdHJlYW1fYnl0ZSxmYWxzZSksIGJ5dGVdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwdXRfYnl0ZS8xXHJcblx0XHRcInB1dF9ieXRlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInB1dF9ieXRlXCIsIFtuZXcgVmFyKFwiQlwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwdXRfYnl0ZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkJcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwdXRfYnl0ZS8yXHJcblx0XHRcInB1dF9ieXRlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGJ5dGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggYnl0ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2J5dGUoIGJ5dGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYnl0ZVwiLCBieXRlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLmlucHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcInRleHRcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwidGV4dF9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIuc3RyZWFtLnB1dF9ieXRlKCBieXRlLnZhbHVlLCBzdHJlYW0yLnBvc2l0aW9uICkgKSB7XHJcblx0XHRcdFx0XHRpZih0eXBlb2Ygc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIFRFUk0gSU5QVVQvT1VUUFVUXHJcblxyXG5cdFx0Ly8gcmVhZC8xXHJcblx0XHRcInJlYWQvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicmVhZFwiLCBbbmV3IFZhcihcIlRcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJyZWFkX3Rlcm1cIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpLG5ldyBUZXJtKFwiW11cIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyByZWFkLzJcclxuXHRcdFwicmVhZC8yXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJyZWFkXCIsIFtuZXcgVmFyKFwiU1wiKSwgbmV3IFZhcihcIlRcIildKSwgbmV3IFRlcm0oXCJyZWFkX3Rlcm1cIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpLG5ldyBUZXJtKFwiW11cIildKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcmVhZF90ZXJtLzJcclxuXHRcdFwicmVhZF90ZXJtLzJcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInJlYWRfdGVybVwiLCBbbmV3IFZhcihcIlRcIiksbmV3IFZhcihcIk9cIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJyZWFkX3Rlcm1cIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpLG5ldyBWYXIoXCJPXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcmVhZF90ZXJtLzNcclxuXHRcdFwicmVhZF90ZXJtLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHRlcm0gPSBhdG9tLmFyZ3NbMV0sIG9wdGlvbnMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlb2ZfY29kZVwiICkge1xyXG5cdFx0XHRcdGV4cHIgPSB7XHJcblx0XHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCJlbmRfb2ZfZmlsZVwiLCBbXSksXHJcblx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTLFxyXG5cdFx0XHRcdFx0bGVuOiAtMVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gR2V0IG9wdGlvbnNcclxuXHRcdFx0XHR2YXIgb2JqX29wdGlvbnMgPSB7fTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wdGlvbnM7XHJcblx0XHRcdFx0dmFyIHByb3BlcnR5O1xyXG5cdFx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRwcm9wZXJ0eSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19yZWFkX29wdGlvbiggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwicmVhZF9vcHRpb25cIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b2JqX29wdGlvbnNbcHJvcGVydHkuaWRdID0gcHJvcGVydHkuYXJnc1swXTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApIClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGNoYXIsIHRva2VuaXplciwgZXhwcjtcclxuXHRcdFx0XHRcdHZhciB0ZXh0ID0gXCJcIjtcclxuXHRcdFx0XHRcdHZhciB0b2tlbnMgPSBbXTtcclxuXHRcdFx0XHRcdHZhciBsYXN0X3Rva2VuID0gbnVsbDtcclxuXHRcdFx0XHRcdHZhciBsZXhpY2FsX2Vycm9yID0gZmFsc2U7XHJcblx0XHRcdFx0XHQvLyBHZXQgdGVybVxyXG5cdFx0XHRcdFx0d2hpbGUoIGxhc3RfdG9rZW4gPT09IG51bGwgfHwgbGV4aWNhbF9lcnJvciB8fCBsYXN0X3Rva2VuLm5hbWUgIT09IFwiYXRvbVwiIHx8IGxhc3RfdG9rZW4udmFsdWUgIT09IFwiLlwiIHx8IHRva2Vucy5sZW5ndGggPiAwICYmIGV4cHIudHlwZSA9PT0gRVJST1IgKSB7XHJcblx0XHRcdFx0XHRcdGNoYXIgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdFx0d2hpbGUoY2hhciAhPT0gbnVsbCAmJiBjaGFyICE9PSBcIi5cIiAmJiBjaGFyICE9PSBcImVuZF9vZl9zdHJlYW1cIiAmJiBjaGFyICE9PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRcdHRleHQgKz0gY2hhcjtcclxuXHRcdFx0XHRcdFx0XHRjaGFyID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoIGNoYXIgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBjaGFyID09PSBcImVuZF9vZl9zdHJlYW1cIiB8fCBjaGFyID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRva2VucyA9PT0gbnVsbCB8fCB0b2tlbnMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cHIgPSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcImVuZF9vZl9maWxlXCIsIFtdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTUyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGVuOiAtMVxyXG5cdFx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZihleHByKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnN5bnRheCggbGFzdF90b2tlbiwgXCJ1bmV4cGVjdGVkIGVuZCBvZiBmaWxlXCIsIGZhbHNlICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5zeW50YXgoIGxhc3RfdG9rZW4sIFwidG9rZW4gbm90IGZvdW5kXCIsIHRydWUgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKGNoYXIgPT09IFwiLlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRcdHRleHQgKz0gY2hhcjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKCB0aHJlYWQgKTtcclxuXHRcdFx0XHRcdFx0dG9rZW5pemVyLm5ld190ZXh0KCB0ZXh0ICk7XHJcblx0XHRcdFx0XHRcdHRva2VucyA9IHRva2VuaXplci5nZXRfdG9rZW5zKCk7XHJcblx0XHRcdFx0XHRcdG51bV90b2tlbiA9IHRva2VucyAhPT0gbnVsbCAmJiB0b2tlbnMubGVuZ3RoID4gMSA/IHRva2Vuc1t0b2tlbnMubGVuZ3RoLTJdIDogbnVsbDtcclxuXHRcdFx0XHRcdFx0bGFzdF90b2tlbiA9IHRva2VucyAhPT0gbnVsbCAmJiB0b2tlbnMubGVuZ3RoID4gMCA/IHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdIDogbnVsbDtcclxuXHRcdFx0XHRcdFx0aWYodG9rZW5zID09PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRsZXhpY2FsX2Vycm9yID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoICYmICFsZXhpY2FsX2Vycm9yOyBpKyspXHJcblx0XHRcdFx0XHRcdFx0bGV4aWNhbF9lcnJvciA9IHRva2Vuc1tpXS5uYW1lID09PSBcImxleGljYWxcIjtcclxuXHRcdFx0XHRcdFx0aWYobGV4aWNhbF9lcnJvcilcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0ZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2VucywgMCwgdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpLCBmYWxzZSk7XHJcblx0XHRcdFx0XHRcdGlmKG51bV90b2tlbiAmJiBudW1fdG9rZW4ubmFtZSA9PT0gXCJudW1iZXJcIiAmJiAhbnVtX3Rva2VuLmZsb2F0ICYmICFudW1fdG9rZW4uYmxhbmsgJiYgbGFzdF90b2tlbi52YWx1ZSA9PT0gXCIuXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbmV4dF9jaGFyID0gc3RyZWFtMi5zdHJlYW0uZ2V0KDEsIHN0cmVhbTIucG9zaXRpb24pO1xyXG5cdFx0XHRcdFx0XHRcdGlmKG5leHRfY2hhciA+PSAnMCcgJiYgbmV4dF9jaGFyIDw9ICc5Jykge1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCArPSBuZXh0X2NoYXI7XHJcblx0XHRcdFx0XHRcdFx0XHRsYXN0X3Rva2VuID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYobGFzdF90b2tlbikge1xyXG5cdFx0XHRcdFx0XHRpZihsYXN0X3Rva2VuLmxpbmVfcG9zaXRpb24gPT09IGxhc3RfdG9rZW4ubGVuKVxyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiArPSBsYXN0X3Rva2VuLmxpbmVfcG9zaXRpb247XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSBsYXN0X3Rva2VuLmxpbmVfcG9zaXRpb247XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCArPSBsYXN0X3Rva2VuLmxpbmVfY291bnQ7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCArPSBsYXN0X3Rva2VuLmxlbjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIFN1Y2NlZWQgYW5hbHl6aW5nIHRlcm1cclxuXHRcdFx0XHRcdGlmKCBleHByLnR5cGUgPT09IFNVQ0NFU1MgJiYgKGV4cHIubGVuID09PSAtMSB8fCBleHByLmxlbiA9PT0gdG9rZW5zLmxlbmd0aC0xICYmIGxhc3RfdG9rZW4udmFsdWUgPT09IFwiLlwiICkpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHRcdFx0ZXhwciA9IGV4cHIudmFsdWUucmVuYW1lKCB0aHJlYWQgKTtcclxuXHRcdFx0XHRcdFx0dmFyIGVxID0gbmV3IFRlcm0oIFwiPVwiLCBbdGVybSwgZXhwcl0gKTtcclxuXHRcdFx0XHRcdFx0Ly8gVmFyaWFibGVzXHJcblx0XHRcdFx0XHRcdGlmKCBvYmpfb3B0aW9ucy52YXJpYWJsZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhcnMgPSBhcnJheVRvTGlzdCggbWFwKCBudWIoIGV4cHIudmFyaWFibGVzKCkgKSwgZnVuY3Rpb24odikgeyByZXR1cm4gbmV3IFZhcih2KTsgfSApICk7XHJcblx0XHRcdFx0XHRcdFx0ZXEgPSBuZXcgVGVybSggXCIsXCIsIFtlcSwgbmV3IFRlcm0oIFwiPVwiLCBbb2JqX29wdGlvbnMudmFyaWFibGVzLCB2YXJzXSApXSApXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Ly8gVmFyaWFibGUgbmFtZXNcclxuXHRcdFx0XHRcdFx0aWYoIG9ial9vcHRpb25zLnZhcmlhYmxlX25hbWVzICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2YXJzID0gbnViKGV4cHIudmFyaWFibGVzKCkpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwbHZhcnMgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHYgPSB2YXJzW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKCB2YXIgcHJvcCBpbiB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzWyBwcm9wIF0gPT09IHYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwbHZhcnMucHVzaChuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggcHJvcCwgW10pLCBuZXcgVmFyKHYpXSApKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwbHZhcnMgPSBhcnJheVRvTGlzdChwbHZhcnMpO1xyXG5cdFx0XHRcdFx0XHRcdGVxID0gbmV3IFRlcm0oIFwiLFwiLCBbZXEsIG5ldyBUZXJtKCBcIj1cIiwgW29ial9vcHRpb25zLnZhcmlhYmxlX25hbWVzLCBwbHZhcnNdICldICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0Ly8gU2luZ2xldG9uc1xyXG5cdFx0XHRcdFx0XHRpZiggb2JqX29wdGlvbnMuc2luZ2xldG9ucyApIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFycyA9IG51YihuZXcgUnVsZShleHByLCBudWxsKS5zaW5nbGV0b25fdmFyaWFibGVzKHRydWUpKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcGx2YXJzID0gW107XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB2ID0gdmFyc1tpXTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciggdmFyIHByb3AgaW4gdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlc1sgcHJvcCBdID09PSB2ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGx2YXJzLnB1c2gobmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHByb3AsIFtdKSwgbmV3IFZhcih2KV0gKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cGx2YXJzID0gYXJyYXlUb0xpc3QocGx2YXJzKTtcclxuXHRcdFx0XHRcdFx0XHRlcSA9IG5ldyBUZXJtKCBcIixcIiwgW2VxLCBuZXcgVGVybSggXCI9XCIsIFtvYmpfb3B0aW9ucy5zaW5nbGV0b25zLCBwbHZhcnNdICldICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZXEgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0Ly8gRmFpbGVkIGFuYWx5emluZyB0ZXJtXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpZiggZXhwci50eXBlID09PSBTVUNDRVNTIClcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnN5bnRheCggdG9rZW5zW2V4cHIubGVuXSwgXCJ1bmV4cGVjdGVkIHRva2VuXCIsIGZhbHNlICkgKTtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggZXhwci52YWx1ZSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyB3cml0ZS8xXHJcblx0XHRcIndyaXRlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcIndyaXRlXCIsIFtuZXcgVmFyKFwiVFwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJ3cml0ZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIildKV0pKVxyXG5cdFx0XSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGUvMlxyXG5cdFx0XCJ3cml0ZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCB0ZXJtID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybShcIndyaXRlX3Rlcm1cIiwgW3N0cmVhbSwgdGVybSxcclxuXHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJxdW90ZWRcIiwgW25ldyBUZXJtKFwiZmFsc2VcIiwgW10pXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJpZ25vcmVfb3BzXCIsIFtuZXcgVGVybShcImZhbHNlXCIpXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcIm51bWJlcnZhcnNcIiwgW25ldyBUZXJtKFwidHJ1ZVwiKV0pLCBuZXcgVGVybShcIltdXCIsW10pXSldKV0pXSkgKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlcS8xXHJcblx0XHRcIndyaXRlcS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJ3cml0ZXFcIiwgW25ldyBWYXIoXCJUXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcIndyaXRlcVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIildKV0pKVxyXG5cdFx0XSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGVxLzJcclxuXHRcdFwid3JpdGVxLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHRlcm0gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKFwid3JpdGVfdGVybVwiLCBbc3RyZWFtLCB0ZXJtLFxyXG5cdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcInF1b3RlZFwiLCBbbmV3IFRlcm0oXCJ0cnVlXCIsIFtdKV0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwiaWdub3JlX29wc1wiLCBbbmV3IFRlcm0oXCJmYWxzZVwiKV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJudW1iZXJ2YXJzXCIsIFtuZXcgVGVybShcInRydWVcIildKSwgbmV3IFRlcm0oXCJbXVwiLFtdKV0pXSldKV0pICksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZV9jYW5vbmljYWwvMVxyXG5cdFx0XCJ3cml0ZV9jYW5vbmljYWwvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwid3JpdGVfY2Fub25pY2FsXCIsIFtuZXcgVmFyKFwiVFwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJ3cml0ZV9jYW5vbmljYWxcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpXSldKSlcclxuXHRcdF0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlX2Nhbm9uaWNhbC8yXHJcblx0XHRcIndyaXRlX2Nhbm9uaWNhbC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCB0ZXJtID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybShcIndyaXRlX3Rlcm1cIiwgW3N0cmVhbSwgdGVybSxcclxuXHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJxdW90ZWRcIiwgW25ldyBUZXJtKFwidHJ1ZVwiLCBbXSldKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcImlnbm9yZV9vcHNcIiwgW25ldyBUZXJtKFwidHJ1ZVwiKV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJudW1iZXJ2YXJzXCIsIFtuZXcgVGVybShcImZhbHNlXCIpXSksIG5ldyBUZXJtKFwiW11cIixbXSldKV0pXSldKSApLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyB3cml0ZV90ZXJtLzJcclxuXHRcdFwid3JpdGVfdGVybS8yXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJ3cml0ZV90ZXJtXCIsIFtuZXcgVmFyKFwiVFwiKSxuZXcgVmFyKFwiT1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJ3cml0ZV90ZXJtXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKSxuZXcgVmFyKFwiT1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZV90ZXJtLzNcclxuXHRcdFwid3JpdGVfdGVybS8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCB0ZXJtID0gYXRvbS5hcmdzWzFdLCBvcHRpb25zID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLmlucHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBHZXQgb3B0aW9uc1xyXG5cdFx0XHRcdHZhciBvYmpfb3B0aW9ucyA9IHt9O1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gb3B0aW9ucztcclxuXHRcdFx0XHR2YXIgcHJvcGVydHk7XHJcblx0XHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdHByb3BlcnR5ID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3dyaXRlX29wdGlvbiggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwid3JpdGVfb3B0aW9uXCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJ2YXJpYWJsZV9uYW1lcy8xXCIpXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW3Byb3BlcnR5LmlkXSA9IHByb3BlcnR5LmFyZ3NbMF07XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW3Byb3BlcnR5LmlkXSA9IHByb3BlcnR5LmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRvYmpfb3B0aW9ucy5zZXNzaW9uID0gdGhyZWFkLnNlc3Npb247XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IHRlcm0udG9TdHJpbmcoIG9ial9vcHRpb25zICk7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnN0cmVhbS5wdXQoIHRleHQsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCB0eXBlb2Ygc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIiApXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gKz0gdGV4dC5sZW5ndGg7XHJcblx0XHRcdFx0XHR2YXIgbmwgPSAodGV4dC5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQgKz0gbmw7XHJcblx0XHRcdFx0XHRpZihubCA+IDApXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IHRleHQubGVuZ3RoIC0gdGV4dC5sYXN0SW5kZXhPZihcIlxcblwiKSAtIDE7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiArPSB0ZXh0Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCArPSB0ZXh0Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gSU1QTEVNRU5UQVRJT04gREVGSU5FRCBIT09LU1xyXG5cdFx0XHJcblx0XHQvLyBoYWx0LzBcclxuXHRcdFwiaGFsdC8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBfICkge1xyXG5cdFx0XHRpZiggdGhyZWFkLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIiApXHJcblx0XHRcdFx0cHJvY2Vzcy5leGl0KCk7XHJcblx0XHRcdHRocmVhZC5wb2ludHMgPSBbXTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGhhbHQvMVxyXG5cdFx0XCJoYWx0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBpbnQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbnQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBpbnQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBpbnQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggdGhyZWFkLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIiApXHJcblx0XHRcdFx0XHRwcm9jZXNzLmV4aXQoaW50LnZhbHVlKTtcclxuXHRcdFx0XHR0aHJlYWQucG9pbnRzID0gW107XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGN1cnJlbnRfcHJvbG9nX2ZsYWcvMlxyXG5cdFx0XCJjdXJyZW50X3Byb2xvZ19mbGFnLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBmbGFnID0gYXRvbS5hcmdzWzBdLCB2YWx1ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBmbGFnICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggZmxhZyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZmxhZyApICYmICFwbC50eXBlLmlzX2ZsYWcoIGZsYWcgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJwcm9sb2dfZmxhZ1wiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdGZvciggdmFyIG5hbWUgaW4gcGwuZmxhZyApIHtcclxuXHRcdFx0XHRcdGlmKCFwbC5mbGFnLmhhc093blByb3BlcnR5KG5hbWUpKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIG5hbWUgKSwgZmxhZ10gKSwgbmV3IFRlcm0oIFwiPVwiLCBbdGhyZWFkLmdldF9mbGFnKG5hbWUpLCB2YWx1ZV0gKV0gKTtcclxuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICkgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBzZXRfcHJvbG9nX2ZsYWcvMlxyXG5cdFx0XCJzZXRfcHJvbG9nX2ZsYWcvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGZsYWcgPSBhdG9tLmFyZ3NbMF0sIHZhbHVlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZmxhZyApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggZmxhZyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19mbGFnKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwicHJvbG9nX2ZsYWdcIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX21vZGlmaWFibGVfZmxhZyggZmxhZyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJtb2RpZnlcIiwgXCJmbGFnXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YWx1ZV9mbGFnKCBmbGFnLCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcImZsYWdfdmFsdWVcIiwgbmV3IFRlcm0oIFwiK1wiLCBbZmxhZywgdmFsdWVdICksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5mbGFnW2ZsYWcuaWRdID0gdmFsdWU7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBMT0FEIFBST0xPRyBTT1VSQ0UgRklMRVNcclxuXHJcblx0XHQvLyBjb25zdWx0LzFcclxuXHRcdFwiY29uc3VsdC8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHNyYyA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKHNyYy5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IHNyYy5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdHNyYyA9IHNyYy5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoc3JjKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfYXRvbShzcmMpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgc3JjLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYodGhyZWFkLmNvbnN1bHQoc3JjLmlkLCB7XHJcblx0XHRcdFx0XHRjb250ZXh0X21vZHVsZTogY29udGV4dF9tb2R1bGUsXHJcblx0XHRcdFx0XHR0ZXh0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGh0bWw6IGZhbHNlLFxyXG5cdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmFnYWluKCk7XHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoZXJyKTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmFnYWluKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSkpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gVElNRSBBTkQgREFURVNcclxuXHJcblx0XHQvLyBnZXRfdGltZS8xXHJcblx0XHRcImdldF90aW1lLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB0aW1lID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZSh0aW1lKSAmJiAhcGwudHlwZS5pc19udW1iZXIodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibnVtYmVyXCIsIHRpbWUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgY3VycmVudCA9IG5ldyBOdW0oRGF0ZS5ub3coKSwgdHJ1ZSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3RpbWUsIGN1cnJlbnRdICkgKSwgXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gdGltZV9wcm9wZXJ0eVxyXG5cdFx0XCJ0aW1lX3Byb3BlcnR5LzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGltZSA9IGF0b20uYXJnc1swXSwgcHJvcGVydHkgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUodGltZSkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJudW1iZXJcIiwgdGltZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSAmJiAhcGwudHlwZS5pc190aW1lX3Byb3BlcnR5KHByb3BlcnR5KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5kb21haW4oXCJ0aW1lX3Byb3BlcnR5XCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBwcm9wcztcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSkge1xyXG5cdFx0XHRcdFx0cHJvcHMgPSBbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIsIFwid2Vla2RheVwiXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cHJvcHMgPSBbcHJvcGVydHkuaWRdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgZGF0ZSA9IG5ldyBEYXRlKHRpbWUudmFsdWUpO1xyXG5cdFx0XHRcdHZhciB2YWx1ZTtcclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRzd2l0Y2gocHJvcHNbaV0pIHtcclxuXHRcdFx0XHRcdFx0Y2FzZSBcInllYXJcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwieWVhclwiLCBbbmV3IE51bShkYXRlLmdldEZ1bGxZZWFyKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwibW9udGhcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwibW9udGhcIiwgW25ldyBOdW0oZGF0ZS5nZXRNb250aCgpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcImRheVwiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJkYXlcIiwgW25ldyBOdW0oZGF0ZS5nZXREYXRlKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiaG91cnNcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwiaG91cnNcIiwgW25ldyBOdW0oZGF0ZS5nZXRIb3VycygpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIm1pbnV0ZXNcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwibWludXRlc1wiLCBbbmV3IE51bShkYXRlLmdldE1pbnV0ZXMoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJzZWNvbmRzXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcInNlY29uZHNcIiwgW25ldyBOdW0oZGF0ZS5nZXRTZWNvbmRzKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwibWlsbGlzZWNvbmRzXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcIm1pbGxpc2Vjb25kc1wiLCBbbmV3IE51bShkYXRlLmdldE1pbGxpc2Vjb25kcygpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIndlZWtkYXlcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwid2Vla2RheVwiLCBbbmV3IE51bShkYXRlLmdldERheSgpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtwcm9wZXJ0eSwgdmFsdWVdICkgKSwgXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHRpbWVfeWVhci8yXHJcblx0XHRcInRpbWVfeWVhci8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdGltZSA9IGF0b20uYXJnc1swXSwgeWVhciA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfbnVtYmVyKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcIm51bWJlclwiLCB0aW1lLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZSh5ZWFyKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKHllYXIpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgeWVhciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IG5ldyBOdW0obmV3IERhdGUodGltZS52YWx1ZSkuZ2V0RnVsbFllYXIoKSwgZmFsc2UpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFt5ZWFyLCB2YWx1ZV0gKSApLCBcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyB0aW1lX21vbnRoLzJcclxuXHRcdFwidGltZV9tb250aC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdGltZSA9IGF0b20uYXJnc1swXSwgbW9udGggPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX251bWJlcih0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJudW1iZXJcIiwgdGltZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUobW9udGgpICYmICFwbC50eXBlLmlzX2ludGVnZXIobW9udGgpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgbW9udGgsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgdmFsdWUgPSBuZXcgTnVtKG5ldyBEYXRlKHRpbWUudmFsdWUpLmdldE1vbnRoKCksIGZhbHNlKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbW9udGgsIHZhbHVlXSApICksIFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gR1JBTU1BUlNcclxuXHJcblx0XHQvLyBwaHJhc2UvM1xyXG5cdFx0XCJwaHJhc2UvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdyYm9keSA9IGF0b20uYXJnc1swXSwgczAgPSBhdG9tLmFyZ3NbMV0sIHMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihncmJvZHkuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBncmJvZHkuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRncmJvZHkgPSBncmJvZHkuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZ3Jib2R5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY2FsbGFibGUoIGdyYm9keSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjYWxsYWJsZVwiLCBncmJvZHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZ29hbCA9IGJvZHlfdG9fZGNnKCBncmJvZHkuY2xvbmUoKSwgczAsIHRocmVhZCApO1xyXG5cdFx0XHRcdGdvYWwudmFsdWUgPSBuZXcgVGVybShcIjpcIiwgW25ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSwgbmV3IFRlcm0oXCJjYWxsXCIsIFtnb2FsLnZhbHVlXSldKTtcclxuXHRcdFx0XHRpZihnb2FsICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCIsXCIsIFtnb2FsLnZhbHVlLCBuZXcgVGVybShcIj1cIiwgW2dvYWwudmFyaWFibGUsIHNdKV0gKSApLCBcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcGhyYXNlLzJcclxuXHRcdFwicGhyYXNlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBncmJvZHkgPSBhdG9tLmFyZ3NbMF0sIHMwID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcInBocmFzZVwiLCBbZ3Jib2R5LCBzMCwgbmV3IFRlcm0oXCJbXVwiLCBbXSldICkgKSwgXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gVEFVIFBST0xPRyBJTkZPUk1BVElPTlxyXG5cclxuXHRcdC8vIHZlcnNpb24vMFxyXG5cdFx0XCJ2ZXJzaW9uLzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBtc2cgPSBcIldlbGNvbWUgdG8gVGF1IFByb2xvZyB2ZXJzaW9uIFwiICsgdmVyc2lvbi5tYWpvciArIFwiLlwiICsgdmVyc2lvbi5taW5vciArIFwiLlwiICsgdmVyc2lvbi5wYXRjaCArIFwiXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIlRhdSBQcm9sb2cgY29tZXMgd2l0aCBBQlNPTFVURUxZIE5PIFdBUlJBTlRZLiBUaGlzIGlzIGZyZWUgc29mdHdhcmUuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIlBsZWFzZSBydW4gPy0gbGljZW5zZS4gZm9yIGxlZ2FsIGRldGFpbHMuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIkZvciBvbmxpbmUgaGVscCBhbmQgYmFja2dyb3VuZCwgdmlzaXQgaHR0cDovdGF1LXByb2xvZy5vcmdcIjtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJ3cml0ZVwiLCBbbmV3IFRlcm0oIG1zZywgW10gKV0gKSApLCBcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbGljZW5zZS8wXHJcblx0XHRcImxpY2Vuc2UvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG1zZyA9IFwiVGF1IFByb2xvZy4gQSBQcm9sb2cgaW50ZXJwcmV0ZXIgaW4gSmF2YVNjcmlwdC5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiQ29weXJpZ2h0IChDKSAyMDE3IC0gMjAyMiBKb3PDqSBBbnRvbmlvIFJpYXphIFZhbHZlcmRlXFxuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIlJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCIyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIjMuIE5laXRoZXIgdGhlIG5hbWUgb2YgdGhlIGNvcHlyaWdodCBob2xkZXIgbm9yIHRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cXG5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cXG5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgQlNEIDMtQ2xhdXNlIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uIElmIG5vdCwgc2VlIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXCI7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwid3JpdGVcIiwgW25ldyBUZXJtKCBtc2csIFtdICldICkgKSwgXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9XHJcblxyXG5cdH0sIFwiYWxsXCIsIHtcclxuXHRcdG1ldGFfcHJlZGljYXRlczoge1xyXG5cdFx0XHQvLyAnJGZpbmRhbGwnKD8sIDAsIC0sID8pXHJcblx0XHRcdFwiJGZpbmRhbGwvNFwiOiBuZXcgVGVybShcIiRmaW5kYWxsXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBOdW0oMCwgZmFsc2UpLCBuZXcgVGVybShcIi1cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyAnJGJhZ29mJyg/LCBeLCAtKVxyXG5cdFx0XHRcIiRiYWdvZi8zXCI6IG5ldyBUZXJtKFwiJGJhZ29mXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiXlwiKSwgbmV3IFRlcm0oXCItXCIpXSksXHJcblx0XHRcdC8vICckc2V0b2YnKD8sIF4sIC0pXHJcblx0XHRcdFwiJHNldG9mLzNcIjogbmV3IFRlcm0oXCIkc2V0b2ZcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCJeXCIpLCBuZXcgVGVybShcIi1cIildKSxcclxuXHRcdFx0Ly8gJyRpZicoMCwgMCwgMClcclxuXHRcdFx0XCIkaWYvM1wiOiBuZXcgVGVybShcIiRpZlwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyAoMDswKVxyXG5cdFx0XHRcIjsvMlwiOiBuZXcgVGVybShcIjtcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyAoMC0+MClcclxuXHRcdFx0XCItPi8yXCI6IG5ldyBUZXJtKFwiLT5cIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyAoMC0+MClcclxuXHRcdFx0XCIqLT4vMlwiOiBuZXcgVGVybShcIiotPlwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIChcXCswKVxyXG5cdFx0XHRcIlxcXFwrLzFcIjogbmV3IFRlcm0oXCJcXFxcK1wiLCBbbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gYWJvbGlzaCg6KVxyXG5cdFx0XHRcImFib2xpc2gvMVwiOiBuZXcgVGVybShcImFib2xpc2hcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBhc3NlcnRhKDopXHJcblx0XHRcdFwiYXNzZXJ0YS8xXCI6IG5ldyBUZXJtKFwiYXNzZXJ0YVwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIGFzc2VydHooOilcclxuXHRcdFx0XCJhc3NlcnR6LzFcIjogbmV3IFRlcm0oXCJhc3NlcnR6XCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gYmFnb2YoPywgXiwgLSlcclxuXHRcdFx0XCJiYWdvZi8zXCI6IG5ldyBUZXJtKFwiYmFnb2ZcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCJeXCIpLCBuZXcgVGVybShcIi1cIildKSxcclxuXHRcdFx0Ly8gY2FsbCgwKVxyXG5cdFx0XHRcImNhbGwvMVwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIGNhbGwoMSwgPylcclxuXHRcdFx0XCJjYWxsLzJcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDEsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoMiwgPywgPylcclxuXHRcdFx0XCJjYWxsLzNcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDIsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCgzLCA/LCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvNFwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oMywgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoNCwgPywgPywgPywgPylcclxuXHRcdFx0XCJjYWxsLzVcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDQsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoNSwgPywgPywgPywgPywgPylcclxuXHRcdFx0XCJjYWxsLzZcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDUsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCg2LCA/LCA/LCA/LCA/LCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvN1wiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oNiwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoNywgPywgPywgPywgPywgPywgPywgPylcclxuXHRcdFx0XCJjYWxsLzhcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDYsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGxfY2xlYW51cCgwLCAwKVxyXG5cdFx0XHRcImNhbGxfY2xlYW51cC8yXCI6IG5ldyBUZXJtKFwiY2FsbF9jbGVhbnVwXCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gY2F0Y2goMCwgPywgMClcclxuXHRcdFx0XCJjYXRjaC8zXCI6IG5ldyBUZXJtKFwiY2F0Y2hcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIGNvbnN1bHQoOilcclxuXHRcdFx0XCJjb25zdWx0LzFcIjogbmV3IFRlcm0oXCJjb25zdWx0XCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gY2xhdXNlKDosID8pXHJcblx0XHRcdFwiY2xhdXNlLzJcIjogbmV3IFRlcm0oXCJjbGF1c2VcIiwgW25ldyBUZXJtKFwiOlwiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGN1cnJlbnRfcHJlZGljYXRlKD8sIDopXHJcblx0XHRcdFwiY3VycmVudF9wcmVkaWNhdGUvMlwiOiBuZXcgVGVybShcImN1cnJlbnRfcHJlZGljYXRlXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBmaW5kYWxsKD8sIDAsIC0pXHJcblx0XHRcdFwiZmluZGFsbC8zXCI6IG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IFRlcm0oXCItXCIpXSksXHJcblx0XHRcdC8vIGZpbmRhbGwoPywgMCwgLSwgPylcclxuXHRcdFx0XCJmaW5kYWxsLzRcIjogbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBOdW0oMCwgZmFsc2UpLCBuZXcgVGVybShcIi1cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBmb3JhbGwoMCwgMClcclxuXHRcdFx0XCJmb3JhbGwvMlwiOiBuZXcgVGVybShcImZvcmFsbFwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIGxpc3RpbmcoOilcclxuXHRcdFx0XCJsaXN0aW5nLzFcIjogbmV3IFRlcm0oXCJsaXN0aW5nXCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gb25jZSgwKVxyXG5cdFx0XHRcIm9uY2UvMVwiOiBuZXcgVGVybShcIm9uY2VcIiwgW25ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIHBocmFzZSg6LCA/KVxyXG5cdFx0XHRcInBocmFzZS8yXCI6IG5ldyBUZXJtKFwicGhyYXNlXCIsIFtuZXcgVGVybShcIjpcIiksbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIHBocmFzZSg6LCA/LCA/KVxyXG5cdFx0XHRcInBocmFzZS8zXCI6IG5ldyBUZXJtKFwicGhyYXNlXCIsIFtuZXcgVGVybShcIjpcIiksbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gcmV0cmFjdCg6KVxyXG5cdFx0XHRcInJldHJhY3QvMVwiOiBuZXcgVGVybShcInJldHJhY3RcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyByZXRyYWN0YWxsKDopXHJcblx0XHRcdFwicmV0cmFjdGFsbC8xXCI6IG5ldyBUZXJtKFwicmV0cmFjdGFsbFwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIHNldHVwX2NhbGxfY2xlYW51cCgwLCAwLCAwKVxyXG5cdFx0XHRcInNldHVwX2NhbGxfY2xlYW51cC8zXCI6IG5ldyBUZXJtKFwic2V0dXBfY2FsbF9jbGVhbnVwXCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIHNldG9mKD8sIF4sIC0pXHJcblx0XHRcdFwic2V0b2YvM1wiOiBuZXcgVGVybShcInNldG9mXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiXlwiKSwgbmV3IFRlcm0oXCItXCIpXSlcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0aWYoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICkge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBwbDtcclxuXHR9IGVsc2Uge1xyXG5cdFx0d2luZG93LnBsID0gcGw7XHJcblx0fVxyXG5cdFxyXG59KSgpO1xyXG4iLCJ2YXIgcGw7XHJcbihmdW5jdGlvbihwbCkge1xyXG5cclxuXHQvLyBFeHRlbmQgVGF1IFByb2xvZyBwcm90b3R5cGVzXHJcblx0dmFyIGV4dGVuZCA9IGZ1bmN0aW9uKHBsKSB7XHJcblxyXG5cdFx0Ly8gQ29uc3VsdCBhIHByb2dyYW0gZnJvbSBhIHN0cmluZ1xyXG5cdFx0cGwudHlwZS5TZXNzaW9uLnByb3RvdHlwZS5wcm9taXNlQ29uc3VsdCA9IGZ1bmN0aW9uKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGhyZWFkLnByb21pc2VDb25zdWx0KHByb2dyYW0sIG9wdGlvbnMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRwbC50eXBlLlRocmVhZC5wcm90b3R5cGUucHJvbWlzZUNvbnN1bHQgPSBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XHJcblx0XHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHRcdFx0dmFyIG9wdHMgPSB7fTtcclxuXHRcdFx0XHRvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0XHRcdG9wdHMuY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHRcdG9wdHMudGV4dCA9IG9wdGlvbnMudGV4dDtcclxuXHRcdFx0XHRvcHRzLmh0bWwgPSBvcHRpb25zLmh0bWw7XHJcblx0XHRcdFx0b3B0cy51cmwgPSBvcHRpb25zLnVybDtcclxuXHRcdFx0XHRvcHRzLmZpbGUgPSBvcHRpb25zLmZpbGU7XHJcblx0XHRcdFx0b3B0cy5zY3JpcHQgPSBvcHRpb25zLnNjcmlwdDtcclxuXHRcdFx0XHRvcHRzLnN1Y2Nlc3MgPSByZXNvbHZlO1xyXG5cdFx0XHRcdG9wdHMuZXJyb3IgPSByZWplY3Q7XHJcblx0XHRcdFx0dGhyZWFkLmNvbnN1bHQocHJvZ3JhbSwgb3B0cyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBRdWVyeSBnb2FsIGZyb20gYSBzdHJpbmcgKHdpdGhvdXQgPy0pXHJcblx0XHRwbC50eXBlLlNlc3Npb24ucHJvdG90eXBlLnByb21pc2VRdWVyeSA9IGZ1bmN0aW9uKHN0cmluZykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHJvbWlzZVF1ZXJ5KHN0cmluZyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHBsLnR5cGUuVGhyZWFkLnByb3RvdHlwZS5wcm9taXNlUXVlcnkgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdFx0XHR0aHJlYWQucXVlcnkoc3RyaW5nLCB7XHJcblx0XHRcdFx0XHRzdWNjZXNzOiByZXNvbHZlLFxyXG5cdFx0XHRcdFx0ZXJyb3I6IHJlamVjdFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRmluZCBuZXh0IGNvbXB1dGVkIGFuc3dlclxyXG5cdFx0cGwudHlwZS5TZXNzaW9uLnByb3RvdHlwZS5wcm9taXNlQW5zd2VyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRocmVhZC5wcm9taXNlQW5zd2VyKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHBsLnR5cGUuVGhyZWFkLnByb3RvdHlwZS5wcm9taXNlQW5zd2VyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHRcdFx0dGhyZWFkLmFuc3dlcih7XHJcblx0XHRcdFx0XHRzdWNjZXNzOiByZXNvbHZlLFxyXG5cdFx0XHRcdFx0ZmFpbDogcmVzb2x2ZSxcclxuXHRcdFx0XHRcdGVycm9yOiByZWplY3QsXHJcblx0XHRcdFx0XHRsaW1pdDogcmVqZWN0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBGaW5kIGFsbCBjb21wdXRlZCBhbnN3ZXJzIChhc3luY2hyb25vdXMgZ2VuZXJhdG9yIGZ1bmN0aW9uKVxyXG5cdFx0cGwudHlwZS5TZXNzaW9uLnByb3RvdHlwZS5wcm9taXNlQW5zd2VycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHJvbWlzZUFuc3dlcnMoKTtcclxuXHRcdH07XHJcblx0XHRwbC50eXBlLlRocmVhZC5wcm90b3R5cGUucHJvbWlzZUFuc3dlcnMgPSBhc3luYyBmdW5jdGlvbiooKSB7XHJcblx0XHRcdHdoaWxlKHRydWUpIHtcclxuXHRcdFx0XHR2YXIgYW5zd2VyID0gYXdhaXQgdGhpcy5wcm9taXNlQW5zd2VyKCk7XHJcblx0XHRcdFx0aWYoYW5zd2VyICE9PSBmYWxzZSlcclxuXHRcdFx0XHRcdHlpZWxkIGFuc3dlcjtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdH1cclxuXHJcblx0aWYodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocCkge1xyXG5cdFx0XHRwbCA9IHA7XHJcblx0XHRcdGV4dGVuZChwbCk7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRleHRlbmQocGwpO1xyXG5cdH1cclxuXHJcbn0pKHBsKTsiLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJiaWdcIixcbiAgICBcInNtYWxsXCIsXG4gICAgXCJoZWxwZnVsXCIsXG4gICAgXCJyZWRcIixcbiAgICBcImJsYWNrXCIsXG4gICAgXCJncmVhdFwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiaXNcIixcbiAgICBcImFyZVwiLFxuICAgIFwiYmVcIlxuXSIsImV4cG9ydCBkZWZhdWx0W1xuICAgIFwidGhlXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJzb21lXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJkb1wiLFxuICAgIFwiZG9lc1wiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiYVwiLFxuICAgIFwiYW5cIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImV4aXN0XCIsXG4gICAgXCJleGlzdHNcIixcbiAgICBcInJ1blwiLFxuICAgIFwiZ3Jvd1wiLFxuICAgIFwiZGllXCIsXG4gICAgXCJsaXZlXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJlYXRcIixcbiAgICBcImRyaW5rXCIsXG4gICAgXCJ3YXRjaFwiLFxuICAgIFwibWFrZVwiLFxuICAgIFwiaGl0XCIsXG4gICAgXCJjbGlja1wiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZG9lc24ndFwiLFxuICAgIFwiZG9lcyBub3RcIixcbiAgICAnbm90JyxcbiAgICBcImRvbid0XCIsXG4gICAgJ2RvIG5vdCdcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJhbmRcIixcbiAgICBcIm9yXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJjYXRcIixcbiAgICBcIm1hdFwiLFxuICAgIFwidGFibGVcIixcbiAgICBcImRvZ1wiLFxuICAgIFwibm9kZWpzXCIsXG4gICAgXCJjb2xvclwiLFxuICAgIFwiYnV0dG9uXCIsXG4gICAgXCJkaXZcIixcbiAgICBcInByZXNpZGVudFwiLFxuICAgIFwidHJ1bXBcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcInRvXCIsXG4gICAgXCJ3aXRoXCIsXG4gICAgXCJmcm9tXCIsXG4gICAgXCJvZlwiLFxuICAgIFwib3ZlclwiLFxuICAgIFwib25cIixcbiAgICBcImF0XCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJ0aGF0XCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJpZlwiLFxuICAgIFwid2hlblwiLFxuICAgIFwiYmVjYXVzZVwiLFxuICAgIFwid2hpbGVcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcInRoZW5cIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImV2ZXJ5XCIsXG4gICAgXCJhbGxcIixcbiAgICBcImVhY2hcIlxuXSIsImltcG9ydCB7IFRvUHJvbG9nQXJncyB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgeyBDbGF1c2UsIGNsYXVzZU9mLCBnZXRSYW5kb21JZCwgSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBQaHJhc2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvUGhyYXNlXCI7XG5pbXBvcnQgUHJlcG9zaXRpb24gZnJvbSBcIi4uL3Rva2Vucy9QcmVwb3NpdGlvblwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4vTm91blBocmFzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wbGVtZW50IGltcGxlbWVudHMgUGhyYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHByZXBvc2l0aW9uOiBQcmVwb3NpdGlvbiwgcmVhZG9ubHkgbm91blBocmFzZTogTm91blBocmFzZSkge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7IC8vIHByZXBvc2l0aW9uKGFyZ3Muc3ViamVjdCwgWSkgKyBub3VucGhyYXNlLnRvUHJvbG9nKHN1YmplY3Q9WSlcblxuICAgICAgICBjb25zdCBzdWJqSWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyAoKCk6IElkID0+IHsgdGhyb3cgbmV3IEVycm9yKCd1bmRlZmluZWQgc3ViamVjdCBpZCcpIH0pKClcbiAgICAgICAgY29uc3QgbmV3SWQgPSBnZXRSYW5kb21JZCgpXG5cbiAgICAgICAgcmV0dXJuIGNsYXVzZU9mKHRoaXMucHJlcG9zaXRpb24uc3RyaW5nLCBzdWJqSWQsIG5ld0lkKVxuICAgICAgICAgICAgLmFuZCh0aGlzLm5vdW5QaHJhc2UudG9DbGF1c2UoeyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBuZXdJZCB9IH0pKVxuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxufSIsImltcG9ydCB7IFRvUHJvbG9nQXJncyB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgeyBDbGF1c2UgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IENvcHVsYSBmcm9tIFwiLi4vdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tIFwiLi4vdG9rZW5zL1JlbGF0aXZlUHJvbm91blwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4vTm91blBocmFzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSBpbXBsZW1lbnRzIFN1Ym9yZGluYXRlQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHJlbHByb246IFJlbGF0aXZlUHJvbm91biwgcmVhZG9ubHkgcHJlZGljYXRlOiBOb3VuUGhyYXNlLCByZWFkb25seSBjb3B1bGE6IENvcHVsYSkge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZS50b0NsYXVzZSh7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IGFyZ3M/LnJvbGVzPy5zdWJqZWN0IH0gfSlcbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG59IiwiaW1wb3J0IFBocmFzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9QaHJhc2VcIjtcbmltcG9ydCBBZGplY3RpdmUgZnJvbSBcIi4uL3Rva2Vucy9BZGplY3RpdmVcIjtcbmltcG9ydCBBcnRpY2xlIGZyb20gXCIuLi90b2tlbnMvQXJ0aWNsZVwiO1xuaW1wb3J0IE5vdW4gZnJvbSBcIi4uL3Rva2Vucy9Ob3VuXCI7XG5pbXBvcnQgUXVhbnRpZmllciBmcm9tIFwiLi4vdG9rZW5zL1F1YW50aWZpZXJcIjtcbmltcG9ydCBDb21wbGVtZW50IGZyb20gXCIuL0NvbXBsZW1lbnRcIjtcbmltcG9ydCBTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgZ2V0UmFuZG9tSWQsIGNsYXVzZU9mLCBlbXB0eUNsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3VuUGhyYXNlIGltcGxlbWVudHMgUGhyYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGFkamVjdGl2ZXM6IEFkamVjdGl2ZVtdLFxuICAgICAgICByZWFkb25seSBjb21wbGVtZW50czogQ29tcGxlbWVudFtdLFxuICAgICAgICByZWFkb25seSBub3VuPzogTm91bixcbiAgICAgICAgcmVhZG9ubHkgcXVhbnRpZmllcj86IFF1YW50aWZpZXIsXG4gICAgICAgIHJlYWRvbmx5IGFydGljbGU/OiBBcnRpY2xlLFxuICAgICAgICByZWFkb25seSBzdWJvcmRDbGF1c2U/OiBTdWJvcmRpbmF0ZUNsYXVzZSkge1xuXG4gICAgfVxuXG4gICAgaXNVbmlRdWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVhbnRpZmllcj8uaXNVbml2ZXJzYWwoKSA/PyBmYWxzZVxuICAgIH1cblxuICAgIHRvQ2xhdXNlKGFyZ3M/OiBUb1Byb2xvZ0FyZ3MpOiBDbGF1c2Uge1xuXG4gICAgICAgIGNvbnN0IHN1YmplY3RJZCA9IGFyZ3M/LnJvbGVzPy5zdWJqZWN0ID8/IGdldFJhbmRvbUlkKClcbiAgICAgICAgY29uc3QgbmV3QXJncyA9IHsgLi4uYXJncywgcm9sZXM6IHsgc3ViamVjdDogc3ViamVjdElkIH0gfVxuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAuYWRqZWN0aXZlc1xuICAgICAgICAgICAgLm1hcChhID0+IGEuc3RyaW5nKVxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLm5vdW4gPyBbdGhpcy5ub3VuLnN0cmluZ10gOiBbXSlcbiAgICAgICAgICAgIC5tYXAocCA9PiBjbGF1c2VPZihwLCBzdWJqZWN0SWQpKVxuICAgICAgICAgICAgLnJlZHVjZSgoYzEsIGMyKSA9PiBjMS5hbmQoYzIpLCBlbXB0eUNsYXVzZSgpKVxuICAgICAgICAgICAgLmFuZCh0aGlzLmNvbXBsZW1lbnRzLm1hcChjID0+IGMudG9DbGF1c2UobmV3QXJncykpLnJlZHVjZSgoYzEsIGMyKSA9PiBjMS5hbmQoYzIpLCBlbXB0eUNsYXVzZSgpKSlcbiAgICAgICAgICAgIC5hbmQodGhpcy5zdWJvcmRDbGF1c2U/LnRvQ2xhdXNlKG5ld0FyZ3MpID8/IGVtcHR5Q2xhdXNlKCkpXG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG59IiwiaW1wb3J0IENvbXBvdW5kU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29tcG91bmRTZW50ZW5jZVwiO1xuaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBTaW1wbGVTZW50ZW5jZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TaW1wbGVTZW50ZW5jZVwiO1xuaW1wb3J0IFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiBmcm9tIFwiLi4vdG9rZW5zL1N1Ym9yZGluYXRpbmdDb25qdW5jdGlvblwiO1xuXG4vKipcbiAqIEEgc2VudGVuY2UgdGhhdCByZWxhdGVzIHR3byBzaW1wbGUgc2VudGVuY2VzIGh5cG90YWN0aWNhbGx5LCBpbiBhIFxuICogY29uZGl0aW9uLW91dGNvbWUgcmVsYXRpb25zaGlwLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wbGV4U2VudGVuY2UgaW1wbGVtZW50cyBDb21wb3VuZFNlbnRlbmNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNvbmRpdGlvbjogU2ltcGxlU2VudGVuY2UsXG4gICAgICAgIHJlYWRvbmx5IG91dGNvbWU6IFNpbXBsZVNlbnRlbmNlLFxuICAgICAgICByZWFkb25seSBzdWJjb25qOiBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24pIHtcblxuICAgIH1cblxuICAgIHRvQ2xhdXNlKGFyZ3M/OiBUb1Byb2xvZ0FyZ3MpOiBDbGF1c2Uge1xuICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyBnZXRSYW5kb21JZCgpXG4gICAgICAgIGNvbnN0IG5ld0FyZ3MgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IHN1YmplY3RJZCB9IH1cblxuICAgICAgICAvL1RPRE86IHRoaXMgaXMgV1JPTkcsIHN1YmplY3Qgb2YgY29uZGl0aW9uIG1heSBOT1QgYWx3YXlzIGJlIHRoZSBzdWJqZWN0IG9mIHRoZSBvdXRjb21lXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uLnRvQ2xhdXNlKG5ld0FyZ3MpXG4gICAgICAgIGNvbnN0IG91dGNvbWUgPSB0aGlzLm91dGNvbWUudG9DbGF1c2UobmV3QXJncylcblxuICAgICAgICByZXR1cm4gY29uZGl0aW9uLmltcGxpZXMob3V0Y29tZSlcbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgQmluYXJ5UXVlc3Rpb24gZnJvbSBcIi4uL2ludGVyZmFjZXMvQmluYXJ5UXVlc3Rpb25cIjtcbmltcG9ydCB7IFRvUHJvbG9nQXJncyB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgeyBDbGF1c2UsIGdldFJhbmRvbUlkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi4vcGhyYXNlcy9Ob3VuUGhyYXNlXCI7XG5pbXBvcnQgQ29wdWxhIGZyb20gXCIuLi90b2tlbnMvQ29wdWxhXCI7XG5pbXBvcnQgQ29wdWxhU2VudGVuY2UgZnJvbSBcIi4vQ29wdWxhU2VudGVuY2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29wdWxhUXVlc3Rpb24gaW1wbGVtZW50cyBCaW5hcnlRdWVzdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzdWJqZWN0OiBOb3VuUGhyYXNlLCByZWFkb25seSBwcmVkaWNhdGU6IE5vdW5QaHJhc2UsIHJlYWRvbmx5IGNvcHVsYTogQ29wdWxhKSB7XG5cbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzKTogQ2xhdXNlIHtcblxuICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyBnZXRSYW5kb21JZCh7IGFzVmFyOiB0aGlzLnN1YmplY3QuaXNVbmlRdWFudCgpIH0pXG4gICAgICAgIGNvbnN0IG5ld0FyZ3MgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IHN1YmplY3RJZCB9IH1cblxuICAgICAgICAvL1RPRE86IGluIGNhc2Ugb2YgYSB1bml2ZXJzYWxseSBxdWFudGlmaWVkIHF1ZXN0aW9uIGVnOiBcImFyZSBhbGwgY2F0cyBzbWFydD9cIiB0aGUgcHJvbG9nXG4gICAgICAgIC8vIHByb2R1Y2VkIHNob3VsZCBOT1QgYmUgYW4gaW1wbGljYXRpb24sIGJ1dCByYXRoZXIgYSBjaGVjayB0aGF0IGFsbCBjYXRzIGFyZSBzbWFydC5cblxuICAgICAgICByZXR1cm4gbmV3IENvcHVsYVNlbnRlbmNlKHRoaXMuc3ViamVjdCwgdGhpcy5jb3B1bGEsIHRoaXMucHJlZGljYXRlKS50b0NsYXVzZShuZXdBcmdzKVxuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxufSIsImltcG9ydCB7IFRvUHJvbG9nQXJncyB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgeyBDbGF1c2UsIGdldFJhbmRvbUlkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgU2ltcGxlU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvU2ltcGxlU2VudGVuY2VcIjtcbmltcG9ydCBOb3VuUGhyYXNlIGZyb20gXCIuLi9waHJhc2VzL05vdW5QaHJhc2VcIjtcbmltcG9ydCBDb3B1bGEgZnJvbSBcIi4uL3Rva2Vucy9Db3B1bGFcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vdG9rZW5zL05lZ2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHVsYVNlbnRlbmNlIGltcGxlbWVudHMgU2ltcGxlU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSwgcmVhZG9ubHkgY29wdWxhOiBDb3B1bGEsIHJlYWRvbmx5IHByZWRpY2F0ZTogTm91blBocmFzZSwgcmVhZG9ubHkgbmVnYXRpb24/OiBOZWdhdGlvbikge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoeyBhc1ZhcjogdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSB9KVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMuc3ViamVjdC50b0NsYXVzZShuZXdBcmdzKVxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnByZWRpY2F0ZS50b0NsYXVzZShuZXdBcmdzKS5jb3B5KHsgbmVnYXRlOiAhIXRoaXMubmVnYXRpb24gfSlcblxuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSA/XG4gICAgICAgICAgICBzdWJqZWN0LmltcGxpZXMocHJlZGljYXRlKSA6XG4gICAgICAgICAgICBzdWJqZWN0LmFuZChwcmVkaWNhdGUsIHsgYXNSaGVtZTogdHJ1ZSB9KVxuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgY2xhdXNlT2YsIGdldFJhbmRvbUlkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgVmVyYlNlbnRlbmNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1ZlcmJTZW50ZW5jZVwiO1xuaW1wb3J0IENvbXBsZW1lbnQgZnJvbSBcIi4uL3BocmFzZXMvQ29tcGxlbWVudFwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IElWZXJiIGZyb20gXCIuLi90b2tlbnMvSVZlcmJcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vdG9rZW5zL05lZ2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEludHJhbnNpdGl2ZVNlbnRlbmNlIGltcGxlbWVudHMgVmVyYlNlbnRlbmNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHN1YmplY3Q6IE5vdW5QaHJhc2UsXG4gICAgICAgIHJlYWRvbmx5IGl2ZXJiOiBJVmVyYixcbiAgICAgICAgcmVhZG9ubHkgY29tcGxlbWVudHM6IENvbXBsZW1lbnRbXSxcbiAgICAgICAgcmVhZG9ubHkgbmVnYXRpb24/OiBOZWdhdGlvbikge1xuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoeyBhc1ZhcjogdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSB9KVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgY29uc3QgdGhlbWUgPSB0aGlzLnN1YmplY3QudG9DbGF1c2UobmV3QXJncylcbiAgICAgICAgY29uc3QgcmhlbWUgPSBjbGF1c2VPZih0aGlzLml2ZXJiLnN0cmluZywgc3ViamVjdElkKVxuICAgICAgICAgICAgLmFuZCh0aGlzLmNvbXBsZW1lbnRzLm1hcChjID0+IGMudG9DbGF1c2UobmV3QXJncykpLnJlZHVjZSgoYzEsIGMyKSA9PiBjMS5hbmQoYzIpKSlcblxuICAgICAgICByZXR1cm4gdGhlbWUuYW5kKHJoZW1lLCB7IGFzUmhlbWU6IHRydWUgfSlcbiAgICB9XG5cbn1cblxuIiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IFZlcmJTZW50ZW5jZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9WZXJiU2VudGVuY2VcIjtcbmltcG9ydCBDb21wbGVtZW50IGZyb20gXCIuLi9waHJhc2VzL0NvbXBsZW1lbnRcIjtcbmltcG9ydCBOb3VuUGhyYXNlIGZyb20gXCIuLi9waHJhc2VzL05vdW5QaHJhc2VcIjtcbmltcG9ydCBNVmVyYiBmcm9tIFwiLi4vdG9rZW5zL01WZXJiXCI7XG5pbXBvcnQgTmVnYXRpb24gZnJvbSBcIi4uL3Rva2Vucy9OZWdhdGlvblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb25vdHJhbnNpdGl2ZVNlbnRlbmNlIGltcGxlbWVudHMgVmVyYlNlbnRlbmNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHN1YmplY3Q6IE5vdW5QaHJhc2UsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgbXZlcmI6IE1WZXJiLFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5IG9iamVjdDogTm91blBocmFzZSxcbiAgICAgICAgICAgICAgICByZWFkb25seSBjb21wbGVtZW50czogQ29tcGxlbWVudFtdLFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5IG5lZ2F0aW9uPzogTmVnYXRpb24pIHtcblxuICAgIH1cbiAgICBcbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyB8IHVuZGVmaW5lZCk6IENsYXVzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1ldGhvZCBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH1cbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQWJzdHJhY3RUb2tlbiBpbXBsZW1lbnRzIFRva2Vue1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3RyaW5nOnN0cmluZyl7XG5cbiAgICB9ICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBZGplY3RpdmUgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBkZWZpbml0ZV9hcnRpY2xlcyBmcm9tIFwiLi4vLi4vLi4vcmVzL3Rva2Vucy9kZWZpbml0ZV9hcnRpY2xlc1wiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcnRpY2xlIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcblxuICAgIGlzRGVmaW5pdGUoKXtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRlX2FydGljbGVzLmluY2x1ZGVzKHRoaXMuc3RyaW5nKVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCl7XG4gICAgICAgIHJldHVybiBgQXJ0aWNsZSgke3RoaXMuc3RyaW5nfSwgaXNEZWZpbml0ZT0ke3RoaXMuaXNEZWZpbml0ZSgpfSlgXG4gICAgfVxuXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHVsYSBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZ1bGxTdG9wIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFZlcmIgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJVmVyYiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1WZXJiIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmVnYXRpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9uU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcblxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb3VuIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJlcG9zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgICAgIFxufSIsImltcG9ydCBleGlzdGVudGlhbF9xdWFudGlmaWVycyBmcm9tIFwiLi4vLi4vLi4vcmVzL3Rva2Vucy9leGlzdGVudGlhbF9xdWFudGlmaWVyc1wiO1xuaW1wb3J0IHVuaXZlcnNhbF9xdWFudGlmaWVycyBmcm9tIFwiLi4vLi4vLi4vcmVzL3Rva2Vucy91bml2ZXJzYWxfcXVhbnRpZmllcnNcIjtcbmltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFudGlmaWVyIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbiAgICBpc1VuaXZlcnNhbCgpe1xuICAgICAgICByZXR1cm4gdW5pdmVyc2FsX3F1YW50aWZpZXJzLmluY2x1ZGVzKHRoaXMuc3RyaW5nKVxuICAgIH1cblxuICAgIGlzRXhpc3RlbnRpYWwoKXtcbiAgICAgICAgcmV0dXJuIGV4aXN0ZW50aWFsX3F1YW50aWZpZXJzLmluY2x1ZGVzKHRoaXMuc3RyaW5nKVxuICAgIH1cbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVsYXRpdmVQcm9ub3VuIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGhlbiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgIFxufSIsImltcG9ydCB7IENsYXVzZSwgTWFwLCB0b1ZhciB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuL0JyYWluXCI7XG5cbi8qKlxuICogRW50aXRpZXMgaW4gYSBuZXcgc2VudGVuY2UgcG90ZW50aWFsbHkgcG9pbnQgdG8gZXhpc3RpbmcgZW50aXRpZXNcbiAqIGluIHRoZSB1bml2ZXJzZSAoaWU6IHtAbGluayBCcmFpbn0pLiB7QGxpbmsgQW5hcGhvcmF9IHJlc29sdmVzIHRoZSBhbmFwaG9yYS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBbmFwaG9yYSB7XG4gICAgbWFwVG8odW5pdmVyc2U6IEJyYWluKTogUHJvbWlzZTxNYXA+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbmFwaG9yYShjbGF1c2U6IENsYXVzZSk6IEFuYXBob3JhIHtcbiAgICByZXR1cm4gbmV3IEJhc2VBbmFwaG9yYShjbGF1c2UpXG59XG5cbmNsYXNzIEJhc2VBbmFwaG9yYSBpbXBsZW1lbnRzIEFuYXBob3JhIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNsYXVzZTogQ2xhdXNlKSB7XG5cbiAgICB9XG5cbiAgICBhc3luYyBtYXBUbyh1bml2ZXJzZTogQnJhaW4pOiBQcm9taXNlPE1hcD4ge1xuXG4gICAgICAgIGNvbnN0IHRoZW1lRW50cyA9IHRoaXMuY2xhdXNlLnRoZW1lLmVudGl0aWVzXG5cbiAgICAgICAgLy8gZ2V0IGRlc2NyaXB0aW9ucyBvZiBlbnRpdGllcyBpbiB0aGVtZSBvbWl0dGluZyByZWxhdGlvbnMgd2l0aCBlbnRpdGllcyBpbiByaGVtZVxuICAgICAgICBjb25zdCB0aGVtZURlc2NzID0gdGhpcy5jbGF1c2UudGhlbWUuZmxhdExpc3QoKVxuICAgICAgICAgICAgLmZpbHRlcihlID0+ICFlLmlzSW1wbHkpXG5cbiAgICAgICAgLy8gZ2V0IGRlc2NyaXB0aW9ucyBvZiBlbnRpdGllcyBpbiByaGVtZSBvbWl0dGluZyByZWxhdGlvbnMgd2l0aCBlbnRpdGllcyBpbiB0aGVtZVxuICAgICAgICBjb25zdCByaGVtZURlc2NzID0gdGhpcy5jbGF1c2UucmhlbWUuZmxhdExpc3QoKVxuICAgICAgICAgICAgLmZpbHRlcihjID0+IHRoZW1lRW50cy5ldmVyeShlID0+ICFjLmVudGl0aWVzLmluY2x1ZGVzKGUpKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZSA9PiAhZS5pc0ltcGx5KVxuXG4gICAgICAgIGNvbnN0IG1hcFRvVmFyID0gdGhpcy5jbGF1c2UuZW50aXRpZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoeyBbZV06IHRvVmFyKGUpIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICBjb25zdCByZXZlcnNlTWFwVG9WYXIgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobWFwVG9WYXIpLm1hcChlID0+IFtlWzFdLCBlWzBdXSkpXG5cbiAgICAgICAgY29uc3QgYmlnRGVzY0NsYXVzZSA9IHRoZW1lRGVzY3NcbiAgICAgICAgICAgIC5jb25jYXQocmhlbWVEZXNjcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKGMxLCBjMikgPT4gYzEuYW5kKGMyKSlcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBtYXBUb1ZhciB9KVxuXG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBhd2FpdCB1bml2ZXJzZS5xdWVyeShiaWdEZXNjQ2xhdXNlKSBhcyBNYXBbXVxuICAgICAgICBjb25zdCBjaG9zZW4gPSBjYW5kaWRhdGVzWzBdID8/IHt9IC8vVE9ETzogYmV0dGVyIGNyaXRlcmlvbiAhISFcblxuICAgICAgICBjb25zdCBhbmFwaG9yYSA9IE9iamVjdFxuICAgICAgICAgICAgLmtleXMoY2hvc2VuKVxuICAgICAgICAgICAgLm1hcChrID0+ICh7IFtyZXZlcnNlTWFwVG9WYXJba11dOiBjaG9zZW5ba10gPz8gcmV2ZXJzZU1hcFRvVmFyW2tdIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSwge30pXG5cbiAgICAgICAgcmV0dXJuIGFuYXBob3JhXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2xhdXNlLCBNYXAgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIlxuaW1wb3J0IFByb2xvZ0JyYWluIGZyb20gXCIuL1Byb2xvZ0JyYWluXCJcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIEJyYWlue1xuICAgIHF1ZXJ5KHF1ZXJ5OkNsYXVzZSk6IFByb21pc2U8TWFwW10gfCBib29sZWFuPlxuICAgIGFzc2VydChjb2RlOkNsYXVzZSk6UHJvbWlzZTx2b2lkPlxuICAgIGV4ZWN1dGUobmF0bGFuZzpzdHJpbmcpOlByb21pc2U8TWFwW10gfCBib29sZWFuPlxuICAgIC8vIGNsb25lKCk6QnJhaW5cbiAgICAvLyBhZGRMaXN0ZW5lcihlbGVtZW50Om51bWJlciwgZXZlbnQ6c3RyaW5nLCBjYWxsYmFjazooZXZlbnQ6RXZlbnQpPT52b2lkKTp2b2lkXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcmFpbigpOlByb21pc2U8QnJhaW4+eyAvLyBhc3luYyBkdWUgdG8gcG9zc2libGUgaW5pdCBwaGFzZSAoaW4gdGhlIGZ1dHVyZSlcbiAgICByZXR1cm4gbmV3IFByb2xvZ0JyYWluKClcbn0iLCJpbXBvcnQgeyBDbGF1c2UsIE1hcCwgdG9WYXIgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCB7IGdldFBhcnNlciB9IGZyb20gXCIuLi9wYXJzZXIvUGFyc2VyXCI7XG5pbXBvcnQgUHJvbG9nLCB7IGdldFByb2xvZyB9IGZyb20gXCIuLi9wcm9sb2cvUHJvbG9nXCI7XG5pbXBvcnQgQnJhaW4gZnJvbSBcIi4vQnJhaW5cIjtcbmltcG9ydCB7IGdldEFuYXBob3JhIH0gZnJvbSBcIi4vQW5hcGhvcmFcIjtcbmltcG9ydCBDb25zdGl0dWVudCBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbG9nQnJhaW4gaW1wbGVtZW50cyBCcmFpbiB7XG5cbiAgICByZWFkb25seSBrYjogUHJvbG9nXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5rYiA9IGdldFByb2xvZygpXG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZShuYXRsYW5nOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4gfCBNYXBbXT4ge1xuXG4gICAgICAgIGxldCB4OiBib29sZWFuIHwgTWFwW10gPSBmYWxzZVxuXG4gICAgICAgIGZvciAoY29uc3QgYXN0IG9mIGdldFBhcnNlcihuYXRsYW5nKS5wYXJzZUFsbCgpKSB7XG4gICAgICAgICAgICB4ID0gYXdhaXQgdGhpcy5leGVjdXRlT25lKGFzdClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB4XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIGV4ZWN1dGVPbmUoYXN0OiBDb25zdGl0dWVudCkge1xuXG4gICAgICAgIGlmIChhc3QuaXNTaWRlRWZmZWN0eSkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hc3NlcnQoYXN0LnRvQ2xhdXNlKCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucXVlcnkoYXN0LnRvQ2xhdXNlKCkpXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIHF1ZXJ5KHF1ZXJ5OiBDbGF1c2UpOiBQcm9taXNlPGJvb2xlYW4gfCBNYXBbXT4ge1xuXG4gICAgICAgIGNvbnN0IG1hcFRvVmFyID0gcXVlcnkuZW50aXRpZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoeyBbZV06IHRvVmFyKGUpIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICBjb25zdCBxID0gcXVlcnlcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBtYXBUb1ZhciB9KVxuICAgICAgICAgICAgLnRvUHJvbG9nKClcbiAgICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IGAke2F9LCAke2J9YCkgKyAnLicgLy8gVE9ETzogZGVhbCB3aXRoIGRvdCBhdCBhIGxvd2VyIGxldmVsID9cblxuICAgICAgICBjb25zdCBxdWVyeVJlcyA9IGF3YWl0IHRoaXMua2IucXVlcnkocSkgYXMgTWFwW11cblxuICAgICAgICByZXR1cm4gcXVlcnlSZXMgLy9UT0RPOiBtYXliZSByZXR1cm4gY2xhdXNlIGxpc3QgaW5zdGVhZCwgd2l0aCBxdWVyeS5jb3B5KHttYXA6bWFwVG9WYXJ9KS5jb3B5KHttYXA6cXVlcnlSZXNbaV19KSAvL2ZvciBlYWNoIHF1ZXJ5UmVzXG5cbiAgICB9XG5cbiAgICBhc3luYyBhc3NlcnQoY2xhdXNlOiBDbGF1c2UpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICBjb25zdCBhbmFwaG9yYU1hcCA9IGF3YWl0IGdldEFuYXBob3JhKGNsYXVzZSkubWFwVG8odGhpcylcblxuICAgICAgICBjb25zdCB0b0JlQXNzZXJ0ZWQgPSBjbGF1c2VcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBhbmFwaG9yYU1hcCB9KVxuICAgICAgICAgICAgLnRvUHJvbG9nKClcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdG9CZUFzc2VydGVkKSB7IC8vIFRPRE86IGJ1ZyBmaW5kaW5nIG9uZSBlbnRpdHkgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMua2IuYXNzZXJ0KGMpXG4gICAgICAgIH1cblxuICAgIH1cblxufSIsImltcG9ydCB7IENsYXVzZSwgQW5kT3B0cywgQ29weU9wdHMsIElkIH0gZnJvbSBcIi4vQ2xhdXNlXCI7XG5pbXBvcnQgSW1wbHkgZnJvbSBcIi4vSW1wbHlcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5kIGltcGxlbWVudHMgQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNsYXVzZXM6IENsYXVzZVtdLCByZWFkb25seSBuZWdhdGVkID0gZmFsc2UsIHJlYWRvbmx5IGlzSW1wbHkgPSBmYWxzZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcblxuICAgICAgICByZXR1cm4gb3B0cz8uYXNSaGVtZSA/XG4gICAgICAgICAgICBuZXcgQW5kKFt0aGlzLmNvcHkoKSwgb3RoZXIuY29weSgpXSkgOlxuICAgICAgICAgICAgbmV3IEFuZChbLi4udGhpcy5mbGF0TGlzdCgpLCAuLi5vdGhlci5mbGF0TGlzdCgpXSlcblxuICAgIH1cblxuICAgIGNvcHkob3B0cz86IENvcHlPcHRzKTogQW5kIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmQodGhpcy5jbGF1c2VzLm1hcChjID0+IGMuY29weSh7IC4uLm9wdHMsIG5lZ2F0ZTogZmFsc2UgfSkpLCBvcHRzPy5uZWdhdGUgPyAhdGhpcy5uZWdhdGVkIDogdGhpcy5uZWdhdGVkKVxuICAgIH1cblxuICAgIGZsYXRMaXN0KCk6IENsYXVzZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZCA/IFt0aGlzLmNvcHkoKV0gOiB0aGlzLmNsYXVzZXMuZmxhdE1hcChjID0+IGMuZmxhdExpc3QoKSlcbiAgICB9XG5cbiAgICBnZXQgZW50aXRpZXMoKTogSWRbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5jbGF1c2VzLmZsYXRNYXAoYyA9PiBjLmVudGl0aWVzKSkpXG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXVzZXNbMF1cbiAgICB9XG5cbiAgICBnZXQgcmhlbWUoKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhdXNlc1sxXVxuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLmNvcHkoKSwgY29uY2x1c2lvbi5jb3B5KCkpXG4gICAgfVxuXG4gICAgdG9Qcm9sb2coKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IHByb2xvZ0NsYXVzZXMgPSB0aGlzLmNsYXVzZXMuZmxhdE1hcChjID0+IGMudG9Qcm9sb2coKSlcblxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkID9cbiAgICAgICAgICAgIFtgbG9naWNOb3QoJHtwcm9sb2dDbGF1c2VzLnJlZHVjZSgoYSwgYikgPT4gYCR7YX0sICR7Yn1gKX0pYF0gOlxuICAgICAgICAgICAgcHJvbG9nQ2xhdXNlc1xuXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2xhdXNlLCBBbmRPcHRzLCBDb3B5T3B0cywgZW1wdHlDbGF1c2UsIElkIH0gZnJvbSBcIi4vQ2xhdXNlXCI7XG5pbXBvcnQgSW1wbHkgZnJvbSBcIi4vSW1wbHlcIjtcbmltcG9ydCBBbmQgZnJvbSBcIi4vQW5kXCI7XG5cblxuZXhwb3J0IGNsYXNzIEJhc2ljQ2xhdXNlIGltcGxlbWVudHMgQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHByZWRpY2F0ZTogc3RyaW5nLCByZWFkb25seSBhcmdzOiBJZFtdLCByZWFkb25seSBuZWdhdGVkID0gZmFsc2UsIHJlYWRvbmx5IGlzSW1wbHkgPSBmYWxzZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmQodGhpcy5mbGF0TGlzdCgpLmNvbmNhdChvdGhlci5mbGF0TGlzdCgpKSlcbiAgICB9XG5cbiAgICBjb3B5KG9wdHM/OiBDb3B5T3B0cyk6IEJhc2ljQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNpY0NsYXVzZSh0aGlzLnByZWRpY2F0ZSwgdGhpcy5hcmdzLm1hcChhID0+IG9wdHM/Lm1hcCA/IG9wdHM/Lm1hcFthXSA/PyBhIDogYSksIG9wdHM/Lm5lZ2F0ZSA/ICF0aGlzLm5lZ2F0ZWQgOiB0aGlzLm5lZ2F0ZWQpXG4gICAgfVxuXG4gICAgZmxhdExpc3QoKTogQ2xhdXNlW10ge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29weSgpXVxuICAgIH1cblxuICAgIHRvUHJvbG9nKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY29yZSA9IGAke3RoaXMucHJlZGljYXRlfSgke3RoaXMuYXJncy5yZWR1Y2UoKGEsIGIpID0+IGAke2F9LCAke2J9YCl9KWBcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZCA/IFtgbG9naWNOb3QoJHtjb3JlfSlgXSA6IFtjb3JlXVxuICAgIH1cblxuICAgIGdldCBlbnRpdGllcygpOiBJZFtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmFyZ3MuY29uY2F0KFtdKSkpXG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKVxuICAgIH1cblxuICAgIGdldCByaGVtZSgpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gZW1wdHlDbGF1c2UoKVxuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLmNvcHkoKSwgY29uY2x1c2lvbi5jb3B5KCkpXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmFzaWNDbGF1c2UgfSBmcm9tIFwiLi9CYXNpY0NsYXVzZVwiXG5pbXBvcnQgQW5kIGZyb20gXCIuL0FuZFwiXG5cbmV4cG9ydCB0eXBlIElkID0gbnVtYmVyIHwgc3RyaW5nXG5cbi8qKlxuICogQSAnbGFuZ3VhZ2UtYWdub3N0aWMnIGZpcnN0IG9yZGVyIGxvZ2ljIHJlcHJlc2VudGF0aW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENsYXVzZSB7XG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlXG4gICAgaW1wbGllcyhjb25jbHVzaW9uOiBDbGF1c2UpOiBDbGF1c2VcbiAgICBjb3B5KG9wdHM/OiBDb3B5T3B0cyk6IENsYXVzZVxuICAgIGZsYXRMaXN0KCk6IENsYXVzZVtdXG4gICAgdG9Qcm9sb2coKTogc3RyaW5nW11cbiAgICByZWFkb25seSBuZWdhdGVkOiBib29sZWFuXG4gICAgcmVhZG9ubHkgaXNJbXBseTogYm9vbGVhblxuICAgIGdldCBlbnRpdGllcygpOiBJZFtdXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZVxuICAgIGdldCByaGVtZSgpOiBDbGF1c2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXVzZU9mKHByZWRpY2F0ZTogc3RyaW5nLCAuLi5hcmdzOiBJZFtdKSB7XG4gICAgcmV0dXJuIG5ldyBCYXNpY0NsYXVzZShwcmVkaWNhdGUsIGFyZ3MpXG59XG5cbmV4cG9ydCBjb25zdCBlbXB0eUNsYXVzZSA9ICgpOiBDbGF1c2UgPT4gbmV3IEFuZChbXSlcblxuZXhwb3J0IGludGVyZmFjZSBDb3B5T3B0cyB7XG4gICAgbmVnYXRlPzogYm9vbGVhblxuICAgIG1hcD86IE1hcFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFuZE9wdHMge1xuICAgIGFzUmhlbWU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UmFuZG9tSWRPcHRzIHtcbiAgICBhc1ZhcjogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tSWQob3B0cz86IEdldFJhbmRvbUlkT3B0cyk6IElkIHsgLy8gVE9ETzogaGlnaGVyIGNvbnN0IGZvciBwcm9kdWN0aW9uIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgICByZXR1cm4gYCR7b3B0cz8uYXNWYXIgPyAnSWQnIDogJ2lkJ30ke3BhcnNlSW50KDEwMDAgKiBNYXRoLnJhbmRvbSgpICsgJycpfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvVmFyKGlkOiBJZCk6IElkIHtcbiAgICByZXR1cm4gKCFOdW1iZXIuaXNOYU4oTnVtYmVyKGlkKSkgPyBgaWQke2lkfWAgOiBpZCArICcnKS50b1VwcGVyQ2FzZSgpXG59XG5cbi8qKlxuICogTWFwcGluZyBhbnkgZ2l2ZW4gaWQgaW4gdGhlIHNhbmRib3ggdG8gYW4gaWQgaW4gdGhlIFxuICogbGFyZ2VyIHVuaXZlcnNlLlxuICovXG5leHBvcnQgdHlwZSBNYXAgPSB7IFthOiBJZF06IElkIH0iLCJpbXBvcnQgeyBDbGF1c2UsIEFuZE9wdHMsIENvcHlPcHRzLCBJZCB9IGZyb20gXCIuL0NsYXVzZVwiO1xuaW1wb3J0IEFuZCBmcm9tIFwiLi9BbmRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1wbHkgaW1wbGVtZW50cyBDbGF1c2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY29uZGl0aW9uOiBDbGF1c2UsIHJlYWRvbmx5IGNvbmNsdXNpb246IENsYXVzZSwgcmVhZG9ubHkgbmVnYXRlZCA9IGZhbHNlLCByZWFkb25seSBpc0ltcGx5ID0gdHJ1ZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmQoW3RoaXMuY29weSgpLCBvdGhlci5jb3B5KCldKVxuICAgIH1cblxuICAgIGNvcHkob3B0cz86IENvcHlPcHRzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLmNvbmRpdGlvbi5jb3B5KG9wdHMpLCB0aGlzLmNvbmNsdXNpb24uY29weShvcHRzKSwgb3B0cz8ubmVnYXRlID8gIXRoaXMubmVnYXRlZCA6IHRoaXMubmVnYXRlZClcbiAgICB9XG5cbiAgICBmbGF0TGlzdCgpOiBDbGF1c2VbXSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5jb3B5KCldXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGhvcm4gY2xhdXNlcywgb25lIGZvciBlYWNoIGNvbmNsdXNpb24uIFxuICAgICAqIFNpbmNlIHByb2xvZyBvbmx5IHN1cHBvcnRzIHRoYXQga2luZCBvZiBpbXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICB0b1Byb2xvZygpOiBzdHJpbmdbXSB7XG5cbiAgICAgICAgY29uc3QgY29uZGl0aW9uU3RyaW5nID0gdGhpcy5jb25kaXRpb25cbiAgICAgICAgICAgIC50b1Byb2xvZygpXG4gICAgICAgICAgICAucmVkdWNlKChjMSwgYzIpID0+IGAke2MxfSwgJHtjMn1gKVxuXG4gICAgICAgIGNvbnN0IGNvbmNsdXNpb25zID0gdGhpcy5jb25jbHVzaW9uLmZsYXRMaXN0KClcblxuICAgICAgICByZXR1cm4gY29uY2x1c2lvbnMubWFwKGMgPT4gYCR7Yy50b1Byb2xvZygpWzBdfSA6LSAke2NvbmRpdGlvblN0cmluZ31gKSAvL1RPRE86IFswXSBpcyB0byBiZSBkZWFsdCB3aXRoIGJldHRlclxuXG4gICAgfVxuXG4gICAgZ2V0IGVudGl0aWVzKCk6IElkW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24uZW50aXRpZXMuY29uY2F0KHRoaXMuY29uY2x1c2lvbi5lbnRpdGllcylcbiAgICB9XG5cbiAgICBnZXQgdGhlbWUoKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLnRoZW1lXG4gICAgfVxuXG4gICAgZ2V0IHJoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKSAvLyBkdW5ubyB3aGF0IEknbSBkb2luJ1xuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQhJylcbiAgICB9XG5cbn0iLCJpbXBvcnQgcGwsIHsgZm9ybWF0X2Fuc3dlciB9IGZyb20gJ3RhdS1wcm9sb2cnXG5pbXBvcnQgTm91blBocmFzZSBmcm9tICcuL2FzdC9waHJhc2VzL05vdW5QaHJhc2UnO1xuaW1wb3J0IENvcHVsYVF1ZXN0aW9uIGZyb20gJy4vYXN0L3NlbnRlbmNlcy9Db3B1bGFRdWVzdGlvbic7XG5pbXBvcnQgQXJ0aWNsZSBmcm9tICcuL2FzdC90b2tlbnMvQXJ0aWNsZSc7XG5pbXBvcnQgQ29wdWxhIGZyb20gJy4vYXN0L3Rva2Vucy9Db3B1bGEnO1xuaW1wb3J0IE5vdW4gZnJvbSAnLi9hc3QvdG9rZW5zL05vdW4nO1xuaW1wb3J0IHsgZ2V0QnJhaW4gfSBmcm9tICcuL2JyYWluL0JyYWluJztcbmltcG9ydCB7IGdldEFuYXBob3JhIH0gZnJvbSAnLi9icmFpbi9BbmFwaG9yYSc7XG5pbXBvcnQgeyBCYXNpY0NsYXVzZSB9IGZyb20gJy4vY2xhdXNlcy9CYXNpY0NsYXVzZSc7XG5pbXBvcnQgeyBjbGF1c2VPZiB9IGZyb20gJy4vY2xhdXNlcy9DbGF1c2UnO1xuaW1wb3J0IHsgZ2V0TGV4ZXIgfSBmcm9tICcuL2xleGVyL0xleGVyJztcbmltcG9ydCB7IGdldFBhcnNlciB9IGZyb20gJy4vcGFyc2VyL1BhcnNlcic7XG5pbXBvcnQgUHJvbG9nLCB7IGdldFByb2xvZyB9IGZyb20gJy4vcHJvbG9nL1Byb2xvZyc7XG5pbXBvcnQgVGF1UHJvbG9nIGZyb20gJy4vcHJvbG9nL1RhdVByb2xvZyc7XG5pbXBvcnQgY29tcGlsZUxvZ2ljVGVzdCBmcm9tICcuL3Rlc3RzL2NvbXBpbGUtbG9naWMtdGVzdCc7XG5pbXBvcnQgcGxheWdyb3VuZCBmcm9tICcuL3Rlc3RzL3BsYXlncm91bmQnO1xuaW1wb3J0IHByb2xvZ1BsYXkgZnJvbSAnLi90ZXN0cy9wcm9sb2ctcGxheWdyb3VuZCc7XG5cblxuLy8gUFJPTE9HIFRFU1QgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb25zdCBwcm8gPSBnZXRQcm9sb2coKTtcbi8vICh3aW5kb3cgYXMgYW55KS5wcm8gPSBwcm87XG4vLyAoYXN5bmMgKCkgPT4ge1xuLy8gICAgIGF3YWl0IHByby5hc3NlcnQoJ2NhcHJhKHNjZW1vKScpXG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnbWFtbWFsKHBlbG9zbyknKVxuLy8gICAgIGF3YWl0IHByby5hc3NlcnQoJ21hbW1hbChmaWRvKScpXG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnbWFtbWFsKFgpIDotIGNhcHJhKFgpJylcbi8vICAgICBjb25zb2xlLmxvZyhhd2FpdCBwcm8ucXVlcnkoJ21hbW1hbChYKS4nKSlcbi8vICAgICBhd2FpdCBwcm8ucmV0cmFjdCgnY2FwcmEoc2NlbW8pJylcbi8vICAgICBjb25zb2xlLmxvZyhhd2FpdCBwcm8ucXVlcnkoJ21hbW1hbChYKS4nKSlcbi8vIH0pKCk7XG4vLyAvLyAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBjb25zb2xlLmxvZygodG9rZW5PZignYScpIGFzIEFydGljbGUpLmlzRGVmaW5pdGUoKSlcbi8vIGNvbnNvbGUubG9nKHRva2VuT2YoJ2EnKSAgaW5zdGFuY2VvZiBBcnRpY2xlKVxuLy8gY29uc29sZS5sb2codG9rZW5PZignYScpICBpbnN0YW5jZW9mIFF1YW50aWZpZXIpXG4vLyBjb25zb2xlLmxvZyh0b2tlbk9mKCdldmVyeScpICBpbnN0YW5jZW9mIFF1YW50aWZpZXIpXG4vLyBjb25zb2xlLmxvZyh0b2tlbk9mKCdhJykudG9TdHJpbmcoKSlcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnN0IGxleGVyID0gZ2V0TGV4ZXIoJ3RoZSBjYXQgaXMgYSBjYXQuJylcbi8vIGNvbnNvbGUubG9nKGxleGVyKVxuLy8gY29uc29sZS5sb2coJ2lzIGl0IGEgbm91bj8nLCBsZXhlci5hc3NlcnQoTm91biwge2Vycm9yT3V0OmZhbHNlfSkgKVxuLy8gY29uc29sZS5sb2cobGV4ZXIucGVlaylcbi8vIGNvbnNvbGUubG9nKCdpcyBpdCBhIGNvcHVsYT8nLCBsZXhlci5hc3NlcnQoQ29wdWxhLCB7ZXJyb3JPdXQ6ZmFsc2V9KSApXG4vLyBjb25zb2xlLmxvZyhsZXhlci5wZWVrKVxuLy8gY29uc29sZS5sb2coJ2lzIGl0IGFuIGFydGljbGU/JywgbGV4ZXIuYXNzZXJ0KEFydGljbGUsIHtlcnJvck91dDpmYWxzZX0pIClcbi8vIGNvbnNvbGUubG9nKGxleGVyLnBlZWspXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgY2F0IGlzIGJpZycpLnBhcnNlKCkpXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBiaWcgY2F0JykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBiaWcgY2F0IG9uIHRoZSB0YWJsZSBpcyBlYXRpbmcgdHVuYScpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgYmlnIGNhdCBvbiB0aGUgbWF0JykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ2V2ZXJ5IGRvZyBpcyBzdHVwaWQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGNhdCB0aGF0IGlzIHNtYXJ0JykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ25vZGVqcyBpcyBub3QgaGVscGZ1bCcpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCdpZiB0aGUgZG9nIGlzIHN0dXBpZCB0aGVuIHRoZSBjYXQgaXMgaGFwcHknKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGNhdCBpcyBoYXBweSBpZiB0aGUgZG9nIGlzIHN0dXBpZCcpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coKHdpbmRvdyBhcyBhbnkpLmFzdCA9IGdldFBhcnNlcigndGhlIGNvbG9yIG9mIHRoZSBidXR0b24gaXMgcmVkJykucGFyc2UoKSlcbi8vIGNvbnNvbGUubG9nKCh3aW5kb3cgYXMgYW55KS5hc3QgPSBnZXRQYXJzZXIoJ3RoZSBjb2xvciBvZiB0aGUgYnV0dG9uIG9uIHRoZSBibGFjayBkaXYgaXMgcmVkJykucGFyc2UoKSlcblxuLy8gQ09NUElMRVIgVEVTVFNcbi8vIGZ1bmN0aW9uIHRlc3Qoc3RyaW5nOiBzdHJpbmcpIHtcbi8vICAgICBjb25zb2xlLmxvZyhzdHJpbmcpXG4vLyAgICAgY29uc3QgY2xhdXNlID0gZ2V0UGFyc2VyKHN0cmluZykucGFyc2UoKS50b0NsYXVzZSgpLmNvcHkoeyBtYXA6IHsgJ2lkMSc6IDEwMDAsICdpZDInOiAyMDAwIH0gfSlcbi8vICAgICAvLyBjb25zb2xlLmxvZyhjbGF1c2UuZmxhdExpc3QoKS5tYXAoYyA9PiBjLnRvU3RyaW5nKCkpKVxuLy8gICAgIGNvbnNvbGUubG9nKGNsYXVzZS50b1Byb2xvZygpKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsYXVzZSlcbi8vICAgICAvLyBjb25zb2xlLmxvZygnZW50aXRpZXMnLCBjbGF1c2UuZW50aXRpZXMpXG4vLyAgICAgLy8gY29uc29sZS5sb2coJ3RoZW1lJywgY2xhdXNlLnRoZW1lKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKCdyaGVtZScsIGNsYXVzZS5yaGVtZSlcbi8vICAgICAvLyBjb25zb2xlLmxvZyhjbGF1c2UuYWJvdXQoJ2lkMCcpKVxuLy8gfVxuXG4vLyB0ZXN0KCd0aGUgY2F0IGlzIG9uIHRoZSBtYXQnKVxuLy8gLy8gdGVzdCgndGhlIGNhdCB0aGF0IGlzIHJlZCBpcyBvbiB0aGUgbWF0Jylcbi8vIC8vIHRlc3QoJ3RoZSBiaWcgY2F0IHRoYXQgaXMgb24gdGhlIG1hdCBpcyBibGFjaycpXG4vLyB0ZXN0KCdldmVyeSBjYXQgaXMgcmVkJylcbi8vIHRlc3QoJ2V2ZXJ5IHJlZCBjYXQgaXMgb24gdGhlIG1hdCcpXG4vLyAvLyB0ZXN0KCd0aGUgY2F0IGV4aXN0cyBvbiB0aGUgbWF0Jylcbi8vIHRlc3QoJ2lmIHRoZSBjYXQgaXMgb24gdGhlIG1hdCB0aGVuIHRoZSBjYXQgaXMgcmVkJylcbi8vIC8vIHRlc3QoJ3RoZSBjYXQgaXMgbm90IHJlZCcpXG4vLyB0ZXN0KCdldmVyeSBjYXQgaXMgbm90IHJlZCcpXG4vLyB0ZXN0KCd0cnVtcCBpcyBub3QgYSBncmVhdCBwcmVzaWRlbnQnKTsgLy8gcHJvYmFibHkgbmVlZCBhbiBhbmQgcHJlZGljYXRlXG5cbi8vIEVORCBDT01QSUxFUiBURVNUU1xuXG5cbi8vIChhc3luYyAoKSA9PiB7XG4vLyAgICAgY29uc3QgYnJhaW4gPSBhd2FpdCBnZXRCcmFpbigpO1xuLy8gICAgIGNvbnN0IGMgPSBjbGF1c2VPZignY2FwcmEnLCAndW5vJylcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignY2FwcmEnLCAyKSlcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignY2FwcmEnLCAzKSlcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignd2hpdGUnLCAzKSlcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignY2F0JywgNCkpXG4vLyAgICAgICAgIC5jb25jYXQoY2xhdXNlT2YoJ3doaXRlJywgNCkpXG5cbi8vICAgICBhd2FpdCBicmFpbi5hc3NlcnQoYyk7XG4vLyAgICAgY29uc29sZS5sb2coYXdhaXQgYnJhaW4ucXVlcnkoY2xhdXNlT2YoJ3doaXRlJywgJ1gnKS5jb25jYXQoY2xhdXNlT2YoJ2NhdCcsICdYJykpKSlcbi8vIH0pKClcblxuLy8gKGFzeW5jICgpID0+IHtcblxuLy8gICAgIGNvbnN0IHN0YXRlID0ge1xuLy8gICAgICAgICB0aW1lciA6IHNldFRpbWVvdXQoKCk9Pnt9LDApLFxuLy8gICAgICAgICBicmFpbiA6IGF3YWl0IGdldEJyYWluKCksXG4vLyAgICAgICAgIGRlYm91bmNpbmdUaW1lIDogMFxuLy8gICAgIH1cblxuLy8gICAgIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbi8vICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpPy5hcHBlbmRDaGlsZChwKVxuXG4vLyAgICAgY29uc3QgdGV4dGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpXG4vLyAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJzUwdmgnXG4vLyAgICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAnNTB2dydcblxuLy8gICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk/LmFwcGVuZENoaWxkKHRleHRhcmVhKVxuXG4vLyAgICAgY29uc3Qgb25JbnB1dCA9IGFzeW5jICgpID0+IHtcbi8vICAgICAgICAgY29uc3QgdGV4dCA9IHRleHRhcmVhLnZhbHVlXG4vLyAgICAgICAgIGNvbnN0IGFzdCA9IGdldFBhcnNlcih0ZXh0KS5wYXJzZSgpXG4vLyAgICAgICAgIGNvbnN0IGNsYXVzZSA9IGFzdC50b1Byb2xvZygpXG5cbi8vICAgICAgICAgaWYgKCFjbGF1c2Upe1xuLy8gICAgICAgICAgICAgcmV0dXJuIFxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgY29uc3QgbWFwcGluZyA9IGdldFNhbmRib3goY2xhdXNlKS5tYXBUbyhzdGF0ZS5icmFpbilcblxuXG4vLyAgICAgICAgIHAuaW5uZXJIVE1MID0gYCR7KGFzdCBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWV9OiAke2NsYXVzZS50b1N0cmluZygpfWBcblxuLy8gICAgICAgICBpZiAoYXN0IGluc3RhbmNlb2YgQ29wdWxhUXVlc3Rpb24pe1xuLy8gICAgICAgICAgICAgY29uc29sZS5sb2coYXdhaXQgc3RhdGUuYnJhaW4ucXVlcnkoY2xhdXNlKSlcbi8vICAgICAgICAgfWVsc2V7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZygnYXNzZXJ0ZWQ6JywgY2xhdXNlLnRvU3RyaW5nKCkpXG4vLyAgICAgICAgIH1cblxuLy8gICAgIH1cblxuLy8gICAgIHRleHRhcmVhLm9uaW5wdXQgPSBlID0+IHtcbi8vICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVyKVxuLy8gICAgICAgICBzdGF0ZS50aW1lciA9IHNldFRpbWVvdXQoKCk9Pntcbi8vICAgICAgICAgICAgIG9uSW5wdXQoKVxuLy8gICAgICAgICB9LCBzdGF0ZS5kZWJvdW5jaW5nVGltZSlcbi8vICAgICB9XG5cbi8vIH0pKCk7XG5cblxuXG4vLyAoYXN5bmMgKCkgPT4ge1xuXG4vLyAgICAgY29uc3QgcHJvbG9nID0gYXdhaXQgZ2V0QnJhaW4oKTtcbi8vICAgICAod2luZG93IGFzIGFueSkucHJvbG9nID0gcHJvbG9nXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignY2F0JywgJ2EnKSlcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCdjYXQnLCAnYicpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2NhdCcsICdjJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignd2hpdGUnLCAnYScpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2RvZycsICdkJykpXG5cbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCdlYXQnLCAnYScsICdyYWJiaXQnKSlcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCdlYXQnLCAnYScsICdtb3VzZScpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdhJywgJ2JpcmRpZScpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdkJywgJ2JvbmUnKSlcblxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ3RhYmxlJywgJ3RiMScpKVxuXG4vLyAgICAgLy8gY29uc3QgcmVzID0gYXdhaXQgcHJvbG9nLnF1ZXJ5KGNsYXVzZU9mKCdjYXQnLCAnWCcpLmNvbmNhdChjbGF1c2VPZignZWF0JywgJ1gnLCAnWScpLmNvbmNhdChjbGF1c2VPZignZG9nJywgJ1onKSkpKVxuLy8gICAgIC8vIGNvbnN0IGNsYXVzZSA9IGNsYXVzZU9mKCdjYXQnLCAnaWQwJykuY29uY2F0KGNsYXVzZU9mKCdkb2cnLCAnaWQxJykpLmNvbmNhdChjbGF1c2VPZignY2FwcmEnLCAnaWQ1NScpKSBcbi8vICAgICAvLyBjb25zdCBjbGF1c2UgPSBnZXRQYXJzZXIoJ3RoZSBjYXQgdGhhdCBpcyBibGFjayBpcyBzbWFydCcpLnBhcnNlKCkudG9Qcm9sb2coKVxuLy8gICAgIGNvbnN0IGNsYXVzZSA9IGdldFBhcnNlcigndGhlIGNhdCB0aGF0IGlzIHdoaXRlIGlzIG9uIHRoZSB0YWJsZScpLnBhcnNlKCkudG9Qcm9sb2coKVxuLy8gICAgIGNvbnNvbGUubG9nKGNsYXVzZS50b1N0cmluZygpKVxuXG4vLyAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0U2FuZGJveChjbGF1c2UpLm1hcFRvKHByb2xvZylcbi8vICAgICBjb25zb2xlLmxvZyhyZXMpXG4vLyAgICAgY29uc29sZS5sb2coY2xhdXNlLnJoZW1lLmNvcHkoeyBtYXA6IHJlcyB9KS50b1N0cmluZygpKVxuXG4vLyB9KSgpO1xuXG5cbi8vIHByb2xvZ1BsYXkoKVxuY29tcGlsZUxvZ2ljVGVzdCgpXG5wbGF5Z3JvdW5kKClcblxuLy8gY29uc3QgeCA9IGdldFBhcnNlcigndGhlIGNhdCBpcyBvbiB0aGUgbWF0LiB0aGUgY2F0IGlzIHJlZC4gdGhlIGNhdCBpcyBibGFjaycpXG4vLyAgICAgICAgIC5wYXJzZUFsbCgpXG4vLyAgICAgICAgIC5tYXAoYz0+Yy50b0NsYXVzZSgpLnRvUHJvbG9nKCkpXG5cbi8vIGNvbnNvbGUubG9nKHgpXG5cblxuIiwiaW1wb3J0IFRva2VuIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IExleGVyLCB7IEFzc2VydEFyZ3MsIENvbnN0cnVjdG9yIH0gZnJvbSBcIi4vTGV4ZXJcIjtcbmltcG9ydCB0b2tlbk9mIGZyb20gXCIuL3Rva2VuT2ZcIjtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFYWdlckxleGVyIGltcGxlbWVudHMgTGV4ZXIge1xuXG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHRva2VuczogVG9rZW5bXVxuICAgIHByb3RlY3RlZCBfcG9zOiBudW1iZXJcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHNvdXJjZUNvZGU6IHN0cmluZykge1xuICAgICAgICAvL1RPRE86IHJlY29uc3RydWN0IFwiZG8gbm90XCIgYW5kIFwiZG9lcyBub3RcIiB0b2tlbnNcbiAgICAgICAgLy9UT0RPOiBub3VucyB2cyBhZGplY3RpdmVzXG4gICAgICAgIHRoaXMudG9rZW5zID0gc291cmNlQ29kZS50cmltKCkuc3BsaXQoL1xccyt8XFwuLykubWFwKGUgPT4gIWUgPyAnLicgOiBlKS5tYXAodG9rZW5PZilcbiAgICAgICAgY29uc29sZS5kZWJ1ZygndG9rZW5zJywgdGhpcy50b2tlbnMpXG4gICAgICAgIHRoaXMuX3BvcyA9IDBcbiAgICB9XG5cbiAgICBuZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb3MrK1xuICAgIH1cblxuICAgIGdldCBwb3MoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc1xuICAgIH1cblxuICAgIGJhY2tUbyhwb3M6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wb3MgPSBwb3NcbiAgICB9XG5cbiAgICBnZXQgcGVlaygpOiBUb2tlbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLl9wb3NdXG4gICAgfVxuXG4gICAgY3JvYWsoZXJyb3JNc2c6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3JNc2d9IGF0ICR7dGhpcy5fcG9zfWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBjdXJyZW50IHRva2VuIGlmZiBvZiBnaXZlbiB0eXBlIGFuZCBtb3ZlIHRvIG5leHQ7IFxuICAgICAqIGVsc2UgcmV0dXJuIHVuZGVmaW5lZCBhbmQgZG9uJ3QgbW92ZS5cbiAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICBhc3NlcnQ8VD4oY2xheno6IENvbnN0cnVjdG9yPFQ+LCBhcmdzOiBBc3NlcnRBcmdzKTogVCB8IHVuZGVmaW5lZCB7XG5cbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMucGVla1xuXG4gICAgICAgIGlmIChjdXJyZW50IGluc3RhbmNlb2YgY2xhenopIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MuZXJyb3JPdXQgPz8gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5jcm9hayhhcmdzLmVycm9yTXNnID8/ICcnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXQgaXNFbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnRva2Vucy5sZW5ndGggXG4gICAgfVxuXG59IiwiaW1wb3J0IFRva2VuIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Ub2tlblwiXG5pbXBvcnQgRWFnZXJMZXhlciBmcm9tIFwiLi9FYWdlckxleGVyXCJcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIExleGVye1xuICAgIGdldCBwZWVrKCk6VG9rZW5cbiAgICBnZXQgcG9zKCk6bnVtYmVyXG4gICAgZ2V0IGlzRW5kKCk6Ym9vbGVhblxuICAgIG5leHQoKTp2b2lkXG4gICAgYmFja1RvKHBvczpudW1iZXIpOnZvaWRcbiAgICBjcm9hayhlcnJvck1zZzpzdHJpbmcpOnZvaWQgICBcbiAgICBhc3NlcnQgPFQ+KGNsYXp6OkNvbnN0cnVjdG9yPFQ+LCBhcmdzOkFzc2VydEFyZ3MpOiBUfHVuZGVmaW5lZCBcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NlcnRBcmdze1xuICAgIGVycm9yTXNnPzpzdHJpbmdcbiAgICBlcnJvck91dD86Ym9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGV4ZXIoc291cmNlQ29kZTpzdHJpbmcpOkxleGVye1xuICAgIHJldHVybiBuZXcgRWFnZXJMZXhlcihzb3VyY2VDb2RlKVxufVxuXG5leHBvcnQgdHlwZSBDb25zdHJ1Y3RvcjxUPiA9IG5ldyAoLi4uYXJnczogYW55W10pID0+IFRcbiIsImltcG9ydCBhZGplY3RpdmVzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvYWRqZWN0aXZlcydcbmltcG9ydCBpbmRlZmluaXRlX2FydGljbGVzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvaW5kZWZpbml0ZV9hcnRpY2xlcydcbmltcG9ydCBkZWZpbml0ZV9hcnRpY2xlcyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2RlZmluaXRlX2FydGljbGVzJ1xuaW1wb3J0IGNvcHVsYXMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9jb3B1bGFzJ1xuaW1wb3J0IGh2ZXJicyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2h2ZXJicydcbmltcG9ydCBpdmVyYnMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9pdmVyYnMnXG5pbXBvcnQgbXZlcmJzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbXZlcmJzJ1xuaW1wb3J0IG5lZ2F0aW9ucyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL25lZ2F0aW9ucydcbmltcG9ydCBub25zdWJjb25qIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbm9uc3ViY29uaidcbmltcG9ydCBub3VucyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL25vdW5zJ1xuaW1wb3J0IHByZXBvc2l0aW9ucyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL3ByZXBvc2l0aW9ucydcbmltcG9ydCBleGlzdHF1YW50IGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvZXhpc3RlbnRpYWxfcXVhbnRpZmllcnMnXG5pbXBvcnQgdW5pcXVhbnQgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy91bml2ZXJzYWxfcXVhbnRpZmllcnMnXG5pbXBvcnQgcmVscHJvbnMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9yZWxwcm9ucydcbmltcG9ydCBzdWJjb25qIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvc3ViY29uaidcbmltcG9ydCB0aGVuIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvdGhlbidcbmltcG9ydCBBcnRpY2xlIGZyb20gJy4uL2FzdC90b2tlbnMvQXJ0aWNsZSdcbmltcG9ydCBDb3B1bGEgZnJvbSAnLi4vYXN0L3Rva2Vucy9Db3B1bGEnXG5pbXBvcnQgSFZlcmIgZnJvbSAnLi4vYXN0L3Rva2Vucy9IVmVyYidcbmltcG9ydCBJVmVyYiBmcm9tICcuLi9hc3QvdG9rZW5zL0lWZXJiJ1xuaW1wb3J0IE1WZXJiIGZyb20gJy4uL2FzdC90b2tlbnMvTVZlcmInXG5pbXBvcnQgTmVnYXRpb24gZnJvbSAnLi4vYXN0L3Rva2Vucy9OZWdhdGlvbidcbmltcG9ydCBOb25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZnJvbSAnLi4vYXN0L3Rva2Vucy9Ob25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24nXG5pbXBvcnQgUHJlcG9zaXRpb24gZnJvbSAnLi4vYXN0L3Rva2Vucy9QcmVwb3NpdGlvbidcbmltcG9ydCBRdWFudGlmaWVyIGZyb20gJy4uL2FzdC90b2tlbnMvUXVhbnRpZmllcidcbmltcG9ydCBUaGVuIGZyb20gJy4uL2FzdC90b2tlbnMvVGhlbidcbmltcG9ydCBSZWxhdGl2ZVByb25vdW4gZnJvbSAnLi4vYXN0L3Rva2Vucy9SZWxhdGl2ZVByb25vdW4nXG5pbXBvcnQgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGZyb20gJy4uL2FzdC90b2tlbnMvU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uJ1xuaW1wb3J0IE5vdW4gZnJvbSAnLi4vYXN0L3Rva2Vucy9Ob3VuJ1xuaW1wb3J0IEFkamVjdGl2ZSBmcm9tICcuLi9hc3QvdG9rZW5zL0FkamVjdGl2ZSdcbmltcG9ydCBUb2tlbiBmcm9tICcuLi9hc3QvaW50ZXJmYWNlcy9Ub2tlbidcbmltcG9ydCBGdWxsU3RvcCBmcm9tICcuLi9hc3QvdG9rZW5zL0Z1bGxTdG9wJ1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0b2tlbk9mKHN0cmluZzpzdHJpbmcpOlRva2Vue1xuICAgIFxuICAgIGlmIChpbmRlZmluaXRlX2FydGljbGVzLmNvbmNhdChkZWZpbml0ZV9hcnRpY2xlcykuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgQXJ0aWNsZShzdHJpbmcpXG4gICAgfWVsc2UgaWYgKGNvcHVsYXMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoaHZlcmJzLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IEhWZXJiKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoaXZlcmJzLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IElWZXJiKHN0cmluZylcbiAgICB9ZWxzZSBpZiAobXZlcmJzLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IE1WZXJiKHN0cmluZylcbiAgICB9ZWxzZSBpZiAobmVnYXRpb25zLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IE5lZ2F0aW9uKHN0cmluZylcbiAgICB9ZWxzZSBpZiAobm9uc3ViY29uai5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBOb25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChwcmVwb3NpdGlvbnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgUHJlcG9zaXRpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChleGlzdHF1YW50LmNvbmNhdCh1bmlxdWFudCkuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgUXVhbnRpZmllcihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKHRoZW4uaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgVGhlbihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKHJlbHByb25zLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IFJlbGF0aXZlUHJvbm91bihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKHN1YmNvbmouaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uKHN0cmluZylcbiAgICB9ZWxzZSBpZiAobm91bnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgTm91bihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKGFkamVjdGl2ZXMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgQWRqZWN0aXZlKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoJy4nID09PSBzdHJpbmcpe1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxTdG9wKCcuJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFkamVjdGl2ZShzdHJpbmcpXG59IiwiaW1wb3J0IEFzdCBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQXN0XCI7XG5pbXBvcnQgQmluYXJ5UXVlc3Rpb24gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL0JpbmFyeVF1ZXN0aW9uXCI7XG5pbXBvcnQgQ29tcG91bmRTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQ29tcG91bmRTZW50ZW5jZVwiO1xuaW1wb3J0IERlY2xhcmF0aW9uIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9EZWNsYXJhdGlvblwiO1xuaW1wb3J0IFF1ZXN0aW9uIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9RdWVzdGlvblwiO1xuaW1wb3J0IFNpbXBsZVNlbnRlbmNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9TaW1wbGVTZW50ZW5jZVwiO1xuaW1wb3J0IFZlcmJTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvVmVyYlNlbnRlbmNlXCI7XG5pbXBvcnQgQ29tcGxlbWVudCBmcm9tIFwiLi4vYXN0L3BocmFzZXMvQ29tcGxlbWVudFwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL2FzdC9waHJhc2VzL05vdW5QaHJhc2VcIjtcbmltcG9ydCBTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvU3Vib3JkaW5hdGVDbGF1c2VcIjtcbmltcG9ydCBDb21wbGV4U2VudGVuY2UgZnJvbSBcIi4uL2FzdC9zZW50ZW5jZXMvQ29tcGxleFNlbnRlbmNlXCI7XG5pbXBvcnQgQ29uanVuY3RpdmVTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db25qdW5jdGl2ZVNlbnRlbmNlXCI7XG5pbXBvcnQgQ29wdWxhUXVlc3Rpb24gZnJvbSBcIi4uL2FzdC9zZW50ZW5jZXMvQ29wdWxhUXVlc3Rpb25cIjtcbmltcG9ydCBDb3B1bGFTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db3B1bGFTZW50ZW5jZVwiO1xuaW1wb3J0IEludHJhbnNpdGl2ZVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL0ludHJhbnNpdGl2ZVNlbnRlbmNlXCI7XG5pbXBvcnQgTW9ub3RyYW5zaXRpdmVTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Nb25vdHJhbnNpdGl2ZVNlbnRlbmNlXCI7XG5pbXBvcnQgQWRqZWN0aXZlIGZyb20gXCIuLi9hc3QvdG9rZW5zL0FkamVjdGl2ZVwiO1xuaW1wb3J0IEFydGljbGUgZnJvbSBcIi4uL2FzdC90b2tlbnMvQXJ0aWNsZVwiO1xuaW1wb3J0IENvcHVsYSBmcm9tIFwiLi4vYXN0L3Rva2Vucy9Db3B1bGFcIjtcbmltcG9ydCBJVmVyYiBmcm9tIFwiLi4vYXN0L3Rva2Vucy9JVmVyYlwiO1xuaW1wb3J0IE1WZXJiIGZyb20gXCIuLi9hc3QvdG9rZW5zL01WZXJiXCI7XG5pbXBvcnQgTmVnYXRpb24gZnJvbSBcIi4uL2FzdC90b2tlbnMvTmVnYXRpb25cIjtcbmltcG9ydCBOb3VuIGZyb20gXCIuLi9hc3QvdG9rZW5zL05vdW5cIjtcbmltcG9ydCBQcmVwb3NpdGlvbiBmcm9tIFwiLi4vYXN0L3Rva2Vucy9QcmVwb3NpdGlvblwiO1xuaW1wb3J0IFF1YW50aWZpZXIgZnJvbSBcIi4uL2FzdC90b2tlbnMvUXVhbnRpZmllclwiO1xuaW1wb3J0IFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiBmcm9tIFwiLi4vYXN0L3Rva2Vucy9TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb25cIjtcbmltcG9ydCBUaGVuIGZyb20gXCIuLi9hc3QvdG9rZW5zL1RoZW5cIjtcbmltcG9ydCBMZXhlciwgeyBnZXRMZXhlciB9IGZyb20gXCIuLi9sZXhlci9MZXhlclwiO1xuaW1wb3J0IFBhcnNlciBmcm9tIFwiLi9QYXJzZXJcIjtcbmltcG9ydCBDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vYXN0L3BocmFzZXMvQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2VcIjtcbmltcG9ydCBSZWxhdGl2ZVByb25vdW4gZnJvbSBcIi4uL2FzdC90b2tlbnMvUmVsYXRpdmVQcm9ub3VuXCI7XG5pbXBvcnQgQ29uc3RpdHVlbnQgZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgRnVsbFN0b3AgZnJvbSBcIi4uL2FzdC90b2tlbnMvRnVsbFN0b3BcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQYXJzZXIgaW1wbGVtZW50cyBQYXJzZXIge1xuXG4gICAgcHJvdGVjdGVkIGx4OiBMZXhlclxuXG4gICAgY29uc3RydWN0b3Ioc291cmNlQ29kZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubHggPSBnZXRMZXhlcihzb3VyY2VDb2RlKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cnk8VCBleHRlbmRzIEFzdD4obWV0aG9kOiAoKSA9PiBUKSB7XG5cbiAgICAgICAgY29uc3QgbWVtZW50byA9IHRoaXMubHgucG9zXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QoKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gICAgICAgICAgICB0aGlzLmx4LmJhY2tUbyhtZW1lbnRvKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZXJyb3JPdXQoZXJyb3JNc2c6IHN0cmluZyk6IENvbnN0aXR1ZW50IHtcbiAgICAgICAgdGhpcy5seC5jcm9hayhlcnJvck1zZylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKVxuICAgIH1cblxuICAgIHBhcnNlQWxsKCk6IENvbnN0aXR1ZW50W10ge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IENvbnN0aXR1ZW50W10gPSBbXVxuXG4gICAgICAgIHdoaWxlICghdGhpcy5seC5pc0VuZCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGFyc2UoKSlcbiAgICAgICAgICAgIHRoaXMubHguYXNzZXJ0KEZ1bGxTdG9wLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHNcbiAgICB9XG5cbiAgICBwYXJzZSgpOiBDb25zdGl0dWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlUXVlc3Rpb24pXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlRGVjbGFyYXRpb24pXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlTm91blBocmFzZSkgLy8gZm9yIHF1aWNrIHRvcGljIHJlZmVyZW5jZVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2UoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlRGVjbGFyYXRpb24gPSAoKTogRGVjbGFyYXRpb24gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvbXBvdW5kKVxuICAgICAgICAgICAgPz8gdGhpcy50cnkodGhpcy5wYXJzZVNpbXBsZSlcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlRGVjbGFyYXRpb24oKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlUXVlc3Rpb24gPSAoKTogUXVlc3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUJpbmFyeVF1ZXN0aW9uKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VRdWVzdGlvbigpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VTaW1wbGUgPSAoKTogU2ltcGxlU2VudGVuY2UgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvcHVsYVNlbnRlbmNlKVxuICAgICAgICAgICAgPz8gdGhpcy50cnkodGhpcy5wYXJzZVZlcmJTZW50ZW5jZSlcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlU2ltcGxlKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUNvbXBvdW5kID0gKCk6IENvbXBvdW5kU2VudGVuY2UgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvbXBsZXgpXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlQ29uanVuY3RpdmUpXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZUNvbXBvdW5kKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVZlcmJTZW50ZW5jZSA9ICgpOiBWZXJiU2VudGVuY2UgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUludHJhbnNpdGl2ZVNlbnRlbmNlKVxuICAgICAgICAgICAgPz8gdGhpcy50cnkodGhpcy5wYXJzZU1vbm90cmFuc2l0aXZlU2VudGVuY2UpXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZVZlcmJTZW50ZW5jZSgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb3B1bGFTZW50ZW5jZSA9ICgpOiBDb3B1bGFTZW50ZW5jZSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIGNvbnN0IGNvcHVsYSA9IHRoaXMubHguYXNzZXJ0KENvcHVsYSwgeyBlcnJvck1zZzogJ3BhcnNlQ29wdWxhU2VudGVuY2UoKSwgZXhwZWN0ZWQgY29wdWxhJyB9KVxuICAgICAgICBjb25zdCBuZWdhdGlvbiA9IHRoaXMubHguYXNzZXJ0KE5lZ2F0aW9uLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhU2VudGVuY2Uoc3ViamVjdCwgY29wdWxhIGFzIENvcHVsYSwgcHJlZGljYXRlLCBuZWdhdGlvbilcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb21wbGV4ID0gKCk6IENvbXBsZXhTZW50ZW5jZSA9PiB7XG5cbiAgICAgICAgY29uc3Qgc3ViY29uaiA9IHRoaXMubHguYXNzZXJ0KFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiwgeyBlcnJvck91dDogZmFsc2UgfSlcblxuICAgICAgICBpZiAoc3ViY29uaikge1xuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5wYXJzZVNpbXBsZSgpXG4gICAgICAgICAgICB0aGlzLmx4LmFzc2VydChUaGVuLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICAgICAgY29uc3Qgb3V0Y29tZSA9IHRoaXMucGFyc2VTaW1wbGUoKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4U2VudGVuY2UoY29uZGl0aW9uLCBvdXRjb21lLCBzdWJjb25qKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3V0Y29tZSA9IHRoaXMucGFyc2VTaW1wbGUoKVxuICAgICAgICAgICAgY29uc3Qgc3ViY29uaiA9IHRoaXMubHguYXNzZXJ0KFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiwgeyBlcnJvck91dDogdHJ1ZSwgZXJyb3JNc2c6ICdleHBlY3RlZCBzdWJvcmRpbmF0aW5nIGNvbmp1bmN0aW9uJyB9KVxuICAgICAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5wYXJzZVNpbXBsZSgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXhTZW50ZW5jZShjb25kaXRpb24sIG91dGNvbWUsIHN1YmNvbmogYXMgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VJbnRyYW5zaXRpdmVTZW50ZW5jZSA9ICgpOiBJbnRyYW5zaXRpdmVTZW50ZW5jZSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIGNvbnN0IG5lZ2F0aW9uID0gdGhpcy5seC5hc3NlcnQoTmVnYXRpb24sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIGNvbnN0IGl2ZXJiID0gdGhpcy5seC5hc3NlcnQoSVZlcmIsIHsgZXJyb3JNc2c6ICdwYXJzZUludHJhbnNpdGl2ZVNlbnRlbmNlKCksIGV4cGVjdGVkIGktdmVyYicgfSlcbiAgICAgICAgY29uc3QgY29tcGxlbWVudHMgPSB0aGlzLnBhcnNlQ29tcGxlbWVudHMoKVxuICAgICAgICByZXR1cm4gbmV3IEludHJhbnNpdGl2ZVNlbnRlbmNlKHN1YmplY3QsIGl2ZXJiIGFzIElWZXJiLCBjb21wbGVtZW50cywgbmVnYXRpb24pXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlTW9ub3RyYW5zaXRpdmVTZW50ZW5jZSA9ICgpOiBNb25vdHJhbnNpdGl2ZVNlbnRlbmNlID0+IHtcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgY29uc3QgbmVnYXRpb24gPSB0aGlzLmx4LmFzc2VydChOZWdhdGlvbiwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgY29uc3QgbXZlcmIgPSB0aGlzLmx4LmFzc2VydChNVmVyYiwgeyBlcnJvck1zZzogJ3BhcnNlTW9ub3RyYW5zaXRpdmVTZW50ZW5jZSgpLCBleHBlY3RlZCBpLXZlcmInIH0pXG4gICAgICAgIGNvbnN0IGNzMSA9IHRoaXMucGFyc2VDb21wbGVtZW50cygpXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgY29uc3QgY3MyID0gdGhpcy5wYXJzZUNvbXBsZW1lbnRzKClcbiAgICAgICAgcmV0dXJuIG5ldyBNb25vdHJhbnNpdGl2ZVNlbnRlbmNlKHN1YmplY3QsIG12ZXJiIGFzIE1WZXJiLCBvYmplY3QsIGNzMS5jb25jYXQoY3MyKSwgbmVnYXRpb24pXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQmluYXJ5UXVlc3Rpb24gPSAoKTogQmluYXJ5UXVlc3Rpb24gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvcHVsYVF1ZXN0aW9uKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VCaW5hcnlRdWVzdGlvbigpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb3B1bGFRdWVzdGlvbiA9ICgpOiBDb3B1bGFRdWVzdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvcHVsYSA9IHRoaXMubHguYXNzZXJ0KENvcHVsYSwgeyBlcnJvck1zZzogJ3BhcnNlQ29wdWxhUXVlc3Rpb24oKSwgZXhwZWN0ZWQgY29wdWxhJyB9KVxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhUXVlc3Rpb24oc3ViamVjdCwgcHJlZGljYXRlLCBjb3B1bGEgYXMgQ29wdWxhKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZU5vdW5QaHJhc2UgPSAoKTogTm91blBocmFzZSA9PiB7XG4gICAgICAgIGNvbnN0IHF1YW50aWZpZXIgPSB0aGlzLmx4LmFzc2VydChRdWFudGlmaWVyLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICBjb25zdCBhcnRpY2xlID0gdGhpcy5seC5hc3NlcnQoQXJ0aWNsZSwgeyBlcnJvck91dDogZmFsc2UgfSlcblxuICAgICAgICBsZXQgYWRqZWN0aXZlcyA9IFtdXG4gICAgICAgIGxldCBhZGpcblxuICAgICAgICB3aGlsZSAoYWRqID0gdGhpcy5seC5hc3NlcnQoQWRqZWN0aXZlLCB7IGVycm9yT3V0OiBmYWxzZSB9KSkge1xuICAgICAgICAgICAgYWRqZWN0aXZlcy5wdXNoKGFkailcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5vdW4gPSB0aGlzLmx4LmFzc2VydChOb3VuLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICBjb25zdCBzdWJvcmRpbmF0ZUNsYXVzZSA9IHRoaXMudHJ5KHRoaXMucGFyc2VTdWJvcmRpbmF0ZUNsYXVzZSlcbiAgICAgICAgY29uc3QgY29tcGxlbWVudHMgPSB0aGlzLnBhcnNlQ29tcGxlbWVudHMoKVxuXG4gICAgICAgIHJldHVybiBuZXcgTm91blBocmFzZShhZGplY3RpdmVzLCBjb21wbGVtZW50cywgbm91biwgcXVhbnRpZmllciwgYXJ0aWNsZSwgc3Vib3JkaW5hdGVDbGF1c2UpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29tcGxlbWVudHMgPSAoKTogQ29tcGxlbWVudFtdID0+IHtcblxuICAgICAgICBjb25zdCBjb21wbGVtZW50cyA9IFtdXG4gICAgICAgIGxldCBjb21wXG5cbiAgICAgICAgd2hpbGUgKGNvbXAgPSB0aGlzLnRyeSh0aGlzLnBhcnNlQ29tcGxlbWVudCkpIHtcbiAgICAgICAgICAgIGNvbXBsZW1lbnRzLnB1c2goY29tcClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wbGVtZW50c1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUNvbXBsZW1lbnQgPSAoKTogQ29tcGxlbWVudCA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBvc2l0aW9uID0gdGhpcy5seC5hc3NlcnQoUHJlcG9zaXRpb24sIHsgZXJyb3JNc2c6ICdwYXJzZUNvbXBsZW1lbnQoKSBleHBlY3RlZCBwcmVwb3NpdGlvbicgfSlcbiAgICAgICAgY29uc3Qgbm91blBocmFzZSA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wbGVtZW50KHByZXBvc2l0aW9uIGFzIFByZXBvc2l0aW9uLCBub3VuUGhyYXNlKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVN1Ym9yZGluYXRlQ2xhdXNlID0gKCk6IFN1Ym9yZGluYXRlQ2xhdXNlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSlcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlU3Vib3JkaW5hdGVDbGF1c2UoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UgPSAoKTogQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UgPT4ge1xuICAgICAgICBjb25zdCByZWxwcm9uID0gdGhpcy5seC5hc3NlcnQoUmVsYXRpdmVQcm9ub3VuLCB7IGVycm9yTXNnOiAncGFyc2VDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSgpIGV4cGVjdGVkIHJlbGF0aXZlIHByb25vdW4nIH0pXG4gICAgICAgIGNvbnN0IGNvcHVsYSA9IHRoaXMubHguYXNzZXJ0KENvcHVsYSwgeyBlcnJvck1zZzogJ3BhcnNlQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UoKSBleHBlY3RlZCBjb3B1bGEnIH0pXG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UocmVscHJvbiBhcyBSZWxhdGl2ZVByb25vdW4sIHN1YmplY3QsIGNvcHVsYSBhcyBDb3B1bGEpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29uanVuY3RpdmUgPSAoKTogQ29uanVuY3RpdmVTZW50ZW5jZSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEISBUT0RPIScpXG4gICAgfVxuXG59IiwiaW1wb3J0IENvbnN0aXR1ZW50IGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IEJhc2ljUGFyc2VyIGZyb20gXCIuL0Jhc2ljUGFyc2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBQYXJzZXJ7XG4gICAgcGFyc2UoKTpDb25zdGl0dWVudCAgIFxuICAgIHBhcnNlQWxsKCk6Q29uc3RpdHVlbnRbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyc2VyKHNvdXJjZUNvZGU6c3RyaW5nKTpQYXJzZXJ7XG4gICAgcmV0dXJuIG5ldyBCYXNpY1BhcnNlcihzb3VyY2VDb2RlKVxufSIsImltcG9ydCB7IE1hcCB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiXG5pbXBvcnQgVGF1UHJvbG9nIGZyb20gXCIuL1RhdVByb2xvZ1wiXG5cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBQcm9sb2cge1xuICAgIGFzc2VydChjbGF1c2U6IHN0cmluZywgb3B0cz86IEFzc2VydE9wdHMpOiBQcm9taXNlPHZvaWQ+XG4gICAgcmV0cmFjdChjbGF1c2U6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbiAgICBxdWVyeShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPCBNYXBbXSB8IGJvb2xlYW4+XG4gICAgcHJlZGljYXRlcyhvcHRzPzogUHJlaWRjYXRlc09wdHMpOiBzdHJpbmdbXVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2VydE9wdHMge1xuICAgIC8qKiBpZiB0cnVlIGNhbGxzIGFzc2VydHogKi9cbiAgICB6OiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlaWRjYXRlc09wdHMge1xuICAgIGFyaXR5OiBudW1iZXJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2xvZygpOiBQcm9sb2cge1xuICAgIHJldHVybiBuZXcgVGF1UHJvbG9nKClcbn0iLCJpbXBvcnQgUHJvbG9nLCB7IEFzc2VydE9wdHMsIFByZWlkY2F0ZXNPcHRzIH0gZnJvbSBcIi4vUHJvbG9nXCI7XG5pbXBvcnQgcGwgZnJvbSAndGF1LXByb2xvZydcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiO1xucmVxdWlyZShcInRhdS1wcm9sb2cvbW9kdWxlcy9wcm9taXNlcy5qc1wiKShwbCk7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGF1UHJvbG9nIGltcGxlbWVudHMgUHJvbG9nIHtcblxuICAgIHByb3RlY3RlZCBzZXNzaW9uOiBwbC50eXBlLlNlc3Npb25cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBwbC5jcmVhdGUoKVxuICAgIH1cblxuICAgIGFzeW5jIGFzc2VydChjbGF1c2U6IHN0cmluZywgb3B0cz86IEFzc2VydE9wdHMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VRdWVyeShgYXNzZXJ0JHtvcHRzPy56ID8gJ3onIDogJ2EnfSggKCAke2NsYXVzZX0gKSApLmApXG4gICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZUFuc3dlcigpXG4gICAgfVxuXG4gICAgYXN5bmMgcmV0cmFjdChjbGF1c2U6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBhd2FpdCAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZVF1ZXJ5KGByZXRyYWN0KCR7Y2xhdXNlfSkuYClcbiAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlQW5zd2VyKClcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYXN5bmMgcGVyZm9ybVF1ZXJ5KGNvZGU6IHN0cmluZyk6IFByb21pc2U8TWFwW10gfCBib29sZWFuPiB7XG5cbiAgICAgICAgYXdhaXQgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VRdWVyeShjb2RlKVxuICAgICAgICBsZXQgYW5zd2VyczogTWFwW10gPSBbXVxuXG4gICAgICAgIGZvciBhd2FpdCAobGV0IGFucyBvZiAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZUFuc3dlcnMoKSkge1xuXG4gICAgICAgICAgICBjb25zdCBmbWFucyA9IHBsLmZvcm1hdF9hbnN3ZXIoYW5zKVxuXG4gICAgICAgICAgICBpZiAoWyd0cnVlJywgJ2ZhbHNlJ10uaW5jbHVkZXMoZm1hbnMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZtYW5zID09PSAndHJ1ZSdcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBhbnMubGlua3NcblxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBPYmplY3Qua2V5cyhsaW5rcylcbiAgICAgICAgICAgICAgICAubWFwKGsgPT4gKHsgW2tdOiBsaW5rc1trXS52YWx1ZSA/PyBsaW5rc1trXS5pZCB9KSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiAoeyAuLi5hLCAuLi5iIH0pKVxuXG4gICAgICAgICAgICBhbnN3ZXJzLnB1c2goZW50cnkpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5SGFzVmFyKGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYW5zd2Vyc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGFzeW5jIHF1ZXJ5KGNvZGU6IHN0cmluZyk6IFByb21pc2U8TWFwW10gfCBib29sZWFuPiB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnBlcmZvcm1RdWVyeShjb2RlKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5wYXJzZUVycm9yKGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUVycm9yKGU6IGFueSkge1xuXG4gICAgICAgIGNvbnN0IGVycm9yID0gKGUgYXMgYW55KS5hcmdzWzBdLmFyZ3NbMF0uaWRcblxuICAgICAgICBpZiAoZXJyb3IgPT0gJ2V4aXN0ZW5jZV9lcnJvcicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pc3NpbmdQcmVkaWNhdGUgPSAoZSBhcyBhbnkpLmFyZ3NbMF0uYXJnc1swXS5hcmdzWzFdLmFyZ3NbMF0uaWRcbiAgICAgICAgICAgIHJldHVybiB7IGVycm9yLCBtaXNzaW5nUHJlZGljYXRlIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBxdWVyeUhhc1Zhcihjb2RlOiBzdHJpbmcpIHsgLy8gY2hlY2sgaWYgcXVlcnkgaGFzIGEgdmFyLiBicmVha3MgZG93biBpZiBwcmVkaWNhdGUgbmFtZSBjb250YWlucyBjYXBpdGFsIGxldHRlciFcbiAgICAgICAgcmV0dXJuIGNvZGUuc3BsaXQoJycpLmZpbmQoYyA9PiBjLm1hdGNoKC9cXHcrLykgJiYgYy50b1VwcGVyQ2FzZSgpID09PSBjKVxuICAgIH1cblxuICAgIHByZWRpY2F0ZXMob3B0cz86IFByZWlkY2F0ZXNPcHRzKTogc3RyaW5nW10ge1xuXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNlc3Npb24ucnVsZXMpXG4gICAgICAgICAgICAubWFwKHIgPT4gci5zcGxpdCgnLycpKVxuICAgICAgICAgICAgLmZpbHRlcih0ID0+IG9wdHM/LmFyaXR5ICE9PSB1bmRlZmluZWQgPyBwYXJzZUludCh0WzFdKSA9PT0gb3B0cz8uYXJpdHkgOiB0cnVlKVxuICAgICAgICAgICAgLm1hcCh0ID0+IHRbMF0pXG5cbiAgICB9XG5cblxufSIsImltcG9ydCB7IGdldEJyYWluIH0gZnJvbSBcIi4uL2JyYWluL0JyYWluXCJcblxuLyoqXG4gKiBTb21lIGNvb2wgZnV6enkgdGVzdHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29tcGlsZUxvZ2ljVGVzdCgpIHtcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHRlc3Qoc3RhdGVtZW50OiBzdHJpbmcsIGNoZWNrOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYnJhaW4gPSBhd2FpdCBnZXRCcmFpbigpXG4gICAgICAgIGF3YWl0IGJyYWluLmV4ZWN1dGUoc3RhdGVtZW50KVxuICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCBicmFpbi5leGVjdXRlKGNoZWNrKSlcbiAgICB9XG5cbiAgICBhd2FpdCB0ZXN0KCd0aGUgY2F0IGlzIG9uIHRoZSBtYXQnLCAnaXMgdGhlIGNhdCBvbiB0aGUgbWF0JylcblxuICAgIGF3YWl0IHRlc3QoJ3RoZSBjYXQgdGhhdCBpcyByZWQgaXMgb24gdGhlIG1hdCcsICdpcyB0aGUgcmVkIGNhdCBvbiB0aGUgbWF0JylcblxuICAgIGF3YWl0IHRlc3QoJ2EgY2F0IGlzIHJlZC4gZXZlcnkgY2F0IGlzIHNtYXJ0LiBhIGNhdCBpcyBibGFjay4nLCAnaXMgdGhlIHJlZCBjYXQgc21hcnQnKVxuXG4gICAgYXdhaXQgdGVzdCgndGhlIGRvZyBpcyBzdHVwaWQnLCAnaXMgdGhlIGtldHRsZSBvbiB0aGUgc3RvdmUnKSAvLyBmYWxzZVxuXG4gICAgLy8gdGVzdCgndGhlIGJpZyBjYXQgdGhhdCBpcyBvbiB0aGUgbWF0IGlzIGJsYWNrJylcbiAgICAvLyB0ZXN0KCdldmVyeSBjYXQgaXMgcmVkJylcbiAgICAvLyB0ZXN0KCdldmVyeSByZWQgY2F0IGlzIG9uIHRoZSBtYXQnKVxuICAgIC8vIHRlc3QoJ3RoZSBjYXQgZXhpc3RzIG9uIHRoZSBtYXQnKVxuICAgIC8vIHRlc3QoJ2lmIHRoZSBjYXQgaXMgb24gdGhlIG1hdCB0aGVuIHRoZSBjYXQgaXMgcmVkJylcbiAgICAvLyB0ZXN0KCd0aGUgY2F0IGlzIG5vdCByZWQnKVxuICAgIC8vIHRlc3QoJ2V2ZXJ5IGNhdCBpcyBub3QgcmVkJylcbiAgICAvLyB0ZXN0KCd0cnVtcCBpcyBub3QgYSBncmVhdCBwcmVzaWRlbnQnKTsgLy8gcHJvYmFibHkgbmVlZCBhbiBhbmQgcHJlZGljYXRlXG5cbn0iLCJpbXBvcnQgeyBnZXRCcmFpbiB9IGZyb20gXCIuLi9icmFpbi9CcmFpblwiXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsYXlncm91bmQoKXtcbiAgICBcbiAgICBjb25zdCBicmFpbiA9IGF3YWl0IGdldEJyYWluKClcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgYnV0dG9uLmlubmVyVGV4dCA9ICdydW4nXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQoYnV0dG9uKVxuXG4gICAgY29uc3QgcGFyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpPy5hcHBlbmRDaGlsZChwYXJhZylcblxuICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICc1MHZoJ1xuICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gJzUwdncnXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQodGV4dGFyZWEpXG5cbiAgICBidXR0b24ub25jbGljayA9IGFzeW5jIGUgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCBicmFpbi5leGVjdXRlKHRleHRhcmVhLnZhbHVlKSlcbiAgICB9XG5cbn0iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2FwcC9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=