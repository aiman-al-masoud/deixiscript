/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/readline-sync/lib/readline-sync.js":
/*!*********************************************************!*\
  !*** ./node_modules/readline-sync/lib/readline-sync.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __dirname = "/";
/*
 * readlineSync
 * https://github.com/anseki/readline-sync
 *
 * Copyright (c) 2018 anseki
 * Licensed under the MIT license.
 */



var
  IS_WIN = process.platform === 'win32',

  ALGORITHM_CIPHER = 'aes-256-cbc',
  ALGORITHM_HASH = 'sha256',
  DEFAULT_ERR_MSG = 'The current environment doesn\'t support interactive reading from TTY.',

  fs = __webpack_require__(/*! fs */ "?b05a"),
  TTY = process.binding('tty_wrap').TTY,
  childProc = __webpack_require__(/*! child_process */ "?a95c"),
  pathUtil = __webpack_require__(/*! path */ "?1b04"),

  defaultOptions = {
    /* eslint-disable key-spacing */
    prompt:             '> ',
    hideEchoBack:       false,
    mask:               '*',
    limit:              [],
    limitMessage:       'Input another, please.$<( [)limit(])>',
    defaultInput:       '',
    trueValue:          [],
    falseValue:         [],
    caseSensitive:      false,
    keepWhitespace:     false,
    encoding:           'utf8',
    bufferSize:         1024,
    print:              void 0,
    history:            true,
    cd:                 false,
    phContent:          void 0,
    preCheck:           void 0
    /* eslint-enable key-spacing */
  },

  fdR = 'none', fdW, ttyR, isRawMode = false,
  extHostPath, extHostArgs, tempdir, salt = 0,
  lastInput = '', inputHistory = [], rawInput,
  _DBG_useExt = false, _DBG_checkOptions = false, _DBG_checkMethod = false;

function getHostArgs(options) {
  // Send any text to crazy Windows shell safely.
  function encodeArg(arg) {
    return arg.replace(/[^\w\u0080-\uFFFF]/g, function(chr) {
      return '#' + chr.charCodeAt(0) + ';';
    });
  }

  return extHostArgs.concat((function(conf) {
    var args = [];
    Object.keys(conf).forEach(function(optionName) {
      if (conf[optionName] === 'boolean') {
        if (options[optionName]) { args.push('--' + optionName); }
      } else if (conf[optionName] === 'string') {
        if (options[optionName]) {
          args.push('--' + optionName, encodeArg(options[optionName]));
        }
      }
    });
    return args;
  })({
    /* eslint-disable key-spacing */
    display:        'string',
    displayOnly:    'boolean',
    keyIn:          'boolean',
    hideEchoBack:   'boolean',
    mask:           'string',
    limit:          'string',
    caseSensitive:  'boolean'
    /* eslint-enable key-spacing */
  }));
}

// piping via files (for Node.js v0.10-)
function _execFileSync(options, execOptions) {

  function getTempfile(name) {
    var filepath, suffix = '', fd;
    tempdir = tempdir || (__webpack_require__(/*! os */ "?a1b8").tmpdir)();

    while (true) {
      filepath = pathUtil.join(tempdir, name + suffix);
      try {
        fd = fs.openSync(filepath, 'wx');
      } catch (e) {
        if (e.code === 'EEXIST') {
          suffix++;
          continue;
        } else {
          throw e;
        }
      }
      fs.closeSync(fd);
      break;
    }
    return filepath;
  }

  var hostArgs, shellPath, shellArgs, res = {}, exitCode, extMessage,
    pathStdout = getTempfile('readline-sync.stdout'),
    pathStderr = getTempfile('readline-sync.stderr'),
    pathExit = getTempfile('readline-sync.exit'),
    pathDone = getTempfile('readline-sync.done'),
    crypto = __webpack_require__(/*! crypto */ "?4ec4"), shasum, decipher, password;

  shasum = crypto.createHash(ALGORITHM_HASH);
  shasum.update('' + process.pid + (salt++) + Math.random());
  password = shasum.digest('hex');
  decipher = crypto.createDecipher(ALGORITHM_CIPHER, password);

  hostArgs = getHostArgs(options);
  if (IS_WIN) {
    shellPath = process.env.ComSpec || 'cmd.exe';
    process.env.Q = '"'; // The quote (") that isn't escaped.
    // `()` for ignore space by echo
    shellArgs = ['/V:ON', '/S', '/C',
      '(%Q%' + shellPath + '%Q% /V:ON /S /C %Q%' + /* ESLint bug? */ // eslint-disable-line no-path-concat
        '%Q%' + extHostPath + '%Q%' +
          hostArgs.map(function(arg) { return ' %Q%' + arg + '%Q%'; }).join('') +
        ' & (echo !ERRORLEVEL!)>%Q%' + pathExit + '%Q%%Q%) 2>%Q%' + pathStderr + '%Q%' +
      ' |%Q%' + process.execPath + '%Q% %Q%' + __dirname + '\\encrypt.js%Q%' +
        ' %Q%' + ALGORITHM_CIPHER + '%Q% %Q%' + password + '%Q%' +
        ' >%Q%' + pathStdout + '%Q%' +
      ' & (echo 1)>%Q%' + pathDone + '%Q%'];
  } else {
    shellPath = '/bin/sh';
    shellArgs = ['-c',
      // Use `()`, not `{}` for `-c` (text param)
      '("' + extHostPath + '"' + /* ESLint bug? */ // eslint-disable-line no-path-concat
          hostArgs.map(function(arg) { return " '" + arg.replace(/'/g, "'\\''") + "'"; }).join('') +
        '; echo $?>"' + pathExit + '") 2>"' + pathStderr + '"' +
      ' |"' + process.execPath + '" "' + __dirname + '/encrypt.js"' +
        ' "' + ALGORITHM_CIPHER + '" "' + password + '"' +
        ' >"' + pathStdout + '"' +
      '; echo 1 >"' + pathDone + '"'];
  }
  if (_DBG_checkMethod) { _DBG_checkMethod('_execFileSync', hostArgs); }
  try {
    childProc.spawn(shellPath, shellArgs, execOptions);
  } catch (e) {
    res.error = new Error(e.message);
    res.error.method = '_execFileSync - spawn';
    res.error.program = shellPath;
    res.error.args = shellArgs;
  }

  while (fs.readFileSync(pathDone, {encoding: options.encoding}).trim() !== '1') {} // eslint-disable-line no-empty
  if ((exitCode =
      fs.readFileSync(pathExit, {encoding: options.encoding}).trim()) === '0') {
    res.input =
      decipher.update(fs.readFileSync(pathStdout, {encoding: 'binary'}),
        'hex', options.encoding) +
      decipher.final(options.encoding);
  } else {
    extMessage = fs.readFileSync(pathStderr, {encoding: options.encoding}).trim();
    res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
    res.error.method = '_execFileSync';
    res.error.program = shellPath;
    res.error.args = shellArgs;
    res.error.extMessage = extMessage;
    res.error.exitCode = +exitCode;
  }

  fs.unlinkSync(pathStdout);
  fs.unlinkSync(pathStderr);
  fs.unlinkSync(pathExit);
  fs.unlinkSync(pathDone);

  return res;
}

function readlineExt(options) {
  var hostArgs, res = {}, extMessage,
    execOptions = {env: process.env, encoding: options.encoding};

  if (!extHostPath) {
    if (IS_WIN) {
      if (process.env.PSModulePath) { // Windows PowerShell
        extHostPath = 'powershell.exe';
        extHostArgs = ['-ExecutionPolicy', 'Bypass', '-File', __dirname + '\\read.ps1']; // eslint-disable-line no-path-concat
      } else {                        // Windows Script Host
        extHostPath = 'cscript.exe';
        extHostArgs = ['//nologo', __dirname + '\\read.cs.js']; // eslint-disable-line no-path-concat
      }
    } else {
      extHostPath = '/bin/sh';
      extHostArgs = [__dirname + '/read.sh']; // eslint-disable-line no-path-concat
    }
  }
  if (IS_WIN && !process.env.PSModulePath) { // Windows Script Host
    // ScriptPW (Win XP and Server2003) needs TTY stream as STDIN.
    // In this case, If STDIN isn't TTY, an error is thrown.
    execOptions.stdio = [process.stdin];
  }

  if (childProc.execFileSync) {
    hostArgs = getHostArgs(options);
    if (_DBG_checkMethod) { _DBG_checkMethod('execFileSync', hostArgs); }
    try {
      res.input = childProc.execFileSync(extHostPath, hostArgs, execOptions);
    } catch (e) { // non-zero exit code
      extMessage = e.stderr ? (e.stderr + '').trim() : '';
      res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
      res.error.method = 'execFileSync';
      res.error.program = extHostPath;
      res.error.args = hostArgs;
      res.error.extMessage = extMessage;
      res.error.exitCode = e.status;
      res.error.code = e.code;
      res.error.signal = e.signal;
    }
  } else {
    res = _execFileSync(options, execOptions);
  }
  if (!res.error) {
    res.input = res.input.replace(/^\s*'|'\s*$/g, '');
    options.display = '';
  }

  return res;
}

/*
  display:            string
  displayOnly:        boolean
  keyIn:              boolean
  hideEchoBack:       boolean
  mask:               string
  limit:              string (pattern)
  caseSensitive:      boolean
  keepWhitespace:     boolean
  encoding, bufferSize, print
*/
function _readlineSync(options) {
  var input = '', displaySave = options.display,
    silent = !options.display &&
      options.keyIn && options.hideEchoBack && !options.mask;

  function tryExt() {
    var res = readlineExt(options);
    if (res.error) { throw res.error; }
    return res.input;
  }

  if (_DBG_checkOptions) { _DBG_checkOptions(options); }

  (function() { // open TTY
    var fsB, constants, verNum;

    function getFsB() {
      if (!fsB) {
        fsB = process.binding('fs'); // For raw device path
        constants = process.binding('constants');
      }
      return fsB;
    }

    if (typeof fdR !== 'string') { return; }
    fdR = null;

    if (IS_WIN) {
      // iojs-v2.3.2+ input stream can't read first line. (#18)
      // ** Don't get process.stdin before check! **
      // Fixed v5.1.0
      // Fixed v4.2.4
      // It regressed again in v5.6.0, it is fixed in v6.2.0.
      verNum = (function(ver) { // getVerNum
        var nums = ver.replace(/^\D+/, '').split('.');
        var verNum = 0;
        if ((nums[0] = +nums[0])) { verNum += nums[0] * 10000; }
        if ((nums[1] = +nums[1])) { verNum += nums[1] * 100; }
        if ((nums[2] = +nums[2])) { verNum += nums[2]; }
        return verNum;
      })(process.version);
      if (!(verNum >= 20302 && verNum < 40204 || verNum >= 50000 && verNum < 50100 || verNum >= 50600 && verNum < 60200) &&
          process.stdin.isTTY) {
        process.stdin.pause();
        fdR = process.stdin.fd;
        ttyR = process.stdin._handle;
      } else {
        try {
          // The stream by fs.openSync('\\\\.\\CON', 'r') can't switch to raw mode.
          // 'CONIN$' might fail on XP, 2000, 7 (x86).
          fdR = getFsB().open('CONIN$', constants.O_RDWR, parseInt('0666', 8));
          ttyR = new TTY(fdR, true);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('\\\\.\\CON', 'w');
        } catch (e) { /* ignore */ }
        if (typeof fdW !== 'number') { // Retry
          try {
            fdW = getFsB().open('CONOUT$', constants.O_RDWR, parseInt('0666', 8));
          } catch (e) { /* ignore */ }
        }
      }

    } else {
      if (process.stdin.isTTY) {
        process.stdin.pause();
        try {
          fdR = fs.openSync('/dev/tty', 'r'); // device file, not process.stdin
          ttyR = process.stdin._handle;
        } catch (e) { /* ignore */ }
      } else {
        // Node.js v0.12 read() fails.
        try {
          fdR = fs.openSync('/dev/tty', 'r');
          ttyR = new TTY(fdR, false);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('/dev/tty', 'w');
        } catch (e) { /* ignore */ }
      }
    }
  })();

  (function() { // try read
    var atEol, limit,
      isCooked = !options.hideEchoBack && !options.keyIn,
      buffer, reqSize, readSize, chunk, line;
    rawInput = '';

    // Node.js v0.10- returns an error if same mode is set.
    function setRawMode(mode) {
      if (mode === isRawMode) { return true; }
      if (ttyR.setRawMode(mode) !== 0) { return false; }
      isRawMode = mode;
      return true;
    }

    if (_DBG_useExt || !ttyR ||
        typeof fdW !== 'number' && (options.display || !isCooked)) {
      input = tryExt();
      return;
    }

    if (options.display) {
      fs.writeSync(fdW, options.display);
      options.display = '';
    }
    if (options.displayOnly) { return; }

    if (!setRawMode(!isCooked)) {
      input = tryExt();
      return;
    }

    reqSize = options.keyIn ? 1 : options.bufferSize;
    // Check `allocUnsafe` to make sure of the new API.
    buffer = Buffer.allocUnsafe && Buffer.alloc ? Buffer.alloc(reqSize) : new Buffer(reqSize);

    if (options.keyIn && options.limit) {
      limit = new RegExp('[^' + options.limit + ']',
        'g' + (options.caseSensitive ? '' : 'i'));
    }

    while (true) {
      readSize = 0;
      try {
        readSize = fs.readSync(fdR, buffer, 0, reqSize);
      } catch (e) {
        if (e.code !== 'EOF') {
          setRawMode(false);
          input += tryExt();
          return;
        }
      }
      if (readSize > 0) {
        chunk = buffer.toString(options.encoding, 0, readSize);
        rawInput += chunk;
      } else {
        chunk = '\n';
        rawInput += String.fromCharCode(0);
      }

      if (chunk && typeof (line = (chunk.match(/^(.*?)[\r\n]/) || [])[1]) === 'string') {
        chunk = line;
        atEol = true;
      }

      // other ctrl-chars
      // eslint-disable-next-line no-control-regex
      if (chunk) { chunk = chunk.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]/g, ''); }
      if (chunk && limit) { chunk = chunk.replace(limit, ''); }

      if (chunk) {
        if (!isCooked) {
          if (!options.hideEchoBack) {
            fs.writeSync(fdW, chunk);
          } else if (options.mask) {
            fs.writeSync(fdW, (new Array(chunk.length + 1)).join(options.mask));
          }
        }
        input += chunk;
      }

      if (!options.keyIn && atEol ||
        options.keyIn && input.length >= reqSize) { break; }
    }

    if (!isCooked && !silent) { fs.writeSync(fdW, '\n'); }
    setRawMode(false);
  })();

  if (options.print && !silent) {
    options.print(displaySave + (options.displayOnly ? '' :
        (options.hideEchoBack ? (new Array(input.length + 1)).join(options.mask)
          : input) + '\n'), // must at least write '\n'
      options.encoding);
  }

  return options.displayOnly ? '' :
    (lastInput = options.keepWhitespace || options.keyIn ? input : input.trim());
}

function flattenArray(array, validator) {
  var flatArray = [];
  function _flattenArray(array) {
    if (array == null) {
      return;
    } else if (Array.isArray(array)) {
      array.forEach(_flattenArray);
    } else if (!validator || validator(array)) {
      flatArray.push(array);
    }
  }
  _flattenArray(array);
  return flatArray;
}

function escapePattern(pattern) {
  return pattern.replace(/[\x00-\x7f]/g, // eslint-disable-line no-control-regex
    function(s) { return '\\x' + ('00' + s.charCodeAt().toString(16)).substr(-2); });
}

// margeOptions(options1, options2 ... )
// margeOptions(true, options1, options2 ... )
//    arg1=true : Start from defaultOptions and pick elements of that.
function margeOptions() {
  var optionsList = Array.prototype.slice.call(arguments),
    optionNames, fromDefault;

  if (optionsList.length && typeof optionsList[0] === 'boolean') {
    fromDefault = optionsList.shift();
    if (fromDefault) {
      optionNames = Object.keys(defaultOptions);
      optionsList.unshift(defaultOptions);
    }
  }

  return optionsList.reduce(function(options, optionsPart) {
    if (optionsPart == null) { return options; }

    // ======== DEPRECATED ========
    if (optionsPart.hasOwnProperty('noEchoBack') &&
        !optionsPart.hasOwnProperty('hideEchoBack')) {
      optionsPart.hideEchoBack = optionsPart.noEchoBack;
      delete optionsPart.noEchoBack;
    }
    if (optionsPart.hasOwnProperty('noTrim') &&
        !optionsPart.hasOwnProperty('keepWhitespace')) {
      optionsPart.keepWhitespace = optionsPart.noTrim;
      delete optionsPart.noTrim;
    }
    // ======== /DEPRECATED ========

    if (!fromDefault) { optionNames = Object.keys(optionsPart); }
    optionNames.forEach(function(optionName) {
      var value;
      if (!optionsPart.hasOwnProperty(optionName)) { return; }
      value = optionsPart[optionName];
      switch (optionName) {
                           // _readlineSync <- *    * -> defaultOptions
        // ================ string
        case 'mask':                        // *    *
        case 'limitMessage':                //      *
        case 'defaultInput':                //      *
        case 'encoding':                    // *    *
          value = value != null ? value + '' : '';
          if (value && optionName !== 'limitMessage') { value = value.replace(/[\r\n]/g, ''); }
          options[optionName] = value;
          break;
        // ================ number(int)
        case 'bufferSize':                  // *    *
          if (!isNaN(value = parseInt(value, 10)) && typeof value === 'number') {
            options[optionName] = value; // limited updating (number is needed)
          }
          break;
        // ================ boolean
        case 'displayOnly':                 // *
        case 'keyIn':                       // *
        case 'hideEchoBack':                // *    *
        case 'caseSensitive':               // *    *
        case 'keepWhitespace':              // *    *
        case 'history':                     //      *
        case 'cd':                          //      *
          options[optionName] = !!value;
          break;
        // ================ array
        case 'limit':                       // *    *     to string for readlineExt
        case 'trueValue':                   //      *
        case 'falseValue':                  //      *
          options[optionName] = flattenArray(value, function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number' ||
              type === 'function' || value instanceof RegExp;
          }).map(function(value) {
            return typeof value === 'string' ? value.replace(/[\r\n]/g, '') : value;
          });
          break;
        // ================ function
        case 'print':                       // *    *
        case 'phContent':                   //      *
        case 'preCheck':                    //      *
          options[optionName] = typeof value === 'function' ? value : void 0;
          break;
        // ================ other
        case 'prompt':                      //      *
        case 'display':                     // *
          options[optionName] = value != null ? value : '';
          break;
        // no default
      }
    });
    return options;
  }, {});
}

function isMatched(res, comps, caseSensitive) {
  return comps.some(function(comp) {
    var type = typeof comp;
    return type === 'string' ?
        (caseSensitive ? res === comp : res.toLowerCase() === comp.toLowerCase()) :
      type === 'number' ? parseFloat(res) === comp :
      type === 'function' ? comp(res) :
      comp instanceof RegExp ? comp.test(res) : false;
  });
}

function replaceHomePath(path, expand) {
  var homePath = pathUtil.normalize(
    IS_WIN ? (process.env.HOMEDRIVE || '') + (process.env.HOMEPATH || '') :
    process.env.HOME || '').replace(/[\/\\]+$/, '');
  path = pathUtil.normalize(path);
  return expand ? path.replace(/^~(?=\/|\\|$)/, homePath) :
    path.replace(new RegExp('^' + escapePattern(homePath) +
      '(?=\\/|\\\\|$)', IS_WIN ? 'i' : ''), '~');
}

function replacePlaceholder(text, generator) {
  var PTN_INNER = '(?:\\(([\\s\\S]*?)\\))?(\\w+|.-.)(?:\\(([\\s\\S]*?)\\))?',
    rePlaceholder = new RegExp('(\\$)?(\\$<' + PTN_INNER + '>)', 'g'),
    rePlaceholderCompat = new RegExp('(\\$)?(\\$\\{' + PTN_INNER + '\\})', 'g');

  function getPlaceholderText(s, escape, placeholder, pre, param, post) {
    var text;
    return escape || typeof (text = generator(param)) !== 'string' ? placeholder :
      text ? (pre || '') + text + (post || '') : '';
  }

  return text.replace(rePlaceholder, getPlaceholderText)
    .replace(rePlaceholderCompat, getPlaceholderText);
}

function array2charlist(array, caseSensitive, collectSymbols) {
  var values, group = [], groupClass = -1, charCode = 0, symbols = '', suppressed;
  function addGroup(groups, group) {
    if (group.length > 3) { // ellipsis
      groups.push(group[0] + '...' + group[group.length - 1]);
      suppressed = true;
    } else if (group.length) {
      groups = groups.concat(group);
    }
    return groups;
  }

  values = array.reduce(
      function(chars, value) { return chars.concat((value + '').split('')); }, [])
    .reduce(function(groups, curChar) {
      var curGroupClass, curCharCode;
      if (!caseSensitive) { curChar = curChar.toLowerCase(); }
      curGroupClass = /^\d$/.test(curChar) ? 1 :
        /^[A-Z]$/.test(curChar) ? 2 : /^[a-z]$/.test(curChar) ? 3 : 0;
      if (collectSymbols && curGroupClass === 0) {
        symbols += curChar;
      } else {
        curCharCode = curChar.charCodeAt(0);
        if (curGroupClass && curGroupClass === groupClass &&
            curCharCode === charCode + 1) {
          group.push(curChar);
        } else {
          groups = addGroup(groups, group);
          group = [curChar];
          groupClass = curGroupClass;
        }
        charCode = curCharCode;
      }
      return groups;
    }, []);
  values = addGroup(values, group); // last group
  if (symbols) { values.push(symbols); suppressed = true; }
  return {values: values, suppressed: suppressed};
}

function joinChunks(chunks, suppressed) {
  return chunks.join(chunks.length > 2 ? ', ' : suppressed ? ' / ' : '/');
}

function getPhContent(param, options) {
  var text, values, resCharlist = {}, arg;
  if (options.phContent) {
    text = options.phContent(param, options);
  }
  if (typeof text !== 'string') {
    switch (param) {
      case 'hideEchoBack':
      case 'mask':
      case 'defaultInput':
      case 'caseSensitive':
      case 'keepWhitespace':
      case 'encoding':
      case 'bufferSize':
      case 'history':
      case 'cd':
        text = !options.hasOwnProperty(param) ? '' :
          typeof options[param] === 'boolean' ? (options[param] ? 'on' : 'off') :
          options[param] + '';
        break;
      // case 'prompt':
      // case 'query':
      // case 'display':
      //   text = options.hasOwnProperty('displaySrc') ? options.displaySrc + '' : '';
      //   break;
      case 'limit':
      case 'trueValue':
      case 'falseValue':
        values = options[options.hasOwnProperty(param + 'Src') ? param + 'Src' : param];
        if (options.keyIn) { // suppress
          resCharlist = array2charlist(values, options.caseSensitive);
          values = resCharlist.values;
        } else {
          values = values.filter(function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number';
          });
        }
        text = joinChunks(values, resCharlist.suppressed);
        break;
      case 'limitCount':
      case 'limitCountNotZero':
        text = options[options.hasOwnProperty('limitSrc') ?
          'limitSrc' : 'limit'].length;
        text = text || param !== 'limitCountNotZero' ? text + '' : '';
        break;
      case 'lastInput':
        text = lastInput;
        break;
      case 'cwd':
      case 'CWD':
      case 'cwdHome':
        text = process.cwd();
        if (param === 'CWD') {
          text = pathUtil.basename(text);
        } else if (param === 'cwdHome') {
          text = replaceHomePath(text);
        }
        break;
      case 'date':
      case 'time':
      case 'localeDate':
      case 'localeTime':
        text = (new Date())['to' +
          param.replace(/^./, function(str) { return str.toUpperCase(); }) +
          'String']();
        break;
      default: // with arg
        if (typeof (arg = (param.match(/^history_m(\d+)$/) || [])[1]) === 'string') {
          text = inputHistory[inputHistory.length - arg] || '';
        }
    }
  }
  return text;
}

function getPhCharlist(param) {
  var matches = /^(.)-(.)$/.exec(param), text = '', from, to, code, step;
  if (!matches) { return null; }
  from = matches[1].charCodeAt(0);
  to = matches[2].charCodeAt(0);
  step = from < to ? 1 : -1;
  for (code = from; code !== to + step; code += step) { text += String.fromCharCode(code); }
  return text;
}

// cmd "arg" " a r g " "" 'a"r"g' "a""rg" "arg
function parseCl(cl) {
  var reToken = new RegExp(/(\s*)(?:("|')(.*?)(?:\2|$)|(\S+))/g), matches,
    taken = '', args = [], part;
  cl = cl.trim();
  while ((matches = reToken.exec(cl))) {
    part = matches[3] || matches[4] || '';
    if (matches[1]) {
      args.push(taken);
      taken = '';
    }
    taken += part;
  }
  if (taken) { args.push(taken); }
  return args;
}

function toBool(res, options) {
  return (
    (options.trueValue.length &&
      isMatched(res, options.trueValue, options.caseSensitive)) ? true :
    (options.falseValue.length &&
      isMatched(res, options.falseValue, options.caseSensitive)) ? false : res);
}

function getValidLine(options) {
  var res, forceNext, limitMessage,
    matches, histInput, args, resCheck;

  function _getPhContent(param) { return getPhContent(param, options); }
  function addDisplay(text) { options.display += (/[^\r\n]$/.test(options.display) ? '\n' : '') + text; }

  options.limitSrc = options.limit;
  options.displaySrc = options.display;
  options.limit = ''; // for readlineExt
  options.display = replacePlaceholder(options.display + '', _getPhContent);

  while (true) {
    res = _readlineSync(options);
    forceNext = false;
    limitMessage = '';

    if (options.defaultInput && !res) { res = options.defaultInput; }

    if (options.history) {
      if ((matches = /^\s*\!(?:\!|-1)(:p)?\s*$/.exec(res))) { // `!!` `!-1` +`:p`
        histInput = inputHistory[0] || '';
        if (matches[1]) { // only display
          forceNext = true;
        } else { // replace input
          res = histInput;
        }
        // Show it even if it is empty (NL only).
        addDisplay(histInput + '\n');
        if (!forceNext) { // Loop may break
          options.displayOnly = true;
          _readlineSync(options);
          options.displayOnly = false;
        }
      } else if (res && res !== inputHistory[inputHistory.length - 1]) {
        inputHistory = [res];
      }
    }

    if (!forceNext && options.cd && res) {
      args = parseCl(res);
      switch (args[0].toLowerCase()) {
        case 'cd':
          if (args[1]) {
            try {
              process.chdir(replaceHomePath(args[1], true));
            } catch (e) {
              addDisplay(e + '');
            }
          }
          forceNext = true;
          break;
        case 'pwd':
          addDisplay(process.cwd());
          forceNext = true;
          break;
        // no default
      }
    }

    if (!forceNext && options.preCheck) {
      resCheck = options.preCheck(res, options);
      res = resCheck.res;
      if (resCheck.forceNext) { forceNext = true; } // Don't switch to false.
    }

    if (!forceNext) {
      if (!options.limitSrc.length ||
        isMatched(res, options.limitSrc, options.caseSensitive)) { break; }
      if (options.limitMessage) {
        limitMessage = replacePlaceholder(options.limitMessage, _getPhContent);
      }
    }

    addDisplay((limitMessage ? limitMessage + '\n' : '') +
      replacePlaceholder(options.displaySrc + '', _getPhContent));
  }
  return toBool(res, options);
}

// for dev
exports._DBG_set_useExt = function(val) { _DBG_useExt = val; };
exports._DBG_set_checkOptions = function(val) { _DBG_checkOptions = val; };
exports._DBG_set_checkMethod = function(val) { _DBG_checkMethod = val; };
exports._DBG_clearHistory = function() { lastInput = ''; inputHistory = []; };

// ------------------------------------

exports.setDefaultOptions = function(options) {
  defaultOptions = margeOptions(true, options);
  return margeOptions(true); // copy
};

exports.question = function(query, options) {
  /* eslint-disable key-spacing */
  return getValidLine(margeOptions(margeOptions(true, options), {
    display:            query
  }));
  /* eslint-enable key-spacing */
};

exports.prompt = function(options) {
  var readOptions = margeOptions(true, options);
  readOptions.display = readOptions.prompt;
  return getValidLine(readOptions);
};

exports.keyIn = function(query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions(margeOptions(true, options), {
    display:            query,
    keyIn:              true,
    keepWhitespace:     true
  });
  /* eslint-enable key-spacing */

  // char list
  readOptions.limitSrc = readOptions.limit.filter(function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number';
  })
  .map(function(text) { return replacePlaceholder(text + '', getPhCharlist); });
  // pattern
  readOptions.limit = escapePattern(readOptions.limitSrc.join(''));

  ['trueValue', 'falseValue'].forEach(function(optionName) {
    readOptions[optionName] = readOptions[optionName].reduce(function(comps, comp) {
      var type = typeof comp;
      if (type === 'string' || type === 'number') {
        comps = comps.concat((comp + '').split(''));
      } else { comps.push(comp); }
      return comps;
    }, []);
  });

  readOptions.display = replacePlaceholder(readOptions.display + '',
    function(param) { return getPhContent(param, readOptions); });

  return toBool(_readlineSync(readOptions), readOptions);
};

// ------------------------------------

exports.questionEMail = function(query, options) {
  if (query == null) { query = 'Input e-mail address: '; }
  /* eslint-disable key-spacing */
  return exports.question(query, margeOptions({
    // -------- default
    hideEchoBack:       false,
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    limit:              /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    limitMessage:       'Input valid e-mail address, please.',
    trueValue:          null,
    falseValue:         null
  }, options, {
    // -------- forced
    keepWhitespace:     false,
    cd:                 false
  }));
  /* eslint-enable key-spacing */
};

exports.questionNewPassword = function(query, options) {
  /* eslint-disable key-spacing */
  var resCharlist, min, max,
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       true,
      mask:               '*',
      limitMessage:       'It can include: $<charlist>\n' +
                            'And the length must be: $<length>',
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      true
    }, options, {
      // -------- forced
      history:            false,
      cd:                 false,
      // limit (by charlist etc.),
      phContent: function(param) {
        return param === 'charlist' ? resCharlist.text :
          param === 'length' ? min + '...' + max : null;
      }
    }),
    // added:     charlist, min, max, confirmMessage, unmatchMessage
    charlist, confirmMessage, unmatchMessage,
    limit, limitMessage, res1, res2;
  /* eslint-enable key-spacing */
  options = options || {};

  charlist = replacePlaceholder(
    options.charlist ? options.charlist + '' : '$<!-~>', getPhCharlist);
  if (isNaN(min = parseInt(options.min, 10)) || typeof min !== 'number') { min = 12; }
  if (isNaN(max = parseInt(options.max, 10)) || typeof max !== 'number') { max = 24; }
  limit = new RegExp('^[' + escapePattern(charlist) +
    ']{' + min + ',' + max + '}$');
  resCharlist = array2charlist([charlist], readOptions.caseSensitive, true);
  resCharlist.text = joinChunks(resCharlist.values, resCharlist.suppressed);

  confirmMessage = options.confirmMessage != null ? options.confirmMessage :
    'Reinput a same one to confirm it: ';
  unmatchMessage = options.unmatchMessage != null ? options.unmatchMessage :
    'It differs from first one.' +
      ' Hit only the Enter key if you want to retry from first one.';

  if (query == null) { query = 'Input new password: '; }

  limitMessage = readOptions.limitMessage;
  while (!res2) {
    readOptions.limit = limit;
    readOptions.limitMessage = limitMessage;
    res1 = exports.question(query, readOptions);

    readOptions.limit = [res1, ''];
    readOptions.limitMessage = unmatchMessage;
    res2 = exports.question(confirmMessage, readOptions);
  }

  return res1;
};

function _questionNum(query, options, parser) {
  var validValue;
  function getValidValue(value) {
    validValue = parser(value);
    return !isNaN(validValue) && typeof validValue === 'number';
  }
  /* eslint-disable key-spacing */
  exports.question(query, margeOptions({
    // -------- default
    limitMessage:       'Input valid number, please.'
  }, options, {
    // -------- forced
    limit:              getValidValue,
    cd:                 false
    // trueValue, falseValue, caseSensitive, keepWhitespace don't work.
  }));
  /* eslint-enable key-spacing */
  return validValue;
}
exports.questionInt = function(query, options) {
  return _questionNum(query, options, function(value) { return parseInt(value, 10); });
};
exports.questionFloat = function(query, options) {
  return _questionNum(query, options, parseFloat);
};

exports.questionPath = function(query, options) {
  /* eslint-disable key-spacing */
  var validPath, error = '',
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       '$<error(\n)>Input valid path, please.' +
                            '$<( Min:)min>$<( Max:)max>',
      history:            true,
      cd:                 true
    }, options, {
      // -------- forced
      keepWhitespace:     false,
      limit: function(value) {
        var exists, stat, res;
        value = replaceHomePath(value, true);
        error = ''; // for validate
        // mkdir -p
        function mkdirParents(dirPath) {
          dirPath.split(/\/|\\/).reduce(function(parents, dir) {
            var path = pathUtil.resolve((parents += dir + pathUtil.sep));
            if (!fs.existsSync(path)) {
              fs.mkdirSync(path);
            } else if (!fs.statSync(path).isDirectory()) {
              throw new Error('Non directory already exists: ' + path);
            }
            return parents;
          }, '');
        }

        try {
          exists = fs.existsSync(value);
          validPath = exists ? fs.realpathSync(value) : pathUtil.resolve(value);
          // options.exists default: true, not-bool: no-check
          if (!options.hasOwnProperty('exists') && !exists ||
              typeof options.exists === 'boolean' && options.exists !== exists) {
            error = (exists ? 'Already exists' : 'No such file or directory') +
              ': ' + validPath;
            return false;
          }
          if (!exists && options.create) {
            if (options.isDirectory) {
              mkdirParents(validPath);
            } else {
              mkdirParents(pathUtil.dirname(validPath));
              fs.closeSync(fs.openSync(validPath, 'w')); // touch
            }
            validPath = fs.realpathSync(validPath);
          }
          if (exists && (options.min || options.max ||
              options.isFile || options.isDirectory)) {
            stat = fs.statSync(validPath);
            // type check first (directory has zero size)
            if (options.isFile && !stat.isFile()) {
              error = 'Not file: ' + validPath;
              return false;
            } else if (options.isDirectory && !stat.isDirectory()) {
              error = 'Not directory: ' + validPath;
              return false;
            } else if (options.min && stat.size < +options.min ||
                options.max && stat.size > +options.max) {
              error = 'Size ' + stat.size + ' is out of range: ' + validPath;
              return false;
            }
          }
          if (typeof options.validate === 'function' &&
              (res = options.validate(validPath)) !== true) {
            if (typeof res === 'string') { error = res; }
            return false;
          }
        } catch (e) {
          error = e + '';
          return false;
        }
        return true;
      },
      // trueValue, falseValue, caseSensitive don't work.
      phContent: function(param) {
        return param === 'error' ? error :
          param !== 'min' && param !== 'max' ? null :
          options.hasOwnProperty(param) ? options[param] + '' : '';
      }
    });
    // added:     exists, create, min, max, isFile, isDirectory, validate
  /* eslint-enable key-spacing */
  options = options || {};

  if (query == null) { query = 'Input path (you can "cd" and "pwd"): '; }

  exports.question(query, readOptions);
  return validPath;
};

// props: preCheck, args, hRes, limit
function getClHandler(commandHandler, options) {
  var clHandler = {}, hIndex = {};
  if (typeof commandHandler === 'object') {
    Object.keys(commandHandler).forEach(function(cmd) {
      if (typeof commandHandler[cmd] === 'function') {
        hIndex[options.caseSensitive ? cmd : cmd.toLowerCase()] = commandHandler[cmd];
      }
    });
    clHandler.preCheck = function(res) {
      var cmdKey;
      clHandler.args = parseCl(res);
      cmdKey = clHandler.args[0] || '';
      if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
      clHandler.hRes =
        cmdKey !== '_' && hIndex.hasOwnProperty(cmdKey) ?
          hIndex[cmdKey].apply(res, clHandler.args.slice(1)) :
        hIndex.hasOwnProperty('_') ? hIndex._.apply(res, clHandler.args) : null;
      return {res: res, forceNext: false};
    };
    if (!hIndex.hasOwnProperty('_')) {
      clHandler.limit = function() { // It's called after preCheck.
        var cmdKey = clHandler.args[0] || '';
        if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
        return hIndex.hasOwnProperty(cmdKey);
      };
    }
  } else {
    clHandler.preCheck = function(res) {
      clHandler.args = parseCl(res);
      clHandler.hRes = typeof commandHandler === 'function' ?
        commandHandler.apply(res, clHandler.args) : true; // true for break loop
      return {res: res, forceNext: false};
    };
  }
  return clHandler;
}

exports.promptCL = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  exports.prompt(readOptions);
  return clHandler.args;
};

exports.promptLoop = function(inputHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
    // -------- default
    hideEchoBack:       false,
    trueValue:          null,
    falseValue:         null,
    caseSensitive:      false,
    history:            true
  }, options);
  /* eslint-enable key-spacing */
  while (true) { if (inputHandler(exports.prompt(readOptions))) { break; } }
  return;
};

exports.promptCLLoop = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  while (true) {
    exports.prompt(readOptions);
    if (clHandler.hRes) { break; }
  }
  return;
};

exports.promptSimShell = function(options) {
  /* eslint-disable key-spacing */
  return exports.prompt(margeOptions({
    // -------- default
    hideEchoBack:       false,
    history:            true
  }, options, {
    // -------- forced
    prompt:             (function() {
      return IS_WIN ?
        '$<cwd>>' :
        // 'user@host:cwd$ '
        (process.env.USER || '') +
        (process.env.HOSTNAME ?
          '@' + process.env.HOSTNAME.replace(/\..*$/, '') : '') +
        ':$<cwdHome>$ ';
    })()
  }));
  /* eslint-enable key-spacing */
};

function _keyInYN(query, options, limit) {
  var res;
  if (query == null) { query = 'Are you sure? '; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s*:?\s*$/, '') + ' [y/n]: ';
  }
  /* eslint-disable key-spacing */
  res = exports.keyIn(query, margeOptions(options, {
    // -------- forced
    hideEchoBack:       false,
    limit:              limit,
    trueValue:          'y',
    falseValue:         'n',
    caseSensitive:      false
    // mask doesn't work.
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return typeof res === 'boolean' ? res : '';
}
exports.keyInYN = function(query, options) { return _keyInYN(query, options); };
exports.keyInYNStrict = function(query, options) { return _keyInYN(query, options, 'yn'); };

exports.keyInPause = function(query, options) {
  if (query == null) { query = 'Continue...'; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s+$/, '') + ' (Hit any key)';
  }
  /* eslint-disable key-spacing */
  exports.keyIn(query, margeOptions({
    // -------- default
    limit:              null
  }, options, {
    // -------- forced
    hideEchoBack:       true,
    mask:               ''
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return;
};

exports.keyInSelect = function(items, query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false
    }, options, {
      // -------- forced
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      false,
      // limit (by items),
      phContent: function(param) {
        return param === 'itemsCount' ? items.length + '' :
          param === 'firstItem' ? (items[0] + '').trim() :
          param === 'lastItem' ? (items[items.length - 1] + '').trim() : null;
      }
    }),
    // added:     guide, cancel
    keylist = '', key2i = {}, charCode = 49 /* '1' */, display = '\n';
  /* eslint-enable key-spacing */
  if (!Array.isArray(items) || !items.length || items.length > 35) {
    throw '`items` must be Array (max length: 35).';
  }

  items.forEach(function(item, i) {
    var key = String.fromCharCode(charCode);
    keylist += key;
    key2i[key] = i;
    display += '[' + key + '] ' + (item + '').trim() + '\n';
    charCode = charCode === 57 /* '9' */ ? 97 /* 'a' */ : charCode + 1;
  });
  if (!options || options.cancel !== false) {
    keylist += '0';
    key2i['0'] = -1;
    display += '[0] ' +
      (options && options.cancel != null && typeof options.cancel !== 'boolean' ?
        (options.cancel + '').trim() : 'CANCEL') + '\n';
  }
  readOptions.limit = keylist;
  display += '\n';

  if (query == null) { query = 'Choose one from list: '; }
  if ((query += '')) {
    if (!options || options.guide !== false) {
      query = query.replace(/\s*:?\s*$/, '') + ' [$<limit>]: ';
    }
    display += query;
  }

  return key2i[exports.keyIn(display, readOptions).toLowerCase()];
};

exports.getRawInput = function() { return rawInput; };

// ======== DEPRECATED ========
function _setOption(optionName, args) {
  var options;
  if (args.length) { options = {}; options[optionName] = args[0]; }
  return exports.setDefaultOptions(options)[optionName];
}
exports.setPrint = function() { return _setOption('print', arguments); };
exports.setPrompt = function() { return _setOption('prompt', arguments); };
exports.setEncoding = function() { return _setOption('encoding', arguments); };
exports.setMask = function() { return _setOption('mask', arguments); };
exports.setBufferSize = function() { return _setOption('bufferSize', arguments); };


/***/ }),

/***/ "./node_modules/tau-prolog/modules/core.js":
/*!*************************************************!*\
  !*** ./node_modules/tau-prolog/modules/core.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function() {
	
	// VERSION
	var version = { major: 0, minor: 3, patch: 4, status: "beta" };



	// IO FILE SYSTEM
	
	// Virtual file
	function TauFile(name, type, parent, text) {
		text = text === undefined ? "" : text;
		this.name = name;
		this.type = type;
		this.parent = parent;
		this.text = text;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauFile.prototype.get = function(length, position) {
		if(position === this.text.length) {
			return "end_of_stream";
		} else if(position > this.text.length) {
			return "end_of_stream";
		} else {
			return this.text.substring(position, position+length);
		}
	};

	TauFile.prototype.eof = function(position) {
		return position === this.text.length;
	};

	TauFile.prototype.put = function(text, position) {
		if(position === "end_of_stream") {
			this.text += text;
			return true;
		} else if(position === "past_end_of_stream") {
			return null;
		} else {
			this.text = this.text.substring(0, position) + text + this.text.substring(position+text.length);
			return true;
		}
	};

	TauFile.prototype.get_byte = function(position) {
		if(position === "end_of_stream")
			return -1;
		var index = Math.floor(position/2);
		if(this.text.length <= index)
			return -1;
		var code = codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0)
			return code & 0xff;
		else
			return code / 256 >>> 0;
	};

	TauFile.prototype.put_byte = function(byte, position) {
		var index = position === "end_of_stream" ? this.text.length : Math.floor(position/2);
		if(this.text.length < index)
			return null;
		var code = this.text.length === index ? -1 : codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0) {
			code = code / 256 >>> 0;
			code = ((code & 0xff) << 8) | (byte & 0xff);
		} else {
			code = code & 0xff;
			code = ((byte & 0xff) << 8) | (code & 0xff);
		}
		if(this.text.length === index)
			this.text += fromCodePoint(code);
		else 
			this.text = this.text.substring(0, index) + fromCodePoint(code) + this.text.substring(index+1);
		return true;
	};

	TauFile.prototype.flush = function() {
		return true;
	};

	TauFile.prototype.close = function() {
		this.modified = Date.now() / 1000;
		return true;
	};

	TauFile.prototype.size = function() {
		return this.text.length;
	};

	// Virtual directory
	function TauDirectory(name, parent) {
		this.name = name;
		this.parent = parent;
		this.files = {};
		this.length = 0;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauDirectory.prototype.lookup = function(file) {
		if(this.files.hasOwnProperty(file))
			return this.files[file];
		return null;
	};

	TauDirectory.prototype.push = function(name, file) {
		if(!this.files.hasOwnProperty(name))
			this.length++;
		this.files[name] = file;
		this.modified = Date.now() / 1000;
	};

	TauDirectory.prototype.remove = function(name) {
		if(this.files.hasOwnProperty(name)) {
			this.length--;
			delete this.files[name];
			this.modified = Date.now() / 1000;
		}
	};

	TauDirectory.prototype.empty = function() {
		return this.length === 0;
	};

	TauDirectory.prototype.size = function() {
		return 4096;
	};

	// Virtual file system for browser
	tau_file_system = {
		// Current files
		files: new TauDirectory("/", "/", null),
		// Open file
		open: function(path, type, mode) {
			var dirs = path.replace(/\/$/, "").split("/");
			var dir = tau_file_system.files;
			var name = dirs[dirs.length-1];
			for(var i = 1; i < dirs.length-1; i++) {
				dir = dir.lookup(dirs[i]);
				if(!pl.type.is_directory(dir))
					return null;
			}
			var file = dir.lookup(name);
			if(file === null) {
				if(mode === "read")
					return null;
				file = new TauFile(name, type, dir);
				dir.push(name, file);
			} else if(!pl.type.is_file(file)) {
				return null;
			}
			if(mode === "write")
				file.text = "";
			return file;
		},
		// Get item
		get: function(path) {
			var dirs = path.replace(/\/$/, "").split("/");
			var file = tau_file_system.files;
			for(var i = 1; i < dirs.length; i++)
				if(pl.type.is_directory(file))
					file = file.lookup(dirs[i]);
				else
					return null;
			return file;
		}
	};

	// User input for browser
	tau_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			while( tau_user_input.buffer.length < length ) {
				text = window.prompt();
				if( text.length === 0 )
					return "end_of_stream";
				if( text ) {
					tau_user_input.buffer += text;
				}
			}
			text = tau_user_input.buffer.substr( 0, length );
			tau_user_input.buffer = tau_user_input.buffer.substr( length );
			return text;
		},
		eof: function(_) {
			return false;
		}
	};

	// User output for browser
	tau_user_output = {
		put: function( text, _ ) {
			console.log( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// User error for browser
	tau_user_error = {
		put: function( text, _ ) {
			(console.error || console.log)( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// Virtual file system for Node.js
	nodejs_file_system = {
		// Open file
		open: function( path, type, mode ) {
			var fd, fs = __webpack_require__(/*! fs */ "?4a0f");
			if( mode === "read" && !fs.existsSync( path ) )
				return null;
			try {
				fd = fs.openSync( path, mode[0] );
			} catch(ex) {
				return false;
			}
			return {
				get: function( length, position ) {
					var buffer = new Buffer( length );
					fs.readSync( fd, buffer, 0, length, position );
					var end_of_file = true;
					var text = buffer.toString();
					for(var i = 0; i < length && end_of_file; i++)
						end_of_file = text[i] === "\u0000";
					return end_of_file ? "end_of_stream" : buffer.toString();
				},
				eof: function(position) {
					var stats = fs.statSync(path)
					return position === stats["size"];
				},
				put: function( text, position ) {
					var buffer = Buffer.from( text );
					if( position === "end_of_stream" )
						fs.writeSync( fd, buffer );
					else if( position === "past_end_of_stream" )
						return null;
					else
						fs.writeSync( fd, buffer, 0, buffer.length, position );
					return true;
				},
				get_byte: function( position ) {
					try {
						var buffer = Buffer.alloc(1);
						var bytesRead = fs.readSync(fd, buffer, 0, 1, position);
						//var _text = buffer.toString("utf8", 0, bytesRead);
						var end_of_file = bytesRead < 1;
						return end_of_file ? "end_of_stream" : buffer.readUInt8(0);
					} catch(ex) {
						return "end_of_stream";
					}
				},
				put_byte: function(byte, position) {
					var buffer = Buffer.from([byte]);
					if(position === "end_of_stream")
						fs.writeSync(fd, buffer);
					else if(position === "past_end_of_stream")
						return null;
					else
						fs.writeSync(fd, buffer, 0, buffer.length, position);
					return true;
				},
				flush: function() {
					return true;
				},
				close: function() {
					fs.closeSync( fd );
					return true;
				}
			};
		}
	};

	// User input for Node.js
	nodejs_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			var readlineSync = __webpack_require__(/*! readline-sync */ "./node_modules/readline-sync/lib/readline-sync.js");
			while( nodejs_user_input.buffer.length < length )
				nodejs_user_input.buffer += readlineSync.question("", {keepWhitespace: true}) + "\n";
			text = nodejs_user_input.buffer.substr( 0, length );
			nodejs_user_input.buffer = nodejs_user_input.buffer.substr( length );
			return text;
		},
		eof: function(length) {
			return false;
		}
	};

	// User output for Node.js
	nodejs_user_output = {
		put: function( text, _ ) {
			process.stdout.write( text );
			return true;
		},
		flush: function() {
			return true;
		}
	};

	// User error for Node.js
	nodejs_user_error = {
		put: function( text, _ ) {
			process.stderr.write( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};
	
	
	
	// COMPATITBILITY
	
	var indexOf;
	if(!Array.prototype.indexOf) {
		indexOf = function(array, elem) {
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(elem === array[i]) return i;
			}
			return -1;
		};
	} else {
		indexOf = function(array, elem) {
			return array.indexOf(elem);
		};
	}

	var reduce = function(array, fn) {
		if(array.length === 0) return undefined;
		var elem = array[0];
		var len = array.length;
		for(var i = 1; i < len; i++) {
			elem = fn(elem, array[i]);
		}
		return elem;
	};

	var map;
	if(!Array.prototype.map) {
		map = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				a.push( fn(array[i]) );
			}
			return a;
		};
	} else {
		map = function(array, fn) {
			return array.map(fn);
		};
	}
	
	var filter;
	if(!Array.prototype.filter) {
		filter = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(fn(array[i]))
					a.push( array[i] );
			}
			return a;
		};
	} else {
		filter = function(array, fn) {
			return array.filter(fn);
		};
	}
	
	var codePointAt;
	if(!String.prototype.codePointAt) {
		codePointAt = function(str, i) {
			return str.charCodeAt(i);
		};
	} else {
		codePointAt = function(str, i) {
			return str.codePointAt(i);
		};
	}
	
	var fromCodePoint;
	if(!String.fromCodePoint) {
		fromCodePoint = function() {
			return String.fromCharCode.apply(null, arguments);
		};
	} else {
		fromCodePoint = function() {
			return String.fromCodePoint.apply(null, arguments);
		};
	}

	var stringLength;
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	if(Array.from)
		stringLength = function(str) {
			return Array.from(str).length;
		};
	else
		stringLength = function(str) {
			return str.replace(regexAstralSymbols, '_').length;
		};

	
	
	// PARSER

	var ERROR = 0;
	var SUCCESS = 1;

	var regex_escape = /(\\a)|(\\b)|(\\d)|(\\e)|(\\f)|(\\n)|(\\r)|(\\s)|(\\t)|(\\v)|\\x([0-9a-fA-F]+)\\|\\([0-7]+)\\|(\\\\)|(\\')|('')|(\\")|(\\`)|(\\.)|(.)/g;
	var escape_map = {"\\a": 7, "\\b": 8, "\\d": 127, "\\e": 27, "\\f": 12, "\\n": 10, "\\r": 13, "\\s": 32, "\\t": 9, "\\v": 11};
	function escape(str) {
		var stack = [];
		var _error = false;
		str.replace(regex_escape, function(match, a, b, d, e, f, n, r, s, t, v, hex, octal, back, single, dsingle, double, backquote, error, char) {
			switch(true) {
				case hex !== undefined:
					stack.push( parseInt(hex, 16) );
					return "";
				case octal !== undefined:
					stack.push( parseInt(octal, 8) );
					return "";
				case back !== undefined:
				case single !== undefined:
				case dsingle !== undefined:
				case double !== undefined:
				case backquote !== undefined:
					stack.push( codePointAt(match.substr(1),0) );
					return "";
				case char !== undefined:
					stack.push( codePointAt(char,0) );
					return "";
				case error !== undefined:
					_error = true;
				default:
					stack.push(escape_map[match]);
					return "";
			}
		});
		if(_error)
			return null;
		return stack;
	}

	// Escape atoms
	function escapeAtom(str, quote) {
		var atom = '';
		if( str === "\\" ) return null;
		if( str.length < 2 ) return str;
		try {
			str = str.replace(/((?:\\\\)+)|\\([0-7]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 8));
			});
			str = str.replace(/((?:\\\\)+)|\\x([0-9a-fA-F]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
			str = str.replace(/((?:\\\\)+)|\\u([0-9a-fA-F]{4})/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
		} catch(error) {
			return null;
		}
		for( var i = 0; i < str.length; i++) {
			var a = str.charAt(i);
			var b = str.charAt(i+1);
			if( a === quote && b === quote ) {
				i++;
				atom += quote;
			} else if( a === '\\' ) {
				if( ['a','b','f','n','r','t','v',"'",'"','\\','\a','\b','\f','\n','\r','\t','\v'].indexOf(b) !== -1 ) {
					i += 1;
					switch( b ) {
						case 'a': atom += '\a'; break;
						case 'b': atom += '\b'; break;
						case 'f': atom += '\f'; break;
						case 'n': atom += '\n'; break;
						case 'r': atom += '\r'; break;
						case 't': atom += '\t'; break;
						case 'v': atom += '\v'; break;
						case "'": atom += "'"; break;
						case '"': atom += '"'; break;
						case '\\': atom += '\\'; break;
					}
				} else {
					return null;
				}
			} else {
				atom += a;
			}
		}
		return atom;
	}
	
	// Redo escape
	function redoEscape(str) {
		var atom = '';
		for( var i = 0; i < str.length; i++) {
			switch( str.charAt(i) ) {
				case "'": atom += "\\'"; break;
				case '\\': atom += '\\\\'; break;
				//case '\a': atom += '\\a'; break;
				case '\b': atom += '\\b'; break;
				case '\f': atom += '\\f'; break;
				case '\n': atom += '\\n'; break;
				case '\r': atom += '\\r'; break;
				case '\t': atom += '\\t'; break;
				case '\v': atom += '\\v'; break;
				default: atom += str.charAt(i); break;
			}
		}
		return atom;
	}

	// String to num
	function convertNum(num) {
		var n = num.substr(2);
		switch(num.substr(0,2).toLowerCase()) {
			case "0x":
				return parseInt(n, 16);
			case "0b":
				return parseInt(n, 2);
			case "0o":
				return parseInt(n, 8);
			case "0'":
				return escape(n)[0];
			default:
				return parseFloat(num);
		}
	}

	// Is graphic token
	function is_graphic_token(string) {
		return /^[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+/.test(string);
	}

	// Regular expressions for tokens
	var rules = {
		whitespace: /^\s*(?:(?:%.*)|(?:\/\*(?:\n|\r|.)*?(?:\*\/|$))|(?:\s+))\s*/,
		variable: /^(?:[A-Z_][a-zA-Z0-9_]*)/,
		atom: /^(\!|,|;|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+|'(?:(?:'')|(?:\\\\)|(?:\\')|[^'])*')/,
		number: /^(?:0o[0-7]+|0x[0-9a-fA-F]+|0b[01]+|0'(?:''|\\[abdefnrstv\\'"`]|\\x?\d+\\|[^\\])|\d+(?:\.\d+(?:[eE][+-]?\d+)?)?)/,
		string: /^(?:"([^"]|""|\\")*"|`([^`]|``|\\`)*`)/,
		l_brace: /^(?:\[)/,
		r_brace: /^(?:\])/,
		l_bracket: /^(?:\{)/,
		r_bracket: /^(?:\})/,
		bar: /^(?:\|)/,
		l_paren: /^(?:\()/,
		r_paren: /^(?:\))/
	};

	// Replace chars of char_conversion session
	function replace( thread, text ) {
		if( thread.get_flag( "char_conversion" ).id === "on" ) {
			return text.replace(/./g, function(char) {
				return thread.get_char_conversion( char );
			});
		}
		return text;
	}

	// Tokenize strings
	function Tokenizer(thread) {
		this.thread = thread;
		this.text = ""; // Current text to be analized
		this.tokens = []; // Consumed tokens
	}

	Tokenizer.prototype.set_last_tokens = function(tokens) {
		return this.tokens = tokens;
	};

	Tokenizer.prototype.new_text = function(text) {
		this.text = text;
		this.tokens = [];
	};

	Tokenizer.prototype.get_tokens = function(init) {
		var text;
		var len = 0; // Total length respect to text
		var line = 0;
		var start = 0;
		var tokens = [];
		var last_is_blank;

		if(init) {
			var token = this.tokens[init-1];
			len = token.len;
			text = replace( this.thread, this.text.substr(token.len) );
			line = token.line;
			start = token.start;
		}
		else
			text = this.text;


		// If there is nothing to be analized, return null
		if(/^\s*$/.test(text))
			return null;

		while(text !== "") {
			var matches = [];
			last_is_blank = false;

			if(/^\n/.exec(text) !== null) {
				line++;
				start = 0;
				len++;
				text = text.replace(/\n/, "");
				last_is_blank = true;
				continue;
			}

			for(var rule in rules) {
				if(rules.hasOwnProperty(rule)) {
					var matchs = rules[rule].exec( text );
					if(matchs) {
						matches.push({
							value: matchs[0],
							name: rule,
							matches: matchs
						});
					}
				}
			}

			// Lexical error
			if(!matches.length)
				return this.set_last_tokens( [{ value: text, matches: [], name: "lexical", line: line, start: start }] );

			var token = reduce( matches, function(a, b) {
				return a.value.length >= b.value.length ? a : b;
			} );

			token.start = start;
			token.line = line;

			text = text.replace(token.value, "");
			start += token.value.length;
			len += token.value.length;

			var nl = (token.value.match(/\n/g) || []).length;
			line += nl;
			if(nl > 0) 
				start = token.value.length - token.value.lastIndexOf("\n") - 1;
			token.line_count = line;
			token.line_position = start;

			switch(token.name) {
				case "atom":
					token.raw = token.value;
					if(token.value.charAt(0) === "'") {
						token.value = escapeAtom( token.value.substring(1, token.value.length - 1), "'" );
						if( token.value === null ) {
							token.name = "lexical";
							token.value = token.raw;
							token.error = "unknown_escape_sequence";
						}
					}
					break;
				case "number":
					var substr = token.value.substring(0,2);
					token.raw = token.value;
					token.float = substr !== "0x" && substr !== "0'" && token.value.match(/[.eE]/) !== null;
					token.value = convertNum( token.value );
					token.blank = last_is_blank;
					if(!token.float && pl.flag.bounded.value.indicator === "true/0" && token.value > pl.flag.max_integer.value.value) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "int_overflow";
					}
					break;
				case "string":
					var del = token.value.charAt(0);
					token.raw = token.value;
					token.value = escapeAtom( token.value.substring(1, token.value.length - 1), del );
					if( token.value === null ) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "unknown_escape_sequence"
					}
					break;
				case "whitespace":
					var last = tokens[tokens.length-1];
					if(last) last.space = true;
					last_is_blank = true;
					continue;
				case "r_bracket":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_bracket" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "{}";
						token.raw = "{}";
						token.space = false;
					}
					break;
				case "r_brace":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_brace" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "[]";
						token.raw = "[]";
						token.space = false;
					}
					break;
			}
			token.len = len;
			tokens.push( token );
			last_is_blank = false;
		}

		var t = this.set_last_tokens( tokens );
		return t.length === 0 ? null : t;
	};

	// Parse an expression
	function parseExpr(thread, tokens, start, priority, toplevel) {
		if(!tokens[start]) return {type: ERROR, value: pl.error.syntax(tokens[start-1], "expression expected", true)};
		var error;

		if(priority === "0") {
			var token = tokens[start];
			switch(token.name) {
				case "number":
					return {type: SUCCESS, len: start+1, value: new pl.type.Num(token.value, token.float)};
				case "variable":
					return {type: SUCCESS, len: start+1, value: new pl.type.Var(token.value)};
				case "string":
					var str;
					switch( thread.get_flag( "double_quotes" ).id ) {
						case "atom":;
							str = new Term( token.value, [] );
							break;
						case "codes":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Num( codePointAt(token.value,i), false ), str] );
							break;
						case "chars":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Term( token.value.charAt(i), [] ), str] );
							break;
					}
					return {type: SUCCESS, len: start+1, value: str};
				case "l_paren":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_paren") {
						expr.len++;
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], ") or operator expected", !tokens[expr.len])}
				case "l_bracket":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_bracket") {
						expr.len++;
						expr.value = new Term( "{}", [expr.value] );
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], "} or operator expected", !tokens[expr.len])}
			}
			// Compound term
			var result = parseTerm(thread, tokens, start, toplevel);
			if(result.type === SUCCESS || result.derived)
				return result;
			// List
			result = parseList(thread, tokens, start);
			if(result.type === SUCCESS || result.derived)
				return result;
			// Unexpected
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], token.error || "unexpected token")};
		}

		var max_priority = thread.__get_max_priority();
		var next_priority = thread.__get_next_priority(priority);
		var aux_start = start;
		
		// Prefix operators
		if(tokens[start].name === "atom" && tokens[start+1] && (tokens[start].space || tokens[start+1].name !== "l_paren")) {
			var token = tokens[start++];
			var classes = thread.__lookup_operator_classes(priority, token.value);
			
			// Associative prefix operator
			if(classes && classes.indexOf("fy") > -1) {
				var expr = parseExpr(thread, tokens, start, priority, toplevel);
				if(expr.type !== ERROR) {
					if( token.value === "-" && !token.space && pl.type.is_number( expr.value ) ) {
						return {
							value: new pl.type.Num(-expr.value.value, expr.value.is_float),
							len: expr.len,
							type: SUCCESS
						};
					} else {
						return {
							value: new pl.type.Term(token.value, [expr.value]),
							len: expr.len,
							type: SUCCESS
						};
					}
				} else {
					error = expr;
				}
			// Non-associative prefix operator
			} else if(classes && classes.indexOf("fx") > -1) {
				var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
				if(expr.type !== ERROR) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: expr.len,
						type: SUCCESS
					};
				} else {
					error = expr;
				}
			}
		}

		start = aux_start;
		var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
		if(expr.type === SUCCESS) {
			start = expr.len;
			var token = tokens[start];
			if(tokens[start] && (
				tokens[start].name === "atom" && thread.__lookup_operator_classes(priority, token.value) ||
				tokens[start].name === "bar" && thread.__lookup_operator_classes(priority, "|")
			) ) {
				var next_priority_lt = next_priority;
				var next_priority_eq = priority;
				var classes = thread.__lookup_operator_classes(priority, token.value);

				if(classes.indexOf("xf") > -1) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: ++expr.len,
						type: SUCCESS
					};
				} else if(classes.indexOf("xfx") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_lt, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(classes.indexOf("xfy") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_eq, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(expr.type !== ERROR) {
					while(true) {
						start = expr.len;
						var token = tokens[start];
						if(token && token.name === "atom" && thread.__lookup_operator_classes(priority, token.value)) {
							var classes = thread.__lookup_operator_classes(priority, token.value);
							if( classes.indexOf("yf") > -1 ) {
								expr = {
									value: new pl.type.Term(token.value, [expr.value]),
									len: ++start,
									type: SUCCESS
								};
							} else if( classes.indexOf("yfx") > -1 ) {
								var expr2 = parseExpr(thread, tokens, ++start, next_priority_lt, toplevel);
								if(expr2.type === ERROR) {
									expr2.derived = true;
									return expr2;
								}
								start = expr2.len;
								expr = {
									value: new pl.type.Term(token.value, [expr.value, expr2.value]),
									len: start,
									type: SUCCESS
								};
							} else { break; }
						} else { break; }
					}
				}
			} else {
				error = {type: ERROR, value: pl.error.syntax(tokens[expr.len-1], "operator expected")};
			}
			return expr;
		}
		return expr;
	}

	// Parse a compound term
	function parseTerm(thread, tokens, start, toplevel) {
		if(!tokens[start] || (tokens[start].name === "atom" && tokens[start].raw === "." && !toplevel && (tokens[start].space || !tokens[start+1] || tokens[start+1].name !== "l_paren")))
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "unfounded token")};
		var atom = tokens[start];
		var exprs = [];
		if(tokens[start].name === "atom" && tokens[start].raw !== ",") {
			start++;
			if(tokens[start-1].space) return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
			if(tokens[start] && tokens[start].name === "l_paren") {
				if(tokens[start+1] && tokens[start+1].name === "r_paren") 
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1], "argument expected")};
				var expr = parseExpr(thread, tokens, ++start, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], "argument expected", !tokens[start])};
				}
				exprs.push(expr.value);
				start = expr.len;
				while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
					expr = parseExpr(thread, tokens, start+1, "999", true);
					if(expr.type === ERROR) {
						if( expr.derived )
							return expr;
						else
							return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
					}
					exprs.push(expr.value);
					start = expr.len;
				}
				if(tokens[start] && tokens[start].name === "r_paren") start++;
				else return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ", or ) expected", !tokens[start])};
			}
			return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "term expected")};
	}

	// Parse a list
	function parseList(thread, tokens, start) {
		if(!tokens[start]) 
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "[ expected")};
		if(tokens[start] && tokens[start].name === "l_brace") {
			var expr = parseExpr(thread, tokens, ++start, "999", true);
			var exprs = [expr.value];
			var cons = undefined;

			if(expr.type === ERROR) {
				if(tokens[start] && tokens[start].name === "r_brace") {
					return {type: SUCCESS, len: start+1, value: new pl.type.Term("[]", [])};
				}
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start], "] expected")};
			}
			
			start = expr.len;

			while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				exprs.push(expr.value);
				start = expr.len;
			}
			var bar = false
			if(tokens[start] && tokens[start].name === "bar") {
				bar = true;
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				cons = expr.value;
				start = expr.len;
			}
			if(tokens[start] && tokens[start].name === "r_brace")
				return {type: SUCCESS, len: start+1, value: arrayToList(exprs, cons) };
			else
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], bar ? "] expected" : ", or | or ] expected", !tokens[start])};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "list expected")};
	}

	// Parse a rule
	function parseRule(thread, tokens, start) {
		var line = tokens[start].line;
		var expr = parseExpr(thread, tokens, start, thread.__get_max_priority(), false);
		var rule = null;
		var obj;
		if(expr.type !== ERROR) {
			start = expr.len;
			if(tokens[start] && tokens[start].name === "atom" && tokens[start].raw === ".") {
				start++;
				if( pl.type.is_term(expr.value) ) {
					if(expr.value.indicator === ":-/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					} else if(expr.value.indicator === "-->/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						rule = rule_to_dcg(rule, thread);
						rule.body = body_conversion(rule.body);
						if(!pl.type.is_rule(rule))
							return {
								value: rule,
								len: start,
								type: ERROR
							};
						obj = {
							value: rule,
							len: start,
							type: pl.type.is_rule( rule ) ? SUCCESS : ERROR
						};
					} else {
						rule = new pl.type.Rule(expr.value, null);
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					}
					if( rule ) {
						var singleton = rule.singleton_variables();
						if( singleton.length > 0 )
							thread.throw_warning( pl.warning.singleton( singleton, rule.head.indicator, line ) );
					}
					return obj;
				} else {
					return { type: ERROR, value: pl.error.syntax(tokens[start], "callable expected") };
				}
			} else {
				return { type: ERROR, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ". or operator expected") };
			}
		}
		return expr;
	}

	// Parse a program
	function parseProgram(thread, string, options) {
		var opts = {};
		options = options ? options : {};
		opts.success = options.success ? options.success : function(){};
		opts.error = options.error ? options.error : function(){};
		opts.from = options.from ? options.from : "$tau-js";
		opts.reconsult = options.reconsult !== undefined ? options.reconsult : true;
		opts.reconsulted = options.reconsulted === undefined ? {} : options.reconsulted;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.initialization = options.initialization === undefined ? [] : options.initialization;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.tokens = options.tokens === undefined ? null : options.tokens;
		opts.string = string;
		opts.term_expansion = false;
		var reconsulted = opts.reconsulted;
		var tokenizer = opts.tokenizer;
		var tokens = opts.tokens;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			tokenizer.new_text(string);
			opts.tokenizer = tokenizer;
			tokens = tokenizer.get_tokens(0);
			opts.tokens = tokens;
		}
		var n = opts.current_token;
		while(tokens !== null && tokens[n]) {
			var expr = parseRule(thread, tokens, n);
			opts.current_token = expr.len;
			if(expr.type === ERROR) {
				if(opts.error !== undefined)
				opts.error(new Term("throw", [expr.value]));
				return;
			} else {
				// Term expansion
				var context_module = opts.context_module;
				var term_expansion = thread.session.modules[context_module].rules["term_expansion/2"];
				if(term_expansion && term_expansion.length > 0) {
					opts.term_expansion = true;
					var n_thread = new Thread(thread.session);
					var term = expr.value.body ? new Term(":-", [expr.value.head, expr.value.body]) : expr.value.head;
					thread.session.renamed_variables = {};
					term = term.rename(thread.session);
					n_thread.query(context_module + ":term_expansion(" + term.toString({quoted: true}) + ", X).");
					n_thread.answer((function(thread, opts, reconsulted, expr) {
						return function(answer) {
							if(answer && !pl.type.is_error(answer) && pl.type.is_term(answer.links['X'])) {
								var term = answer.links['X'];
								var rule = term.indicator === ":-/2" ? new Rule(term.args[0], term.args[1]) : new Rule(term, null);
								parseProgramExpansion(thread, opts, reconsulted, {value: rule, len: expr.len, type: expr.type});
							} else {
								parseProgramExpansion(thread, opts, reconsulted, expr);
							}
						}
					})(thread, opts, reconsulted, expr));
					return;
				} else {
					opts.term_expansion = false;
					var async = parseProgramExpansion(thread, opts, reconsulted, expr);
					if(async)
						return;
					n = expr.len;
				}
			}
		}
		// run goals from initialization/1 directive
		var callback = opts.success;
		var nthread = new Thread(thread.session);
		for(var i = opts.initialization.length-1; i > 0; i--) {
			var next_callback = (function(init, callback) {
				return function(answer) {
					if(answer === null) {
						nthread.answer();
					} else if(pl.type.is_error(answer)) {
						opts.error(answer);
					} else {
						nthread.add_goal(init);
						nthread.answer(callback);
					}
				};
			})(opts.initialization[i], callback);
			callback = next_callback;
		}
		if(opts.initialization.length > 0) {
			nthread.add_goal(opts.initialization[0]);
			nthread.answer(callback);
		} else {
			callback();
		}
	}

	function parseGoalExpansion(thread, options, expr) {
		var n_thread = new Thread( thread.session );
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var varhead = thread.next_free_variable();
		var goal = varhead + " = " + expr.value.head + ", goal_expansion(" + expr.value.body.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				expr.value.head = answer.links[varhead];
				expr.value.body = body_conversion(answer.links[varterm]);
				parseGoalExpansion(thread, options, expr);
			} else {
				thread.add_rule(expr.value, options);
				parseProgram(thread, options.string, options);
			}
		});
	}

	function parseQueryExpansion(thread, term, options) {
		var n_thread = new Thread(thread.session);
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var goal = "goal_expansion(" + term.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		var variables = n_thread.head_point().substitution.domain();
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				for(var i = 0; i < variables.length; i++) {
					if(variables[i] !== varterm.id && answer.links[variables[i]]) {
						var subs = new Substitution();
						subs.links[answer.links[variables[i]]] = variables[i];
						answer.links[varterm] = answer.links[varterm].apply( subs );
					}
				}
				parseQueryExpansion(thread, body_conversion(answer.links[varterm]), options);
			} else {
				thread.add_goal(term);
				options.success(term);
				parseQuery(thread, options.string, options);
			}
		});
	}

	function parseProgramExpansion(thread, options, reconsulted, expr) {
		var async = options.term_expansion === true;
		if(expr.value.body === null && expr.value.head.indicator === "?-/1") {
			async = true;
			var n_thread = new Thread(thread.session);
			n_thread.add_goal(expr.value.head.args[0]);
			n_thread.answer(function(answer) {
				if(pl.type.is_error(answer)) {
					thread.throw_warning(answer.args[0]);
				} else if(answer === false || answer === null) {
					thread.throw_warning(pl.warning.failed_goal(expr.value.head.args[0], expr.len));
				}
				parseProgram(thread, options.string, options);
			});
		} else if(expr.value.body === null && expr.value.head.indicator === ":-/1") {
			var result = thread.run_directive(expr.value.head.args[0], options);
			async = async || (result === true);
			if(async)
				parseProgram(thread, options.string, options);
		} else {
			var context_module = options.context_module;
			var indicator = expr.value.head.indicator;
			if(expr.value.head.indicator === ":/2") {
				context_module = expr.value.head.args[0].id;
				indicator = expr.value.head.args[1].indicator;
			}
			if(!reconsulted.hasOwnProperty(context_module))
				reconsulted[context_module] = {};
			if(options.reconsult !== false && reconsulted[context_module][indicator] !== true && !thread.is_multifile_predicate(indicator)) {
				var get_module = thread.session.modules[context_module];
				if(context_module !== "system" && get_module && get_module.rules[indicator]) {
					get_module.rules[indicator] = filter(get_module.rules[indicator], function(rule) {
						return rule.dynamic;
					});
					get_module.update_indices_predicate(indicator);
				}
				reconsulted[context_module][indicator] = true;
			}
			var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
			if(expr.value.body !== null && goal_expansion && goal_expansion.length > 0) {
				async = true;
				thread.session.renamed_variables = {};
				var origin = {
					head: function() { return expr.value.head; },
					term: function() { return expr.value.body; },
					set: function(h, p){
						expr.value.head = h;
						expr.value.body = p;
					}
				};
				parseGoalExpansion(thread, options, expr, body_conversion(expr.value.body), origin.set, origin);
			} else {
				thread.add_rule(expr.value, options);
				if(async)
					parseProgram(thread, options.string, options);
			}
		}
		return async;
	}
	
	// Parse a query
	function parseQuery(thread, string, options) {
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.string = string;
		var tokenizer = opts.tokenizer;
		var n = opts.current_token;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			opts.tokenizer = tokenizer;
			tokenizer.new_text(string);
		}
		do {
			var tokens = tokenizer.get_tokens(n);
			if(tokens === null)
				break;
			var expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
			if(expr.type !== ERROR) {
				var expr_position = expr.len;
				n = expr.len + 1;
				opts.current_token = n;
				if(tokens[expr_position] && tokens[expr_position].name === "atom" && tokens[expr_position].raw === ".") {
					expr.value = body_conversion(expr.value);
					// Goal expansion
					var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
					if(!thread.__goal_expansion && goal_expansion && goal_expansion.length > 0) {
						parseQueryExpansion(thread, expr.value, opts);
						return;
					} else {
						thread.add_goal(expr.value);
						opts.success(expr.value);
					}
				} else {
					var token = tokens[expr_position];
					opts.error(
						new Term("throw", [
							pl.error.syntax(
								token ? token : tokens[expr_position-1],
								token && token.error ? token.error : ". or operator expected",
								!token
							)
						])
					);
					return;
				}
			} else {
				opts.error(new Term("throw", [expr.value]));
				return;
			}
		} while(true);
	}


	
	// UTILS

	// Rule to DCG
	function rule_to_dcg(rule, thread) {
		thread.session.renamed_variables = {};
		rule = rule.rename(thread);
		var begin = thread.next_free_variable();
		var dcg = body_to_dcg( rule.body, begin, thread );
		if( dcg.error )
			return dcg.value;
		rule.body = dcg.value;
		// push-back lists
		if(rule.head.indicator === ",/2") {
			var terminals = rule.head.args[1];
			rule.head = rule.head.args[0];
			var last = thread.next_free_variable();
			var pointer = terminals;
			if(!pl.type.is_list(pointer)) {
				return pl.error.type("list", pointer, "DCG/0");
			}
			if(pointer.indicator === "[]/0") {
				terminals = dcg.variable;
			} else {
				while(pointer.indicator === "./2" && pl.type.is_list(pointer) && pointer.args[1].indicator !== "[]/0") {
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer))
					return pl.error.instantiation("DCG/0");
				else if(!pl.type.is_list(pointer))
					return pl.error.type("list", terminals, "DCG/0");
				pointer.args[1] = dcg.variable;
			}
			rule.body = new Term(",", [rule.body, new Term("=", [last, terminals])]);
			rule.head = new Term(rule.head.id, rule.head.args.concat([begin, last]));
		} else {
			// replace first assignment
			var first_assign = rule.body;
			if(pl.type.is_term(first_assign) && first_assign.indicator === ",/2")
				first_assign = first_assign.args[0];
			if(pl.type.is_term(first_assign) && first_assign.indicator === "=/2" &&
			   pl.type.is_variable(first_assign.args[0]) && first_assign.args[0] === begin) {
				begin = first_assign.args[1];
				rule.body = rule.body.replace(null);
			}
			// add first and last variables to the head
			if(rule.head.indicator === ":/2")
				rule.head = new Term(":", [
					new Term(rule.head.args[0].id, []),
					new Term(rule.head.args[1].id, rule.head.args[1].args.concat([begin, dcg.variable]))
				]);
			else
				rule.head = new Term(rule.head.id, rule.head.args.concat([begin, dcg.variable]));
		}
		return rule;
	}

	// Body to DCG
	function body_to_dcg(expr, last, thread) {
		var free;
		if( pl.type.is_term( expr ) && expr.indicator === "!/0" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr, new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ":/2" ) {
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(":", [expr.args[0], right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "\\+/1" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			free = thread.next_free_variable();
			return {
				value: new Term(",", [new Term(expr.id, [left.value]), new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && (expr.indicator === ",/2" || expr.indicator === "->/2") ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], left.variable, thread);
			if( right.error ) return right;
			return {
				value: new Term(expr.id, [left.value, right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ";/2" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(",", [new Term(";", [left.value, right.value]), new Term("=", [left.variable, right.variable])]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "{}/1" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr.args[0], new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_empty_list( expr ) ) {
			return {
				value: new Term("true", []),
				variable: last,
				error: false
			};
		} else if( pl.type.is_list( expr ) ) {
			free = thread.next_free_variable();
			var pointer = expr;
			var prev;
			while( pointer.indicator === "./2" ) {
				prev = pointer;
				pointer = pointer.args[1];
			}
			if( pl.type.is_variable( pointer ) ) {
				return {
					value: pl.error.instantiation("DCG/0"),
					variable: last,
					error: true
				};
			} else if( !pl.type.is_empty_list( pointer ) ) {
				return {
					value: pl.error.type("list", expr, "DCG/0"),
					variable: last,
					error: true
				};
			} else {
				prev.args[1] = free;
				return {
					value: new Term("=", [last, expr]),
					variable: free,
					error: false
				};
			}
		} else if( pl.type.is_callable( expr ) ) {
			free = thread.next_free_variable();
			expr = new Term( expr.id, expr.args.concat([last,free]) );
			return {
				value: expr,
				variable: free,
				error: false
			};
		} else {
			return {
				value: pl.error.type( "callable", expr, "DCG/0" ),
				variable: last,
				error: true
			};
		}
	}
	
	// Body conversion
	function body_conversion( expr ) {
		if( pl.type.is_variable( expr ) )
			return new Term( "call", [expr] );
		else if( pl.type.is_term( expr ) && [",/2", ";/2", "->/2"].indexOf(expr.indicator) !== -1 )
			return new Term( expr.id, [body_conversion( expr.args[0] ), body_conversion( expr.args[1] )] );
		else if( pl.type.is_term(expr) && expr.indicator === ":/2" ) {
			var body = body_conversion(expr.args[1]);
			return new Term(":", [expr.args[0], body]);
		}
		return expr;
	}
	
	// List to Prolog list
	function arrayToList( array, cons ) {
		var list = cons ? cons : new Term( "[]", [] );
		for(var i = array.length-1; i >= 0; i-- )
			list = new Term( ".", [array[i], list] );
		return list;
	}

	// Array difference
	function difference(xs, ys) {
		var zs = [];
		for(var i = 0; i < xs.length; i++) {
			if(indexOf(zs, xs[i]) === -1 && indexOf(ys, xs[i]) === -1)
				zs.push(xs[i]);
		}
		return zs;
	}
	
	// Remove element from array
	function remove( array, element ) {
		for( var i = array.length - 1; i >= 0; i-- ) {
			if( array[i] === element ) {
				array.splice(i, 1);
			}
		}
	}
	
	// Remove duplicate elements
	function nub( array ) {
		var seen = {};
		var unique = [];
		for( var i = 0; i < array.length; i++ ) {
			if( !(array[i] in seen) ) {
				unique.push( array[i] );
				seen[array[i]] = true;
			}
		}
		return unique;
	}

	// Retract a rule
	function retract(thread, point, indicator, rule, get_module) {
		if(get_module.rules[indicator]) {
			for(var i = 0; i < get_module.rules[indicator].length; i++) {
				if(get_module.rules[indicator][i] === rule) {
					get_module.rules[indicator].splice(i, 1);
					get_module.update_indices_predicate(indicator);
					thread.success( point );
					break;
				}
			}
		}
	}
	
	// call/n
	function callN(n) {
		return function(thread, point, atom) {
			var closure = atom.args[0], args = atom.args.slice(1, n);
			var module_atom;
			if(pl.type.is_term(closure) && closure.indicator === ":/2") {
				if(!pl.type.is_atom(closure.args[0])) {
					thread.throw_error(pl.error.type("module", closure.args[0], atom.indicator));
					return;
				}
				module_atom = closure.args[0];
				closure = closure.args[1];
			}
			if(pl.type.is_variable(closure)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(closure)) {
				thread.throw_error(pl.error.type("callable", closure, atom.indicator));
			} else {
				var goal = body_conversion(new Term(closure.id, closure.args.concat(args)));
				if(!pl.type.is_callable(goal)) {
					thread.throw_error(pl.error.type("callable", goal, atom.indicator));
					return;
				}
				if(module_atom)
					goal = new Term(":", [module_atom, goal]);
				thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
			}
		};
	}
	
	// String to indicator
	function str_indicator( str ) {
		for( var i = str.length - 1; i >= 0; i-- )
			if( str.charAt(i) === "/" )
				return new Term( "/", [new Term( str.substring(0, i) ), new Num( parseInt(str.substring(i+1)), false )] );
	}

	// Greatest common divisor
	function gcd(a, b) {
		if(b === 0)
			return a;
		return Math.abs(gcd(b, a % b));
	}
	
	

	// PROLOG OBJECTS
	
	// Variables
	function Var( id ) {
		this.id = id;
		this.ground = false;
	}
	
	// Numbers
	function Num( value, is_float ) {
		this.is_float = is_float !== undefined ? is_float : Math.trunc(value) !== value;
		this.value = this.is_float ? value : Math.trunc(value);
		this.index = this.value;
		this.ground = true;
	}
	
	// Terms
	var term_ref = 0;
	function Term( id, args, ref ) {
		term_ref++;
		this.ref = ref || term_ref;
		this.id = id;
		this.args = args || [];
		this.indicator = id + "/" + this.args.length;
		this.index = this.indicator;
		this.ground = true;
		for(var i = 0; i < this.args.length; i++) {
			if(this.args[i].hasOwnProperty("ground") && this.args[i].ground === false) {
				this.ground = false;
				break;
			}
		}
	}

	// Streams
	var stream_ref = 0;
	function Stream( stream, mode, alias, type, reposition, eof_action ) {
		this.id = stream_ref++;
		this.stream = stream;
		this.mode = mode; // "read" or "write" or "append"
		this.alias = alias;
		this.type = type !== undefined ? type : "text"; // "text" or "binary"
		this.reposition = reposition !== undefined ? reposition : true; // true or false
		this.eof_action = eof_action !== undefined ? eof_action : "eof_code"; // "error" or "eof_code" or "reset"
		this.position = this.mode === "append" ? "end_of_stream" : 0;
		this.output = this.mode === "write" || this.mode === "append";
		this.input = this.mode === "read";
		this.line_position = 0;
		this.line_count = 1;
		this.char_count = 0;
	}
	
	// Substitutions
	function Substitution( links, attrs ) {
		links = links || {};
		attrs = attrs || {};
		this.links = links;
		this.attrs = attrs;
	}
	
	// States
	function State( goal, subs, parent ) {
		subs = subs || new Substitution();
		parent = parent || null;
		this.goal = goal;
		this.substitution = subs;
		this.parent = parent;
	}
	
	// Rules
	function Rule( head, body, dynamic ) {
		this.head = head;
		this.body = body;
		this.dynamic = dynamic ? dynamic : false;
	}

	// Session
	function Session( limit ) {
		limit = typeof limit === "number" && limit > 0 ? limit : null;
		this.rename = 0;
		this.modules = {};
		this.modules.user = new Module("user", {}, "all", {
			session: this,
			dependencies: ["system"]
		});
		this.modules.system = pl.modules.system;
		this.rules = this.modules.user.rules;
		this.total_threads = 0;
		this.renamed_variables = {};
		this.public_predicates = this.modules.user.public_predicates;
		this.multifile_predicates = this.modules.user.multifile_predicates;
		this.limit = limit;
		this.streams = {
			"user_input": new Stream(
				nodejs_flag ? nodejs_user_input : tau_user_input,
				"read", "user_input", "text", false, "reset" ),
			"user_output": new Stream(
				nodejs_flag ? nodejs_user_output : tau_user_output,
				"append", "user_output", "text", false, "reset" ),
			"user_error": new Stream(
				nodejs_flag ? nodejs_user_error : tau_user_error,
				"append", "user_error", "text", false, "reset" ),
		};
		this.file_system = nodejs_flag ? nodejs_file_system : tau_file_system;
		this.standard_input = this.streams["user_input"];
		this.standard_output = this.streams["user_output"];
		this.standard_error = this.streams["user_error"];
		this.current_input = this.streams["user_input"];
		this.current_output = this.streams["user_output"];
		this.working_directory = "/"; // only for browser
		this.format_success = function( state ) { return state.substitution; };
		this.format_error = function( state ) { return state.goal; };
		this.flag = {	
			bounded: pl.flag.bounded.value,
			max_integer: pl.flag.max_integer.value,
			min_integer: pl.flag.min_integer.value,
			integer_rounding_function: pl.flag.integer_rounding_function.value,
			char_conversion: pl.flag.char_conversion.value,
			debug: pl.flag.debug.value,
			max_arity: pl.flag.max_arity.value,
			unknown: pl.flag.unknown.value,
			double_quotes: pl.flag.double_quotes.value,
			occurs_check: pl.flag.occurs_check.value,
			dialect: pl.flag.dialect.value,
			version_data: pl.flag.version_data.value,
			nodejs: pl.flag.nodejs.value,
			argv: pl.flag.argv.value
		};
		this.__loaded_modules = [];
		this.__char_conversion = {};
		this.__operators = {
			1200: { ":-": ["fx", "xfx"],  "-->": ["xfx"], "?-": ["fx"] },
			1150: { "meta_predicate": ["fx"] },
			1100: { ";": ["xfy"] },
			1050: { "->": ["xfy"], "*->": ["xfy"] },
			1000: { ",": ["xfy"] },
			900: { "\\+": ["fy"] },
			700: {
				"=": ["xfx"], "\\=": ["xfx"], "==": ["xfx"], "\\==": ["xfx"],
				"@<": ["xfx"], "@=<": ["xfx"], "@>": ["xfx"], "@>=": ["xfx"],
				"=..": ["xfx"], "is": ["xfx"], "=:=": ["xfx"], "=\\=": ["xfx"],
				"<": ["xfx"], "=<": ["xfx"], ">": ["xfx"], ">=": ["xfx"]
			},
			600: { ":": ["xfy"] },
			500: { "+": ["yfx"], "-": ["yfx"], "/\\": ["yfx"], "\\/": ["yfx"] },
			400: {
				"*": ["yfx"], "/": ["yfx"], "//": ["yfx"], "rem": ["yfx"],
				"mod": ["yfx"], "<<": ["yfx"], ">>": ["yfx"], "div": ["yfx"]
			},
			200: { "**": ["xfx"], "^": ["xfy"], "-": ["fy"], "+": ["fy"], "\\": ["fy"] }
		};
		this.thread = new Thread( this );
	}
	
	// Threads
	function Thread( session ) {
		this.epoch = Date.now();
		this.session = session;
		this.session.total_threads++;
		this.format_success = session.format_success;
		this.format_error = session.format_error;
		this.total_steps = 0;
		this.cpu_time = 0;
		this.points = [];
		this.debugger = false;
		this.debugger_states = [];
		this.level = new Term("top_level");
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
		this.warnings = [];
		this.__calls = [];
		this.__goal_expansion = false;
		this.__stacks = {};
	}
	
	// Modules
	function Module(id, rules, exports, options) {
		options = options === undefined ? {} : options;
		options.public_predicates = options.public_predicates === undefined ? {} : options.public_predicates;
		options.multifile_predicates = options.multifile_predicates === undefined ? {} : options.multifile_predicates;
		options.meta_predicates = options.meta_predicates === undefined ? {} : options.meta_predicates;
		options.session = options.session === undefined ? null : options.session;
		options.dependencies = options.dependencies === undefined ? [] : options.dependencies;
		this.id = id;
		this.rules = rules;
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		this.public_predicates = options.public_predicates;
		this.multifile_predicates = options.multifile_predicates;
		this.meta_predicates = options.meta_predicates;
		this.src_predicates = {};
		this.dependencies = options.dependencies;
		this.exports = exports;
		this.is_library = options.session === null;
		this.modules = {};
		if(options.session) {
			options.session.modules[id] = this;
			for(var i = 0; i < options.dependencies.length; i++) {
				var lib = options.dependencies[i];
				if(!options.session.modules.hasOwnProperty(lib))
					options.session.modules[lib] = pl.modules[lib];
			}
		} else {
			pl.modules[id] = this;
		}
		if(exports !== "all") {
			for(var i = 0; i < exports.length; i++) {
				this.public_predicates[exports[i]] =
					options.public_predicates.hasOwnProperty(exports[i]) &&
					options.public_predicates[exports[i]] === true;
			}
		}
		this.update_indices_clauses();
	}
	
	// Check if a predicate is exported
	Module.prototype.exports_predicate = function(indicator) {
		return this.exports === "all" || indexOf(this.exports, indicator) !== -1;
	};

	// Check if a predicate is public
	Module.prototype.is_public_predicate = function(indicator) {
		return !this.public_predicates.hasOwnProperty(indicator) || this.public_predicates[indicator] === true;
	};
	
	// Check if a predicate is multifile
	Module.prototype.is_multifile_predicate = function( indicator ) {
		return this.multifile_predicates.hasOwnProperty(indicator) && this.multifile_predicates[indicator] === true;
	};

	// Check if a predicate is a meta-predicate
	Module.prototype.is_meta_predicate = function( indicator ) {
		if(this.meta_predicates.hasOwnProperty(indicator))
			return this.meta_predicates[indicator];
		return null;
	};

	// Update indices of all predicates
	Module.prototype.update_indices_clauses = function() {
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		for(var indicator in this.rules)
			this.update_indices_predicate(indicator);
	};

	// Update indices of a predicate
	Module.prototype.update_indices_predicate = function(indicator) {
		this.indexed_clauses[indicator] = {};
		this.non_indexable_clauses[indicator] = [];
		if(!Array.isArray(this.rules[indicator]))
			return;
		for(var i = 0; i < this.rules[indicator].length; i++) {
			var clause = this.rules[indicator][i];
			this.add_index_predicate(clause);
		}
	};

	// Add indexed cluuse to a predicate
	Module.prototype.add_index_predicate = function(clause) {
		var indicator = clause.head.indicator;
		var index = clause.head.args.length > 0 ? clause.head.args[0].index : undefined;
		if(index) {
			if(!this.indexed_clauses.hasOwnProperty(indicator))
				this.indexed_clauses[indicator] = {};
			if(!this.indexed_clauses[indicator].hasOwnProperty(index)) {
				this.indexed_clauses[indicator][index] = [];
				if(this.non_indexable_clauses.hasOwnProperty(indicator))
					for(var j = 0; j < this.non_indexable_clauses[indicator].length; j++)
						this.indexed_clauses[indicator][index].push(this.non_indexable_clauses[indicator][j]);
			}
			this.indexed_clauses[indicator][index].push(clause);
		} else {
			if(!this.non_indexable_clauses.hasOwnProperty(indicator))
				this.non_indexable_clauses[indicator] = [];
			this.non_indexable_clauses[indicator].push(clause);
			for(var index in this.indexed_clauses[indicator])
				this.indexed_clauses[indicator][index].push(clause);
		}
	};



	// UNIFY PROLOG OBJECTS

	// Variables
	Var.prototype.unify = function(obj, occurs_check) {
		if(occurs_check && indexOf(obj.variables(), this.id) !== -1 && !pl.type.is_variable(obj))
			return null;
		var links = {};
		links[this.id] = obj;
		return new Substitution(links);
	};

	// Numbers
	Num.prototype.unify = function(obj, occurs_check) {
		if(pl.type.is_number(obj) && this.value === obj.value && this.is_float === obj.is_float)
			return new Substitution();
		return null;
	};

	// Terms
	Term.prototype.unify = function(obj, occurs_check) {
		if(!pl.type.is_term(obj) && obj.unify !== undefined) {
			return obj.unify(this, occurs_check);
		} else if(pl.type.is_term(obj) && this.indicator === obj.indicator) {
			var subs = new Substitution();
			for(var i = 0; i < this.args.length; i++) {
				var mgu = pl.unify(this.args[i].apply(subs), obj.args[i].apply(subs), occurs_check);
				if(mgu === null)
					return null;
				for(var x in mgu.links)
					subs.links[x] = mgu.links[x];
				subs = subs.apply(mgu);
			}
			return subs;
		}
		return null;
	};

	// Streams
	Stream.prototype.unify = function(obj, _occurs_check) {
		if(pl.type.is_stream(obj) && this.id === obj.id)
			return new Substitution();
		return null;
	};

	Stream.prototype.compare = function(obj) {
		if(this.id < obj.id)
			return -1;
		else if(this.id === obj.id)
			return 0;
		else
			return 1;
	};
	
	

	// PROLOG OBJECTS TO STRING
	
	// Variables
	Var.prototype.toString = function( options ) {
		options = options === undefined ? {} : options;
		if(options.variable_names) {
			var pointer = options.variable_names;
			while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
				var head = pointer.args[0];
				if(pl.type.is_term(head) && head.indicator === "=/2"
				&& pl.type.is_variable(head.args[1]) && head.args[1].id === this.id
				&& pl.type.is_atom(head.args[0]))
					return head.args[0].id;
				pointer = pointer.args[1];
			}
		}
		return this.id;
	};
	
	// Numbers
	Num.prototype.toString = function( _ ) {
		var str = this.value.toString();
		var e = str.indexOf("e");
		if(e !== -1) {
			if(str.indexOf(".") !== -1)
				return str;
			else
				return str.replace("e", ".0e");
		}
		return this.is_float && indexOf(str, ".") === -1 ? this.value + ".0" : str;
	};
	
	// Terms
	Term.prototype.toString = function( options, priority, from ) {
		options = !options ? {} : options;
		options.quoted = options.quoted === undefined ? false: options.quoted;
		options.ignore_ops = options.ignore_ops === undefined ? false : options.ignore_ops;
		options.numbervars = options.numbervars === undefined ? false : options.numbervars;
		options.variable_names = options.variable_names === undefined ? false : options.variable_names;
		priority = priority === undefined ? {priority: 1200, class: "", indicator: ""} : priority;
		from = from === undefined ? "" : from;
		var arg_priority = {priority: 999, class: "", indicator: ""};
		if( options.numbervars && this.indicator === "$VAR/1" && pl.type.is_integer( this.args[0] ) && this.args[0].value >= 0 ) {
			var i = this.args[0].value;
			var number = Math.floor( i/26 );
			var letter =  i % 26;
			return "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter] + (number !== 0 ? number : "");
		}
		switch( this.indicator ){
			case "[]/0":
			case "{}/0":
			case "!/0":
				return this.id;
			case "{}/1":
				if( options.ignore_ops === false ) {
					return "{" + this.args[0].toString( options ) + "}";
				} else {
					return "{}(" + this.args[0].toString( options ) + ")";
				}
			case "./2":
				if( options.ignore_ops === false ) {
					var list = "[" + this.args[0].toString( options, arg_priority );
					var pointer = this.args[1];
					while( pointer.indicator === "./2" ) {
						list += "," + pointer.args[0].toString( options, arg_priority );
						pointer = pointer.args[1];
					}
					if( pointer.indicator !== "[]/0" ) {
						list += "|" + pointer.toString( options, arg_priority );
					}
					list += "]";
					return list;
				}
			default:
				var id = this.id;
				var operator = options.session ? options.session.lookup_operator( this.id, this.args.length ) : null;
				if( options.session === undefined || options.ignore_ops || operator === null ) {
					if( options.quoted && (! /^(!|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+)$/.test( id ) && id !== "{}" && id !== "[]" || indexOf([".",",",";"], id) !== -1 || id.substring(0,2) === "/*") )
						id = "'" + redoEscape(id) + "'";
					if( this.args.length === 0 && is_graphic_token(this.id) && priority.indicator !== "")
						return "(" + id + ")";
					return id + (this.args.length > 0 ? "(" + map( this.args,
						function(x) { return x.toString(options, arg_priority); }
					).join(",") + ")" : "");
				} else {
					var priority_op = parseInt(operator.priority);
					var priority_arg = parseInt(priority.priority);
					var cond = priority_op > priority_arg || priority_op === priority_arg && (
						operator.class === "xfx" ||
						operator.class === "xfy" && this.indicator !== priority.indicator ||
						operator.class === "yfx" && this.indicator !== priority.indicator ||
						this.indicator === priority.indicator && operator.class === "yfx" && from === "right" ||
						this.indicator === priority.indicator && operator.class === "xfy" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "xf" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "fx" && from === "right");
					operator.indicator = this.indicator;
					var lpar = cond ? "(" : "";
					var rpar = cond ? ")" : "";
					var space = !(is_graphic_token(this.id) || this.id === "," || this.id === ";")
						|| operator.class.length === 2
						|| operator.class.length === 3 && pl.type.is_number(this.args[1]) && this.args[1].value < 0 ? " " : "";
					if( this.args.length === 0 ) {
						return lpar + this.id + rpar;
					} else if( ["fy","fx"].indexOf( operator.class) !== -1 ) {
						return lpar + id + space + this.args[0].toString( options, operator, "right" ) + rpar;
					} else if( ["yf","xf"].indexOf( operator.class) !== -1 ) {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + id + rpar;
					} else {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + this.id + space + this.args[1].toString( options, operator, "right" ) +  rpar;
					}
				}
		}
	};

	// Streams
	Stream.prototype.toString = function( _ ) {
		return "<stream>(" + this.id + ")";
	};
	
	// Substitutions
	Substitution.prototype.toString = function( options ) {
		var str = "{";
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( str !== "{" ) {
				str += ", ";
			}
			str += link + "/" + this.links[link].toString( options );
		}
		str += "}";
		return str;
	};
	
	// States
	State.prototype.toString = function( options ) {
		if( this.goal === null ) {
			return "<" + this.substitution.toString( options ) + ">";
		} else {
			return "<" + this.goal.toString( options ) + ", " + this.substitution.toString( options ) + ">";
		}
	};
	
	// Rules
	Rule.prototype.toString = function( options ) {
		if( !this.body ) {
			return this.head.toString( options ) + ".";
		} else {
			return this.head.toString( options, 1200, "left" ) + " :- " + this.body.toString( options, 1200, "right" ) + ".";
		}
	};
	
	// Session
	Session.prototype.toString = function( options ) {
		var str = "";
		for(var prop in this.modules) {
			if(this.modules.hasOwnProperty(prop) && this.modules[prop].is_library)
				str += ":- use_module(library(" + this.modules[prop] + ")).\n";
		}
		str += "\n";
		for(var key in this.modules.user.rules) {
			if(!this.modules.user.rules.hasOwnProperty(key)) continue;
			for(i = 0; i < this.modules.user.rules[key].length; i++) {
				str += this.modules.user.rules[key][i].toString(options);
				str += "\n";
			}
		}
		return str;
	};
	
	
	
	// CLONE PROLOG OBJECTS
	
	// Variables
	Var.prototype.clone = function() {
		return new Var( this.id );
	};
	
	// Numbers
	Num.prototype.clone = function() {
		return new Num( this.value, this.is_float );
	};
	
	// Terms
	Term.prototype.clone = function() {
		var term = new Term( this.id, map( this.args, function( arg ) {
			return arg.clone();
		} ) );
		if(this.definition_module)
			term.definition_module = this.definition_module;
		return term;
	};

	// Streams
	Stream.prototype.clone = function() {
		return new Stream( this.stream, this.mode, this.alias, this.type, this.reposition, this.eof_action );
	};
	
	// Substitutions
	Substitution.prototype.clone = function() {
		var links = {};
		var attrs = {};
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].clone();
		}
		for( var attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attrs)) continue;
			attrs[attr] = {};
			for( var m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].clone();
			}
		}
		return new Substitution( links, attrs );
	};
	
	// States
	State.prototype.clone = function() {
		return new State( this.goal.clone(), this.substitution.clone(), this.parent );
	};
	
	// Rules
	Rule.prototype.clone = function() {
		return new Rule( this.head.clone(), this.body !== null ? this.body.clone() : null );
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.equals = function( obj ) {
		return pl.type.is_variable( obj ) && this.id === obj.id;
	};
	
	// Numbers
	Num.prototype.equals = function( obj ) {
		return pl.type.is_number( obj ) && this.value === obj.value && this.is_float === obj.is_float;
	};
	
	// Terms
	Term.prototype.equals = function( obj ) {
		if( !pl.type.is_term( obj ) || this.indicator !== obj.indicator ) {
			return false;
		}
		for( var i = 0; i < this.args.length; i++ ) {
			if( !this.args[i].equals( obj.args[i] ) ) {
				return false;
			}
		}
		return true;
	};

	// Streams
	Stream.prototype.equals = function( obj ) {
		return pl.type.is_stream( obj ) && this.id === obj.id;
	};
	
	// Substitutions
	Substitution.prototype.equals = function( obj ) {
	var link;
		if( !pl.type.is_substitution( obj ) ) {
			return false;
		}
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( !obj.links[link] || !this.links[link].equals( obj.links[link] ) ) {
				return false;
			}
		}
		for( link in obj.links ) {
			if(!obj.links.hasOwnProperty(link)) continue;
			if( !this.links[link] ) {
				return false;
			}
		}
		return true;
	};
	
	// States
	State.prototype.equals = function( obj ) {
		return pl.type.is_state( obj ) && this.goal.equals( obj.goal ) && this.substitution.equals( obj.substitution ) && this.parent === obj.parent;
	};
	
	// Rules
	Rule.prototype.equals = function( obj ) {
		return pl.type.is_rule( obj ) && this.head.equals( obj.head ) && (this.body === null && obj.body === null || this.body !== null && this.body.equals( obj.body ));
	};
	
	
	
	// RENAME VARIABLES OF PROLOG OBJECTS
	
	// Variables
	Var.prototype.rename = function( thread ) {
		return thread.get_free_variable( this );
	};
	
	// Numbers
	Num.prototype.rename = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.rename = function( thread ) {
		// ground
		if(this.ground)
			return new Term(this.id, this.args);
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].rename(thread);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.rename(thread);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].rename(thread);
			args.push(app);
		}
		return new Term(this.id, args);
	};

	// Streams
	Stream.prototype.rename = function( thread ) {
		return this;
	};
	
	// Rules
	Rule.prototype.rename = function( thread ) {
		return new Rule( this.head.rename( thread ), this.body !== null ? this.body.rename( thread ) : null );
	};



	// CHECK IF RENAME

	// Variables
	Var.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_variable(obj)
		|| links.hasOwnProperty(this.id) && links[this.id] !== obj.id
		|| links.hasOwnProperty(obj.id) && links[obj.id] !== this.id)
			return false;
		links[this.id] = obj.id;
		links[obj.id] = this.id;
		return true;
	};
	
	// Numbers
	Num.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	// Terms
	Term.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_term(obj) || this.indicator !== obj.indicator)
			return false;
		for(var i = 0; i < this.args.length; i++) {
			if(!pl.is_rename(this.args[i], obj.args[i], links))
				return false;
		}
		return true;
	};

	// Streams
	Stream.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	
	
	// GET ID OF VARIABLES FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.variables = function() {
		return [this.id];
	};
	
	// Numbers
	Num.prototype.variables = function() {
		return [];
	};
	
	// Terms
	Term.prototype.variables = function() {
		if(this.ground)
			return [];
		return [].concat.apply( [], map( this.args, function( arg ) {
			return arg.variables();
		} ) );
	};

	// Streams
	Stream.prototype.variables = function() {
		return [];
	};
	
	// Rules
	Rule.prototype.variables = function() {
		if( this.body === null ) {
			return this.head.variables();
		} else {
			return this.head.variables().concat( this.body.variables() );
		}
	};
	
	
	
	// APPLY SUBSTITUTIONS TO PROLOG OBJECTS
	
	// Variables
	Var.prototype.apply = function( subs ) {
		if( subs.lookup( this.id ) ) {
			return subs.lookup( this.id );
		}
		return this;
	};
	
	// Numbers
	Num.prototype.apply = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.apply = function( subs ) {
		// ground atom
		if(this.ground)
			return this;
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].apply(subs);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.apply(subs);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].apply(subs);
			args.push(app);
		}
		return new Term(this.id, args, this.ref);
	};

	// Streams
	Stream.prototype.apply = function( _ ) {
		return this;
	};
	
	// Rules
	Rule.prototype.apply = function( subs ) {
		return new Rule( this.head.apply( subs ), this.body !== null ? this.body.apply( subs ) : null );
	};
	
	// Substitutions
	Substitution.prototype.apply = function( subs ) {
		var link, links = {}, attr, attrs = {}, m;
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].apply(subs);
		}
		for( attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attr)) continue;
			attrs[attr] = {};
			for( m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].apply(subs);
			}
		}
		return new Substitution( links, attrs );
	};
	
	
	
	// SELECTION FUNCTION
	
	// Select term
	Term.prototype.select = function() {
		var pointer = this;
		while(pl.type.is_term(pointer) && pointer.indicator === ",/2")
			pointer = pointer.args[0];
		return pointer;
	};
	
	// Replace term
	Term.prototype.replace = function( expr ) {
		if( this.indicator === ",/2" ) {
			if( this.args[0].indicator === ",/2" ) {
				return new Term( ",", [this.args[0].replace( expr ), this.args[1]] );
			} else {
				return expr === null ? this.args[1] : new Term( ",", [expr, this.args[1]] );
			}
		} else {
			return expr;
		}
	};

	// Search term
	Term.prototype.search = function( expr ) {
		if(this == expr || this.ref === expr.ref)
			return true;
		for( var i = 0; i < this.args.length; i++ )
			if( pl.type.is_term( this.args[i] ) && this.args[i].search( expr ) )
				return true;
		return false;
	};
	
	
	
	// PROLOG SESSIONS AND THREADS

	// Push to a global stack
	Session.prototype.push_global_stack = function(stack, value) {
		return this.thread.push_global_stack(stack, value);
	};
	Thread.prototype.push_global_stack = function(stack, value) {
		if(!this.__stacks.hasOwnProperty(stack))
			this.__stacks[stack] = [];
		this.__stacks[stack].push(value);
	};

	// Pop all from a global stack
	Session.prototype.flush_global_stack = function(stack, tail) {
		return this.thread.push_global_stack(stack, tail);
	};
	Thread.prototype.flush_global_stack = function(stack, tail) {
		var list = tail || new Term("[]", []);
		if(this.__stacks.hasOwnProperty(stack)) {
			while(this.__stacks[stack].length > 0)
				list = new Term(".", [this.__stacks[stack].pop(), list]);
			delete this.__stacks[stack];
		}
		return list;
	};

	// Set max inferences
	Session.prototype.setMaxInferences = function(max) {
		this.limit = typeof max === "number" && max > 0 ? max : null;
	};
	Thread.prototype.setMaxInferences = function(max) {
		this.session.setMaxInferences(max);
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
	};

	// Format answer
	Session.prototype.format_answer = function(answer, options) {
		return this.thread.format_answer(answer, options);
	};
	Thread.prototype.format_answer = function(answer, options) {
		return pl.format_answer(answer, this, options);
	};

	// Get current input
	Session.prototype.get_current_input = function() {
		return this.current_input;
	};
	Thread.prototype.get_current_input = function() {
		return this.session.get_current_input();
	};

	// Get current output
	Session.prototype.get_current_output = function() {
		return this.current_output;
	};
	Thread.prototype.get_current_output = function() {
		return this.session.get_current_output();
	};

	// Set current input
	Session.prototype.set_current_input = function( input ) {
		this.current_input = input;
	};
	Thread.prototype.set_current_input = function( input ) {
		return this.session.set_current_input( input );
	};

	// Set current output
	Session.prototype.set_current_output = function( output ) {
		this.current_output = output;
	};
	Thread.prototype.set_current_output = function( output ) {
		return this.session.set_current_output( output);
	};

	// Get stream by alias
	Session.prototype.get_stream_by_alias = function( alias ) {
		return this.streams[alias];
	};
	Thread.prototype.get_stream_by_alias = function( alias ) {
		return this.session.get_stream_by_alias( alias );
	};

	// Open file
	Session.prototype.file_system_open = function( path, type, mode ) {
		if(this.get_flag("nodejs").indicator === "false/0")
			path = this.absolute_file_name(path);
		return this.file_system.open( path, type, mode );
	};
	Thread.prototype.file_system_open = function( path, type, mode ) {
		return this.session.file_system_open( path, type, mode );
	};

	// Absolute file name
	Session.prototype.absolute_file_name = function(filename) {
		var absolute;
		// node.js
		if(this.get_flag("nodejs").indicator === "true/0") {
			var path = __webpack_require__(/*! path */ "?4461");
			absolute = filename;
			for(var prop in process.env) {
				if(!process.env.hasOwnProperty(prop))
					continue;
				absolute = absolute.replace(new RegExp("\\$" + prop, "g"), process.env[prop]);
			}
			return path.resolve(absolute);
		// browser
		} else {
			var cwd = this.working_directory;
			if(filename[0] === "/")
				absolute = filename;
			else
				absolute = cwd + (cwd[cwd.length-1] === "/" ? filename : "/" + filename);
			absolute = absolute.replace(/\/\.\//g, "/");
			var dirs = absolute.split("/");
			var dirs2 = [];
			for(var i = 0; i < dirs.length; i++) {
				if(dirs[i] !== "..") {
					dirs2.push(dirs[i]);
				} else {
					if(dirs2.length !== 0)
						dirs2.pop();
				}
			}
			absolute = dirs2.join("/").replace(/\/\.$/, "/");
		}
		return absolute;
	};
	Thread.prototype.absolute_file_name = function(path, cwd) {
		return this.session.absolute_file_name(path, cwd);
	};

	// Get conversion of the char
	Session.prototype.get_char_conversion = function( char ) {
		return this.__char_conversion[char] || char;
	};
	Thread.prototype.get_char_conversion = function( char ) {
		return this.session.get_char_conversion( char );
	};
	
	// Parse an expression
	Session.prototype.parse = function( string ) {
		return this.thread.parse( string );
	};
	Thread.prototype.parse = function( string ) {
		var tokenizer = new Tokenizer( this );
		tokenizer.new_text( string );
		var tokens = tokenizer.get_tokens();
		if( tokens === null )
			return false;
		var expr = parseExpr(this, tokens, 0, this.__get_max_priority(), false);
		if( expr.len !== tokens.length )
			return false;
		return { value: expr.value, expr: expr, tokens: tokens };
	};
	
	// Get flag value
	Session.prototype.get_flag = function( flag ) {
		return this.flag[flag];
	};
	Thread.prototype.get_flag = function( flag ) {
		return this.session.get_flag( flag );
	};

	// Add a rule
	Session.prototype.add_rule = function(rule, options) {
		return this.thread.add_rule(rule, options);
	};
	Thread.prototype.add_rule = function(rule, options) {
		options = options ? options : {};
		options.from = options.from ? options.from : "$tau-js";
		var module_id, get_module;
		if(pl.type.is_term(rule.head) && rule.head.indicator === ":/2") {
			if(!pl.type.is_atom(rule.head.args[0])) {
				this.throw_warning(pl.error.type("module", rule.head.args[0], "top_level/0"));
				return;
			}
			module_id = rule.head.args[0].id;
			rule.head = rule.head.args[1];
		}
		if(module_id) {
			get_module = this.session.modules[module_id];
			if(!pl.type.is_module(get_module)) {
				get_module = new Module(module_id, {}, "all", {session: this.session});
				this.session.modules[module_id] = get_module;
			}
		} else {
			get_module = this.session.modules[options.context_module];
		}
		get_module.src_predicates[rule.head.indicator] = options.from;
		if(!get_module.rules.hasOwnProperty(rule.head.indicator)) {
			get_module.rules[rule.head.indicator] = [];
		}
		get_module.rules[rule.head.indicator].push(rule);
		if(!get_module.public_predicates.hasOwnProperty(rule.head.indicator))
			get_module.public_predicates[rule.head.indicator] = false;
		// update term indexing
		get_module.add_index_predicate(rule);
		return true;
	};

	// Run a directive
	Session.prototype.run_directive = function(directive, options) {
		return this.thread.run_directive(directive, options);
	};
	Thread.prototype.run_directive = function(directive, options) {
		if(pl.type.is_directive(directive)) {
			if(pl.directive[directive.indicator])
				return pl.directive[directive.indicator](this, directive, options);
			else
				return pl.directive[directive.id + "/*"](this, directive, options);
		}
		return false;
	};
	
	// Get maximum priority of the operators
	Session.prototype.__get_max_priority = function() {
		return "1200";
	};
	Thread.prototype.__get_max_priority = function() {
		return this.session.__get_max_priority();
	};
	
	// Get next priority of the operators
	Session.prototype.__get_next_priority = function( priority ) {
		var max = 0;
		priority = parseInt( priority );
		for( var key in this.__operators ) {
			if( !this.__operators.hasOwnProperty(key) ) continue;
			var n = parseInt(key);
			if( n > max && n < priority ) max = n;
		}
		return max.toString();
	};
	Thread.prototype.__get_next_priority = function( priority ) {
		return this.session.__get_next_priority( priority );
	};
	
	// Get classes of an operator
	Session.prototype.__lookup_operator_classes = function( priority, operator ) {
		if( this.__operators.hasOwnProperty( priority ) && this.__operators[priority][operator] instanceof Array ) {
			return this.__operators[priority][operator]  || false;
		}
		return false;
	};
	Thread.prototype.__lookup_operator_classes = function( priority, operator ) {
		return this.session.__lookup_operator_classes( priority, operator );
	};

	// Get operator
	Session.prototype.lookup_operator = function( name, arity ) {
		for(var p in this.__operators)
			if(this.__operators[p][name])
				for(var i = 0; i < this.__operators[p][name].length; i++)
					if( this.__operators[p][name][i].length === arity+1 )
						return {priority: p, class: this.__operators[p][name][i]};
		return null;
	};
	Thread.prototype.lookup_operator = function( name, arity ) {
		return this.session.lookup_operator( name, arity );
	};
	
	// Throw a warning
	Session.prototype.throw_warning = function( warning ) {
		this.thread.throw_warning( warning );
	};
	Thread.prototype.throw_warning = function( warning ) {
		this.warnings.push( warning );
	};
	
	// Get warnings
	Session.prototype.get_warnings = function() {
		return this.thread.get_warnings();
	};
	Thread.prototype.get_warnings = function() {
		return this.warnings;
	};

	// Add a goal
	Session.prototype.add_goal = function( goal, unique ) {
		this.thread.add_goal( goal, unique );
	};
	Thread.prototype.add_goal = function( goal, unique, parent ) {
		parent = parent ? parent : null;
		if( unique === true )
			this.points = [];
		var vars = goal.variables();
		var links = {};
		for( var i = 0; i < vars.length; i++ )
			links[vars[i]] = new Var(vars[i]);
		this.points.push( new State( goal, new Substitution(links), parent ) );
	};

	// Consult a program from a string
	Session.prototype.consult = function(program, options) {
		return this.thread.consult(program, options);
	};
	Thread.prototype.consult = function(program, options) {
		var string = "", success = false;
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.text = options.text === undefined ? true : options.text;
		opts.html = options.html === undefined ? true : options.html;
		opts.url = options.url === undefined ? true : options.url;
		opts.file = options.file === undefined ? true : options.file;
		opts.script = options.script === undefined ? true : options.script;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		// string
		if(typeof program === "string") {
			string = program;
			// script id
			if(opts.script && this.get_flag("nodejs").indicator === "false/0" && program != "" && document.getElementById(string)) {
				var script = document.getElementById(string);
				var type = script.getAttribute("type");
				if(type !== null && type.replace(/ /g, "").toLowerCase() === "text/prolog") {
					string = script.text;
					success = true;
				}
			}
			// file (node.js)
			if(!success && opts.file && this.get_flag("nodejs").indicator === "true/0") {
				var fs = __webpack_require__(/*! fs */ "?4a0f");
				var thread = this;
				fs.readFile(program, function(error, data) {
					if(error) {
						opts.file = false;
						thread.consult(program, opts);
					} else {
						parseProgram(thread, data.toString(), opts);
					}
				});
				return;
			}
			// http request
			if(!success && this.get_flag("nodejs").indicator === "false/0" && opts.url && program !== "" && !(/\s/.test(program))) {
				try {
					var xhttp = new XMLHttpRequest();
					var thread = this;
					xhttp.onreadystatechange = function() {
						if(this.readyState == 4) {
							if(this.status == 200) {
								string = xhttp.responseText;
								success = true;
								parseProgram(thread, string, opts);
							} else {
								opts.url = false;
								thread.consult(program, opts);
							}
						}
					}
					xhttp.open("GET", program, true);
					xhttp.send();
					return;
				} catch(ex) {
					opts.error(ex);
					return;
				}
			}
			// text
			if(!success && opts.text) {
				success = true;
			}
		// html
		} else if(opts.html && program.nodeName) {
			switch(program.nodeName.toLowerCase()) {
				case "input":
				case "textarea":
					string = program.value;
					success = true;
					break;
				default:
					string = program.innerHTML;
					success = true;
					break;
			}
		} else {
			opts.error(pl.error.existence("source_sink", new Term(string), "top_level/0"));
		}
		this.warnings = [];
		parseProgram(this, string, opts);
	};

	// Query goal from a string (without ?-)
	Session.prototype.query = function(string, options) {
		return this.thread.query(string, options);
	};
	Thread.prototype.query = function(string, options) {
		this.points = [];
		this.debugger_states = [];
		this.level = new Term("top_level");
		return parseQuery(this, string, options);
	};
	
	// Get first choice point
	Session.prototype.head_point = function() {
		return this.thread.head_point();
	};
	Thread.prototype.head_point = function() {
		return this.points[this.points.length-1];
	};
	
	// Get free variable
	Session.prototype.get_free_variable = function( variable ) {
		return this.thread.get_free_variable( variable );
	};
	Thread.prototype.get_free_variable = function( variable ) {
		var variables = [];
		if( variable.id === "_" || this.session.renamed_variables[variable.id] === undefined ) {
			this.session.rename++;
			if( this.current_point )
				variables = this.current_point.substitution.domain();
			while( indexOf( variables, pl.format_variable( this.session.rename, variable.id ) ) !== -1 ) {
				this.session.rename++;
			}
			if( variable.id === "_" ) {
				return new Var( pl.format_variable( this.session.rename, variable.id ) );
			} else {
				this.session.renamed_variables[variable.id] = pl.format_variable( this.session.rename, variable.id );
			}
		}
		return new Var( this.session.renamed_variables[variable.id] );
	};
	
	// Get next free variable
	Session.prototype.next_free_variable = function() {
		return this.thread.next_free_variable();
	};
	Thread.prototype.next_free_variable = function() {
		this.session.rename++;
		var variables = [];
		if( this.current_point )
			variables = this.current_point.substitution.domain();
		while( indexOf( variables, pl.format_variable( this.session.rename ) ) !== -1 ) {
			this.session.rename++;
		}
		return new Var( pl.format_variable( this.session.rename ) );
	};
	
	// Check if a predicate is public
	Session.prototype.is_public_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_public_predicate(indicator);
	};
	Thread.prototype.is_public_predicate = function(indicator, module_id) {
		return this.session.is_public_predicate(indicator, module_id);
	};
	
	// Check if a predicate is multifile
	Session.prototype.is_multifile_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_multifile_predicate(indicator);
	};
	Thread.prototype.is_multifile_predicate = function(indicator, module_id) {
		return this.session.is_multifile_predicate(indicator, module_id);
	};

	// Check if a predicate is a meta-predicate
	Session.prototype.is_meta_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		if(pl.type.is_module(this.modules[module_id]))
			return this.modules[module_id].is_meta_predicate(indicator);
		return null;
	};
	Thread.prototype.is_meta_predicate = function(indicator, module_id) {
		return this.session.is_meta_predicate(indicator, module_id);
	};
	
	// Insert states at the beginning
	Session.prototype.prepend = function( states ) {
		return this.thread.prepend( states );
	};
	Thread.prototype.prepend = function( states ) {
		for(var i = states.length-1; i >= 0; i--)
			this.points.push( states[i] );
	};
	
	// Remove the selected term and prepend the current state
	Session.prototype.success = function( point, parent ) {
		return this.thread.success( point, parent );
	}
	Thread.prototype.success = function( point, parent ) {
		var parent = typeof parent === "undefined" ? point : parent;
		this.prepend( [new State( point.goal.replace( null ), point.substitution, parent ) ] );
	};
	
	// Throw error
	Session.prototype.throw_error = function(error) {
		return this.thread.throw_error(error);
	};
	Thread.prototype.throw_error = function(error) {
		if(pl.type.is_variable(error))
			error = pl.error.instantiation(this.level.indicator);
		var state = new State(
			new Term("throw", [error]),
			new Substitution(),
			null
		);
		state.error = true;
		this.prepend([state]);
	};
	
	// Get the module of a predicate
	Session.prototype.lookup_module = function(atom, context_module) {
		return this.thread.lookup_module(atom, context_module);
	}
	Thread.prototype.lookup_module = function(atom, context_module) {
		var get_module = this.session.modules[context_module];
		if(!pl.type.is_module(get_module))
			get_module = this.session.modules.user;
		if(get_module.rules.hasOwnProperty(atom.indicator) && (
			get_module.exports_predicate(atom.indicator) ||
			get_module.rules.hasOwnProperty(this.level.indicator) ||
			context_module === get_module.id))
				return get_module;
		get_module.modules.system = pl.modules.system;
		get_module.modules.user = this.session.modules.user;
		for(var prop in get_module.modules) {
			if(!this.session.modules.hasOwnProperty(prop))
				continue;
			var get_module = this.session.modules[prop];
			if(get_module.rules.hasOwnProperty(atom.indicator) && (
				get_module.exports_predicate(atom.indicator) ||
				get_module.rules.hasOwnProperty(this.level.indicator) ||
				context_module === get_module.id))
					return get_module;
		}
		return null;
	};

	// Expand a meta-predicate
	Session.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		return this.thread.expand_meta_predicate(atom, definition_module, context_module);
	};
	Thread.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		var get_module = this.session.modules[definition_module];
		if(!get_module)
			return;
		var meta = get_module.is_meta_predicate(atom.indicator);
		if(!meta)
			return;
		for(var i = 0; i < meta.args.length; i++) {
			if(pl.type.is_integer(meta.args[i]) || pl.type.is_atom(meta.args[i]) && indexOf([":"], meta.args[i].id) !== -1) {
				if(!pl.type.is_term(atom.args[i]) || atom.args[i].indicator !== ":/2") {
					atom.args[i] = new Term(":", [new Term(context_module), atom.args[i]]);
				}
			} else if(pl.type.is_atom(meta.args[i]) && meta.args[i].id === "^") {
				var pointer_last = atom;
				var pointer_index = i;
				var pointer = atom.args[i];
				while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
					pointer_last = pointer;
					pointer_index = 1;
					pointer = pointer.args[1];
				}
				if(!pl.type.is_term(pointer) || pointer.indicator !== ":/2") {
					pointer_last.args[pointer_index] = new Term(":", [new Term(context_module), pointer]);
				}
			}
		}
	};
	
	// Resolution step
	Session.prototype.step = function() {
		return this.thread.step();
	}
	Thread.prototype.step = function() {
		if(this.points.length === 0) {
			return;
		}
		var asyn = false;
		var point = this.points.pop();
		this.current_point = point;
		if(this.debugger)
			this.debugger_states.push(point);
		var atom = pl.type.is_term(point.goal) ? point.goal.select() : point.goal;
		if(pl.type.is_term(atom) && (atom.indicator !== ":/2" || pl.type.is_term(atom.args[1]))) {
			var context_module = null;
			var states = [];
			if(atom !== null) {
				this.total_steps++;
				var level = point;
				while(level.parent !== null && level.parent.goal.search(atom))
					level = level.parent;
				if(level.parent === null) {
					this.level = new Term("top_level");
				} else {
					this.level = level.parent.goal.select();
					if(this.level.indicator === ":/2")
						this.level = this.level.args[1];
				}
				if(pl.type.is_term(atom) && atom.indicator === ":/2") {
					context_module = atom.args[0];
					atom = atom.args[1];
					if(!pl.type.is_atom(context_module)) {
						this.throw_error(pl.error.type("module", context_module, this.level.indicator));
						return;
					}
					context_module = context_module.id;
				} else {
					if(this.level.definition_module) {
						context_module = this.level.definition_module;
					} else {
						context_module = "user";
					}
				}
				atom.context_module = context_module;
				if(atom.indicator === ",/2") {
					this.prepend([new State(
						point.goal.replace(new Term(",", [
							new Term(":", [new Term(context_module), atom.args[0]]),
							new Term(":", [new Term(context_module), atom.args[1]])])),
						point.substitution,
						point
					)]);
					return;
				}
				this.__call_indicator = atom.indicator;
				var get_module = this.lookup_module(atom, context_module);
				atom.definition_module = pl.type.is_module(get_module) ? get_module.id : "user";
				this.expand_meta_predicate(atom, atom.definition_module, context_module);
				var clauses = null;
				if(get_module && atom.args.length > 0 && atom.args[0].index && get_module.indexed_clauses.hasOwnProperty(atom.indicator) && get_module.indexed_clauses[atom.indicator].hasOwnProperty(atom.args[0].index))
					clauses = get_module.indexed_clauses[atom.indicator][atom.args[0].index];
				else
					clauses = get_module === null ? null : get_module.rules[atom.indicator];
				if(clauses === null) {
					if(!this.session.modules.user.rules.hasOwnProperty(atom.indicator)) {
						if(this.get_flag("unknown").id === "error") {
							this.throw_error( pl.error.existence( "procedure", atom.indicator, this.level.indicator));
						} else if(this.get_flag("unknown").id === "warning") {
							this.throw_warning("unknown procedure " + atom.indicator + " (from " + this.level.indicator + ")");
						}
					}
				} else if(clauses instanceof Function) {
					asyn = clauses(this, point, atom);
				} else {
					// Goal expansion
					if(this.__goal_expansion && atom.indicator === "goal_expansion/2")
						clauses = clauses.concat(pl.builtin.rules["goal_expansion/2"]);
					for(var i = 0; i < clauses.length; i++) {
						this.session.renamed_variables = {};
						var clause = clauses[i].rename(this);
						var occurs_check = this.get_flag("occurs_check").indicator === "true/0";
						var mgu = pl.unify(atom, clause.head, occurs_check);
						if(mgu !== null) {
							var state = new State();
							state.goal = point.goal.replace(clause.body);
							if(state.goal !== null)
								state.goal = state.goal.apply(mgu);
							state.substitution = point.substitution.apply(mgu);
							state.parent = point;
							states.push(state);
						}
					}
					this.prepend(states);
				}
			}
		} else {
			var term = pl.type.is_term(atom) && atom.indicator === ":/2" ? atom.args[1] : atom;
			if(pl.type.is_variable(term))
				this.throw_error(pl.error.instantiation(this.level.indicator));
			else
				this.throw_error(pl.error.type("callable", term, this.level.indicator));
		}
		return asyn;
	};
	
	// Find next computed answer
	Session.prototype.answer = function(options) {
		return this.thread.answer(options);
	};
	Thread.prototype.answer = function(options) {
		var opts = {};
		options = options || function() {};
		if(typeof options === "function") {
			opts = {
				success: options,
				error: options,
				fail: options,
				limit: options
			};
		} else {
			opts.success = options.success === undefined ? function() {} : options.success;
			opts.error = options.error === undefined ? function() {} : options.error;
			opts.fail = options.fail === undefined ? function() {} : options.fail;
			opts.limit = options.limit === undefined ? function() {} : options.limit;
		}
		this.__calls.push(opts);
		if( this.__calls.length > 1 ) {
			return;
		}
		this.again();
	};
	
	// Find all computed answers
	Session.prototype.answers = function( callback, max, after ) {
		return this.thread.answers( callback, max, after );
	}
	Thread.prototype.answers = function( callback, max, after ) {
		var answers = max === undefined ? 1000 : max;
		var thread = this;
		if( answers <= 0 ) {
			if(after)
				after();
			return;
		}
		this.answer( function( answer ) {
			callback( answer );
			if( answer !== false ) {
				setTimeout( function() {
					thread.answers( callback, answers-1, after );
				}, 0 );
			} else if(after) {
				after();
			}
		} );
	};

	// Again finding next computed answer
	Session.prototype.again = function(reset_limit) {
		return this.thread.again(reset_limit);
	};
	Thread.prototype.again = function(reset_limit) {
		while(this.__calls.length > 0) {
			this.warnings = [];
			if(reset_limit !== false)
				this.current_limit = this.session.limit;
			while((!this.has_limit || this.current_limit > 0) && this.points.length > 0 && this.head_point().goal !== null && !pl.type.is_error_state(this.head_point())) {
				if(this.has_limit)
					this.current_limit--;
				var t0 = Date.now();
				var asyn = this.step();
				var t1 = Date.now();
				this.cpu_time += t1-t0;
				if(asyn === true)
					return;
			}
			var call = this.__calls.shift();
			// limit of inferences
			if(this.has_limit && this.current_limit <= 0) {
				(function(call) {
					return setTimeout(function() {
						call.limit(null);
					}, 0);
				})(call);
			// no answer
			} else if(this.points.length === 0) {
				(function(call) {
					return setTimeout(function() {
						call.fail(false);
					}, 0);
				})(call);
			// error
			} else if(pl.type.is_error(this.head_point().goal)) {
				var error = this.format_error(this.points.pop());
				this.points = [];
				(function(error, call) {
					return setTimeout(function() {
						call.error(error);
					}, 0);
				})(error, call);
			// computed answer
			} else {
				if(this.debugger)
					this.debugger_states.push(this.head_point());
				var answer = this.format_success(this.points.pop());
				(function(answer, call) {
					return setTimeout(function() {
						call.success(answer);
					}, 0);
				})(answer, call);
			}
		}
	};
	
	// Unfolding transformation
	Session.prototype.unfold = function( rule ) {
		if(rule.body === null)
			return false;
		var head = rule.head;
		var body = rule.body;
		var atom = body.select();
		var thread = new Thread( this );
		var unfolded = [];
		thread.add_goal( atom );
		thread.step();
		for( var i = thread.points.length-1; i >= 0; i-- ) {
			var point = thread.points[i];
			var head2 = head.apply( point.substitution );
			var body2 = body.replace( point.goal );
			if( body2 !== null )
				body2 = body2.apply( point.substitution );
			unfolded.push( new Rule( head2, body2 ) );
		}
		var rules = this.modules.user.rules[head.indicator];
		var index = indexOf( rules, rule );
		if( unfolded.length > 0 && index !== -1 ) {
			rules.splice.apply( rules, [index, 1].concat(unfolded) );
			return true;
		}
		return false;
	};
	Thread.prototype.unfold = function(rule) {
		return this.session.unfold(rule);
	};

	
	
	// INTERPRET EXPRESSIONS
	
	// Variables
	Var.prototype.interpret = function( thread ) {
		return pl.error.instantiation( thread.level.indicator );
	};
	
	// Numbers
	Num.prototype.interpret = function( thread ) {
		return this;
	};
	
	// Terms
	Term.prototype.interpret = function( thread ) {
		if( pl.type.is_unitary_list( this ) ) {
			return this.args[0].interpret( thread );
		} else {
			return pl.operate( thread, this );
		}
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.compare = function( obj ) {
		if( this.id < obj.id ) {
			return -1;
		} else if( this.id > obj.id ) {
			return 1;
		} else {
			return 0;
		}
	};
	
	// Numbers
	Num.prototype.compare = function( obj ) {
		if( this.value === obj.value && this.is_float === obj.is_float ) {
			return 0;
		} else if( this.value < obj.value || this.value === obj.value && this.is_float && !obj.is_float ) {
			return -1;
		} else if( this.value > obj.value ) {
			return 1;
		}
	};
	
	// Terms
	Term.prototype.compare = function( obj ) {
		if( this.args.length < obj.args.length || this.args.length === obj.args.length && this.id < obj.id ) {
			return -1;
		} else if( this.args.length > obj.args.length || this.args.length === obj.args.length && this.id > obj.id ) {
			return 1;
		} else {
			for( var i = 0; i < this.args.length; i++ ) {
				var arg = pl.compare( this.args[i], obj.args[i] );
				if( arg !== 0 ) {
					return arg;
				}
			}
			return 0;
		}
	};
	

	
	// SUBSTITUTIONS
	
	// Lookup variable
	Substitution.prototype.lookup = function( variable ) {
		if( this.links[variable] ) {
			return this.links[variable];
		} else {
			return null;
		}
	};
	
	// Filter variables
	Substitution.prototype.filter = function( predicate ) {
		var links = {};
		for( var id in this.links ) {
			if(!this.links.hasOwnProperty(id)) continue;
			var value = this.links[id];
			if( predicate( id, value ) ) {
				links[id] = value;
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Exclude variables
	Substitution.prototype.exclude = function( variables ) {
		var links = {};
		for( var variable in this.links ) {
			if(!this.links.hasOwnProperty(variable)) continue;
			if( indexOf( variables, variable ) === -1 ) {
				links[variable] = this.links[variable];
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Add link
	Substitution.prototype.add = function( variable, value ) {
		this.links[variable] = value;
	};
	
	// Get domain
	Substitution.prototype.domain = function( plain ) {
		var f = plain === true ? function(x){return x;} : function(x){return new Var(x);};
		var vars = [];
		for( var x in this.links )
			vars.push( f(x) );
		return vars;
	};

	// Get an attribute
	Substitution.prototype.get_attribute = function( variable, module ) {
		if( this.attrs[variable] )
			return this.attrs[variable][module];
	}

	// Set an attribute (in a new substitution)
	Substitution.prototype.set_attribute = function( variable, module, value ) {
		var subs = new Substitution( this.links );
		for( var v in this.attrs ) {
			if( v === variable ) {
				subs.attrs[v] = {};
				for( var m in this.attrs[v] ) {
					subs.attrs[v][m] = this.attrs[v][m];
				}
			} else {
				subs.attrs[v] = this.attrs[v];
			}
		}
		if( !subs.attrs[variable] ) {
			subs.attrs[variable] = {};
		}
		subs.attrs[variable][module] = value;
		return subs;
	}

	// Check if a variables has attributes
	Substitution.prototype.has_attributes = function( variable ) {
		return this.attrs[variable] && this.attrs[variable] !== {};
	}
	
	
	
	// GENERATE JAVASCRIPT CODE FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.compile = function() {
		return 'new pl.type.Var("' + this.id.toString() + '")';
	};
	
	// Numbers
	Num.prototype.compile = function() {
		return 'new pl.type.Num(' + this.value.toString() + ', ' + this.is_float.toString() + ')';
	};
	
	// Terms
	Term.prototype.compile = function() {
		return 'new pl.type.Term("' + this.id.replace(/"/g, '\\"') + '", [' + map( this.args, function( arg ) {
			return arg.compile();
		} ) + '])';
	};
	
	// Rules
	Rule.prototype.compile = function() {
		return 'new pl.type.Rule(' + this.head.compile() + ', ' + (this.body === null ? 'null' : this.body.compile()) + ')';
	};
	
	// Sessions
	Session.prototype.compile = function() {
		var str, obj = [], rules;
		for( var _indicator in this.modules.user.rules ) {
			if(!this.modules.user.rules.hasOwnProperty(_indicator)) continue;
			var indicator = this.modules.user.rules[_indicator];
			rules = [];
			str = "\"" + _indicator + "\": [";
			for(var i = 0; i < indicator.length; i++) {
				rules.push(indicator[i].compile());
			}
			str += rules.join();
			str += "]";
			obj.push( str );
		}
		return "{" + obj.join() + "};";
	};

	// Module
	Module.prototype.compile = function() {
		var length = 0;
		var dependencies = 0;
		var str = "var pl;\n";
		str += "(function(pl) {\n";
		// name
		str += "\tvar name = \"" + this.id + "\";\n";
		// predicates
		str += "\tvar predicates = function() {\n";
		str += "\t\treturn {\n";
		for(var prop in this.rules) {
			if(length > 0)
				str += ",\n";
			str += "\t\t\t\"" + prop + "\": ";
			if(typeof this.rules[prop] === "function") {
				str += this.rules[prop];
			} else {
				str += "[\n";
				for(var i = 0; i < this.rules[prop].length; i++) {
					str += "\t\t\t\t" + this.rules[prop][i].compile();
					if(i < this.rules[prop].length-1)
						str += ",";
					str += "\n";
				}
				str += "\t\t\t]";
			}
			length++;
		}
		str += "\n\t\t};\n";
		str += "\t};\n";
		// exports
		str += "\tvar exports = [";
		for(var i = 0; i < this.exports.length; i++) {
			if(i > 0)
				str += ", ";
			str += "\"" + this.exports[i] + "\"";
		}
		str += "];\n";
		// options
		str += "\tvar options = function() {\n";
		str += "\t\treturn {\n";
		// dependencies
		str += "\t\t\tdependencies: [";
		for(var prop in this.modules) {
			if(dependencies > 0)
				str += ", ";
			str += "\"" + prop + "\"";
			dependencies++;
		}
		str += "]\n";
		str += "\t\t};\n";
		str += "};\n";
		// fixed code
		str += "\tif(typeof module !== 'undefined') {\n";
		str += "\t\tmodule.exports = function(p) {\n";
		str += "\t\t\tpl = p;\n";
		str += "\t\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t\t};\n";
		str += "\t} else {\n";
		str += "\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t}\n";
		str += "})(pl);\n";
		return str;
	};
	
	
	
	// PROLOG TO JAVASCRIPT
	Var.prototype.toJavaScript = function() {
		return this.toString();
	};
	
	// Numbers
	Num.prototype.toJavaScript = function() {
		return this.value;
	};
	
	// Terms
	Term.prototype.toJavaScript = function(options) {
		// Atom => String
		if( this.args.length === 0 && this.indicator !== "[]/0" ) {
			return this.toString(options);
		} else if( pl.type.is_list( this ) ) {
			// List => Array
			var all_obj = true;
			var arr = [];
			var obj = {};
			var pointer = this;
			var value;
			while( pointer.indicator === "./2" ) {
				value = pointer.args[0].toJavaScript(options);
				arr.push( value );
				all_obj = all_obj && pl.type.is_term(pointer.args[0]) && pointer.args[0].indicator === "-/2" && pl.type.is_atom(pointer.args[0].args[0]);
				if(all_obj)
					obj[pointer.args[0].args[0].id] = pointer.args[0].args[1].toJavaScript(options);
				pointer = pointer.args[1];
			}
			if( pointer.indicator === "[]/0" )
				return all_obj && arr.length > 0 ? obj : arr;

		}
		return this.toString(options);
	};
	
	
	
	// RULES
	
	// Return singleton variables in the session
	Rule.prototype.singleton_variables = function(include_named) {
		include_named = include_named || false;
		var variables = this.head.variables();
		var count = {};
		var singleton = [];
		if(this.body !== null)
			variables = variables.concat(this.body.variables());
		for(var i = 0; i < variables.length; i++) {
			if(count[variables[i]] === undefined)
				count[variables[i]] = 0;
			count[variables[i]]++;
		}
		for(var key in count) {
			if(!count.hasOwnProperty(key))
				continue;
			if(count[key] === 1) {
				var charcode = codePointAt(key, 1);
				if(!include_named || key === "_")
					if(key === "_" || key[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
						continue;
				singleton.push(key);
			}
		}
		return singleton;
	};



	// NODEJS

	var nodejs_flag = typeof process !== 'undefined' && !process.browser

	var nodejs_arguments = nodejs_flag ?
		arrayToList( map(process.argv.slice(1), function(arg) { return new Term( arg ); })) :
		new Term("[]", []);
	
	
	
	// PROLOG

	var pl = {
		
		// Environment
		__env: nodejs_flag ? __webpack_require__.g : window,
		
		// Modules
		modules: {},
		
		// Version
		version: version,
		
		// Parser
		parser: {
			tokenizer: Tokenizer,
			expression: parseExpr
		},
		
		// Utils
		utils: {
			
			// String to indicator
			str_indicator: str_indicator,
			// Code point at
			codePointAt: codePointAt,
			// From code point
			fromCodePoint: fromCodePoint,
			// Length of string
			stringLength: stringLength
			
		},
		
		// Statistics
		statistics: {
			
			// Number of created terms
			getCountTerms: function() {
				return term_ref;
			}
			
		},
		
		// JavaScript to Prolog
		fromJavaScript: {
			
			// Type testing
			test: {
				
				// Boolean
				boolean: function( obj, tobj ) {
					return obj === true || obj === false;
				},
				
				// Number
				number: function( obj, tobj ) {
					return typeof obj === "number";
				},
				
				// String
				string: function( obj, tobj ) {
					return typeof obj === "string";
				},
				
				// List
				list: function( obj, tobj ) {
					return obj instanceof Array;
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return obj === undefined;
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					return tobj && !(obj instanceof Array) && typeof obj === "object";
				},
				
				// Any
				any: function( _, tobj ) {
					return true;
				}
				
			},
			
			// Function conversion
			conversion: {
				
				// Bolean
				boolean: function( obj, tobj ) {
					return new Term( obj ? "true" : "false", [] );
				},
				
				// Number
				number: function( obj, tobj ) {
					return new Num( obj, obj % 1 !== 0 );
				},
				
				// String
				string: function( obj, tobj ) {
					return new Term( obj, [] );
				},
				
				// List
				list: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var arr = [];
					var elem;
					for( var i = 0; i < obj.length; i++ ) {
						elem = pl.fromJavaScript.apply( obj[i], tobj );
						if( elem === undefined )
							return undefined;
						arr.push( elem );
					}
					return arrayToList( arr );
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return new Var( "_" );
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var list = new Term("[]", []);
					var arr = [];
					for(var prop in obj) {
						if(!obj.hasOwnProperty(prop)) continue;
						arr.push(new Term("-", [
							pl.fromJavaScript.apply(prop, tobj),
							pl.fromJavaScript.apply(obj[prop], tobj)
						]));
					}
					return arrayToList(arr);
				},
				
				// Any
				any: function( obj, tobj ) {
					return undefined;
				}
				
			},
			
			// Transform object
			apply: function( obj, tobj ) {
				tobj = tobj === undefined ? false : tobj;
				for( var i in pl.fromJavaScript.test )
					if( i !== "any" && pl.fromJavaScript.test[i]( obj, tobj ) )
						return pl.fromJavaScript.conversion[i]( obj, tobj );
				return pl.fromJavaScript.conversion.any( obj, tobj );
			}
		},
		
		// Types
		type: {
			
			// Objects
			Var: Var,
			Num: Num,
			Term: Term,
			Rule: Rule,
			State: State,
			Stream: Stream,
			Module: Module,
			Thread: Thread,
			Session: Session,
			Substitution: Substitution,
			File: TauFile,
			Directory: TauDirectory,
			
			// Order
			order: [Var, Num, Term, Stream],
			
			// Compare types
			compare: function( x, y ) {
				var ord_x = indexOf( pl.type.order, x.constructor );
				var ord_y = indexOf( pl.type.order, y.constructor );
				if( ord_x < ord_y ) {
					return -1;
				} else if( ord_x > ord_y ) {
					return 1;
				} else {
					if( x.constructor === Num )
						if( x.is_float && y.is_float )
							return 0;
						else if( x.is_float )
							return -1;
						else if( y.is_float )
							return 1;
					return 0;
				}
			},
			
			// Is a substitution
			is_substitution: function( obj ) {
				return obj instanceof Substitution;
			},
			
			// Is a state
			is_state: function( obj ) {
				return obj instanceof State;
			},
			
			// Is a rule
			is_rule: function( obj ) {
				return obj instanceof Rule;
			},
			
			// Is a variable
			is_variable: function( obj ) {
				return obj instanceof Var;
			},

			// Is a stream
			is_stream: function( obj ) {
				return obj instanceof Stream;
			},
			
			// Is an anonymous variable
			is_anonymous_var: function( obj ) {
				return obj instanceof Var && obj.id === "_";
			},
			
			// Is a callable term
			is_callable: function( obj ) {
				return obj instanceof Term
				&& (indexOf([",/2",";/2","->/2"], obj.indicator) === -1
				|| pl.type.is_callable(obj.args[0]) && pl.type.is_callable(obj.args[1]))
				|| obj instanceof Var;
			},
			
			// Is a number
			is_number: function( obj ) {
				return obj instanceof Num;
			},
			
			// Is an integer
			is_integer: function( obj ) {
				return obj instanceof Num && !obj.is_float;
			},
			
			// Is a float
			is_float: function( obj ) {
				return obj instanceof Num && obj.is_float;
			},
			
			// Is a term
			is_term: function( obj ) {
				return obj instanceof Term;
			},
			
			// Is an atom
			is_atom: function( obj ) {
				return obj instanceof Term && obj.args.length === 0;
			},
			
			// Is a ground term
			is_ground: function( obj ) {
				if( obj instanceof Var ) return false;
				if( obj instanceof Term )
					for( var i = 0; i < obj.args.length; i++ )
						if( !pl.type.is_ground( obj.args[i] ) )
							return false;
				return true;
			},
			
			// Is atomic
			is_atomic: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 || obj instanceof Num;
			},
			
			// Is compound
			is_compound: function( obj ) {
				return obj instanceof Term && obj.args.length > 0;
			},
			
			// Is a list
			is_list: function( obj ) {
				return obj instanceof Term && (obj.indicator === "[]/0" || obj.indicator === "./2");
			},
			
			// Is an empty list
			is_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a non empty list
			is_non_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2";
			},
			
			// Is a fully list
			is_fully_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Var || obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a instantiated list
			is_instantiated_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is an unitary list
			is_unitary_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2" && obj.args[1] instanceof Term && obj.args[1].indicator === "[]/0";
			},
			
			// Is a character
			is_character: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && (obj.id.length === 1 || obj.id.length > 0 && obj.id.length <= 2 && codePointAt( obj.id, 0 ) >= 65536);
			},
			
			// Is a in_character
			is_in_character: function( obj ) {
				return obj instanceof Term && (obj.indicator === "end_of_file/0"
				|| obj.id.length === 1
				|| obj.id.length > 0 && obj.id.length <= 2 && codePointAt(obj.id, 0) >= 65536);
			},
			
			// Is a character_code
			is_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 1114111;
			},
			
			// Is a in_character_code
			is_in_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 1114111;
			},

			// Is a byte
			is_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 255;
			},

			// Is a in_byte
			is_in_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 255;
			},
			
			// Is an operator
			is_operator: function( obj ) {
				return obj instanceof Term && pl.arithmetic.evaluation[obj.indicator];
			},
			
			// Is a directive
			is_directive: function( obj ) {
				return obj instanceof Term && (pl.directive[obj.indicator] !== undefined || pl.directive[obj.id + "/*"] !== undefined);
			},
			
			// Is a built-in predicate
			is_builtin: function( obj ) {
				return obj instanceof Term && pl.builtin.rules.hasOwnProperty(obj.indicator) && obj.indicator !== "goal_expansion/2";
			},
			
			// Is an error
			is_error: function( obj ) {
				return obj instanceof Term && obj.indicator === "throw/1";
			},

			// Is an error state
			is_error_state: function( obj ) {
				return pl.type.is_state( obj ) && obj.error && obj.error === true;
			},
			
			// Is a predicate indicator
			is_predicate_indicator: function( obj ) {
				return obj instanceof Term && obj.indicator === "//2" && obj.args[0] instanceof Term && obj.args[0].args.length === 0 && obj.args[1] instanceof Num && obj.args[1].is_float === false;
			},
			
			// Is a flag
			is_flag: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && pl.flag[obj.id] !== undefined;
			},
			
			// Is a valid value for a flag
			is_value_flag: function( flag, obj ) {
				if( !pl.type.is_flag( flag ) ) return false;
				for( var value in pl.flag[flag.id].allowed ) {
					if(!pl.flag[flag.id].allowed.hasOwnProperty(value)) continue;
					if( pl.flag[flag.id].allowed[value].equals( obj ) ) return true;
				}
				return false;
			},

			// Is a io mode
			is_io_mode: function( obj ) {
				return pl.type.is_atom( obj ) && ["read","write","append"].indexOf( obj.id ) !== -1;
			},

			// Is a stream option
			is_stream_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "alias/1" && pl.type.is_atom(obj.args[0]) ||
					obj.indicator === "reposition/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "type/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary") ||
					obj.indicator === "eof_action/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")
				);
			},

			// Is a stream position
			is_stream_position: function( obj ) {
				return pl.type.is_term(obj) && (
					obj.indicator === "end_of_stream/0" ||
					obj.indicator === "past_end_of_stream/0" ||
					obj.indicator === "position/3"
						&& pl.type.is_integer(obj.args[0])
						&& pl.type.is_integer(obj.args[1])
						&& pl.type.is_integer(obj.args[2])
				)
			},

			// Is a stream property
			is_stream_property: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "input/0" || 
					obj.indicator === "output/0" || 
					obj.indicator === "alias/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "file_name/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "reposition/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false")) ||
					obj.indicator === "type/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary")) ||
					obj.indicator === "mode/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "read" || obj.args[0].id === "write" || obj.args[0].id === "append")) ||
					obj.indicator === "eof_action/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")) ||
					obj.indicator === "end_of_stream/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "at" || obj.args[0].id === "past" || obj.args[0].id === "not")) ||
					obj.indicator === "position/1"
						&& (pl.type.is_variable(obj.args[0]) || pl.type.is_term(obj.args[0]) && obj.args[0].indicator === "position/3"
							&& (pl.type.is_variable(obj.args[0].args[0]) || pl.type.is_integer(obj.args[0].args[0]))
							&& (pl.type.is_variable(obj.args[0].args[1]) || pl.type.is_integer(obj.args[0].args[1]))
							&& (pl.type.is_variable(obj.args[0].args[2]) || pl.type.is_integer(obj.args[0].args[2])))
				);
			},

			// Is a streamable term
			is_streamable: function( obj ) {
				return obj.__proto__.stream !== undefined;
			},

			// Is a read option
			is_read_option: function( obj ) {
				return pl.type.is_term( obj ) && ["variables/1","variable_names/1","singletons/1"].indexOf( obj.indicator ) !== -1;
			},

			// Is a write option
			is_write_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "quoted/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "ignore_ops/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "numbervars/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "variable_names/1" && pl.type.is_fully_list(obj.args[0])
				);
			},

			// Is a close option
			is_close_option: function( obj ) {
				return pl.type.is_term( obj ) &&
					obj.indicator === "force/1" &&
					pl.type.is_atom(obj.args[0]) &&
					(obj.args[0].id === "true" || obj.args[0].id === "false");
			},
			
			// Is a modifiable flag
			is_modifiable_flag: function( obj ) {
				return pl.type.is_flag( obj ) && pl.flag[obj.id].changeable;
			},

			// Is a module
			is_module: function( obj ) {
				return obj instanceof Module;
			},

			// Is a virtual file
			is_file: function( obj ) {
				return obj instanceof TauFile;
			},

			// Is a virtual directory
			is_directory: function( obj ) {
				return obj instanceof TauDirectory;
			},

			// Is a predicate property
			is_predicate_property: function(obj) {
				return pl.type.is_term(obj) && (
					obj.indicator === "built_in/0" ||
					obj.indicator === "static/0" ||
					obj.indicator === "dynamic/0" ||
					obj.indicator === "native_code/0" ||
					obj.indicator === "multifile/0" ||
					obj.indicator === "meta_predicate/1"
				);
			},

			// Is a meta-argument specifier
			is_meta_argument_specifier: function(obj) {
				return pl.type.is_integer(obj) && obj.value >= 0 ||
					pl.type.is_atom(obj) && indexOf(["+", "-", "?", "*", "^", ":", "//"], obj.id) !== -1;
			},

			// Is a time property
			is_time_property: function( obj ) {
				return pl.type.is_term(obj) && obj.args.length === 1 
				&& (pl.type.is_variable(obj.args[0]) || pl.type.is_integer(obj.args[0]))
				&& indexOf(["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"], obj.id) !== -1;
			},
			
		},

		// Arithmetic functions
		arithmetic: {
			
			// Evaluation
			evaluation: {
				"e/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.E; }
				},
				"pi/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.PI; }
				},
				"tau/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return 2*Math.PI; }
				},
				"epsilon/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Number.EPSILON; }
				},
				"+/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return x; }
				},
				"-/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return -x; }
				},
				"\\/1": {
					type_args: false,
					type_result: false,
					fn: function( x, _ ) { return ~x; }
				},
				"abs/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.abs( x ); }
				},
				"sign/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.sign( x ); }
				},
				"float_integer_part/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"float_fractional_part/1": {
					type_args: true,
					type_result: true,
					fn: function( x, _ ) { return x - parseInt( x ); }
				},
				"float/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return parseFloat( x ); }
				},
				"floor/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.floor( x ); }
				},
				"truncate/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"round/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.round( x ); }
				},
				"ceiling/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.ceil( x ); }
				},
				"sin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sin( x ); }
				},
				"cos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cos( x ); }
				},
				"tan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tan( x ); }
				},
				"asin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.asin(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"acos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.acos(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"atan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.atan( x ); }
				},
				"atan2/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x === 0 && y === 0 ? pl.error.evaluation("undefined", thread.__call_indicator) : Math.atan2(x, y); }
				},
				"acosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 1 ? Math.acosh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"asinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.asinh( x ); }
				},
				"atanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) < 1 ? Math.atanh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"cosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cosh( x ); }
				},
				"sinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sinh( x ); }
				},
				"tanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tanh( x ); }
				},
				"exp/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.exp( x ); }
				},
				"sqrt/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 0 ? Math.sqrt( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x > 0 && y > 0 ? Math.log(y)/Math.log(x) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log10/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log(x)/Math.log(10) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"+/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x + y; }
				},
				"-/2": {
					type_args: null,
					type_result: null,
					fn:  function( x, y, _ ) { return x - y; }
				},
				"*/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x * y; }
				},
				"//2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return y ? x / y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"///2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.trunc( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"div/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.floor( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"**/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"^/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"<</2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x << y; }
				},
				">>/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x >> y; }
				},
				"/\\/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x & y; }
				},
				"\\//2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x | y; }
				},
				"xor/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x ^ y; }
				},
				"rem/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x % y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"mod/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x - Math.floor( x / y ) * y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"max/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.max( x, y ); }
				},
				"min/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.min( x, y ); }
				},
				"gcd/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return gcd(x, y); }
				}
				
			}
			
		},
		
		// Directives
		directive: {
			
			// dynamic/1
			"dynamic/1": function( thread, atom, options ) {
				var indicators = atom.args[0];
				if(!pl.type.is_list(indicators))
					indicators = arrayToList([indicators]);
				var pointer = indicators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					indicator = pointer.args[0];
					if( pl.type.is_variable( indicator ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
						thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
					} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_atom( indicator.args[0] ) ) {
						thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
					} else if( !pl.type.is_integer( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
					} else {
						var key = indicator.args[0].id + "/" + indicator.args[1].value;
						var get_module = thread.session.modules[options.context_module];
						get_module.public_predicates[key] = true;
						if( !get_module.rules[key] )
						get_module.rules[key] = [];
					}
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				}
			},

			// dynamic/[2..]
			"dynamic/*": function( thread, atom ) {
				for(var i = 0; i < atom.args.length; i++) {
					pl.directive["dynamic/1"](thread, new Term("dynamic", [atom.args[i]]));
				}
			},
			
			// multifile/1
			"multifile/1": function( thread, atom, options ) {
				var indicator = atom.args[0];
				if( pl.type.is_variable( indicator ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( indicator.args[0] ) ) {
					thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
				} else if( !pl.type.is_integer( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
				} else {
					var predicate_indicator = atom.args[0].args[0].id + "/" + atom.args[0].args[1].value;
					var get_module = thread.session.modules[options.context_module];
					get_module.multifile_predicates[predicate_indicator] = true;
					if(!get_module.rules.hasOwnProperty(predicate_indicator)) {
						get_module.rules[predicate_indicator] = [];
						get_module.public_predicates[predicate_indicator] = false;
					}
				}
			},

			// meta_predicate/1
			"meta_predicate/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				var head = atom.args[0];
				if( pl.type.is_variable(head) ) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_warning(pl.error.type("callable", head, atom.indicator));
				} else {
					for(var i = 0; i < head.args.length; i++) {
						var arg = head.args[i];
						if(!pl.type.is_meta_argument_specifier(arg)) {
							thread.throw_warning(pl.error.type("meta_argument_specifier", arg, atom.indicator));
							return;
						}
					}
					thread.session.modules[options.context_module].meta_predicates[head.indicator] = head;
				}
			},
			
			// set_prolog_flag
			"set_prolog_flag/2": function( thread, atom ) {
				var flag = atom.args[0], value = atom.args[1];
				if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( flag ) ) {
					thread.throw_warning( pl.error.type( "atom", flag, atom.indicator ) );
				} else if( !pl.type.is_flag( flag ) ) {
					thread.throw_warning( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
				} else if( !pl.type.is_modifiable_flag( flag ) ) {
					thread.throw_warning( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
				} else if( !pl.type.is_value_flag( flag, value ) ) {
					thread.throw_warning( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
				} else {
					thread.session.flag[flag.id] = value;
				}
			},

			// module/2
			"module/2": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0], exports = atom.args[1];
				if(pl.type.is_variable(module_id) || pl.type.is_variable(exports)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_atom(module_id)) {
					thread.throw_warning(pl.error.type("atom", module_id, atom.indicator));
				} else if(!pl.type.is_list(exports)) {
					thread.throw_warning(pl.error.type("list", exports, atom.indicator));
				} else {
					if(!pl.type.is_module(thread.session.modules[module_id.indicator])) {
						var pointer = exports;
						var indicators = [];
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var predicate = pointer.args[0];
							if(!pl.type.is_predicate_indicator(predicate)) {
								thread.throw_warning(pl.error.type("predicate_indicator", predicate, atom.indicator));
							} else {
								indicators.push(predicate.args[0].id + "/" + predicate.args[1].value);
							}
							pointer = pointer.args[1];
						}
						if(pl.type.is_variable(pointer)) {
							thread.throw_warning(pl.error.instantiation(atom.indicator));
						} else if(!pl.type.is_empty_list(pointer)) {
							thread.throw_warning(pl.error.type("list", exports, atom.indicator));
						}
						var new_module = new Module(module_id.id, {}, indicators, {
							session: thread.session
						});
						thread.session.modules[module_id.id] = new_module;
						thread.session.modules[options.context_module].modules[module_id.id] = new_module;
						options.context_module = module_id.id;
					} else {
						thread.throw_warning(pl.error.permission("create", "module", module_id, atom.indicator));
					}
				}
			},
			
			// use_module/1
			"use_module/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0];
				if(pl.type.is_variable(module_id)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_term(module_id)) {
					thread.throw_warning(pl.error.type("term", module_id, atom.indicator));
				} else {
					if(module_id.indicator === "library/1") {
						var name = module_id.args[0].id;
						var get_module = pl.modules[name];
						if(pl.type.is_module(get_module)) {
							if(!thread.session.modules[options.context_module].modules.hasOwnProperty(name)) {
								thread.session.modules[name] = get_module;
								thread.session.modules[options.context_module].modules[name] = get_module;
								for(var i = 0; i < get_module.dependencies.length; i++) {
									var term = new Term("use_module", [new Term("library", [new Term(get_module.dependencies[i])])]);
									pl.directive["use_module/1"](thread, term, {
										context_module: name
									});
								}
							}
						} else {
							thread.throw_warning(pl.error.existence("module", module_id, atom.indicator));
						}
					} else {
						var name = module_id.id;
						thread.consult(name, {
							context_module: options.context_module,
							text: false,
							success: function() {
								parseProgram(thread, options.string, options);
							},
							error: function() {
								options.error(pl.error.existence("module", module_id, atom.indicator));
							}
						});
						return true;
					}
				}
			},
			
			// char_conversion/2
			"char_conversion/2": function(thread, atom, options) {
				var inchar = atom.args[0], outchar = atom.args[1];
				if(pl.type.is_variable(inchar) || pl.type.is_variable(outchar)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_character(inchar)) {
					thread.throw_warning(pl.error.type("character", inchar, atom.indicator));
				} else if(!pl.type.is_character(outchar)) {
					thread.throw_warning(pl.error.type("character", outchar, atom.indicator));
				} else {
					if(inchar.id === outchar.id) {
						delete thread.session.__char_conversion[inchar.id];
					} else {
						thread.session.__char_conversion[inchar.id] = outchar.id;
					}
					options.tokens = options.tokenizer.get_tokens(options.current_token);
					options.current_token = 0;
					return true;
				}
			},
			
			// op/3
			"op/3": function( thread, atom ) {
				var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
				if(pl.type.is_atom(operators))
					operators = new Term(".", [operators, new Term("[]")]);
				if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_integer( priority ) ) {
					thread.throw_warning( pl.error.type( "integer", priority, atom.indicator ) );
				} else if( !pl.type.is_atom( type ) ) {
					thread.throw_warning( pl.error.type( "atom", type, atom.indicator ) );
				} else if( !pl.type.is_list( operators ) ) {
					thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
				} else if( pl.type.is_empty_list( operators ) ) {
					thread.throw_warning( pl.error.permission( "create", "operator", operators, atom.indicator ) );
				} else {
					var pointer = operators;
					while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
						var operator = pointer.args[0];
						pointer = pointer.args[1];
						if( pl.type.is_variable( operator ) ) {
							thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						} else if( !pl.type.is_atom( operator ) ) {
							thread.throw_warning( pl.error.type( "atom", operator, atom.indicator ) );
						} else if( priority.value < 0 || priority.value > 1200 ) {
							thread.throw_warning( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						} else if( operator.id === "," ) {
							thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						} else if( operator.id === "{}" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "[]" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
							thread.throw_warning( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						} else {
							var fix = { prefix: null, infix: null, postfix: null };
							for( var p in thread.session.__operators ) {
								if(!thread.session.__operators.hasOwnProperty(p)) continue;
								var classes = thread.session.__operators[p][operator.id];
								if( classes ) {
									if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
									if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
									if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
									if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
									if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
									if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
									if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
								}
							}
							var current_class;
							switch( type.id ) {
								case "fy": case "fx": current_class = "prefix"; break;
								case "yf": case "xf": current_class = "postfix"; break;
								default: current_class = "infix"; break;
							}
							if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
								thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							} else {
								if( fix[current_class] ) {
									remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
									if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
										delete thread.session.__operators[fix[current_class].priority][operator.id];
									}
								}
								if( priority.value > 0 ) {
									if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
									if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
									thread.session.__operators[priority.value][operator.id].push( type.id );
								}
							}
						}
					}
					if(pl.type.is_variable(pointer)) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						return;
					} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
						thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
						return;
					}
				}
			},

			// initialization/1
			"initialization/1": function(thread, atom, options) {
				var goal = atom.args[0];
				options.initialization.push(goal);
			}
			
		},
		
		// Flags
		flag: {
			
			// Bounded numbers
			bounded: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( "true" ),
				changeable: false
			},
			
			// Maximum integer
			max_integer: {
				allowed: [new Num( Number.MAX_SAFE_INTEGER )],
				value: new Num( Number.MAX_SAFE_INTEGER ),
				changeable: false
			},
			
			// Minimum integer
			min_integer: {
				allowed: [new Num( Number.MIN_SAFE_INTEGER )],
				value: new Num( Number.MIN_SAFE_INTEGER ),
				changeable: false
			},
			
			// Rounding function
			integer_rounding_function: {
				allowed: [new Term( "down" ), new Term( "toward_zero" )],
				value: new Term( "toward_zero" ),
				changeable: false
			},
			
			// Character conversion
			char_conversion: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "on" ),
				changeable: true
			},
			
			// Debugger
			debug: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "off" ),
				changeable: true
			},
			
			// Maximum arity of predicates
			max_arity: {
				allowed: [new Term( "unbounded" )],
				value: new Term( "unbounded" ),
				changeable: false
			},
			
			// Unkwnow predicates behavior
			unknown: {
				allowed: [new Term( "error" ), new Term( "fail" ), new Term( "warning" )],
				value: new Term( "error" ),
				changeable: true
			},
			
			// Double quotes behavior
			double_quotes: {
				allowed: [new Term( "chars" ), new Term( "codes" ), new Term( "atom" )],
				value: new Term( "chars" ),
				changeable: true
			},
			
			// Occurs check behavior
			occurs_check: {
				allowed: [new Term( "false" ), new Term( "true" )],
				value: new Term( "false" ),
				changeable: true
			},
			
			// Dialect
			dialect: {
				allowed: [new Term( "tau" )],
				value: new Term( "tau" ),
				changeable: false
			},
			
			// Version
			version_data: {
				allowed: [new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] )],
				value: new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] ),
				changeable: false
			},
			
			// NodeJS
			nodejs: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( nodejs_flag ? "true" : "false" ),
				changeable: false
			},

			// Arguments
			argv: {
				allowed: [nodejs_arguments],
				value: nodejs_arguments,
				changeble: false
			}
			
		},
		
		// Unify
		unify: function(t1, t2, occurs_check) {
			occurs_check = occurs_check === undefined ? false : occurs_check;
			var left = Array.isArray(t1) ? t1 : [t1];
			var right = Array.isArray(t2) ? t2 : [t2];
			if(left.length !== right.length)
				return null;
			var subs = new Substitution();
			while(left.length > 0) {
				var s = left.pop();
				var t = right.pop();
				if(pl.type.is_variable(s))
					s = s.apply(subs);
				if(pl.type.is_variable(t))
					t = t.apply(subs);
				// same object
				if(s == t)
					continue;
				// compound terms
				if(pl.type.is_term(s) && pl.type.is_term(t)) {
					if(s.indicator !== t.indicator)
						return null;
					for(var i = s.args.length-1; i >= 0; i--) {
						left.push(s.args[i]);
						right.push(t.args[i]);
					}
				// numbers
				} else if(pl.type.is_number(s) && pl.type.is_number(t)) {
					if(s.value !== t.value || s.is_float !== t.is_float)
						return null;
				// variable - term
				} else if(pl.type.is_variable(s)) {
					t = t.apply(subs);
					// x = x
					if(pl.type.is_variable(t) && s.id === t.id)
						continue;
					// occurs check
					if(occurs_check === true && indexOf(t.variables(), s.id) !== -1)
						return null;
					// anonymous variable
					if(s.id !== "_")
						subs.add(s.id, t);
				// term - variable
				} else if(pl.type.is_variable(t)) {
					left.push(t);
					right.push(s);
				// user-defined terms
				} else if(s.unify !== undefined) {
					var user_subs = s.apply(subs).unify(t.apply(subs), occurs_check);
					if(user_subs == null)
						return null;
					for(var i in user_subs.links)
						subs.add(i, user_subs.links[i]);
				} else {
					return null;
				}
			}
			return subs.apply(subs);
		},

		// Is rename
		is_rename: function(obj1, obj2, links) {
			links = links || {};
			if(obj1.is_rename && obj2.is_rename)
				return obj1.is_rename(obj2, links);
			else if(obj1.equals && obj2.equals)
				return obj1.equals(obj2);
			else
				return false;
		},
		
		// Compare
		compare: function( obj1, obj2 ) {
			var type = pl.type.compare( obj1, obj2 );
			return type !== 0 ? type : obj1.compare( obj2 );
		},
		
		// Arithmetic comparison
		arithmetic_compare: function( thread, obj1, obj2 ) {
			var expr1 = obj1.interpret( thread );
			if( !pl.type.is_number( expr1 ) ) {
				return expr1;
			} else {
				var expr2 = obj2.interpret( thread );
				if( !pl.type.is_number( expr2 ) ) {
					return expr2;
				} else {
					return expr1.value < expr2.value ? -1 : (expr1.value > expr2.value ? 1 : 0);
				}
			}
		},
		
		// Operate
		operate: function( thread, obj ) {
			if( pl.type.is_operator( obj ) ) {
				var op = pl.type.is_operator( obj );
				var args = [], value;
				var type = false;
				for( var i = 0; i < obj.args.length; i++ ) {
					value = obj.args[i].interpret( thread );
					if( !pl.type.is_number( value ) ) {
						return value;
					} else if( op.type_args !== null && value.is_float !== op.type_args ) {
						return pl.error.type( op.type_args ? "float" : "integer", value, thread.__call_indicator );
					} else {
						args.push( value.value );
					}
					type = type || value.is_float;
				}
				args.push( thread );
				value = pl.arithmetic.evaluation[obj.indicator].fn.apply( this, args );
				if(obj.indicator === "^/2" && !type && value !== parseInt(value, 10))
					return pl.error.type( "float", new Num(args[0],false), thread.__call_indicator );
				type = op.type_result === null ? type : op.type_result;
				if( pl.type.is_term( value ) ) {
					return value;
				} else if( value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY ) {
					return pl.error.evaluation( "float_overflow", thread.__call_indicator );
				} else if( type === false && thread.get_flag( "bounded" ).id === "true" && (value > thread.get_flag( "max_integer" ).value || value < thread.get_flag( "min_integer" ).value) ) {
					return pl.error.evaluation( "int_overflow", thread.__call_indicator );
				} else {
					return new Num( value, type );
				}
			} else {
				return pl.error.type( "evaluable", str_indicator(obj.indicator), thread.__call_indicator );
			}
		},
		
		// Errors
		error: {
			
			// Existence error
			existence: function( type, object, indicator ) {
				if( typeof object === "string" )
					object = str_indicator( object );
				return new Term( "error", [new Term( "existence_error", [new Term( type ), object] ), str_indicator( indicator )] );
			},
			
			// Type error
			type: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "type_error", [new Term( expected ), found] ), str_indicator( indicator )] );
			},
			
			// Instantation error
			instantiation: function( indicator ) {
				return new Term( "error", [new Term( "instantiation_error" ), str_indicator( indicator )] );
			},
			
			// Uninstantation error
			uninstantiation: function( found, indicator ) {
				return new Term( "error", [new Term( "uninstantiation_error", [new Term( found )] ), str_indicator( indicator )] );
			},
			
			// Domain error
			domain: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "domain_error", [new Term( expected ), found]), str_indicator( indicator )] );
			},
			
			// Representation error
			representation: function( flag, indicator ) {
				return new Term( "error", [new Term( "representation_error", [new Term( flag )] ), str_indicator( indicator )] );
			},
			
			// Permission error
			permission: function( operation, type, found, indicator ) {
				return new Term( "error", [new Term( "permission_error", [new Term( operation ), new Term( type ), found] ), str_indicator( indicator )] );
			},
			
			// Evaluation error
			evaluation: function( error, indicator ) {
				return new Term( "error", [new Term( "evaluation_error", [new Term( error )] ), str_indicator( indicator )] );
			},
			
			// Syntax error
			syntax: function( token, expected, last ) {
				token = token || {value: "", line: 0, column: 0, matches: [""], start: 0};
				var position = last && token.matches.length > 0 ? token.start + token.matches[0].length : token.start;
				var found = last ? new Term("token_not_found") : new Term("found", [new Term(token.value.toString())]);
				var info = new Term( ".", [new Term( "line", [new Num(token.line+1)] ), new Term( ".", [new Term( "column", [new Num(position)] ), new Term( ".", [found, new Term( "[]", [] )] )] )] );
				return new Term( "error", [new Term( "syntax_error", [new Term( expected )] ), info] );
			},
			
			// Syntax error by predicate
			syntax_by_predicate: function( expected, indicator ) {
				return new Term( "error", [new Term( "syntax_error", [new Term( expected ) ] ), str_indicator( indicator )] );
			}
			
		},
		
		// Warnings
		warning: {
			
			// Singleton variables
			singleton: function( variables, rule, line ) {
				var list = new Term( "[]" );
				for( var i = variables.length-1; i >= 0; i-- )
					list = new Term( ".", [new Var(variables[i]), list] );
				return new Term( "warning", [new Term( "singleton_variables", [list, str_indicator(rule)]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			},
			
			// Failed goal
			failed_goal: function( goal, line ) {
				return new Term( "warning", [new Term( "failed_goal", [goal]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			}

		},
		
		// Format of renamed variables
		format_variable: function( id, variable ) {
			var charcode = variable && variable.length > 0 ? codePointAt(variable, 1) : 0;
			if(variable === "_" || variable && variable[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
				return "__" + id;
			return "_" + id;
		},
		
		// Format of computed answers
		format_answer: function( answer, thread, options ) {
			if( thread instanceof Session )
				thread = thread.thread;
			var options = options ? options : {};
			options.session = thread ? thread.session : undefined;
			if( pl.type.is_error( answer ) ) {
				return "uncaught exception: " + answer.args[0].toString(options);
			} else if( answer === false ) {
				return "false";
			} else if( answer === null ) {
				return "limit exceeded";
			} else {
				var i = 0;
				var str = "";
				if( pl.type.is_substitution( answer ) ) {
					var dom = answer.domain( true );
					for( var link in answer.links ){
						if( !answer.links.hasOwnProperty(link) ) continue;
						if( pl.type.is_variable(answer.links[link]) ) {
							var links = {};
							links[answer.links[link].id] = new Var(link);
							answer = answer.apply( new Substitution(links) );
						}
					}
					answer = answer.filter( function( id, value ) {
						return !pl.type.is_variable( value ) ||
							pl.type.is_variable( value ) && answer.has_attributes( id ) ||
							indexOf( dom, value.id ) !== -1 && id !== value.id;
					} );
				}
				for( var link in answer.links ) {
					if(!answer.links.hasOwnProperty(link))
						continue;
					if( pl.type.is_variable( answer.links[link] ) && link === answer.links[link].id ) {
						var attrs = answer.attrs[link];
						for( var module in attrs ) {
							if(!attrs.hasOwnProperty(module))
								continue;
							i++;
							if( str !== "" )
								str += ", ";
							str += "put_attr(" + link + ", " + module + ", " + attrs[module].toString(options) + ")";
						}
					} else {
						i++;
						if( str !== "" )
							str += ", ";
						str += link.toString( options ) + " = " +
							answer.links[link].toString( options, {priority: "700", class: "xfx", indicator: "=/2"}, "right" );
					}
				}
				if( i === 0 ) {
					return "true";
				} else {
					return str;
				}
			}
		},
		
		// Flatten default errors
		flatten_error: function( error ) {
			if( !pl.type.is_error( error ) ) return null;
			error = error.args[0];
			var obj = {};
			obj.type = error.args[0].id;
			obj.thrown = obj.type === "syntax_error" ? null : error.args[1].id;
			obj.expected = null;
			obj.found = null;
			obj.representation = null;
			obj.existence = null;
			obj.existence_type = null;
			obj.line = null;
			obj.column = null;
			obj.permission_operation = null;
			obj.permission_type = null;
			obj.evaluation_type = null;
			if( obj.type === "type_error" || obj.type === "domain_error" ) {
				obj.expected = error.args[0].args[0].id;
				obj.found = error.args[0].args[1].toString();
			} else if( obj.type === "syntax_error" ) {
				if( error.args[1].indicator === "./2" ) {
					obj.expected = error.args[0].args[0].id;
					obj.found = error.args[1].args[1].args[1].args[0];
					obj.found = obj.found.id === "token_not_found" ? obj.found.id : obj.found.args[0].id;
					obj.line = error.args[1].args[0].args[0].value;
					obj.column = error.args[1].args[1].args[0].args[0].value;
				} else {
					obj.thrown = error.args[1].id;
				}
			} else if( obj.type === "permission_error" ) {
				obj.found = error.args[0].args[2].toString();
				obj.permission_operation = error.args[0].args[0].id;
				obj.permission_type = error.args[0].args[1].id;
			} else if( obj.type === "evaluation_error" ) {
				obj.evaluation_type = error.args[0].args[0].id;
			} else if( obj.type === "representation_error" ) {
				obj.representation = error.args[0].args[0].id;
			} else if( obj.type === "existence_error" ) {
				obj.existence = error.args[0].args[1].toString();
				obj.existence_type = error.args[0].args[0].id;
			}
			return obj;
		},
		
		// Create new session
		create: function( limit ) {
			return new pl.type.Session( limit );
		}
		
	};

	// Built-in predicates
	pl.builtin = new Module("system", {

		// TERM AND GOAL EXPANSION

		// goal_expansion/2
		"goal_expansion/2": [
			new Rule(new Term("goal_expansion", [new Term(",", [new Var("X"),new Var("Y")]),new Term(",", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term(";", [new Var("X"),new Var("Y")]),new Term(";", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("->", [new Var("X"),new Var("Y")]),new Term("->", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("catch", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("catch", [new Var("X_"),new Var("Y"),new Var("Z_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Z"),new Var("Z_")]),new Term("=", [new Var("Z_"),new Var("Z")])])]),new Term(",", [new Term("=", [new Var("X_"),new Var("X")]),new Term("goal_expansion", [new Var("Z"),new Var("Z_")])])])),
			new Rule(new Term("goal_expansion", [new Term("\\+", [new Var("X")]),new Term("\\+", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("once", [new Var("X")]),new Term("once", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("findall", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("setof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("bagof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X")]),new Term("call", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term("[]", [])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term("[]", [])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term("[]", [])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term("[]", [])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term("[]", [])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term("[]", [])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6"),new Var("A7")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term(".", [new Var("A7"),new Term("[]", [])])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])]))
		],



		// SYSTEM PREDICATES ($)

		// '$push_global_stack'/2
		"$push_global_stack/2": function(thread, point, atom) {
			var stack = atom.args[0], value = atom.args[1];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				thread.push_global_stack(stack.id, value);
				thread.success(point);
			}
		},

		// '$flush_global_stack'/3
		"$flush_global_stack/3": function(thread, point, atom) {
			var stack = atom.args[0], list = atom.args[1], tail = atom.args[2];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				var values = thread.flush_global_stack(stack.id, tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [list, values])),
					point.substitution,
					point
				)]);
			}
		},

		// '$free_variable_set'/3
		"$free_variable_set/3": function(thread, point, atom) {
			var goal_in = atom.args[0], goal_out = atom.args[1], vars = atom.args[2];
			var bv = [];
			var pointer = goal_in;
			while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
				bv = bv.concat(pointer.args[0].variables());
				pointer = pointer.args[1];
			}
			var gv = pointer.variables();
			var fv = arrayToList(map(difference(gv, bv), function(v) {
				return new Var(v);
			}));
			thread.prepend([
				new State(
					point.goal.replace(new Term(",", [
						new Term("=", [goal_out, pointer]),
						new Term("=", [vars, fv]) 
					])),
					point.substitution,
					point
				)
			]);
		},

		// '$member'/2
		"$member/2": [
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("X"),new pl.type.Var("_")])]), null),
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("_"),new pl.type.Var("Xs")])]), new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Var("Xs")]))
		],

		// '$bind_bagof_keys/2'/2
		"$bind_bagof_keys/2": [
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term("[]", []),new pl.type.Var("_")]), null),
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term(".", [new pl.type.Term("-", [new pl.type.Var("Key"),new pl.type.Var("_")]),new pl.type.Var("Bag")]),new pl.type.Var("Vars")]), new pl.type.Term(",", [new pl.type.Term("term_variables", [new pl.type.Var("Key"),new pl.type.Var("Vars"),new pl.type.Var("_")]),new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Bag"),new pl.type.Var("Vars")])]))
		],

		// '$findall'/4
		"$findall/4": [
			new pl.type.Rule(new pl.type.Term("$findall", [new pl.type.Var("Template0"),new pl.type.Var("Goal0"),new pl.type.Var("Instances"),new pl.type.Var("Tail")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Term("-", [new pl.type.Var("Template0"),new pl.type.Var("Goal0")]),new pl.type.Term("-", [new pl.type.Var("Template1"),new pl.type.Var("Goal1")])]),new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("Goal1")]),new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Var("Template1"),new pl.type.Var("Template2")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Template2")]),new pl.type.Term("false", [])])])])]),new pl.type.Term("$flush_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Instances"),new pl.type.Var("Tail")])]))
		],

		// '$bagof'/3
		"$bagof/3": [
			new pl.type.Rule(new pl.type.Term("$bagof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Answer")]),new pl.type.Var("KeySorted")])])])])])]))
		],

		// '$setof'/3
		"$setof/3": [
			new pl.type.Rule(new pl.type.Term("$setof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term(",", [new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Unsorted")]),new pl.type.Var("KeySorted")]),new pl.type.Term("sort", [new pl.type.Var("Unsorted"),new pl.type.Var("Answer")])])])])])])]))
		],

		// '$if/3'
		"$if/3": [
			new pl.type.Rule(new pl.type.Term("$if", [new pl.type.Var("If"),new pl.type.Var("Then"),new pl.type.Var("Else")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("If")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Stack"),new pl.type.Var("_")]),new pl.type.Term("call", [new pl.type.Var("Then")])])]),new pl.type.Term(",", [new pl.type.Term("$flush_global_stack", [new pl.type.Var("Stack"),new pl.type.Term("[]", []),new pl.type.Term("[]", [])]),new pl.type.Term("call", [new pl.type.Var("Else")])])]))
		],


		// ATTRIBUTED VARIABLES
		
		//put_attr/3
		"put_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var subs = point.substitution.set_attribute( variable.id, module, value );
				thread.prepend( [new State( point.goal.replace(null), subs, point )] );
			}
		},

		// get_attr/3
		"get_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var attr = point.substitution.get_attribute( variable.id, module );
				if( attr ) {
					thread.prepend( [new State(
						point.goal.replace( new Term("=", [value, attr]) ),
						point.substitution,
						point
					)] );
				}
			}
		},


		
		// INPUT AND OUTPUT
		
		// op/3
		"op/3": function( thread, point, atom ) {
			var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
			if(pl.type.is_atom(operators))
				operators = new Term(".", [operators, new Term("[]")]);
			if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( !pl.type.is_atom( type ) ) {
				thread.throw_error( pl.error.type( "atom", type, atom.indicator ) );
			} else if( !pl.type.is_list( operators ) ) {
				thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
			} else if( pl.type.is_empty_list( operators ) ) {
				thread.throw_error( pl.error.permission( "create", "operator", operators, atom.indicator ) );
			} else {
				var pointer = operators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var operator = pointer.args[0];
					pointer = pointer.args[1];
					if( pl.type.is_variable( operator ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( operator ) ) {
						thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
						return;
					} else if( priority.value < 0 || priority.value > 1200 ) {
						thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						return;
					} else if( operator.id === "," ) {
						thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "{}" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "[]" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
						thread.throw_error( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						return;
					} else {
						var fix = { prefix: null, infix: null, postfix: null };
						for( var p in thread.session.__operators ) {
							if(!thread.session.__operators.hasOwnProperty(p)) continue;
							var classes = thread.session.__operators[p][operator.id];
							if( classes ) {
								if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
								if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
								if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
								if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
								if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
								if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
								if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
							}
						}
						var current_class;
						switch( type.id ) {
							case "fy": case "fx": current_class = "prefix"; break;
							case "yf": case "xf": current_class = "postfix"; break;
							default: current_class = "infix"; break;
						}
						if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
							thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							return;
						} else {
							if( fix[current_class] ) {
								remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
								if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
									delete thread.session.__operators[fix[current_class].priority][operator.id];
								}
							}
							if( priority.value > 0 ) {
								if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
								if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
								thread.session.__operators[priority.value][operator.id].push( type.id );
							}
						}
					}
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
					return;
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
					return;
				} else {
					thread.success(point);
				}
			}
		},
		
		// current_op/3
		"current_op/3": function( thread, point, atom ) {
			var priority = atom.args[0], specifier = atom.args[1], operator = atom.args[2];
			var points = [];
			if( !pl.type.is_variable( priority ) && !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( pl.type.is_integer( priority ) && ( priority.value < 0 || priority.value > 1200 ) ) {
				thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
			} else if( !pl.type.is_variable( specifier ) && !pl.type.is_atom( specifier ) ) {
				thread.throw_error( pl.error.type( "atom", specifier, atom.indicator ) );
			} else if( pl.type.is_atom( specifier ) && indexOf( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"], specifier.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "operator_specifier", specifier, atom.indicator ) );
			} else if( !pl.type.is_variable( operator ) && !pl.type.is_atom( operator ) ) {
				thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
			} else {
				for( var p in thread.session.__operators )
					for( var o in thread.session.__operators[p] )
						for( var i = 0; i < thread.session.__operators[p][o].length; i++ )
							points.push( new State(
								point.goal.replace(
									new Term( ",", [
										new Term( "=", [new Num( p, false ), priority] ),
										new Term( ",", [
											new Term( "=", [new Term( thread.session.__operators[p][o][i], [] ), specifier] ),
											new Term( "=", [new Term( o, [] ), operator] )
										] )
									] )
								),
								point.substitution,
								point
							) );
				thread.prepend( points );
			}
		},
	


		// LOGIC AND CONTROL STRUCTURES
	
		// ;/2 (disjunction)
		";/2": function(thread, point, atom) {
			var left = atom.args[0], right = atom.args[1];
			var context_left = left.args[0];
			var free_left = left.indicator === ":/2" ? left.args[1] : left;
			// if then else
			if(pl.type.is_term(free_left) && free_left.indicator === "->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, new Term("call", [free_left.args[0]])]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				var goal_fst = point.goal.replace(new Term( ",", [cond, new Term(",", [new Term("!"), then])] ) );
				var goal_snd = point.goal.replace(new Term( ",", [new Term("!"), otherwise]));
				thread.prepend([
					new State(goal_fst, point.substitution, point),
					new State(goal_snd, point.substitution, point)
				]);
			// soft-cut
			} else if(pl.type.is_term(free_left) && free_left.indicator === "*->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[0]]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				thread.prepend([new State(
					point.goal.replace(new Term("$if", [cond, then, otherwise])),
					point.substitution,
					point
				)]);
			// otherwise
			} else {
				thread.prepend([
					new State(point.goal.replace(left), point.substitution, point),
					new State(point.goal.replace(right), point.substitution, point)
				]);
			}
		},
		
		// !/0 (cut)
		"!/0": function( thread, point, atom ) {
			var parent_cut, last_cut, states = [];
			parent_cut = point;
			last_cut = null;
			while( parent_cut.parent !== null && parent_cut.parent.goal.search( atom ) ) {
				last_cut = parent_cut;
				parent_cut = parent_cut.parent;
				if(parent_cut.goal !== null) {
					var selected = parent_cut.goal.select();
					if(selected && selected.indicator === ":/2")
						selected = selected.args[1];
					if( selected && selected.id === "call" && selected.search(atom) ) {
						parent_cut = last_cut;
						break;
					}
				}
			}
			var setup_call_cleanup = null;
			for( var i = thread.points.length-1; i >= 0; i-- ) {
				var state = thread.points[i];
				var node = state.parent;
				while( node !== null && node !== parent_cut.parent ) {
					node = node.parent;
				}
				if( node === null && node !== parent_cut.parent )
					states.push( state );
				else if(state.setup_call_cleanup_goal)
					setup_call_cleanup = state.setup_call_cleanup_goal
			}
			thread.points = states.reverse();
			thread.prepend([new State(
				point.goal.replace(setup_call_cleanup),
				point.substitution,
				point
			)]);
		},
		
		// \+ (negation)
		"\\+/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			if( pl.type.is_variable( goal ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( goal ) ) {
				thread.throw_error( pl.error.type( "callable", goal, atom.indicator ) );
			} else {
				// TRANSPARENT VERSION OF THE NEGATION
				/*var neg_thread;
				if(point.negation_thread) {
					neg_thread = point.negation_thread;
				} else {
					neg_thread = new Thread( thread.session );
					neg_thread.add_goal( goal );
					point.negation_thread = neg_thread;
				}
				neg_thread.answer( function( answer ) {
					if(answer === false) {
						thread.success( point );
					} else if(pl.type.is_error( answer )) {
						thread.throw_error( answer.args[0] );
					} else if(answer === null) {
						thread.prepend( [point] );
						thread.current_limit = 0;
					}
					thread.again( answer !== null );
				} );
				return true;*/
				
				// '\+'(X) :- call(X), !, fail.
				// '\+'(_).
				thread.prepend( [
					new State( point.goal.replace( new Term( ",", [new Term( ",", [ new Term( "call", [goal] ), new Term( "!", [] ) ] ), new Term( "fail", [] ) ] ) ), point.substitution, point ),
					new State( point.goal.replace( null ), point.substitution, point )
				] );
			}
		},
		
		// ->/2 (implication)
		"->/2": function( thread, point, atom ) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]),
				new Term(",", [new Term("!"), then])
			]));
			thread.prepend( [new State( goal, point.substitution, point )] );
		},

		// *->/2 (soft-cut)
		"*->/2": function(thread, point, atom) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]), then]));
			thread.prepend([new State(goal, point.substitution, point)]);
		},
		
		// fail/0
		"fail/0": function( _1, _2, _3 ) {},
		
		// false/0
		"false/0": function( _1, _2, _3 ) {},
		
		// true/0
		"true/0": function( thread, point, _ ) {
			thread.success( point );
		},
		
		// call/1..8
		"call/1": callN(1),
		"call/2": callN(2),
		"call/3": callN(3),
		"call/4": callN(4),
		"call/5": callN(5),
		"call/6": callN(6),
		"call/7": callN(7),
		"call/8": callN(8),
		
		// once/1
		"once/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			thread.prepend( [new State( point.goal.replace( new Term( ",", [new Term( "call", [goal] ), new Term( "!", [] )] ) ), point.substitution, point )] );
		},
		
		// forall/2
		"forall/2": function( thread, point, atom ) {
			var generate = atom.args[0], test = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "\\+", [new Term( ",", [new Term( "call", [generate] ), new Term( "\\+", [new Term( "call", [test] )] )] )] ) ), point.substitution, point )] );
		},
		
		// repeat/0
		"repeat/0": function( thread, point, _ ) {
			thread.prepend( [new State( point.goal.replace( null ), point.substitution, point ), point] );
		},

		// EXCEPTIONS
		
		// throw/1
		"throw/1": function( thread, point, atom ) {
			var error = atom.args[0];
			if(pl.type.is_variable(error)) {
				thread.throw_error(pl.error.instantiation(thread.level.indicator));
			} else {
				for(var i = 0; i < thread.points.length; i++) {
					var state = thread.points[i];
					if(state.setup_call_cleanup_catch) {
						thread.points = [new State(
							new Term(",", [
								new Term("catch", [
									state.setup_call_cleanup_catch,
									new Var("_"),
									new Term("throw", [error])
								]),
								new Term("throw", [error])
							]),
							point.substitution,
							point
						)];
						return;
					}
					
				}
				thread.throw_error(error);
			}
		},
		
		// catch/3
		"catch/3": function(thread, point, atom) {
			var goal = atom.args[0], catcher = atom.args[1], recover = atom.args[2];
			var nthread;
			if(!point.catch) {
				nthread = new Thread(thread.session);
				nthread.debugger = thread.debugger;
				nthread.format_success = function(state) { return state.substitution; };
				nthread.format_error = function(state) { return state.goal; };
				nthread.add_goal(goal, true, point);
				point.catch = nthread;
			} else {
				nthread = point.catch;
			}
			var callback = function(answer) {
				if(pl.type.is_error(answer)) {
					var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
					var state = new State();
					var mgu = pl.unify(answer.args[0], catcher, occurs_check);
					if(mgu !== null) {
						state.substitution = point.substitution.apply(mgu);
						state.goal = point.goal.replace(recover).apply(mgu);
						state.parent = point;
						thread.prepend([state]);
					} else {
						thread.throw_error(answer.args[0]);
					}
				} else if(answer !== false && answer !== null) {
					var state = answer === null ? [] : new State(
						point.goal.apply(answer).replace(null),
						point.substitution.apply(answer),
						point
					);
					thread.prepend([state, point]);
				} else if(answer === null) {
					thread.prepend([point]);
					if(thread.has_limit)
						thread.current_limit = 0;
				}
				thread.again(answer !== null);
			};
			nthread.answer(callback);
			return true;
		},

		// call_cleanup/2
		"call_cleanup/2": function(thread, point, atom) {
			var call = atom.args[0], cleanup = atom.args[1];
			if(pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				var nthread, callback;
				if(point.hasOwnProperty("setup_call_cleanup_thread")) {
					nthread = point.setup_call_cleanup_thread;
					callback = point.setup_call_cleanup_callback;
				} else {
					var goal = new Term("call", [call]);
					nthread = new Thread(thread.session);
					nthread.add_goal(goal, true, point);
					callback = function(answer) {
						if(answer === null) {
							var state = new State(
								point.goal,
								point.substitution,
								point
							);
							state.setup_call_cleanup_thread = nthread;
							state.setup_call_cleanup_callback = callback;
							thread.prepend([state]);
						} else if(answer === false) {
							var cleanup_and_fail = new Term(",", [
								new Term("call", [cleanup]),
								new Term("fail")
							]);
							var state = new State(
								point.goal.replace(cleanup_and_fail),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else if(pl.type.is_error(answer)) {
							var cleanup_and_throw = new Term(",", [
								new Term("call", [cleanup]),
								answer
							]);
							var state = new State(
								point.goal.replace(cleanup_and_throw),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else {
							if(nthread.points.length === 0) {
								var state = new State(
									point.goal.replace(
										new Term("call", [cleanup])
									).apply(answer),
									point.substitution.apply(answer),
									point
								);
								thread.prepend([state]);
							} else {
								var state1 = new State(
									point.goal.apply(answer).replace(null),
									point.substitution.apply(answer),
									point
								);
								var state2 = new State(
									point.goal,
									point.substitution,
									point
								);
								state2.setup_call_cleanup_thread = nthread;
								state2.setup_call_cleanup_callback = callback;
								state2.setup_call_cleanup_goal = cleanup.apply(answer);
								state2.setup_call_cleanup_catch = cleanup;
								thread.prepend([state1, state2]);
							}
						}
						thread.again();
					}
				}
				nthread.answer(callback);
				return true;
			}
		},

		// setup_call_cleanup/3
		"setup_call_cleanup/3": function(thread, point, atom) {
			var setup = atom.args[0], call = atom.args[1], cleanup = atom.args[2];
			if(pl.type.is_variable(setup) || pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(setup)) {
				thread.throw_error(pl.error.type("callable", setup, atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term(",", [
						new Term("once", [setup]),
						new Term("call_cleanup", [call, cleanup])
					])),
					point.substitution,
					point
				)]);
			}
		},
		
		// UNIFICATION
		
		// =/2 (unification)
		"=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// unify_with_occurs_check/2
		"unify_with_occurs_check/2": function( thread, point, atom ) {
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], true );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// \=/2
		"\\=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu === null ) {
				thread.success( point );
			}
		},
		
		// subsumes_term/2
		/*
		subsumes_term(General, Specific) :-
			\+ \+ (
			term_variables(Specific, Vars1),
			unify_with_occurs_check(General, Specific),
			term_variables(Vars1, Vars2),
			Vars1 == Vars2
		).
		*/
		"subsumes_term/2": function( thread, point, atom ) {
			var general = atom.args[0], specific = atom.args[1];
			var vars1 = thread.next_free_variable();
			var vars2 = thread.next_free_variable();
			thread.prepend([new State(
				point.goal.replace(new Term("\\+", [
					new Term("\\+", [
						new Term(",", [
							new Term("term_variables", [specific, vars1]),
							new Term(",", [
								new Term("unify_with_occurs_check", [general, specific]),
								new Term(",", [
									new Term("term_variables", [vars1, vars2]),
									new Term("==", [vars1, vars2])
								])
							])
						])
					])
				])),
				point.substitution,
				point
			)]);
		},
		
		// ALL SOLUTIONS

		// findall/3
		"findall/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			var tail = new Term("[]", []);
			thread.prepend([new State(
				point.goal.replace(new Term("findall", [template, goal, instances, tail])),
				point.substitution,
				point
			)]);
		},

		// findall/4
		"findall/4": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2], tail = atom.args[3];
			var proper_goal = goal;
			if(pl.type.is_term(goal) && goal.indicator === ":/2")
				proper_goal = goal.args[1];
			if(pl.type.is_variable(proper_goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(proper_goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error(pl.error.type("list", instances, atom.indicator));
			} else if(!pl.type.is_variable(tail) && !pl.type.is_list(tail)) {
				thread.throw_error(pl.error.type("list", tail, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$findall", [template, goal, instances, tail])),
					point.substitution,
					point
				)]);
			}
		},
		
		// bagof/3
		"bagof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$bagof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},

		// setof/3
		"setof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$setof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},
		
		// TERM CREATION AND DECOMPOSITION
		
		// functor/3
		"functor/3": function( thread, point, atom ) {
			var subs;
			var term = atom.args[0], name = atom.args[1], arity = atom.args[2];
			if( pl.type.is_variable( term ) && (pl.type.is_variable( name ) || pl.type.is_variable( arity )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( arity ) && !pl.type.is_integer( arity ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[2], atom.indicator ) );
			} else if( !pl.type.is_variable( name ) && !pl.type.is_atomic( name ) ) {
				thread.throw_error( pl.error.type( "atomic", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && !pl.type.is_atom( name ) && pl.type.is_integer( arity ) && arity.value > 0 ) {
				thread.throw_error( pl.error.type( "atom", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && pl.type.is_integer( arity ) && arity.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[2], atom.indicator ) );
			} else if( pl.type.is_variable( term ) ) {
				if( atom.args[2].value >= 0 ) {
					var args = [];
					for( var i = 0; i < arity.value; i++ )
						args.push( thread.next_free_variable() );
					var functor = pl.type.is_number( name ) ? name : new Term( name.id, args );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [term, functor] ) ), point.substitution, point )] );
				}
			} else {
				var id = pl.type.is_number( term ) ? term : new Term( term.id, [] );
				var length = pl.type.is_number( term ) ? new Num( 0, false ) : new Num( term.args.length, false );
				var goal = new Term( ",", [new Term( "=", [id, name] ), new Term( "=", [length, arity] )] );
				thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
			}
		},
		
		// arg/3
		"arg/3": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) || pl.type.is_variable( atom.args[1] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[0], atom.indicator ) );
			} else if( atom.args[0].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_compound( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "compound", atom.args[1], atom.indicator ) );
			} else {
				var n = atom.args[0].value;
				if( n > 0 && n <= atom.args[1].args.length ) {
					var goal = new Term( "=", [atom.args[1].args[n-1], atom.args[2]] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				}
			}
		},
		
		// =../2 (univ)
		"=../2": function( thread, point, atom ) {
			var list;
			if( pl.type.is_variable( atom.args[0] ) && (pl.type.is_variable( atom.args[1] )
			|| pl.type.is_non_empty_list( atom.args[1] ) && pl.type.is_variable( atom.args[1].args[0] )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_fully_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "list", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( atom.args[0] ) && pl.type.is_empty_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.domain( "non_empty_list", atom.args[1], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[0] ) ) {
				if( pl.type.is_term( atom.args[0] ) && atom.args[0].args.length > 0 ) {
					list = new Term( "[]" );
					for( var i = atom.args[0].args.length - 1; i >= 0; i-- ) {
						list = new Term( ".", [atom.args[0].args[i], list] );
					}
					list = new Term( ".", [new Term( atom.args[0].id ), list] );
				} else {
					list = new Term( ".", [atom.args[0], new Term( "[]" )] );
				}
				thread.prepend( [new State( point.goal.replace( new Term( "=", [list, atom.args[1]] ) ), point.substitution, point )] );
			} else if( !pl.type.is_variable( atom.args[1] ) ) {
				var args = [];
				list = atom.args[1].args[1];
				while( list.indicator === "./2" ) {
					args.push( list.args[0] );
					list = list.args[1];
				}
				if( pl.type.is_variable( atom.args[0] ) && pl.type.is_variable( list ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( args.length === 0 && pl.type.is_compound( atom.args[1].args[0] ) ) {
					thread.throw_error( pl.error.type( "atomic", atom.args[1].args[0], atom.indicator ) );
				} else if( args.length > 0 && (pl.type.is_compound( atom.args[1].args[0] ) || pl.type.is_number( atom.args[1].args[0] )) ) {
					thread.throw_error( pl.error.type( "atom", atom.args[1].args[0], atom.indicator ) );
				} else {
					if( args.length === 0 ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[1].args[0], atom.args[0]], point ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( atom.args[1].args[0].id, args ), atom.args[0]] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// copy_term/2
		"copy_term/2": function(thread, point, atom) {
			var original_term = atom.args[0], renamed_term = atom.args[1];
			thread.session.renamed_variables = {};
			var new_term = original_term.rename(thread);
			thread.session.renamed_variables = {};
			thread.prepend([
				new State(
					point.goal.replace(new Term("=", [renamed_term, new_term])),
					point.substitution,
					point)
				]
			);
		},
		
		// term_variables/2
		"term_variables/2": [
			new pl.type.Rule(new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars")]), new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars"),new pl.type.Term("[]", [])]))
		],

		// term_variables/3
		"term_variables/3": function(thread, point, atom) {
			var term = atom.args[0], vars = atom.args[1], tail = atom.args[2];
			if( !pl.type.is_fully_list( vars ) ) {
				thread.throw_error( pl.error.type( "list", vars, atom.indicator ) );
			} else {
				var list = arrayToList(map(nub(term.variables()), function(v) {
					return new Var(v);
				}), tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [vars, list])),
					point.substitution,
					point
				)]);
			}
		},

		// numbervars/3
		"numbervars/3": function(thread, point, atom) {
			var term = atom.args[0], start = atom.args[1], end = atom.args[2];
			if(pl.type.is_variable(start)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_integer(start)) {
				thread.throw_error(pl.error.type("integer", start, atom.indicator));
			} else if(!pl.type.is_variable(end) && !pl.type.is_integer(end)) {
				thread.throw_error(pl.error.type("integer", end, atom.indicator));
			} else {
				var variables = nub(term.variables());
				var value = start.value;
				var unif_body = new Term("true");
				for(var i = 0; i < variables.length; i++) {
					unif_body = new Term(",", [
						new Term("=", [
							new Var(variables[i]),
							new Term("$VAR", [new Num(value, false)])]),
							unif_body]);
					value++;
				}
				var unif_end = new Term("=", [end, new Num(value, false)]);
				if(pl.type.is_variable(end) || end.value === value) {
					thread.prepend([new State(
						point.goal.replace(new Term(",", [unif_body, unif_end])),
						point.substitution,
						point
					)]);
				}
			}
		},
		
		// CLAUSE RETRIEVAL AND INFORMATION
		
		// clause/2
		"clause/2": function(thread, point, atom) {
			var head = atom.args[0], body = atom.args[1];
			var module_id = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			var get_module = thread.session.modules[module_id];
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(body) && !pl.type.is_callable(body)) {
				thread.throw_error(pl.error.type("callable", body, atom.indicator));
			} else if(head.indicator === ",/2" || thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
			} else if(pl.type.is_module(get_module) && get_module.rules[head.indicator]) {
				if(get_module.is_public_predicate(head.indicator)) {
					var states = [];
					if(typeof get_module.rules[head.indicator] === "function") {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
						return;
					}
					for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
						var rule = get_module.rules[head.indicator][i];
						thread.session.renamed_variables = {};
						rule = rule.rename(thread);
						if(rule.body === null)
							rule.body = new Term("true");
						var goal = new Term(",", [
							new Term("=", [rule.head, head]),
							new Term("=", [rule.body, body])
						]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				} else {
					thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// current_predicate/1
		"current_predicate/1": function(thread, point, atom) {
			var indicator = atom.args[0];
			var module_id;
			if(pl.type.is_term(indicator) && indicator.indicator === ":/2") {
				if(!pl.type.is_atom(indicator.args[0])) {
					thread.throw_error(pl.error.type("module", indicator.args[0], atom.indicator));
					return;
				}
				module_id = indicator.args[0].id;
				indicator = indicator.args[1];
			} else {
				module_id = "user";
			}
			if(!pl.type.is_variable(indicator) && (!pl.type.is_compound(indicator) || indicator.indicator !== "//2")) {
				thread.throw_error(pl.error.type( "predicate_indicator", indicator, atom.indicator));
			} else if(!pl.type.is_variable( indicator ) && !pl.type.is_variable(indicator.args[0]) && !pl.type.is_atom(indicator.args[0])) {
				thread.throw_error(pl.error.type( "atom", indicator.args[0], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && !pl.type.is_variable(indicator.args[1]) && !pl.type.is_integer(indicator.args[1])) {
				thread.throw_error(pl.error.type("integer", indicator.args[1], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && pl.type.is_integer(indicator.args[1]) && indicator.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", indicator.args[1], atom.indicator));
			} else {
				var states = [];
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					for(var prop in get_module.rules) {
						if(!get_module.rules.hasOwnProperty(prop))
							continue;
						var predicate = str_indicator(prop);
						var goal = new Term("=", [predicate, indicator]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				}
			}
		},

		// current_module/1
		"current_module/1": function(thread, point, atom) {
			var module_id = atom.args[0];
			if(!pl.type.is_variable(module_id) && !pl.type.is_atom(module_id)) {
				thread.throw_error(pl.error.type("atom", module_id, atom.indicator));
			} else {
				if(pl.type.is_variable(module_id)) {
					var states = [];
					for(var prop in thread.session.modules) {
						if(!thread.session.modules.hasOwnProperty(prop))
							continue;
						states.push(new State(
							point.goal.replace(new Term("=", [module_id, new Term(prop)])),
							point.substitution,
							point
						));
					}
					thread.prepend(states);
				} else {
					if(thread.session.modules.hasOwnProperty(module_id.id))
						thread.success(point);
				}
			}
		},

		// predicate_property/2
		"predicate_property/2": function(thread, point, atom) {
			var head = atom.args[0], property = atom.args[1];
			var module_id;
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			if(!pl.type.is_variable(head) && !pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_predicate_property(property)) {
				thread.throw_error(pl.error.domain("predicate_property", property, atom.indicator));
			} else {
				var get_module = module_id ? thread.session.modules[module_id] : thread.session.modules.user;
				var points = [];
				// all predicates
				if(pl.type.is_variable(head)) {
					// built-in predicates (built_in + static + native_code + meta_predicate?)
					if(!module_id) {
						for(var prop in pl.builtin.rules) {
							if(!pl.builtin.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
							if(pl.builtin.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									pl.builtin.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
					// user-defined predicates
					if(pl.type.is_module(get_module)) {
						for(var prop in get_module.rules) {
							if(!get_module.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [];
							if(thread.is_public_predicate(prop, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(get_module.rules[prop] instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(prop, module_id))
								current_properties.push(new Term("multifile"));
							if(get_module.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									get_module.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
				// one predicate
				} else {
					var builtin = !module_id && pl.type.is_builtin(head);
					var predicate = builtin ? pl.builtin.rules[head.indicator] : get_module.rules[head.indicator];
					get_module = builtin ? pl.builtin : get_module;
					if(predicate) {
						var current_properties;
						if(builtin) {
							current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
						} else {
							current_properties = [];
							if(thread.is_public_predicate(head.indicator, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(predicate instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(head.indicator, module_id))
								current_properties.push(new Term("multifile"));
						}
						if(get_module.meta_predicates.hasOwnProperty(head.indicator))
							current_properties.push(new Term("meta_predicate", [
								get_module.meta_predicates[head.indicator]
							]));
						var args = [];
						for(var i = 0; i < head.args.length; i++)
							args.push(thread.next_free_variable());
						var unif_head = new Term(head.id, args);
						// one predicate, one property / all properties
						for(var i = 0; i < current_properties.length; i++) {
							if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
								points.push(new State(
									point.goal.replace(new Term(",", [
										new Term("=", [head, unif_head]),
										new Term("=", [property, current_properties[i]])
									])),
									point.substitution,
									point
								));
							}
						}
					}
				}
				thread.prepend(points);
			}
		},

		// listing/0
		"listing/0": function( thread, point, atom ) {
			var context_module = atom.context_module ? atom.context_module : "user";
			var rules = {};
			if(pl.type.is_module(thread.session.modules[context_module])) {
				rules = thread.session.modules[context_module].rules;
			}
			var str = "";
			for(var indicator in rules) {
				if(!rules.hasOwnProperty(indicator)) continue;
				var predicate = rules[indicator];
				str += "% " + indicator + "\n";
				if(predicate instanceof Array) {
					for(var i = 0; i < predicate.length; i++)
						str += predicate[i].toString( {session: thread.session} ) + "\n";
				} else {
					str += "/*\n" + predicate.toString() + "\n*/";
				}
				str += "\n";
			}
			thread.prepend( [new State(
				point.goal.replace(new Term("write", [new Term(str, [])])),
				point.substitution,
				point
			)] );
		},

		// listing/1
		"listing/1": function( thread, point, atom ) {
			var indicator = atom.args[0];
			var context_module = "user";
			if(indicator.indicator === ":/2") {
				context_module = indicator.args[0].id;
				indicator = indicator.args[1];
			}
			if(pl.type.is_variable(indicator)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_predicate_indicator(indicator)) {
				thread.throw_error( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
			} else {
				var rules = {};
				if(pl.type.is_module(thread.session.modules[context_module])) {
					rules = thread.session.modules[context_module].rules;
				}
				var str = "";
				var str_indicator = indicator.args[0].id + "/" + indicator.args[1].value;
				if(rules.hasOwnProperty(str_indicator)) {
					var predicate = rules[str_indicator];
					if(predicate instanceof Array) {
						for(var i = 0; i < predicate.length; i++)
							str += predicate[i].toString( {session: thread.session} ) + "\n";
					} else {
						str += "/*\n" + predicate.toString() + "\n*/";
					}
					str += "\n";
				}
				thread.prepend( [new State(
					point.goal.replace(new Term("write", [new Term(str, [])])),
					point.substitution,
					point
				)] );
			}
		},

		// LIST OPERATIONS

		// sort/2
		"sort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					arr.push( pointer.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					var sorted_arr = arr.sort( pl.compare );
					for( var i = sorted_arr.length-1; i > 0; i-- ) {
						if( sorted_arr[i].equals(sorted_arr[i-1]) )
							sorted_arr.splice(i,1);
					}
					var sorted_list = new Term( "[]" );
					for( var i = sorted_arr.length-1; i >= 0; i-- ) {
						sorted_list = new Term( ".", [sorted_arr[i], sorted_list] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keysort/2
		"keysort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var elem;
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					elem = pointer.args[0];
					if( pl.type.is_variable( elem ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_term( elem ) || elem.indicator !== "-/2" ) {
						thread.throw_error( pl.error.type( "pair", elem, atom.indicator ) );
						return;
					}
					elem.args[0].pair = elem.args[1];
					arr.push( elem.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error( pl.error.type( "pair", head, atom.indicator ) );
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
							return;
						}
					}
					var sorted_arr = arr.sort( pl.compare );
					var sorted_list = new pl.type.Term( "[]" );
					for( var i = sorted_arr.length - 1; i >= 0; i-- ) {
						sorted_list = new pl.type.Term( ".", [new pl.type.Term( "-", [sorted_arr[i], sorted_arr[i].pair] ), sorted_list] );
						delete sorted_arr[i].pair;
					}
					thread.prepend( [new pl.type.State( point.goal.replace( new pl.type.Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keygroup
		"keygroup/2": function(thread, point, atom) {
			var list = atom.args[0], expected = atom.args[1];
			if(pl.type.is_variable(list)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(expected) && !pl.type.is_fully_list(expected)) {
				thread.throw_error(pl.error.type("list", expected, atom.indicator));
			} else {
				var keys = [];
				var values = [];
				var pointer = list
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var elem = pointer.args[0];
					if(pl.type.is_variable(elem)) {
						thread.throw_error(pl.error.instantiation(atom.indicator));
						return;
					} else if(!pl.type.is_term(elem) || elem.indicator !== "-/2") {
						thread.throw_error(pl.error.type("pair", elem, atom.indicator));
						return;
					}
					var key = elem.args[0], value = elem.args[1];
					var index = -1;
					for(var i = 0; i < keys.length; i++) {
						if(pl.compare(key, keys[i]) === 0) {
							index = i;
							break;
						}
					}
					if(index === -1) {
						index = keys.length;
						keys.push(key);
						values.push([]);
					}
					values[index].push(value);
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_empty_list(pointer)) {
					thread.throw_error(pl.error.type("list", list, atom.indicator));
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error(pl.error.type("pair", head, atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error(pl.error.type("list", expected, atom.indicator));
							return;
						}
					}
					group = new Term("[]", []);
					for(var i = keys.length-1; i >= 0; i--)
						group = new Term(".", [new Term("-", [keys[i], arrayToList(values[i])]), group]);
					thread.prepend([
						new State(
							point.goal.replace(new pl.type.Term("=", [expected, group])),
							point.substitution,
							point
						)
					]);
				}
			}
		},
		
		// CLAUSE CREATION AND DESTRUCTION
		
		// asserta/1
		"asserta/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator] = [new Rule(head, body, true)].concat(get_module.rules[head.indicator]);
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// assertz/1
		"assertz/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator].push(new Rule(head, body, true));
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// retract/1
		"retract/1": function(thread, point, atom) {
			var clause = atom.args[0];
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, module_atom, module_id;
				if(clause.indicator === ":/2") {
					module_atom = clause.args[0];
					clause = clause.args[1];
					if(!pl.type.is_atom(module_atom)) {
						thread.throw_error(pl.error.type("module", module_atom, atom.indicator));
						return;
					}
				} else {
					module_atom = new Term("user");
				}
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = clause.args[1];
				} else {
					head = clause;
					body = new Term("true");
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
					return;
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
					return;
				}
				module_id = module_atom.id;
				var get_module = thread.session.modules[module_id];
				if(!pl.type.is_module(get_module))
					return;
				if(!point.retract) {
					if(thread.is_public_predicate(head.indicator, module_id)
					&& head.indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
						if(get_module.rules[head.indicator] !== undefined) {
							var states = [];
							if(typeof get_module.rules[head.indicator] === "function") {
								thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
								return;
							}
							for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
								thread.session.renamed_variables = {};
								var orule = get_module.rules[head.indicator][i];
								var rule = orule.rename(thread);
								if(rule.body === null)
									rule.body = new Term("true", []);
								var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
								var mgu = pl.unify(new Term(",", [head, body]), new Term(",", [rule.head, rule.body]), occurs_check);
								if(mgu !== null) {
									var state = new State(
										point.goal.replace(new Term(",", [
											new Term(":", [
												module_atom,
												new Term("retract", [new Term(":-", [head, body])]),
											]),
											new Term(",", [
												new Term("=", [head, rule.head]),
												new Term("=", [body, rule.body])
											])
										])), point.substitution, point);
									state.retract = orule;
									states.push(state);
								}
							}
							thread.prepend(states);
						}
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
					}
				} else {
					retract(thread, point, head.indicator, point.retract, get_module);
				}
			}
		},
		
		// retractall/1
		"retractall/1": function(thread, point, atom) {
			var head = atom.args[0];
			var context_module = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				context_module = head.args[0].id;
				head = head.args[1];
			}
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!thread.is_public_predicate(head.indicator, context_module)
			|| head.indicator === ",/2"
			|| thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
			} else {
				thread.prepend([
					new State(point.goal.replace(new Term(",", [
						new Term(":", [
							new Term(context_module),
							new Term("retract", [new pl.type.Term(":-", [head, new Var("_")])])
						]),
						new Term("fail", [])
					])), point.substitution, point),
					new State(point.goal.replace(null), point.substitution, point)
				]);
			}
		},

		// abolish/1
		"abolish/1": function(thread, point, atom) {
			var predicate = atom.args[0];
			var module_id;
			if(pl.type.is_term(predicate) && predicate.indicator === ":/2") {
				if(!pl.type.is_atom(predicate.args[0])) {
					thread.throw_error(pl.error.type("module", predicate.args[0], atom.indicator));
					return;
				}
				module_id = predicate.args[0].id;
				predicate = predicate.args[1];
			} else {
				module_id = "user";
			}
			if(pl.type.is_variable(predicate) || pl.type.is_term(predicate) && predicate.indicator === "//2"
			&& (pl.type.is_variable(predicate.args[0]) || pl.type.is_variable(predicate.args[1]))) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(predicate) || predicate.indicator !== "//2") {
				thread.throw_error(pl.error.type("predicate_indicator", predicate, atom.indicator));
			} else if(!pl.type.is_atom(predicate.args[0])) {
				thread.throw_error(pl.error.type("atom", predicate.args[0], atom.indicator));
			} else if(!pl.type.is_integer(predicate.args[1])) {
				thread.throw_error(pl.error.type("integer", predicate.args[1], atom.indicator));
			} else if(predicate.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", predicate.args[1], atom.indicator));
			} else if(pl.type.is_number(thread.get_flag("max_arity")) && predicate.args[1].value > thread.get_flag("max_arity").value) {
				thread.throw_error(pl.error.representation("max_arity", atom.indicator));
			} else {
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					var indicator = predicate.args[0].id + "/" + predicate.args[1].value;
					if(thread.is_public_predicate(indicator, module_id)
					&& indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(indicator)) {
						delete get_module.rules[indicator];
						delete get_module.indexed_clauses[indicator];
						delete get_module.non_indexable_clauses[indicator];
						delete get_module.public_predicates[indicator];
						delete get_module.multifile_predicates[indicator];
						thread.success(point);
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", atom.args[0], atom.indicator));
					}
				} else {
					thread.success(point);
				}
			}
		},
		
		// ATOM PROCESSING
		
		// atom_length/2
		"atom_length/2": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "atom", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[1] ) && !pl.type.is_integer( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_integer( atom.args[1] ) && atom.args[1].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[1], atom.indicator ) );
			} else {
				var length = new Num( stringLength(atom.args[0].id), false );
				thread.prepend( [new State( point.goal.replace( new Term( "=", [length, atom.args[1]] ) ), point.substitution, point )] );
			}
		},
		
		// atom_concat/3
		"atom_concat/3": function( thread, point, atom ) {
			var str, goal, start = atom.args[0], end = atom.args[1], whole = atom.args[2];
			if( pl.type.is_variable( whole ) && (pl.type.is_variable( start ) || pl.type.is_variable( end )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( start ) && !pl.type.is_atom( start ) ) {
				thread.throw_error( pl.error.type( "atom", start, atom.indicator ) );
			} else if( !pl.type.is_variable( end ) && !pl.type.is_atom( end ) ) {
				thread.throw_error( pl.error.type( "atom", end, atom.indicator ) );
			} else if( !pl.type.is_variable( whole ) && !pl.type.is_atom( whole ) ) {
				thread.throw_error( pl.error.type( "atom", whole, atom.indicator ) );
			} else {
				var v1 = pl.type.is_variable( start );
				var v2 = pl.type.is_variable( end );
				//var v3 = pl.type.is_variable( whole );
				if( !v1 && !v2 ) {
					goal = new Term( "=", [whole, new Term( start.id + end.id )] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				} else if( v1 && !v2 ) {
					str = whole.id.substr( 0, whole.id.length - end.id.length );
					if( str + end.id === whole.id ) {
						goal = new Term( "=", [start, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else if( v2 && !v1 ) {
					str = whole.id.substr( start.id.length );
					if( start.id + str === whole.id ) {
						goal = new Term( "=", [end, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else {
					var states = [];
					for( var i = 0; i <= whole.id.length; i++ ) {
						var atom1 = new Term( whole.id.substr( 0, i ) );
						var atom2 = new Term( whole.id.substr( i ) );
						goal = new Term( ",", [new Term( "=", [atom1, start] ), new Term( "=", [atom2, end] )] );
						states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
					}
					thread.prepend( states );
				}
			}
		},
		
		// sub_atom/5
		"sub_atom/5": function( thread, point, atom ) {
			var i, atom1 = atom.args[0], before = atom.args[1], length = atom.args[2], after = atom.args[3], subatom = atom.args[4];
			if( pl.type.is_variable( atom1 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else if( !pl.type.is_variable( before ) && !pl.type.is_integer( before ) ) {
				thread.throw_error( pl.error.type( "integer", before, atom.indicator ) );
			} else if( !pl.type.is_variable( length ) && !pl.type.is_integer( length ) ) {
				thread.throw_error( pl.error.type( "integer", length, atom.indicator ) );
			} else if( !pl.type.is_variable( after ) && !pl.type.is_integer( after ) ) {
				thread.throw_error( pl.error.type( "integer", after, atom.indicator ) );
			} else if( pl.type.is_integer( before ) && before.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", before, atom.indicator ) );
			} else if( pl.type.is_integer( length ) && length.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", length, atom.indicator ) );
			} else if( pl.type.is_integer( after ) && after.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", after, atom.indicator ) );
			} else if( !pl.type.is_variable( subatom ) && !pl.type.is_atom( subatom ) ) {
				thread.throw_error( pl.error.type( "atom", subatom, atom.indicator ) );
			} else {
				var bs = [], ls = [], as = [];
				if( pl.type.is_variable( before ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						bs.push( i );
					}
				} else {
					bs.push( before.value );
				}
				if( pl.type.is_variable( length ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						ls.push( i );
					}
				} else {
					ls.push( length.value );
				}
				if( pl.type.is_variable( after ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						as.push( i );
					}
				} else {
					as.push( after.value );
				}
				var states = [];
				for( var _i in bs ) {
					if(!bs.hasOwnProperty(_i)) continue;
					i = bs[_i];
					for( var _j in ls ) {
						if(!ls.hasOwnProperty(_j)) continue;
						var j = ls[_j];
						var k = atom1.id.length - i - j;
						if( indexOf( as, k ) !== -1 ) {
						if( i+j+k === atom1.id.length ) {
								var str = atom1.id.substr( i, j );
								if( atom1.id === atom1.id.substr( 0, i ) + str + atom1.id.substr( i+j, k ) ) {
									var pl1 = new Term( "=", [new Term( str ), subatom] );
									var pl2 = new Term( "=", [before, new Num( i )] );
									var pl3 = new Term( "=", [length, new Num( j )] );
									var pl4 = new Term( "=", [after, new Num( k )] );
									var goal = new Term( ",", [ new Term( ",", [ new Term( ",", [pl2, pl3] ), pl4] ), pl1] );
									states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
								}
							}
						}
					}
				}
				thread.prepend( states );
			}
		},
		
		// atom_chars/2
		"atom_chars/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Term( atom1.id.charAt( i ) ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// atom_codes/2
		"atom_codes/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character_code(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("integer", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Num( codePointAt(atom1.id,i), false ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// char_code/2
		"char_code/2": function( thread, point, atom ) {
			var char = atom.args[0], code = atom.args[1];
			if( pl.type.is_variable( char ) && pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else {
				if( pl.type.is_variable( code ) ) {
					var code1 = new Num( codePointAt(char.id,0 ), false );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [code1, code] ) ), point.substitution, point )] );
				} else {
					var char1 = new Term( fromCodePoint( code.value ) );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [char1, char] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_chars/2
		"number_chars/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Term( str.charAt( i ) ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_codes/2
		"number_codes/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Num( codePointAt(str,i), false ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// upcase_atom/2
		"upcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], upcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( upcase ) && !pl.type.is_atom( upcase ) ) {
				thread.throw_error( pl.error.type( "atom", upcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [upcase, new Term( original.id.toUpperCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// downcase_atom/2
		"downcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], downcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( downcase ) && !pl.type.is_atom( downcase ) ) {
				thread.throw_error( pl.error.type( "atom", downcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [downcase, new Term( original.id.toLowerCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// atomic_concat/3
		"atomic_concat/3": function( thread, point, atom ) {
			var atomic1 = atom.args[0], atomic2 = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( atomic1 ) || pl.type.is_variable( atomic2 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic1 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic1, atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic2 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic2, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				if( pl.type.is_atom( atomic1 ) ) {
					id += atomic1.id;
				} else {
					id += "" + atomic1.value;
				}
				if( pl.type.is_atom( atomic2 ) ) {
					id += atomic2.id;
				} else {
					id += "" + atomic2.value;
				}
				var atom = new Term(id, []);
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom, concat] ) ), point.substitution, point )] );
			}
		},

		// atomic_list_concat/2
		"atomic_list_concat/2": function( thread, point, atom ) {
			var list = atom.args[0], concat = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "atomic_list_concat", [list, new Term( "", [] ), concat] ) ), point.substitution, point )] );
		},
		
		// atomic_list_concat/3
		"atomic_list_concat/3": function( thread, point, atom ) {
			var list = atom.args[0], separator = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( separator ) || pl.type.is_variable( list ) && pl.type.is_variable( concat ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else if( !pl.type.is_atom( separator ) && !pl.type.is_number( separator ) ) {
				thread.throw_error( pl.error.type( "atomic", separator, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				var pointer = list;
				while( pl.type.is_term( pointer ) && pointer.indicator === "./2" ) {
					if( pl.type.is_variable( pointer.args[0] ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( pointer.args[0] ) && !pl.type.is_number( pointer.args[0] ) ) {
						thread.throw_error( pl.error.type( "atomic", pointer.args[0], atom.indicator ) );
						return;
					}
					if( id !== "" )
						id += separator.id;
					if( pl.type.is_atom( pointer.args[0] ) )
						id += pointer.args[0].id;
					else
						id += "" + pointer.args[0].value;
					pointer = pointer.args[1];
				}
				id = new Term( id, [] );
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_term( pointer ) || pointer.indicator !== "[]/0" ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					thread.prepend( [new State( point.goal.replace( new Term( "=", [id, concat] ) ), point.substitution, point )] );
				}
			}
		},
		
		// TERM COMPARISON
		
		"@=</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) <= 0 ) {
				thread.success( point );
			}
		},
		
		"==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) === 0 ) {
				thread.success( point );
			}
		},
		
		"\\==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) !== 0 ) {
				thread.success( point );
			}
		},
		
		"@</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) < 0 ) {
				thread.success( point );
			}
		},
		
		"@>/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) > 0 ) {
				thread.success( point );
			}
		},
		
		"@>=/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) >= 0 ) {
				thread.success( point );
			}
		},
		
		"compare/3": function( thread, point, atom ) {
			var order = atom.args[0], left = atom.args[1], right = atom.args[2];
			if( !pl.type.is_variable( order ) && !pl.type.is_atom( order ) ) {
				thread.throw_error( pl.error.type( "atom", order, atom.indicator ) );
			} else if( pl.type.is_atom( order ) && ["<", ">", "="].indexOf( order.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "order", order, atom.indicator ) );
			} else {
				var compare = pl.compare( left, right );
				compare = compare === 0 ? "=" : (compare === -1 ? "<" : ">");
				thread.prepend( [new State( point.goal.replace( new Term( "=", [order, new Term( compare, [] )] ) ), point.substitution, point )] );
			}
		},
		
		// EVALUATION
		
		// is/2
		"is/2": function( thread, point, atom ) {
			var op = atom.args[1].interpret( thread );
			if( !pl.type.is_number( op ) ) {
				thread.throw_error( op );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[0], op], atom.indicator ) ), point.substitution, point )] );
			}
		},
		
		// between/3
		"between/3": function( thread, point, atom ) {
			var lower = atom.args[0], upper = atom.args[1], bet = atom.args[2];
			if( pl.type.is_variable( lower ) || pl.type.is_variable( upper ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( lower ) ) {
				thread.throw_error( pl.error.type( "integer", lower, atom.indicator ) );
			} else if( !pl.type.is_integer( upper ) ) {
				thread.throw_error( pl.error.type( "integer", upper, atom.indicator ) );
			} else if( !pl.type.is_variable( bet ) && !pl.type.is_integer( bet ) ) {
				thread.throw_error( pl.error.type( "integer", bet, atom.indicator ) );
			} else {
				if( pl.type.is_variable( bet ) ) {
					if( lower.value <= upper.value ) {
						var states = [new State( point.goal.replace( new Term( "=", [bet, lower] ) ), point.substitution, point )];
						states.push( new State( point.goal.replace( new Term( "between", [new Num( lower.value+1, false ), upper, bet] ) ), point.substitution, point ) );
						thread.prepend( states );
					}
				} else if( lower.value <= bet.value && upper.value >= bet.value ) {
					thread.success( point );
				}
			}
		},
		
		// succ/2
		"succ/2": function( thread, point, atom ) {
			var n = atom.args[0], m = atom.args[1];
			if( pl.type.is_variable( n ) && pl.type.is_variable( m ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && !pl.type.is_integer( n ) ) {
				thread.throw_error( pl.error.type( "integer", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && !pl.type.is_integer( m ) ) {
				thread.throw_error( pl.error.type( "integer", m, atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && n.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && m.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", m, atom.indicator ) );
			} else {
				if( pl.type.is_variable( m ) || m.value > 0 ) {
					if( pl.type.is_variable( n ) ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [n, new Num( m.value-1, false )] ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [m, new Num( n.value+1, false )] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// =:=/2
		"=:=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp === 0 ) {
				thread.success( point );
			}
		},
		
		// =\=/2
		"=\\=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp !== 0 ) {
				thread.success( point );
			}
		},
		
		// </2
		"</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp < 0 ) {
				thread.success( point );
			}
		},
		
		// =</2
		"=</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp <= 0 ) {
				thread.success( point );
			}
		},
		
		// >/2
		">/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp > 0 ) {
				thread.success( point );
			}
		},
		
		// >=/2
		">=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp >= 0 ) {
				thread.success( point );
			}
		},
		
		// TYPE TEST
		
		// var/1
		"var/1": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atom/1
		"atom/1": function( thread, point, atom ) {
			if( pl.type.is_atom( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atomic/1
		"atomic/1": function( thread, point, atom ) {
			if( pl.type.is_atomic( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// compound/1
		"compound/1": function( thread, point, atom ) {
			if( pl.type.is_compound( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// integer/1
		"integer/1": function( thread, point, atom ) {
			if( pl.type.is_integer( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// float/1
		"float/1": function( thread, point, atom ) {
			if( pl.type.is_float( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// number/1
		"number/1": function( thread, point, atom ) {
			if( pl.type.is_number( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// nonvar/1
		"nonvar/1": function( thread, point, atom ) {
			if( !pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// ground/1
		"ground/1": function( thread, point, atom ) {
			if( atom.variables().length === 0 ) {
				thread.success( point );
			}
		},
		
		// acyclic_term/1
		"acyclic_term/1": function( thread, point, atom ) {
			var test = point.substitution.apply( point.substitution );
			var variables = atom.args[0].variables();
			for( var i = 0; i < variables.length; i++ )
				if( point.substitution.links[variables[i]] !== undefined && !point.substitution.links[variables[i]].equals( test.links[variables[i]] ) )
					return;
			thread.success( point );
		},
		
		// callable/1
		"callable/1": function( thread, point, atom ) {
			var callable = atom.args[0];
			if(pl.type.is_term(callable)) {
				thread.success( point );
			}
		},

		// is_list/1
		"is_list/1": function( thread, point, atom ) {
			var list = atom.args[0];
			while( pl.type.is_term( list ) && list.indicator === "./2" )
				list = list.args[1];
			if( pl.type.is_term( list ) && list.indicator === "[]/0" )
				thread.success( point );
		},



		// STREAM SELECTION AND CONTROL

		// current_input/1
		"current_input/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias(stream.id);
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_input()])),
					point.substitution,
					point)
				] );
			}
		},

		// current_output/1
		"current_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias( stream.id );
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_output()])),
					point.substitution,
					point)
				] );
			}
		},

		// set_input/1
		"set_input/1": function( thread, point, atom ) {
			var input = atom.args[0];
			var stream = pl.type.is_stream( input ) ? input : thread.get_stream_by_alias( input.id );
			if( pl.type.is_variable( input ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( input ) && !pl.type.is_atom( input ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", input, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(input.alias)
													&& !thread.get_stream_by_alias(input.id) ) {
				thread.throw_error( pl.error.existence( "stream", input, atom.indicator ) );
			} else if( stream.output === true ) {
				thread.throw_error( pl.error.permission( "input", "stream", input, atom.indicator ) );
			} else {
				thread.set_current_input( stream );
				thread.success( point );
			}
		},

		// set_output/1
		"set_output/1": function( thread, point, atom ) {
			var output = atom.args[0];
			var stream = pl.type.is_stream( output ) ? output : thread.get_stream_by_alias( output.id );
			if( pl.type.is_variable( output ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( output ) && !pl.type.is_atom( output ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", output, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(output.alias)
													&& !thread.get_stream_by_alias(output.id) ) {
				thread.throw_error( pl.error.existence( "stream", output, atom.indicator ) );
			} else if( stream.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", output, atom.indicator ) );
			} else {
				thread.set_current_output( stream );
				thread.success( point );
			}
		},

		// open/3
		"open/3": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2];
			thread.prepend( [new State(
				point.goal.replace(new Term("open", [dest, mode, stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// open/4
		"open/4": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2], options = atom.args[3];
			if( pl.type.is_variable( dest ) || pl.type.is_variable( mode ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( mode ) && !pl.type.is_atom( mode ) ) {
				thread.throw_error( pl.error.type( "atom", mode, atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.uninstantiation( stream, atom.indicator ) );
			} else if( !pl.type.is_atom( dest ) && !pl.type.is_streamable( dest ) ) {
				thread.throw_error( pl.error.domain( "source_sink", dest, atom.indicator ) );
			} else if( !pl.type.is_io_mode( mode ) ) {
				thread.throw_error( pl.error.domain( "io_mode", mode, atom.indicator ) );
			} else {
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_stream_option( property ) ) {
						thread.throw_error( pl.error.domain( "stream_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id;
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var alias = obj_options["alias"];
					if( alias && thread.get_stream_by_alias(alias) ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", new Term("alias", [new Term(alias, [])]), atom.indicator ) );
						return;
					}
					if( !obj_options["type"] )
						obj_options["type"] = "text";
					var file;
					if( pl.type.is_atom( dest ) )
						file = thread.file_system_open( dest.id, obj_options["type"], mode.id );
					else
						file = dest.stream( obj_options["type"], mode.id );
					if( file === false ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", dest, atom.indicator ) );
						return;
					} else if( file === null ) {
						thread.throw_error( pl.error.existence( "source_sink", dest, atom.indicator ) );
						return;
					}
					var newstream = new Stream(
						file, mode.id,
						obj_options["alias"],
						obj_options["type"],
						obj_options["reposition"] === "true",
						obj_options["eof_action"] );
					if( alias )
						thread.session.streams[alias] = newstream;
					else
						thread.session.streams[newstream.id] = newstream;
					thread.prepend( [new State(
						point.goal.replace( new Term( "=", [stream, newstream] ) ),
						point.substitution,
						point
					)] );
				}
			}
		},

		// close/1
		"close/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State(
				point.goal.replace(new Term("close", [stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// close/2
		"close/2": function( thread, point, atom ) {
			var stream = atom.args[0], options = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_close_option( property ) ) {
						thread.throw_error( pl.error.domain( "close_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					if(stream2 === thread.session.standard_input || stream2 === thread.session.standard_output || stream2 === thread.session.standard_error) {
						thread.success( point );
						return;
					} else if( stream2 === thread.session.current_input ) {
						thread.session.current_input = thread.session.standard_input;
					} else if( stream2 === thread.session.current_output ) {
						thread.session.current_output = thread.session.standard_output;
					}
					if( stream2.alias !== null && stream2.alias !== undefined )
						delete thread.session.streams[stream2.alias];
					else
						delete thread.session.streams[stream2.id];
					if( stream2.output )
						stream2.stream.flush();
					var closed = stream2.stream.close();
					stream2.stream = null;
					if( obj_options.force === true || closed === true ) {
						thread.success( point );
					}
				}
			}
		},

		// flush_output/0
		"flush_output/0": [
			new Rule(new Term("flush_output", []), new Term(",", [new Term("current_output", [new Var("S")]),new Term("flush_output", [new Var("S")])]))
		],

		// flush_output/1
		"flush_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else {
				stream2.stream.flush();
				thread.success( point );
			}
		},

		// stream_property/2
		"stream_property/2": function( thread, point, atom ) {
			var stream = atom.args[0], property = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) ) {
				thread.throw_error( pl.error.domain( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && (!pl.type.is_stream( stream2 ) || stream2.stream === null) ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( property ) && !pl.type.is_stream_property( property ) ) {
				thread.throw_error( pl.error.domain( "stream_property", property, atom.indicator ) );
			} else {
				var streams = [];
				var states = [];
				var propvar = pl.type.is_variable(property);
				if( !pl.type.is_variable( stream ) )
					streams.push( stream2 );
				else
					for( var key in thread.session.streams )
						streams.push( thread.session.streams[key] );
				for( var i = 0; i < streams.length; i++ ) {
					var properties = [];
					// file_name/1
					if( (propvar || property.indicator === "file_name/1") && streams[i].filename )
						properties.push( new Term( "file_name", [new Term(streams[i].file_name, [])] ) );
					// mode/1
					if(propvar || property.indicator === "mode/1")
						properties.push( new Term( "mode", [new Term(streams[i].mode, [])] ) );
					// input/0 or output/0
					if(propvar || property.indicator === "input/0" || property.indicator === "output/0")
						properties.push( new Term( streams[i].input ? "input" : "output", [] ) );
					// alias/1
					if( (propvar || property.indicator === "alias/1") && streams[i].alias )
						properties.push( new Term( "alias", [new Term(streams[i].alias, [])] ) );
					// position/1
					if(propvar || property.indicator === "position/1")
						properties.push( new Term( "position", [
							new Term("position", [
								new Num(streams[i].char_count, false),
								new Num(streams[i].line_count, false),
								new Num(streams[i].line_position, false)
							])
						] ) );
					// end_of_stream/1
					if(propvar || property.indicator === "end_of_stream/1")
						properties.push( new Term( "end_of_stream", [new Term(
							streams[i].position === "end_of_stream" || streams[i].stream.eof && streams[i].stream.eof(streams[i].position) ? "at" :
							streams[i].position === "past_end_of_stream" ? "past" :
							"not", [])] ) );
					// eof_action/1
					if(propvar || property.indicator === "eof_action/1")	
						properties.push( new Term( "eof_action", [new Term(streams[i].eof_action, [])] ) );
					// reposition/1
					if(propvar || property.indicator === "reposition/1")
						properties.push( new Term( "reposition", [new Term(streams[i].reposition ? "true" : "false", [])] ) );
					// type/1
					if(propvar || property.indicator === "type/1")
						properties.push( new Term( "type", [new Term(streams[i].type, [])] ) );
					for( var j = 0; j < properties.length; j++ ) {
						states.push( new State(
							point.goal.replace( new Term( ",", [
								new Term("=", [pl.type.is_variable( stream ) ? stream : stream2, streams[i]]),
								new Term("=", [property, properties[j]])]) ),
							point.substitution,
							point
						) );
					}
				}
				thread.prepend( states );
			}
		},

		// stream_position_data
		"stream_position_data/3": function(thread, point, atom) {
			var field = atom.args[0], position = atom.args[1], value = atom.args[2];
			if(pl.type.is_variable(position)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(position) || position.indicator !== "position/3") {
				thread.throw_error(pl.error.domain("stream_position", position, atom.indicator));
			} else if(!pl.type.is_variable(field) && !pl.type.is_atom(field)) {
				thread.throw_error(pl.error.type("atom", field, atom.indicator));
			} else if(!pl.type.is_variable(value) && !pl.type.is_integer(value)) {
				thread.throw_error(pl.error.type("integer", value, atom.indicator));
			} else {
				var fields = ["char_count", "line_count", "line_position"];
				var states = [];
				var data_pos = {char_count: 0, line_count: 1, line_position: 2};
				if(pl.type.is_variable(field)) {
					for(var i = 0; i < fields.length; i++) {
						states.push(new State(point.goal.replace(
							new Term(",", [
								new Term("=", [new Term(fields[i]), field]),
								new Term("=", [value, position.args[data_pos[fields[i]]]])
							])
						), point.substitution, point));
					}
				} else if(data_pos.hasOwnProperty(field.id)) {
					states.push(new State(point.goal.replace(
						new Term("=", [value, position.args[data_pos[field.id]]])
					), point.substitution, point));
				}
				thread.prepend(states);
			}
		},

		// at_end_of_stream/0
		"at_end_of_stream/0": [
			new Rule(new Term("at_end_of_stream", []), new pl.type.Term(",", [new Term("current_input", [new Var("S")]),new Term(",", [new Term("stream_property", [new Var("S"),new Term("end_of_stream", [new Var("E")])]),new Term(",", [new Term("!", []),new Term(";", [new Term("=", [new Var("E"),new Term("at", [])]),new Term("=", [new Var("E"),new Term("past", [])])])])])]))
		],

		// at_end_of_stream/1
		"at_end_of_stream/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				var e = thread.next_free_variable();
				thread.prepend( [new State(
					point.goal.replace(
						new Term(",", [new Term("stream_property", [stream2,new Term("end_of_stream", [e])]),
						new Term(",", [new Term("!", []),new Term(";", [new Term("=", [e,new Term("at", [])]),
						new Term("=", [e,new Term("past", [])])])])])
					),
					point.substitution,
					point
				)] );
			}
		},

		// set_stream_position/2
		"set_stream_position/2": function( thread, point, atom ) {
			var stream = atom.args[0], position = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( position ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_stream_position( position ) ) {
				thread.throw_error( pl.error.domain( "stream_position", position, atom.indicator ) );
			} else if( stream2.reposition === false ) {
				thread.throw_error( pl.error.permission( "reposition", "stream", stream, atom.indicator ) );
			} else {
				if( position.indicator === "position/3" ) {
					stream2.position = position.args[0].value;
					stream2.char_count = position.args[0].value;
					stream2.line_count = position.args[1].value;
					stream2.line_position = position.args[2].value;
				} else {
					stream2.position = position.id;
				}
				thread.success( point );
			}
		},



		//  CHARACTER INPUT OUTPUT
		
		// get_char/1
		"get_char/1": [
			new Rule(new Term("get_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_char", [new Var("S"),new Var("C")])]))
		],

		// get_char/2
		"get_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_char === "\n") {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// get_code/1
		"get_code/1": [
			new Rule(new Term("get_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_code", [new Var("S"),new Var("C")])]))
		],

		// get_code/2
		"get_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream_code = codePointAt( stream_code, 0 );
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_code === 10) {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_char/1
		"peek_char/1": [
			new Rule(new Term("peek_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_char", [new Var("S"),new Var("C")])]))
		],

		// peek_char/2
		"peek_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_code/1
		"peek_code/1": [
			new Rule(new Term("peek_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_code", [new Var("S"),new Var("C")])]))
		],

		// peek_code/2
		"peek_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
					} else {
						stream_code = codePointAt( stream_code, 0 );
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_char/1
		"put_char/1": [
			new Rule(new Term("put_char", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Var("C")])]))
		],

		// put_char/2
		"put_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( char ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( char.id, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(char.id === "\n") {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// put_code/1
		"put_code/1": [
			new Rule(new Term("put_code", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_code", [new Var("S"),new Var("C")])]))
		],

		// put_code/2
		"put_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( fromCodePoint( code.value ), stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(code.value === 10) {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// nl/0
		"nl/0": [
			new Rule(new Term("nl"), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Term("\n")])]))
		],

		// nl/1
		"nl/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State( 
				point.goal.replace( new Term("put_char", [stream, new Term("\n", [])]) ),
				point.substitution,
				point
			)] );
		},



		// BYTE INPUT/OUTPUT

		// get_byte/1
		"get_byte/1": [
			new Rule(new Term("get_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_byte", [new Var("S"),new Var("B")])]))
		],

		// get_byte/2
		"get_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},
		
		// peek_byte/1
		"peek_byte/1": [
			new Rule(new Term("peek_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_byte", [new Var("S"),new Var("B")])]))
		],

		// peek_byte/2
		"peek_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_byte/1
		"put_byte/1": [
			new Rule(new Term("put_byte", [new Var("B")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_byte", [new Var("S"),new Var("B")])]))
		],

		// put_byte/2
		"put_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( byte ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_byte( byte ) ) {
				thread.throw_error( pl.error.type( "byte", byte, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "output", "text_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put_byte( byte.value, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					thread.success( point );
				}
			}
		},



		// TERM INPUT/OUTPUT

		// read/1
		"read/1": [
			new Rule(new Term("read", [new Var("T")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")])]))
		],

		// read/2
		"read/2": [
			new Rule(new Term("read", [new Var("S"), new Var("T")]), new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")]))
		],

		// read_term/2
		"read_term/2": [
			new Rule(new Term("read_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],

		// read_term/3
		"read_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "eof_code" ) {
				expr = {
					value: new Term("end_of_file", []),
					type: SUCCESS,
					len: -1
				};
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_read_option( property ) ) {
						thread.throw_error( pl.error.domain( "read_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0];
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var char, tokenizer, expr;
					var text = "";
					var tokens = [];
					var last_token = null;
					var lexical_error = false;
					// Get term
					while( last_token === null || lexical_error || last_token.name !== "atom" || last_token.value !== "." || tokens.length > 0 && expr.type === ERROR ) {
						char = stream2.stream.get( 1, stream2.position );
						while(char !== null && char !== "." && char !== "end_of_stream" && char !== "past_end_of_stream") {
							stream2.position++;
							text += char;
							char = stream2.stream.get( 1, stream2.position );
						}
						if( char === null ) {
							thread.throw_error( pl.error.representation( "character", atom.indicator ) );
							return;
						} else if( char === "end_of_stream" || char === "past_end_of_stream" ) {
							if(tokens === null || tokens.length === 0) {
								stream2.position = "past_end_of_stream";
								expr = {
									value: new Term("end_of_file", []),
									type: SUCCESS,
									len: -1
								};
								break;
							} else if(expr) {
								thread.throw_error( pl.error.syntax( last_token, "unexpected end of file", false ) );
								return;
							} else {
								thread.throw_error( pl.error.syntax( last_token, "token not found", true ) );
								return;
							}
						} else if(char === ".") {
							stream2.position++;
							text += char;
						}
						tokenizer = new Tokenizer( thread );
						tokenizer.new_text( text );
						tokens = tokenizer.get_tokens();
						num_token = tokens !== null && tokens.length > 1 ? tokens[tokens.length-2] : null;
						last_token = tokens !== null && tokens.length > 0 ? tokens[tokens.length-1] : null;
						if(tokens === null)
							continue;
						lexical_error = false;
						for(var i = 0; i < tokens.length && !lexical_error; i++)
							lexical_error = tokens[i].name === "lexical";
						if(lexical_error)
							continue;
						expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
						if(num_token && num_token.name === "number" && !num_token.float && !num_token.blank && last_token.value === ".") {
							var next_char = stream2.stream.get(1, stream2.position);
							if(next_char >= '0' && next_char <= '9') {
								stream2.position++;
								text += next_char;
								last_token = null;
								continue;
							}
						}
					}
					if(last_token) {
						if(last_token.line_position === last_token.len)
							stream2.line_position += last_token.line_position;
						else
							stream2.line_position = last_token.line_position;
						stream2.line_count += last_token.line_count;
						stream2.char_count += last_token.len;
					}
					// Succeed analyzing term
					if( expr.type === SUCCESS && (expr.len === -1 || expr.len === tokens.length-1 && last_token.value === "." )) {
						thread.session.renamed_variables = {};
						expr = expr.value.rename( thread );
						var eq = new Term( "=", [term, expr] );
						// Variables
						if( obj_options.variables ) {
							var vars = arrayToList( map( nub( expr.variables() ), function(v) { return new Var(v); } ) );
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variables, vars] )] )
						}
						// Variable names
						if( obj_options.variable_names ) {
							var vars = nub(expr.variables());
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variable_names, plvars] )] );
						}
						// Singletons
						if( obj_options.singletons ) {
							var vars = nub(new Rule(expr, null).singleton_variables(true));
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.singletons, plvars] )] );
						}
						thread.prepend( [new State( point.goal.replace( eq ), point.substitution, point )] );
					// Failed analyzing term
					} else {
						if( expr.type === SUCCESS )
							thread.throw_error( pl.error.syntax( tokens[expr.len], "unexpected token", false ) );
						else
							thread.throw_error( expr.value );
					}
				}
			}
		},

		// write/1
		"write/1": [
			new Rule(new Term("write", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write", [new Var("S"),new Var("T")])]))
		],
		
		// write/2
		"write/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("false", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// writeq/1
		"writeq/1": [
			new Rule(new Term("writeq", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("writeq", [new Var("S"),new Var("T")])]))
		],
		
		// writeq/2
		"writeq/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// write_canonical/1
		"write_canonical/1": [
			new Rule(new Term("write_canonical", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_canonical", [new Var("S"),new Var("T")])]))
		],
		
		// write_canonical/2
		"write_canonical/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("true")]),
							new Term(".", [new Term("numbervars", [new Term("false")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},

		// write_term/2
		"write_term/2": [
			new Rule(new Term("write_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],
		
		// write_term/3
		"write_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "output", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_write_option( property ) ) {
						thread.throw_error( pl.error.domain( "write_option", property, atom.indicator ) );
						return;
					}
					if(property.indicator === "variable_names/1")
						obj_options[property.id] = property.args[0];
					else
						obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					obj_options.session = thread.session;
					var text = term.toString( obj_options );
					stream2.stream.put( text, stream2.position );
					if( typeof stream2.position === "number" )
						stream2.position += text.length;
					var nl = (text.match(/\n/g) || []).length;
					stream2.line_count += nl;
					if(nl > 0)
						stream2.line_position = text.length - text.lastIndexOf("\n") - 1;
					else
						stream2.line_position += text.length;
					stream2.char_count += text.length;
					thread.success( point );
				}
			}
		},
		
		// IMPLEMENTATION DEFINED HOOKS
		
		// halt/0
		"halt/0": function( thread, point, _ ) {
			if( thread.get_flag("nodejs").indicator === "true/0" )
				process.exit();
			thread.points = [];
		},
		
		// halt/1
		"halt/1": function( thread, point, atom ) {
			var int = atom.args[0];
			if( pl.type.is_variable( int ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( int ) ) {
				thread.throw_error( pl.error.type( "integer", int, atom.indicator ) );
			} else {
				if( thread.get_flag("nodejs").indicator === "true/0" )
					process.exit(int.value);
				thread.points = [];
			}
		},
		
		// current_prolog_flag/2
		"current_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( !pl.type.is_variable( flag ) && !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_variable( flag ) && !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else {
				var states = [];
				for( var name in pl.flag ) {
					if(!pl.flag.hasOwnProperty(name)) continue;
					var goal = new Term( ",", [new Term( "=", [new Term( name ), flag] ), new Term( "=", [thread.get_flag(name), value] )] );
					states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
				}
				thread.prepend( states );
			}
		},
		
		// set_prolog_flag/2
		"set_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else if( !pl.type.is_modifiable_flag( flag ) ) {
				thread.throw_error( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
			} else if( !pl.type.is_value_flag( flag, value ) ) {
				thread.throw_error( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
			} else {
				thread.session.flag[flag.id] = value;
				thread.success( point );
			}
		},



		// LOAD PROLOG SOURCE FILES

		// consult/1
		"consult/1": function(thread, point, atom) {
			var src = atom.args[0];
			var context_module = "user";
			if(src.indicator === ":/2") {
				context_module = src.args[0].id;
				src = src.args[1];
			}
			if(pl.type.is_variable(src)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_atom(src)) {
				thread.throw_error( pl.error.type( "atom", src, atom.indicator ) );
			} else {
				if(thread.consult(src.id, {
					context_module: context_module,
					text: false,
					html: false,
					success: function() {
						thread.success(point);
						thread.again();
					},
					error: function(err) {
						thread.throw_error(err);
						thread.again();
					}
				}));
				return true;
			}
		},



		// TIME AND DATES

		// get_time/1
		"get_time/1": function( thread, point, atom ) {
			var time = atom.args[0];
			if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else {
				var current = new Num(Date.now(), true);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [time, current] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_property
		"time_property/2": function(thread, point, atom) {
			var time = atom.args[0], property = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error(pl.error.type("number", time, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_time_property(property)) {
				thread.throw_error(pl.error.domain("time_property", property, atom.indicator));
			} else {
				var props;
				if(pl.type.is_variable(property)) {
					props = ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"];
				} else {
					props = [property.id];
				}
				var date = new Date(time.value);
				var value;
				var states = [];
				for(var i = 0; i < props.length; i++) {
					switch(props[i]) {
						case "year":
							value = new Term("year", [new Num(date.getFullYear(), false)]);
							break;
						case "month":
							value = new Term("month", [new Num(date.getMonth(), false)]);
							break;
						case "day":
							value = new Term("day", [new Num(date.getDate(), false)]);
							break;
						case "hours":
							value = new Term("hours", [new Num(date.getHours(), false)]);
							break;
						case "minutes":
							value = new Term("minutes", [new Num(date.getMinutes(), false)]);
							break;
						case "seconds":
							value = new Term("seconds", [new Num(date.getSeconds(), false)]);
							break;
						case "milliseconds":
							value = new Term("milliseconds", [new Num(date.getMilliseconds(), false)]);
							break;
						case "weekday":
							value = new Term("weekday", [new Num(date.getDay(), false)]);
							break;
					}
					states.push(new State(
						point.goal.replace( new Term( "=", [property, value] ) ), 
						point.substitution,
						point
					));
				}
				thread.prepend(states);
			}
		},

		// time_year/2
		"time_year/2": function( thread, point, atom ) {
			var time = atom.args[0], year = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(year) && !pl.type.is_integer(year)) {
				thread.throw_error( pl.error.type( "integer", year, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getFullYear(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [year, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_month/2
		"time_month/2": function( thread, point, atom ) {
			var time = atom.args[0], month = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(month) && !pl.type.is_integer(month)) {
				thread.throw_error( pl.error.type( "integer", month, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getMonth(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [month, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},



		// GRAMMARS

		// phrase/3
		"phrase/3": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1], s = atom.args[2];
			var context_module = "user";
			if(grbody.indicator === ":/2") {
				context_module = grbody.args[0].id;
				grbody = grbody.args[1];
			}
			if( pl.type.is_variable( grbody ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( grbody ) ) {
				thread.throw_error( pl.error.type( "callable", grbody, atom.indicator ) );
			} else {
				var goal = body_to_dcg( grbody.clone(), s0, thread );
				goal.value = new Term(":", [new Term(context_module), new Term("call", [goal.value])]);
				if(goal !== null) {
					thread.prepend( [new State(
						point.goal.replace( new Term( ",", [goal.value, new Term("=", [goal.variable, s])] ) ), 
						point.substitution,
						point
					)] );
				}
			}
		},

		// phrase/2
		"phrase/2": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1];
			thread.prepend( [new State(
				point.goal.replace( new Term( "phrase", [grbody, s0, new Term("[]", [])] ) ), 
				point.substitution,
				point
			)] );
		},



		// TAU PROLOG INFORMATION

		// version/0
		"version/0": function( thread, point, atom ) {
			var msg = "Welcome to Tau Prolog version " + version.major + "." + version.minor + "." + version.patch + "\n";
			msg += "Tau Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\n";
			msg += "Please run ?- license. for legal details.\n";
			msg += "For online help and background, visit http:/tau-prolog.org";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		},

		// license/0
		"license/0": function( thread, point, atom ) {
			var msg = "Tau Prolog. A Prolog interpreter in JavaScript.\n";
			msg += "Copyright (C) 2017 - 2022 Jos Antonio Riaza Valverde\n\n";
			msg += "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n";
			msg += "1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n";
			msg += "2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n";
			msg += "3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n";
			msg += "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n";
			msg += "You should have received a copy of the BSD 3-Clause License along with this program. If not, see https://opensource.org/licenses/BSD-3-Clause";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		}

	}, "all", {
		meta_predicates: {
			// '$findall'(?, 0, -, ?)
			"$findall/4": new Term("$findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// '$bagof'(?, ^, -)
			"$bagof/3": new Term("$bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$setof'(?, ^, -)
			"$setof/3": new Term("$setof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$if'(0, 0, 0)
			"$if/3": new Term("$if", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// (0;0)
			";/2": new Term(";", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"->/2": new Term("->", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"*->/2": new Term("*->", [new Num(0, false), new Num(0, false)]),
			// (\+0)
			"\\+/1": new Term("\\+", [new Num(0, false)]),
			// abolish(:)
			"abolish/1": new Term("abolish", [new Term(":")]),
			// asserta(:)
			"asserta/1": new Term("asserta", [new Term(":")]),
			// assertz(:)
			"assertz/1": new Term("assertz", [new Term(":")]),
			// bagof(?, ^, -)
			"bagof/3": new Term("bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// call(0)
			"call/1": new Term("call", [new Num(0, false)]),
			// call(1, ?)
			"call/2": new Term("call", [new Num(1, false), new Term("?")]),
			// call(2, ?, ?)
			"call/3": new Term("call", [new Num(2, false), new Term("?"), new Term("?")]),
			// call(3, ?, ?, ?)
			"call/4": new Term("call", [new Num(3, false), new Term("?"), new Term("?"), new Term("?")]),
			// call(4, ?, ?, ?, ?)
			"call/5": new Term("call", [new Num(4, false), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(5, ?, ?, ?, ?, ?)
			"call/6": new Term("call", [new Num(5, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(6, ?, ?, ?, ?, ?, ?)
			"call/7": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(7, ?, ?, ?, ?, ?, ?, ?)
			"call/8": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call_cleanup(0, 0)
			"call_cleanup/2": new Term("call_cleanup", [new Num(0, false), new Num(0, false)]),
			// catch(0, ?, 0)
			"catch/3": new Term("catch", [new Num(0, false), new Term("?"), new Num(0, false)]),
			// consult(:)
			"consult/1": new Term("consult", [new Term(":")]),
			// clause(:, ?)
			"clause/2": new Term("clause", [new Term(":"), new Term("?")]),
			// current_predicate(?, :)
			"current_predicate/2": new Term("current_predicate", [new Term("?"), new Term(":")]),
			// findall(?, 0, -)
			"findall/3": new Term("findall", [new Term("?"), new Num(0, false), new Term("-")]),
			// findall(?, 0, -, ?)
			"findall/4": new Term("findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// forall(0, 0)
			"forall/2": new Term("forall", [new Num(0, false), new Num(0, false)]),
			// listing(:)
			"listing/1": new Term("listing", [new Term(":")]),
			// once(0)
			"once/1": new Term("once", [new Num(0, false)]),
			// phrase(:, ?)
			"phrase/2": new Term("phrase", [new Term(":"),new Term("?")]),
			// phrase(:, ?, ?)
			"phrase/3": new Term("phrase", [new Term(":"),new Term("?"), new Term("?")]),
			// retract(:)
			"retract/1": new Term("retract", [new Term(":")]),
			// retractall(:)
			"retractall/1": new Term("retractall", [new Term(":")]),
			// setup_call_cleanup(0, 0, 0)
			"setup_call_cleanup/3": new Term("setup_call_cleanup", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// setof(?, ^, -)
			"setof/3": new Term("setof", [new Term("?"), new Term("^"), new Term("-")])
		}
	});

	if( true ) {
		module.exports = pl;
	} else {}
	
})();


/***/ }),

/***/ "./node_modules/tau-prolog/modules/promises.js":
/*!*****************************************************!*\
  !*** ./node_modules/tau-prolog/modules/promises.js ***!
  \*****************************************************/
/***/ ((module) => {

var pl;
(function(pl) {

	// Extend Tau Prolog prototypes
	var extend = function(pl) {

		// Consult a program from a string
		pl.type.Session.prototype.promiseConsult = function(program, options) {
			return this.thread.promiseConsult(program, options);
		};

		pl.type.Thread.prototype.promiseConsult = function(program, options) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				var opts = {};
				options = options === undefined ? {} : options;
				opts.context_module = options.context_module;
				opts.text = options.text;
				opts.html = options.html;
				opts.url = options.url;
				opts.file = options.file;
				opts.script = options.script;
				opts.success = resolve;
				opts.error = reject;
				thread.consult(program, opts);
			});
		};

		// Query goal from a string (without ?-)
		pl.type.Session.prototype.promiseQuery = function(string) {
			return this.thread.promiseQuery(string);
		};

		pl.type.Thread.prototype.promiseQuery = function(string) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.query(string, {
					success: resolve,
					error: reject
				});
			});
		};

		// Find next computed answer
		pl.type.Session.prototype.promiseAnswer = function() {
			return this.thread.promiseAnswer();
		};

		pl.type.Thread.prototype.promiseAnswer = function() {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.answer({
					success: resolve,
					fail: resolve,
					error: reject,
					limit: reject
				});
			});
		};

		// Find all computed answers (asynchronous generator function)
		pl.type.Session.prototype.promiseAnswers = function() {
			return this.thread.promiseAnswers();
		};
		pl.type.Thread.prototype.promiseAnswers = async function*() {
			while(true) {
				var answer = await this.promiseAnswer();
				if(answer !== false)
					yield answer;
				else
					return;
			}
		};

	}

	if(true) {
		module.exports = function(p) {
			pl = p;
			extend(pl);
		};
	} else {}

})(pl);

/***/ }),

/***/ "./app/res/tokens/adjectives.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/adjectives.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "big",
    "small",
    "helpful",
    "red",
    "black",
    "great"
];


/***/ }),

/***/ "./app/res/tokens/copulas.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/copulas.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "is",
    "are",
    "be"
];


/***/ }),

/***/ "./app/res/tokens/definite_articles.ts":
/*!*********************************************!*\
  !*** ./app/res/tokens/definite_articles.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "the"
];


/***/ }),

/***/ "./app/res/tokens/existential_quantifiers.ts":
/*!***************************************************!*\
  !*** ./app/res/tokens/existential_quantifiers.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "some"
];


/***/ }),

/***/ "./app/res/tokens/hverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/hverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "do",
    "does"
];


/***/ }),

/***/ "./app/res/tokens/indefinite_articles.ts":
/*!***********************************************!*\
  !*** ./app/res/tokens/indefinite_articles.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "a",
    "an"
];


/***/ }),

/***/ "./app/res/tokens/iverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/iverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "exist",
    "exists",
    "run",
    "grow",
    "die",
    "live"
];


/***/ }),

/***/ "./app/res/tokens/mverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/mverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "eat",
    "drink",
    "watch",
    "make",
    "hit",
    "click"
];


/***/ }),

/***/ "./app/res/tokens/negations.ts":
/*!*************************************!*\
  !*** ./app/res/tokens/negations.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "doesn't",
    "does not",
    'not',
    "don't",
    'do not'
];


/***/ }),

/***/ "./app/res/tokens/nonsubconj.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/nonsubconj.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "and",
    "or"
];


/***/ }),

/***/ "./app/res/tokens/nouns.ts":
/*!*********************************!*\
  !*** ./app/res/tokens/nouns.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "cat",
    "mat",
    "table",
    "dog",
    "nodejs",
    "color",
    "button",
    "div",
    "president",
    "trump"
];


/***/ }),

/***/ "./app/res/tokens/prepositions.ts":
/*!****************************************!*\
  !*** ./app/res/tokens/prepositions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "to",
    "with",
    "from",
    "of",
    "over",
    "on",
    "at"
];


/***/ }),

/***/ "./app/res/tokens/relprons.ts":
/*!************************************!*\
  !*** ./app/res/tokens/relprons.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "that"
];


/***/ }),

/***/ "./app/res/tokens/subconj.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/subconj.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "if",
    "when",
    "because",
    "while"
];


/***/ }),

/***/ "./app/res/tokens/then.ts":
/*!********************************!*\
  !*** ./app/res/tokens/then.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "then"
];


/***/ }),

/***/ "./app/res/tokens/universal_quantifiers.ts":
/*!*************************************************!*\
  !*** ./app/res/tokens/universal_quantifiers.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "every",
    "all",
    "each"
];


/***/ }),

/***/ "./app/src/ast/phrases/Complement.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/Complement.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class Complement {
    constructor(preposition, nounPhrase) {
        this.preposition = preposition;
        this.nounPhrase = nounPhrase;
    }
    toClause(args) {
        var _a, _b;
        const subjId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (() => { throw new Error('undefined subject id'); })();
        const newId = (0, Clause_1.getRandomId)();
        return (0, Clause_1.clauseOf)(this.preposition.string, subjId, newId)
            .and(this.nounPhrase.toClause(Object.assign(Object.assign({}, args), { roles: { subject: newId } })));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = Complement;


/***/ }),

/***/ "./app/src/ast/phrases/CopulaSubordinateClause.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/phrases/CopulaSubordinateClause.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CopulaSubordinateClause {
    constructor(relpron, predicate, copula) {
        this.relpron = relpron;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a;
        return this.predicate.toClause(Object.assign(Object.assign({}, args), { roles: { subject: (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject } }));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaSubordinateClause;


/***/ }),

/***/ "./app/src/ast/phrases/NounPhrase.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/NounPhrase.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class NounPhrase {
    constructor(adjectives, complements, noun, quantifier, article, subordClause) {
        this.adjectives = adjectives;
        this.complements = complements;
        this.noun = noun;
        this.quantifier = quantifier;
        this.article = article;
        this.subordClause = subordClause;
    }
    isUniQuant() {
        var _a, _b;
        return (_b = (_a = this.quantifier) === null || _a === void 0 ? void 0 : _a.isUniversal()) !== null && _b !== void 0 ? _b : false;
    }
    toClause(args) {
        var _a, _b, _c, _d;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)();
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        return this
            .adjectives
            .map(a => a.string)
            .concat(this.noun ? [this.noun.string] : [])
            .map(p => (0, Clause_1.clauseOf)(p, subjectId))
            .reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)())
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)()))
            .and((_d = (_c = this.subordClause) === null || _c === void 0 ? void 0 : _c.toClause(newArgs)) !== null && _d !== void 0 ? _d : (0, Clause_1.emptyClause)());
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = NounPhrase;


/***/ }),

/***/ "./app/src/ast/sentences/ComplexSentence.ts":
/*!**************************************************!*\
  !*** ./app/src/ast/sentences/ComplexSentence.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
/**
 * A sentence that relates two simple sentences hypotactically, in a
 * condition-outcome relationship.
 */
class ComplexSentence {
    constructor(condition, outcome, subconj) {
        this.condition = condition;
        this.outcome = outcome;
        this.subconj = subconj;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)();
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        //TODO: this is WRONG, subject of condition may NOT always be the subject of the outcome
        const condition = this.condition.toClause(newArgs);
        const outcome = this.outcome.toClause(newArgs);
        return condition.implies(outcome);
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = ComplexSentence;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaQuestion.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaQuestion.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ./CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
class CopulaQuestion {
    constructor(subject, predicate, copula) {
        this.subject = subject;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        //TODO: in case of a universally quantified question eg: "are all cats smart?" the prolog
        // produced should NOT be an implication, but rather a check that all cats are smart.
        return new CopulaSentence_1.default(this.subject, this.copula, this.predicate).toClause(newArgs);
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaQuestion;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaSentence.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaSentence.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class CopulaSentence {
    constructor(subject, copula, predicate, negation) {
        this.subject = subject;
        this.copula = copula;
        this.predicate = predicate;
        this.negation = negation;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const subject = this.subject.toClause(newArgs);
        const predicate = this.predicate.toClause(newArgs).copy({ negate: !!this.negation });
        return this.subject.isUniQuant() ?
            subject.implies(predicate) :
            subject.and(predicate, { asRheme: true });
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = CopulaSentence;


/***/ }),

/***/ "./app/src/ast/sentences/IntransitiveSentence.ts":
/*!*******************************************************!*\
  !*** ./app/src/ast/sentences/IntransitiveSentence.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class IntransitiveSentence {
    constructor(subject, iverb, complements, negation) {
        this.subject = subject;
        this.iverb = iverb;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Clause_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const theme = this.subject.toClause(newArgs);
        const rheme = (0, Clause_1.clauseOf)(this.iverb.string, subjectId)
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2)));
        return theme.and(rheme, { asRheme: true });
    }
}
exports["default"] = IntransitiveSentence;


/***/ }),

/***/ "./app/src/ast/sentences/MonotransitiveSentence.ts":
/*!*********************************************************!*\
  !*** ./app/src/ast/sentences/MonotransitiveSentence.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MonotransitiveSentence {
    constructor(subject, mverb, object, complements, negation) {
        this.subject = subject;
        this.mverb = mverb;
        this.object = object;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        throw new Error("Method not implemented.");
    }
}
exports["default"] = MonotransitiveSentence;


/***/ }),

/***/ "./app/src/ast/tokens/AbstractToken.ts":
/*!*********************************************!*\
  !*** ./app/src/ast/tokens/AbstractToken.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AbstractToken {
    constructor(string) {
        this.string = string;
    }
}
exports["default"] = AbstractToken;


/***/ }),

/***/ "./app/src/ast/tokens/Adjective.ts":
/*!*****************************************!*\
  !*** ./app/src/ast/tokens/Adjective.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Adjective extends AbstractToken_1.default {
}
exports["default"] = Adjective;


/***/ }),

/***/ "./app/src/ast/tokens/Article.ts":
/*!***************************************!*\
  !*** ./app/src/ast/tokens/Article.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Article extends AbstractToken_1.default {
    isDefinite() {
        return definite_articles_1.default.includes(this.string);
    }
    toString() {
        return `Article(${this.string}, isDefinite=${this.isDefinite()})`;
    }
}
exports["default"] = Article;


/***/ }),

/***/ "./app/src/ast/tokens/Copula.ts":
/*!**************************************!*\
  !*** ./app/src/ast/tokens/Copula.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Copula extends AbstractToken_1.default {
}
exports["default"] = Copula;


/***/ }),

/***/ "./app/src/ast/tokens/FullStop.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/FullStop.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class FullStop extends AbstractToken_1.default {
}
exports["default"] = FullStop;


/***/ }),

/***/ "./app/src/ast/tokens/HVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/HVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class HVerb extends AbstractToken_1.default {
}
exports["default"] = HVerb;


/***/ }),

/***/ "./app/src/ast/tokens/IVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/IVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class IVerb extends AbstractToken_1.default {
}
exports["default"] = IVerb;


/***/ }),

/***/ "./app/src/ast/tokens/MVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/MVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class MVerb extends AbstractToken_1.default {
}
exports["default"] = MVerb;


/***/ }),

/***/ "./app/src/ast/tokens/Negation.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/Negation.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Negation extends AbstractToken_1.default {
}
exports["default"] = Negation;


/***/ }),

/***/ "./app/src/ast/tokens/NonSubordinatingConjunction.ts":
/*!***********************************************************!*\
  !*** ./app/src/ast/tokens/NonSubordinatingConjunction.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class NonSubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = NonSubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Noun.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Noun.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Noun extends AbstractToken_1.default {
}
exports["default"] = Noun;


/***/ }),

/***/ "./app/src/ast/tokens/Preposition.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/tokens/Preposition.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Preposition extends AbstractToken_1.default {
}
exports["default"] = Preposition;


/***/ }),

/***/ "./app/src/ast/tokens/Quantifier.ts":
/*!******************************************!*\
  !*** ./app/src/ast/tokens/Quantifier.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Quantifier extends AbstractToken_1.default {
    isUniversal() {
        return universal_quantifiers_1.default.includes(this.string);
    }
    isExistential() {
        return existential_quantifiers_1.default.includes(this.string);
    }
}
exports["default"] = Quantifier;


/***/ }),

/***/ "./app/src/ast/tokens/RelativePronoun.ts":
/*!***********************************************!*\
  !*** ./app/src/ast/tokens/RelativePronoun.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class RelativePronoun extends AbstractToken_1.default {
}
exports["default"] = RelativePronoun;


/***/ }),

/***/ "./app/src/ast/tokens/SubordinatingConjunction.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/tokens/SubordinatingConjunction.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class SubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = SubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Then.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Then.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Then extends AbstractToken_1.default {
}
exports["default"] = Then;


/***/ }),

/***/ "./app/src/brain/Brain.ts":
/*!********************************!*\
  !*** ./app/src/brain/Brain.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBrain = void 0;
const PrologBrain_1 = __importDefault(__webpack_require__(/*! ./PrologBrain */ "./app/src/brain/PrologBrain.ts"));
function getBrain() {
    return __awaiter(this, void 0, void 0, function* () {
        return new PrologBrain_1.default();
    });
}
exports.getBrain = getBrain;


/***/ }),

/***/ "./app/src/brain/PrologBrain.ts":
/*!**************************************!*\
  !*** ./app/src/brain/PrologBrain.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Parser_1 = __webpack_require__(/*! ../parser/Parser */ "./app/src/parser/Parser.ts");
const Prolog_1 = __webpack_require__(/*! ../prolog/Prolog */ "./app/src/prolog/Prolog.ts");
const Sandbox_1 = __webpack_require__(/*! ./Sandbox */ "./app/src/brain/Sandbox.ts");
class PrologBrain {
    constructor() {
        this.kb = (0, Prolog_1.getProlog)();
    }
    execute(natlang) {
        return __awaiter(this, void 0, void 0, function* () {
            const ast = (0, Parser_1.getParser)(natlang).parse();
            if (ast.isSideEffecty) {
                yield this.assert(ast.toClause());
                return true;
            }
            else {
                return yield this.query(ast.toClause());
            }
        });
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapToVar = query.entities
                .map(e => ({ [e]: (0, Clause_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            // const reverseMapToVar = Object.fromEntries(Object.entries(mapToVar).map(e => [e[1], e[0]]))
            const q = query
                .copy({ map: mapToVar })
                .toProlog()
                .reduce((a, b) => `${a}, ${b}`) + '.'; // TODO: deal with dot at a lower level ?
            const queryRes = yield this.kb.query(q);
            return queryRes; //TODO: reverse map to original constants used for query ??
        });
    }
    assert(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            const anaphoraMap = yield (0, Sandbox_1.getSandbox)(clause).mapTo(this);
            const toBeAsserted = clause
                .copy({ map: anaphoraMap })
                .toProlog();
            for (const c of toBeAsserted) { // TODO: bug finding one entity multiple times
                yield this.kb.assert(c);
            }
        });
    }
}
exports["default"] = PrologBrain;


/***/ }),

/***/ "./app/src/brain/Sandbox.ts":
/*!**********************************!*\
  !*** ./app/src/brain/Sandbox.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSandbox = void 0;
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
function getSandbox(clause) {
    return new BaseSandbox(clause);
}
exports.getSandbox = getSandbox;
class BaseSandbox {
    constructor(clause) {
        this.clause = clause;
    }
    mapTo(universe) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const themeEnts = this.clause.theme.entities;
            // get descriptions of entities in theme omitting relations with entities in rheme
            const themeDescs = this.clause.theme.flatList()
                .filter(e => !e.isImply);
            // get descriptions of entities in rheme omitting relations with entities in theme
            const rhemeDescs = this.clause.rheme.flatList()
                .filter(c => themeEnts.every(e => !c.entities.includes(e)))
                .filter(e => !e.isImply);
            const mapToVar = this.clause.entities
                .map(e => ({ [e]: (0, Clause_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            const reverseMapToVar = Object.fromEntries(Object.entries(mapToVar).map(e => [e[1], e[0]]));
            const bigDescClause = themeDescs
                .concat(rhemeDescs)
                .reduce((c1, c2) => c1.and(c2))
                .copy({ map: mapToVar });
            const candidates = yield universe.query(bigDescClause);
            const chosen = (_a = candidates[0]) !== null && _a !== void 0 ? _a : {}; //TODO: better criterion !!!
            const anaphora = Object
                .keys(chosen)
                .map(k => { var _a; return ({ [reverseMapToVar[k]]: (_a = chosen[k]) !== null && _a !== void 0 ? _a : reverseMapToVar[k] }); })
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
            return anaphora;
        });
    }
}


/***/ }),

/***/ "./app/src/clauses/BasicClause.ts":
/*!****************************************!*\
  !*** ./app/src/clauses/BasicClause.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicClause = void 0;
const Clause_1 = __webpack_require__(/*! ./Clause */ "./app/src/clauses/Clause.ts");
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
const ListClause_1 = __importDefault(__webpack_require__(/*! ./ListClause */ "./app/src/clauses/ListClause.ts"));
class BasicClause {
    constructor(predicate, args, negated = false, isImply = false) {
        this.predicate = predicate;
        this.args = args;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return new ListClause_1.default(this.flatList().concat(other.flatList()));
    }
    copy(opts) {
        return new BasicClause(this.predicate, this.args.map(a => { var _a; return (opts === null || opts === void 0 ? void 0 : opts.map) ? (_a = opts === null || opts === void 0 ? void 0 : opts.map[a]) !== null && _a !== void 0 ? _a : a : a; }), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this.copy()];
    }
    toProlog() {
        const core = `${this.predicate}(${this.args.reduce((a, b) => `${a}, ${b}`)})`;
        return this.negated ? [`logicNot(${core})`] : [core];
    }
    get entities() {
        return Array.from(new Set(this.args.concat([])));
    }
    get theme() {
        return this.copy();
    }
    get rheme() {
        return (0, Clause_1.emptyClause)();
    }
    implies(conclusion) {
        return new Imply_1.default(this.copy(), conclusion.copy());
    }
}
exports.BasicClause = BasicClause;


/***/ }),

/***/ "./app/src/clauses/Clause.ts":
/*!***********************************!*\
  !*** ./app/src/clauses/Clause.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toVar = exports.getRandomId = exports.emptyClause = exports.clauseOf = void 0;
const BasicClause_1 = __webpack_require__(/*! ./BasicClause */ "./app/src/clauses/BasicClause.ts");
const ListClause_1 = __importDefault(__webpack_require__(/*! ./ListClause */ "./app/src/clauses/ListClause.ts"));
function clauseOf(predicate, ...args) {
    return new BasicClause_1.BasicClause(predicate, args);
}
exports.clauseOf = clauseOf;
const emptyClause = () => new ListClause_1.default([]);
exports.emptyClause = emptyClause;
function getRandomId(opts) {
    return `${(opts === null || opts === void 0 ? void 0 : opts.asVar) ? 'Id' : 'id'}${parseInt(1000 * Math.random() + '')}`;
}
exports.getRandomId = getRandomId;
function toVar(id) {
    return (!Number.isNaN(Number(id)) ? `id${id}` : id + '').toUpperCase();
}
exports.toVar = toVar;


/***/ }),

/***/ "./app/src/clauses/Imply.ts":
/*!**********************************!*\
  !*** ./app/src/clauses/Imply.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ListClause_1 = __importDefault(__webpack_require__(/*! ./ListClause */ "./app/src/clauses/ListClause.ts"));
class Imply {
    constructor(condition, conclusion, negated = false, isImply = true) {
        this.condition = condition;
        this.conclusion = conclusion;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return new ListClause_1.default([this.copy(), other.copy()]);
    }
    copy(opts) {
        return new Imply(this.condition.copy(opts), this.conclusion.copy(opts), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this.copy()];
    }
    /**
     * Generates horn clauses, one for each conclusion.
     * Since prolog only supports that kind of implication.
     * @returns
     */
    toProlog() {
        const conditionString = this.condition
            .toProlog()
            .reduce((c1, c2) => `${c1}, ${c2}`);
        const conclusions = this.conclusion.flatList();
        return conclusions.map(c => `${c.toProlog()[0]} :- ${conditionString}`); //TODO: [0] is to be dealt with better
    }
    get entities() {
        return this.condition.entities.concat(this.conclusion.entities);
    }
    get theme() {
        return this.condition.theme;
    }
    get rheme() {
        return this.copy(); // dunno what I'm doin'
    }
    implies(conclusion) {
        throw new Error('not implemented!');
    }
}
exports["default"] = Imply;


/***/ }),

/***/ "./app/src/clauses/ListClause.ts":
/*!***************************************!*\
  !*** ./app/src/clauses/ListClause.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
class AndClause {
    constructor(clauses, negated = false, isImply = false) {
        this.clauses = clauses;
        this.negated = negated;
        this.isImply = isImply;
    }
    and(other, opts) {
        return (opts === null || opts === void 0 ? void 0 : opts.asRheme) ?
            new AndClause([this.copy(), other.copy()]) :
            new AndClause([...this.flatList(), ...other.flatList()]);
    }
    copy(opts) {
        return new AndClause(this.clauses.map(c => c.copy(Object.assign(Object.assign({}, opts), { negate: false }))), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return this.negated ? [this.copy()] : this.clauses.flatMap(c => c.flatList());
    }
    get entities() {
        return Array.from(new Set(this.clauses.flatMap(c => c.entities)));
    }
    get theme() {
        return this.clauses[0];
    }
    get rheme() {
        return this.clauses[1];
    }
    implies(conclusion) {
        return new Imply_1.default(this.copy(), conclusion.copy());
    }
    toProlog() {
        const prologClauses = this.clauses.flatMap(c => c.toProlog());
        return this.negated ?
            [`logicNot(${prologClauses.reduce((a, b) => `${a}, ${b}`)})`] :
            prologClauses;
    }
}
exports["default"] = AndClause;


/***/ }),

/***/ "./app/src/index.ts":
/*!**************************!*\
  !*** ./app/src/index.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const playground_1 = __importDefault(__webpack_require__(/*! ./tests/playground */ "./app/src/tests/playground.ts"));
// PROLOG TEST //////////////////////////////////////////
// const pro = getProlog();
// (window as any).pro = pro;
// (async () => {
//     await pro.assert('capra(scemo)')
//     await pro.assert('mammal(peloso)')
//     await pro.assert('mammal(fido)')
//     await pro.assert('mammal(X) :- capra(X)')
//     console.log(await pro.query('mammal(X).'))
//     await pro.retract('capra(scemo)')
//     console.log(await pro.query('mammal(X).'))
// })();
// //      //////////////////////////////////////////
//////////////////////////////////////////////////////////////
// console.log((tokenOf('a') as Article).isDefinite())
// console.log(tokenOf('a')  instanceof Article)
// console.log(tokenOf('a')  instanceof Quantifier)
// console.log(tokenOf('every')  instanceof Quantifier)
// console.log(tokenOf('a').toString())
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// const lexer = getLexer('the cat is a cat.')
// console.log(lexer)
// console.log('is it a noun?', lexer.assert(Noun, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it a copula?', lexer.assert(Copula, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it an article?', lexer.assert(Article, {errorOut:false}) )
// console.log(lexer.peek)
///////////////////////////////////////////////////////
// console.log(getParser('the cat is big').parse())
// console.log(getParser('the big cat').parse() )
// console.log(getParser('the big cat on the table is eating tuna').parse() )
// console.log(getParser('the big cat on the mat').parse() )
// console.log(getParser('every dog is stupid').parse() )
// console.log(getParser('the cat that is smart').parse() )
// console.log(getParser('nodejs is not helpful').parse() )
// console.log(getParser('if the dog is stupid then the cat is happy').parse() )
// console.log(getParser('the cat is happy if the dog is stupid').parse() )
// console.log((window as any).ast = getParser('the color of the button is red').parse())
// console.log((window as any).ast = getParser('the color of the button on the black div is red').parse())
// COMPILER TESTS
// function test(string: string) {
//     console.log(string)
//     const clause = getParser(string).parse().toClause().copy({ map: { 'id1': 1000, 'id2': 2000 } })
//     // console.log(clause.flatList().map(c => c.toString()))
//     console.log(clause.toProlog())
//     // console.log(clause)
//     // console.log('entities', clause.entities)
//     // console.log('theme', clause.theme)
//     // console.log('rheme', clause.rheme)
//     // console.log(clause.about('id0'))
// }
// test('the cat is on the mat')
// // test('the cat that is red is on the mat')
// // test('the big cat that is on the mat is black')
// test('every cat is red')
// test('every red cat is on the mat')
// // test('the cat exists on the mat')
// test('if the cat is on the mat then the cat is red')
// // test('the cat is not red')
// test('every cat is not red')
// test('trump is not a great president'); // probably need an and predicate
// END COMPILER TESTS
// (async () => {
//     const brain = await getBrain();
//     const c = clauseOf('capra', 'uno')
//         .concat(clauseOf('capra', 2))
//         .concat(clauseOf('capra', 3))
//         .concat(clauseOf('white', 3))
//         .concat(clauseOf('cat', 4))
//         .concat(clauseOf('white', 4))
//     await brain.assert(c);
//     console.log(await brain.query(clauseOf('white', 'X').concat(clauseOf('cat', 'X'))))
// })()
// (async () => {
//     const state = {
//         timer : setTimeout(()=>{},0),
//         brain : await getBrain(),
//         debouncingTime : 0
//     }
//     const p = document.createElement('p')
//     document.getElementById('root')?.appendChild(p)
//     const textarea = document.createElement('textarea')
//     textarea.style.height = '50vh'
//     textarea.style.width = '50vw'
//     document.getElementById('root')?.appendChild(textarea)
//     const onInput = async () => {
//         const text = textarea.value
//         const ast = getParser(text).parse()
//         const clause = ast.toProlog()
//         if (!clause){
//             return 
//         }
//         const mapping = getSandbox(clause).mapTo(state.brain)
//         p.innerHTML = `${(ast as any).constructor.name}: ${clause.toString()}`
//         if (ast instanceof CopulaQuestion){
//             console.log(await state.brain.query(clause))
//         }else{
//             console.log('asserted:', clause.toString())
//         }
//     }
//     textarea.oninput = e => {
//         clearTimeout(state.timer)
//         state.timer = setTimeout(()=>{
//             onInput()
//         }, state.debouncingTime)
//     }
// })();
// (async () => {
//     const prolog = await getBrain();
//     (window as any).prolog = prolog
//     await prolog.assert(clauseOf('cat', 'a'))
//     await prolog.assert(clauseOf('cat', 'b'))
//     await prolog.assert(clauseOf('cat', 'c'))
//     await prolog.assert(clauseOf('white', 'a'))
//     await prolog.assert(clauseOf('dog', 'd'))
//     await prolog.assert(clauseOf('eat', 'a', 'rabbit'))
//     await prolog.assert(clauseOf('eat', 'a', 'mouse'))
//     await prolog.assert(clauseOf('eat', 'a', 'birdie'))
//     await prolog.assert(clauseOf('eat', 'd', 'bone'))
//     await prolog.assert(clauseOf('table', 'tb1'))
//     // const res = await prolog.query(clauseOf('cat', 'X').concat(clauseOf('eat', 'X', 'Y').concat(clauseOf('dog', 'Z'))))
//     // const clause = clauseOf('cat', 'id0').concat(clauseOf('dog', 'id1')).concat(clauseOf('capra', 'id55')) 
//     // const clause = getParser('the cat that is black is smart').parse().toProlog()
//     const clause = getParser('the cat that is white is on the table').parse().toProlog()
//     console.log(clause.toString())
//     const res = await getSandbox(clause).mapTo(prolog)
//     console.log(res)
//     console.log(clause.rheme.copy({ map: res }).toString())
// })();
// prologPlay()
// compileLogicTest()
(0, playground_1.default)();


/***/ }),

/***/ "./app/src/lexer/EagerLexer.ts":
/*!*************************************!*\
  !*** ./app/src/lexer/EagerLexer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tokenOf_1 = __importDefault(__webpack_require__(/*! ./tokenOf */ "./app/src/lexer/tokenOf.ts"));
class EagerLexer {
    constructor(sourceCode) {
        this.sourceCode = sourceCode;
        //TODO: reconstruct "do not" and "does not" tokens
        //TODO: nouns vs adjectives
        this.tokens = sourceCode.trim().split(/\s+|\./).map(e => !e ? '.' : e).map(tokenOf_1.default);
        console.debug('tokens', this.tokens);
        this._pos = 0;
    }
    next() {
        this._pos++;
    }
    get pos() {
        return this._pos;
    }
    backTo(pos) {
        this._pos = pos;
    }
    get peek() {
        return this.tokens[this._pos];
    }
    croak(errorMsg) {
        throw new Error(`${errorMsg} at ${this._pos}`);
    }
    /**
     * Return current token iff of given type and move to next;
     * else return undefined and don't move.
     * @param args
     * @returns
     */
    assert(clazz, args) {
        var _a, _b;
        const current = this.peek;
        if (current instanceof clazz) {
            this.next();
            return current;
        }
        else if ((_a = args.errorOut) !== null && _a !== void 0 ? _a : true) {
            this.croak((_b = args.errorMsg) !== null && _b !== void 0 ? _b : '');
        }
        else {
            return undefined;
        }
    }
}
exports["default"] = EagerLexer;


/***/ }),

/***/ "./app/src/lexer/Lexer.ts":
/*!********************************!*\
  !*** ./app/src/lexer/Lexer.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLexer = void 0;
const EagerLexer_1 = __importDefault(__webpack_require__(/*! ./EagerLexer */ "./app/src/lexer/EagerLexer.ts"));
function getLexer(sourceCode) {
    return new EagerLexer_1.default(sourceCode);
}
exports.getLexer = getLexer;


/***/ }),

/***/ "./app/src/lexer/tokenOf.ts":
/*!**********************************!*\
  !*** ./app/src/lexer/tokenOf.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const adjectives_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/adjectives */ "./app/res/tokens/adjectives.ts"));
const indefinite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/indefinite_articles */ "./app/res/tokens/indefinite_articles.ts"));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const copulas_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/copulas */ "./app/res/tokens/copulas.ts"));
const hverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/hverbs */ "./app/res/tokens/hverbs.ts"));
const iverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/iverbs */ "./app/res/tokens/iverbs.ts"));
const mverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/mverbs */ "./app/res/tokens/mverbs.ts"));
const negations_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/negations */ "./app/res/tokens/negations.ts"));
const nonsubconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nonsubconj */ "./app/res/tokens/nonsubconj.ts"));
const nouns_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nouns */ "./app/res/tokens/nouns.ts"));
const prepositions_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/prepositions */ "./app/res/tokens/prepositions.ts"));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const relprons_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/relprons */ "./app/res/tokens/relprons.ts"));
const subconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/subconj */ "./app/res/tokens/subconj.ts"));
const then_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/then */ "./app/res/tokens/then.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const HVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/HVerb */ "./app/src/ast/tokens/HVerb.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const NonSubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/NonSubordinatingConjunction */ "./app/src/ast/tokens/NonSubordinatingConjunction.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const FullStop_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/FullStop */ "./app/src/ast/tokens/FullStop.ts"));
function tokenOf(string) {
    if (indefinite_articles_1.default.concat(definite_articles_1.default).includes(string)) {
        return new Article_1.default(string);
    }
    else if (copulas_1.default.includes(string)) {
        return new Copula_1.default(string);
    }
    else if (hverbs_1.default.includes(string)) {
        return new HVerb_1.default(string);
    }
    else if (iverbs_1.default.includes(string)) {
        return new IVerb_1.default(string);
    }
    else if (mverbs_1.default.includes(string)) {
        return new MVerb_1.default(string);
    }
    else if (negations_1.default.includes(string)) {
        return new Negation_1.default(string);
    }
    else if (nonsubconj_1.default.includes(string)) {
        return new NonSubordinatingConjunction_1.default(string);
    }
    else if (prepositions_1.default.includes(string)) {
        return new Preposition_1.default(string);
    }
    else if (existential_quantifiers_1.default.concat(universal_quantifiers_1.default).includes(string)) {
        return new Quantifier_1.default(string);
    }
    else if (then_1.default.includes(string)) {
        return new Then_1.default(string);
    }
    else if (relprons_1.default.includes(string)) {
        return new RelativePronoun_1.default(string);
    }
    else if (subconj_1.default.includes(string)) {
        return new SubordinatingConjunction_1.default(string);
    }
    else if (nouns_1.default.includes(string)) {
        return new Noun_1.default(string);
    }
    else if (adjectives_1.default.includes(string)) {
        return new Adjective_1.default(string);
    }
    else if ('.' === string) {
        return new FullStop_1.default('.');
    }
    return new Adjective_1.default(string);
}
exports["default"] = tokenOf;


/***/ }),

/***/ "./app/src/parser/BasicParser.ts":
/*!***************************************!*\
  !*** ./app/src/parser/BasicParser.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Complement_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/Complement */ "./app/src/ast/phrases/Complement.ts"));
const NounPhrase_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/NounPhrase */ "./app/src/ast/phrases/NounPhrase.ts"));
const ComplexSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/ComplexSentence */ "./app/src/ast/sentences/ComplexSentence.ts"));
const CopulaQuestion_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaQuestion */ "./app/src/ast/sentences/CopulaQuestion.ts"));
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
const IntransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/IntransitiveSentence */ "./app/src/ast/sentences/IntransitiveSentence.ts"));
const MonotransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/MonotransitiveSentence */ "./app/src/ast/sentences/MonotransitiveSentence.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const Lexer_1 = __webpack_require__(/*! ../lexer/Lexer */ "./app/src/lexer/Lexer.ts");
const CopulaSubordinateClause_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/CopulaSubordinateClause */ "./app/src/ast/phrases/CopulaSubordinateClause.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
class BasicParser {
    constructor(sourceCode) {
        this.parseDeclaration = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCompound)) !== null && _a !== void 0 ? _a : this.try(this.parseSimple)) !== null && _b !== void 0 ? _b : this.errorOut('parseDeclaration()');
        };
        this.parseQuestion = () => {
            var _a;
            return (_a = this.try(this.parseBinaryQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseQuestion()');
        };
        this.parseSimple = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCopulaSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseVerbSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseSimple()');
        };
        this.parseCompound = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseComplex)) !== null && _a !== void 0 ? _a : this.try(this.parseConjunctive)) !== null && _b !== void 0 ? _b : this.errorOut('parseCompound()');
        };
        this.parseVerbSentence = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseIntransitiveSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseMonotransitiveSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseVerbSentence()');
        };
        this.parseCopulaSentence = () => {
            const subject = this.parseNounPhrase();
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSentence(), expected copula' });
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const predicate = this.parseNounPhrase();
            return new CopulaSentence_1.default(subject, copula, predicate, negation);
        };
        this.parseComplex = () => {
            const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: false });
            if (subconj) {
                const condition = this.parseSimple();
                this.lx.assert(Then_1.default, { errorOut: false });
                const outcome = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
            else {
                const outcome = this.parseSimple();
                const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: true, errorMsg: 'expected subordinating conjunction' });
                const condition = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
        };
        this.parseIntransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const iverb = this.lx.assert(IVerb_1.default, { errorMsg: 'parseIntransitiveSentence(), expected i-verb' });
            const complements = this.parseComplements();
            return new IntransitiveSentence_1.default(subject, iverb, complements, negation);
        };
        this.parseMonotransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const mverb = this.lx.assert(MVerb_1.default, { errorMsg: 'parseMonotransitiveSentence(), expected i-verb' });
            const cs1 = this.parseComplements();
            const object = this.parseNounPhrase();
            const cs2 = this.parseComplements();
            return new MonotransitiveSentence_1.default(subject, mverb, object, cs1.concat(cs2), negation);
        };
        this.parseBinaryQuestion = () => {
            var _a;
            return (_a = this.try(this.parseCopulaQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseBinaryQuestion()');
        };
        this.parseCopulaQuestion = () => {
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaQuestion(), expected copula' });
            const subject = this.parseNounPhrase();
            const predicate = this.parseNounPhrase();
            return new CopulaQuestion_1.default(subject, predicate, copula);
        };
        this.parseNounPhrase = () => {
            const quantifier = this.lx.assert(Quantifier_1.default, { errorOut: false });
            const article = this.lx.assert(Article_1.default, { errorOut: false });
            let adjectives = [];
            let adj;
            while (adj = this.lx.assert(Adjective_1.default, { errorOut: false })) {
                adjectives.push(adj);
            }
            const noun = this.lx.assert(Noun_1.default, { errorOut: false });
            const subordinateClause = this.try(this.parseSubordinateClause);
            const complements = this.parseComplements();
            return new NounPhrase_1.default(adjectives, complements, noun, quantifier, article, subordinateClause);
        };
        this.parseComplements = () => {
            const complements = [];
            let comp;
            while (comp = this.try(this.parseComplement)) {
                complements.push(comp);
            }
            return complements;
        };
        this.parseComplement = () => {
            const preposition = this.lx.assert(Preposition_1.default, { errorMsg: 'parseComplement() expected preposition' });
            const nounPhrase = this.parseNounPhrase();
            return new Complement_1.default(preposition, nounPhrase);
        };
        this.parseSubordinateClause = () => {
            var _a;
            return (_a = this.try(this.parseCopulaSubordinateClause)) !== null && _a !== void 0 ? _a : this.errorOut('parseSubordinateClause()');
        };
        this.parseCopulaSubordinateClause = () => {
            const relpron = this.lx.assert(RelativePronoun_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected relative pronoun' });
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected copula' });
            const subject = this.parseNounPhrase();
            return new CopulaSubordinateClause_1.default(relpron, subject, copula);
        };
        this.parseConjunctive = () => {
            throw new Error('NOT IMPLEMENTED! TODO!');
        };
        this.lx = (0, Lexer_1.getLexer)(sourceCode);
    }
    try(method) {
        const memento = this.lx.pos;
        try {
            return method();
        }
        catch (error) {
            console.debug(error.message);
            this.lx.backTo(memento);
        }
    }
    errorOut(errorMsg) {
        this.lx.croak(errorMsg);
        throw new Error(errorMsg);
    }
    parse() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.try(this.parseQuestion)) !== null && _a !== void 0 ? _a : this.try(this.parseDeclaration)) !== null && _b !== void 0 ? _b : this.try(this.parseNounPhrase) // for quick topic reference
        ) !== null && _c !== void 0 ? _c : this.errorOut('parse()');
    }
}
exports["default"] = BasicParser;


/***/ }),

/***/ "./app/src/parser/Parser.ts":
/*!**********************************!*\
  !*** ./app/src/parser/Parser.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParser = void 0;
const BasicParser_1 = __importDefault(__webpack_require__(/*! ./BasicParser */ "./app/src/parser/BasicParser.ts"));
function getParser(sourceCode) {
    return new BasicParser_1.default(sourceCode);
}
exports.getParser = getParser;


/***/ }),

/***/ "./app/src/prolog/Prolog.ts":
/*!**********************************!*\
  !*** ./app/src/prolog/Prolog.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProlog = void 0;
const TauProlog_1 = __importDefault(__webpack_require__(/*! ./TauProlog */ "./app/src/prolog/TauProlog.ts"));
function getProlog() {
    return new TauProlog_1.default();
}
exports.getProlog = getProlog;


/***/ }),

/***/ "./app/src/prolog/TauProlog.ts":
/*!*************************************!*\
  !*** ./app/src/prolog/TauProlog.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tau_prolog_1 = __importDefault(__webpack_require__(/*! tau-prolog */ "./node_modules/tau-prolog/modules/core.js"));
__webpack_require__(/*! tau-prolog/modules/promises.js */ "./node_modules/tau-prolog/modules/promises.js")(tau_prolog_1.default);
class TauProlog {
    constructor() {
        this.session = tau_prolog_1.default.create();
    }
    assert(clause, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`assert${(opts === null || opts === void 0 ? void 0 : opts.z) ? 'z' : 'a'}( ( ${clause} ) ).`);
            return yield this.session.promiseAnswer();
        });
    }
    retract(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`retract(${clause}).`);
            return yield this.session.promiseAnswer();
        });
    }
    performQuery(code) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(code);
            let answers = [];
            try {
                for (var _b = __asyncValues(this.session.promiseAnswers()), _c; _c = yield _b.next(), !_c.done;) {
                    let ans = _c.value;
                    const fmans = tau_prolog_1.default.format_answer(ans);
                    if (['true', 'false'].includes(fmans)) {
                        return fmans === 'true';
                    }
                    const links = ans.links;
                    const entry = Object.keys(links)
                        .map(k => { var _a; return ({ [k]: (_a = links[k].value) !== null && _a !== void 0 ? _a : links[k].id }); })
                        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
                    answers.push(entry);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.queryHasVar(code)) {
                return answers;
            }
            else {
                return false;
            }
        });
    }
    query(code) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.performQuery(code);
            }
            catch (e) {
                console.warn(this.parseError(e));
                return false;
            }
        });
    }
    parseError(e) {
        const error = e.args[0].args[0].id;
        if (error == 'existence_error') {
            const missingPredicate = e.args[0].args[0].args[1].args[0].id;
            return { error, missingPredicate };
        }
        else {
            return e;
        }
    }
    queryHasVar(code) {
        return code.split('').find(c => c.match(/\w+/) && c.toUpperCase() === c);
    }
    predicates(opts) {
        return Object.keys(this.session.rules)
            .map(r => r.split('/'))
            .filter(t => (opts === null || opts === void 0 ? void 0 : opts.arity) !== undefined ? parseInt(t[1]) === (opts === null || opts === void 0 ? void 0 : opts.arity) : true)
            .map(t => t[0]);
    }
}
exports["default"] = TauProlog;


/***/ }),

/***/ "./app/src/tests/playground.ts":
/*!*************************************!*\
  !*** ./app/src/tests/playground.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Brain_1 = __webpack_require__(/*! ../brain/Brain */ "./app/src/brain/Brain.ts");
function playground() {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const brain = yield (0, Brain_1.getBrain)();
        const button = document.createElement('button');
        button.innerText = 'run';
        (_a = document.getElementById('root')) === null || _a === void 0 ? void 0 : _a.appendChild(button);
        const parag = document.createElement('p');
        (_b = document.getElementById('root')) === null || _b === void 0 ? void 0 : _b.appendChild(parag);
        const textarea = document.createElement('textarea');
        textarea.style.height = '50vh';
        textarea.style.width = '50vw';
        (_c = document.getElementById('root')) === null || _c === void 0 ? void 0 : _c.appendChild(textarea);
        button.onclick = (e) => __awaiter(this, void 0, void 0, function* () {
            console.log(yield brain.execute(textarea.value));
        });
    });
}
exports["default"] = playground;


/***/ }),

/***/ "?a95c":
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4ec4":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b05a":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a1b8":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1b04":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4a0f":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4461":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./app/src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpQkFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFlO0FBQzdDO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0RBQWtELEVBQUU7QUFDcEQ7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQXlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBMEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdDQUF3QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrREFBa0Q7QUFDbEQsa0VBQWtFO0FBQ2xFLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBb0Q7QUFDL0QsV0FBVywwQkFBMEI7QUFDckMsV0FBVyxFQUFFLFlBQVk7QUFDekIsV0FBVywrQkFBK0I7QUFDMUMsV0FBVyxjQUFjO0FBQ3pCLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLFVBQVUsY0FBYztBQUN4QixVQUFVLDREQUE0RDtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QywyRUFBMkU7QUFDM0UsaUZBQWlGO0FBQ2pGLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQWtEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDBDQUEwQztBQUNqRjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxjQUFjLHlDQUF5QztBQUN2RCxNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILHVDQUF1QztBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsbUJBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUJBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7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Q0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2QkFBNkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0JBQStCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLHFDQUFxQyx5QkFBeUI7QUFDOUQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0Msc0NBQXNDLHlCQUF5QjtBQUMvRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsUUFBUTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVSx3QkFBd0I7QUFDN0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsd0JBQXdCO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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Q0FBQyxDQUFDO1FBQ3BELENBQUM7O0NBRUo7QUFwQkQsZ0NBb0JDOzs7Ozs7Ozs7OztBQ3RCRDs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7OztBQ0FBOzs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7QUNBQTs7Ozs7O1VDQUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N0QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1VFUEQ7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWIvcmVhZGxpbmUtc3luYy5qcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9ub2RlX21vZHVsZXMvdGF1LXByb2xvZy9tb2R1bGVzL2NvcmUuanMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vbm9kZV9tb2R1bGVzL3RhdS1wcm9sb2cvbW9kdWxlcy9wcm9taXNlcy5qcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9hZGplY3RpdmVzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2NvcHVsYXMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvZGVmaW5pdGVfYXJ0aWNsZXMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvZXhpc3RlbnRpYWxfcXVhbnRpZmllcnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvaHZlcmJzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2luZGVmaW5pdGVfYXJ0aWNsZXMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvaXZlcmJzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL212ZXJicy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9uZWdhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvbm9uc3ViY29uai50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9ub3Vucy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9wcmVwb3NpdGlvbnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvcmVscHJvbnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvc3ViY29uai50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy90aGVuLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL3VuaXZlcnNhbF9xdWFudGlmaWVycy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9waHJhc2VzL0NvbXBsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvcGhyYXNlcy9Db3B1bGFTdWJvcmRpbmF0ZUNsYXVzZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9waHJhc2VzL05vdW5QaHJhc2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3Qvc2VudGVuY2VzL0NvbXBsZXhTZW50ZW5jZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9zZW50ZW5jZXMvQ29wdWxhUXVlc3Rpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3Qvc2VudGVuY2VzL0NvcHVsYVNlbnRlbmNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3NlbnRlbmNlcy9JbnRyYW5zaXRpdmVTZW50ZW5jZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9zZW50ZW5jZXMvTW9ub3RyYW5zaXRpdmVTZW50ZW5jZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvQWJzdHJhY3RUb2tlbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvQWRqZWN0aXZlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9BcnRpY2xlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9Db3B1bGEudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0Z1bGxTdG9wLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9IVmVyYi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvSVZlcmIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL01WZXJiLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9OZWdhdGlvbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvTm9uU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9Ob3VuLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9QcmVwb3NpdGlvbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvUXVhbnRpZmllci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvUmVsYXRpdmVQcm9ub3VuLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL1RoZW4udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9icmFpbi9CcmFpbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2JyYWluL1Byb2xvZ0JyYWluLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYnJhaW4vU2FuZGJveC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2NsYXVzZXMvQmFzaWNDbGF1c2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9jbGF1c2VzL0NsYXVzZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2NsYXVzZXMvSW1wbHkudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9jbGF1c2VzL0xpc3RDbGF1c2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2xleGVyL0VhZ2VyTGV4ZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9sZXhlci9MZXhlci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2xleGVyL3Rva2VuT2YudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9wYXJzZXIvQmFzaWNQYXJzZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9wYXJzZXIvUGFyc2VyLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvcHJvbG9nL1Byb2xvZy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL3Byb2xvZy9UYXVQcm9sb2cudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy90ZXN0cy9wbGF5Z3JvdW5kLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy9yZWFkbGluZS1zeW5jL2xpYnxjaGlsZF9wcm9jZXNzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy9yZWFkbGluZS1zeW5jL2xpYnxjcnlwdG8iLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGlifGZzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy9yZWFkbGluZS1zeW5jL2xpYnxvcyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWJ8cGF0aCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvdGF1LXByb2xvZy9tb2R1bGVzfGZzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy90YXUtcHJvbG9nL21vZHVsZXN8cGF0aCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L3dlYnBhY2svc3RhcnR1cCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvd2VicGFjay9hZnRlci1zdGFydHVwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiByZWFkbGluZVN5bmNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbnNla2kvcmVhZGxpbmUtc3luY1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxOCBhbnNla2lcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhclxuICBJU19XSU4gPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInLFxuXG4gIEFMR09SSVRITV9DSVBIRVIgPSAnYWVzLTI1Ni1jYmMnLFxuICBBTEdPUklUSE1fSEFTSCA9ICdzaGEyNTYnLFxuICBERUZBVUxUX0VSUl9NU0cgPSAnVGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc25cXCd0IHN1cHBvcnQgaW50ZXJhY3RpdmUgcmVhZGluZyBmcm9tIFRUWS4nLFxuXG4gIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgVFRZID0gcHJvY2Vzcy5iaW5kaW5nKCd0dHlfd3JhcCcpLlRUWSxcbiAgY2hpbGRQcm9jID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLFxuICBwYXRoVXRpbCA9IHJlcXVpcmUoJ3BhdGgnKSxcblxuICBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICAgIHByb21wdDogICAgICAgICAgICAgJz4gJyxcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgIG1hc2s6ICAgICAgICAgICAgICAgJyonLFxuICAgIGxpbWl0OiAgICAgICAgICAgICAgW10sXG4gICAgbGltaXRNZXNzYWdlOiAgICAgICAnSW5wdXQgYW5vdGhlciwgcGxlYXNlLiQ8KCBbKWxpbWl0KF0pPicsXG4gICAgZGVmYXVsdElucHV0OiAgICAgICAnJyxcbiAgICB0cnVlVmFsdWU6ICAgICAgICAgIFtdLFxuICAgIGZhbHNlVmFsdWU6ICAgICAgICAgW10sXG4gICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZSxcbiAgICBrZWVwV2hpdGVzcGFjZTogICAgIGZhbHNlLFxuICAgIGVuY29kaW5nOiAgICAgICAgICAgJ3V0ZjgnLFxuICAgIGJ1ZmZlclNpemU6ICAgICAgICAgMTAyNCxcbiAgICBwcmludDogICAgICAgICAgICAgIHZvaWQgMCxcbiAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWUsXG4gICAgY2Q6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICBwaENvbnRlbnQ6ICAgICAgICAgIHZvaWQgMCxcbiAgICBwcmVDaGVjazogICAgICAgICAgIHZvaWQgMFxuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfSxcblxuICBmZFIgPSAnbm9uZScsIGZkVywgdHR5UiwgaXNSYXdNb2RlID0gZmFsc2UsXG4gIGV4dEhvc3RQYXRoLCBleHRIb3N0QXJncywgdGVtcGRpciwgc2FsdCA9IDAsXG4gIGxhc3RJbnB1dCA9ICcnLCBpbnB1dEhpc3RvcnkgPSBbXSwgcmF3SW5wdXQsXG4gIF9EQkdfdXNlRXh0ID0gZmFsc2UsIF9EQkdfY2hlY2tPcHRpb25zID0gZmFsc2UsIF9EQkdfY2hlY2tNZXRob2QgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0SG9zdEFyZ3Mob3B0aW9ucykge1xuICAvLyBTZW5kIGFueSB0ZXh0IHRvIGNyYXp5IFdpbmRvd3Mgc2hlbGwgc2FmZWx5LlxuICBmdW5jdGlvbiBlbmNvZGVBcmcoYXJnKSB7XG4gICAgcmV0dXJuIGFyZy5yZXBsYWNlKC9bXlxcd1xcdTAwODAtXFx1RkZGRl0vZywgZnVuY3Rpb24oY2hyKSB7XG4gICAgICByZXR1cm4gJyMnICsgY2hyLmNoYXJDb2RlQXQoMCkgKyAnOyc7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXh0SG9zdEFyZ3MuY29uY2F0KChmdW5jdGlvbihjb25mKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhjb25mKS5mb3JFYWNoKGZ1bmN0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICAgIGlmIChjb25mW29wdGlvbk5hbWVdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uTmFtZV0pIHsgYXJncy5wdXNoKCctLScgKyBvcHRpb25OYW1lKTsgfVxuICAgICAgfSBlbHNlIGlmIChjb25mW29wdGlvbk5hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25OYW1lXSkge1xuICAgICAgICAgIGFyZ3MucHVzaCgnLS0nICsgb3B0aW9uTmFtZSwgZW5jb2RlQXJnKG9wdGlvbnNbb3B0aW9uTmFtZV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcmdzO1xuICB9KSh7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICBkaXNwbGF5OiAgICAgICAgJ3N0cmluZycsXG4gICAgZGlzcGxheU9ubHk6ICAgICdib29sZWFuJyxcbiAgICBrZXlJbjogICAgICAgICAgJ2Jvb2xlYW4nLFxuICAgIGhpZGVFY2hvQmFjazogICAnYm9vbGVhbicsXG4gICAgbWFzazogICAgICAgICAgICdzdHJpbmcnLFxuICAgIGxpbWl0OiAgICAgICAgICAnc3RyaW5nJyxcbiAgICBjYXNlU2Vuc2l0aXZlOiAgJ2Jvb2xlYW4nXG4gICAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICB9KSk7XG59XG5cbi8vIHBpcGluZyB2aWEgZmlsZXMgKGZvciBOb2RlLmpzIHYwLjEwLSlcbmZ1bmN0aW9uIF9leGVjRmlsZVN5bmMob3B0aW9ucywgZXhlY09wdGlvbnMpIHtcblxuICBmdW5jdGlvbiBnZXRUZW1wZmlsZShuYW1lKSB7XG4gICAgdmFyIGZpbGVwYXRoLCBzdWZmaXggPSAnJywgZmQ7XG4gICAgdGVtcGRpciA9IHRlbXBkaXIgfHwgcmVxdWlyZSgnb3MnKS50bXBkaXIoKTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBmaWxlcGF0aCA9IHBhdGhVdGlsLmpvaW4odGVtcGRpciwgbmFtZSArIHN1ZmZpeCk7XG4gICAgICB0cnkge1xuICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKGZpbGVwYXRoLCAnd3gnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSA9PT0gJ0VFWElTVCcpIHtcbiAgICAgICAgICBzdWZmaXgrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBmaWxlcGF0aDtcbiAgfVxuXG4gIHZhciBob3N0QXJncywgc2hlbGxQYXRoLCBzaGVsbEFyZ3MsIHJlcyA9IHt9LCBleGl0Q29kZSwgZXh0TWVzc2FnZSxcbiAgICBwYXRoU3Rkb3V0ID0gZ2V0VGVtcGZpbGUoJ3JlYWRsaW5lLXN5bmMuc3Rkb3V0JyksXG4gICAgcGF0aFN0ZGVyciA9IGdldFRlbXBmaWxlKCdyZWFkbGluZS1zeW5jLnN0ZGVycicpLFxuICAgIHBhdGhFeGl0ID0gZ2V0VGVtcGZpbGUoJ3JlYWRsaW5lLXN5bmMuZXhpdCcpLFxuICAgIHBhdGhEb25lID0gZ2V0VGVtcGZpbGUoJ3JlYWRsaW5lLXN5bmMuZG9uZScpLFxuICAgIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpLCBzaGFzdW0sIGRlY2lwaGVyLCBwYXNzd29yZDtcblxuICBzaGFzdW0gPSBjcnlwdG8uY3JlYXRlSGFzaChBTEdPUklUSE1fSEFTSCk7XG4gIHNoYXN1bS51cGRhdGUoJycgKyBwcm9jZXNzLnBpZCArIChzYWx0KyspICsgTWF0aC5yYW5kb20oKSk7XG4gIHBhc3N3b3JkID0gc2hhc3VtLmRpZ2VzdCgnaGV4Jyk7XG4gIGRlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyKEFMR09SSVRITV9DSVBIRVIsIHBhc3N3b3JkKTtcblxuICBob3N0QXJncyA9IGdldEhvc3RBcmdzKG9wdGlvbnMpO1xuICBpZiAoSVNfV0lOKSB7XG4gICAgc2hlbGxQYXRoID0gcHJvY2Vzcy5lbnYuQ29tU3BlYyB8fCAnY21kLmV4ZSc7XG4gICAgcHJvY2Vzcy5lbnYuUSA9ICdcIic7IC8vIFRoZSBxdW90ZSAoXCIpIHRoYXQgaXNuJ3QgZXNjYXBlZC5cbiAgICAvLyBgKClgIGZvciBpZ25vcmUgc3BhY2UgYnkgZWNob1xuICAgIHNoZWxsQXJncyA9IFsnL1Y6T04nLCAnL1MnLCAnL0MnLFxuICAgICAgJyglUSUnICsgc2hlbGxQYXRoICsgJyVRJSAvVjpPTiAvUyAvQyAlUSUnICsgLyogRVNMaW50IGJ1Zz8gKi8gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxuICAgICAgICAnJVElJyArIGV4dEhvc3RQYXRoICsgJyVRJScgK1xuICAgICAgICAgIGhvc3RBcmdzLm1hcChmdW5jdGlvbihhcmcpIHsgcmV0dXJuICcgJVElJyArIGFyZyArICclUSUnOyB9KS5qb2luKCcnKSArXG4gICAgICAgICcgJiAoZWNobyAhRVJST1JMRVZFTCEpPiVRJScgKyBwYXRoRXhpdCArICclUSUlUSUpIDI+JVElJyArIHBhdGhTdGRlcnIgKyAnJVElJyArXG4gICAgICAnIHwlUSUnICsgcHJvY2Vzcy5leGVjUGF0aCArICclUSUgJVElJyArIF9fZGlybmFtZSArICdcXFxcZW5jcnlwdC5qcyVRJScgK1xuICAgICAgICAnICVRJScgKyBBTEdPUklUSE1fQ0lQSEVSICsgJyVRJSAlUSUnICsgcGFzc3dvcmQgKyAnJVElJyArXG4gICAgICAgICcgPiVRJScgKyBwYXRoU3Rkb3V0ICsgJyVRJScgK1xuICAgICAgJyAmIChlY2hvIDEpPiVRJScgKyBwYXRoRG9uZSArICclUSUnXTtcbiAgfSBlbHNlIHtcbiAgICBzaGVsbFBhdGggPSAnL2Jpbi9zaCc7XG4gICAgc2hlbGxBcmdzID0gWyctYycsXG4gICAgICAvLyBVc2UgYCgpYCwgbm90IGB7fWAgZm9yIGAtY2AgKHRleHQgcGFyYW0pXG4gICAgICAnKFwiJyArIGV4dEhvc3RQYXRoICsgJ1wiJyArIC8qIEVTTGludCBidWc/ICovIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcbiAgICAgICAgICBob3N0QXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7IHJldHVybiBcIiAnXCIgKyBhcmcucmVwbGFjZSgvJy9nLCBcIidcXFxcJydcIikgKyBcIidcIjsgfSkuam9pbignJykgK1xuICAgICAgICAnOyBlY2hvICQ/PlwiJyArIHBhdGhFeGl0ICsgJ1wiKSAyPlwiJyArIHBhdGhTdGRlcnIgKyAnXCInICtcbiAgICAgICcgfFwiJyArIHByb2Nlc3MuZXhlY1BhdGggKyAnXCIgXCInICsgX19kaXJuYW1lICsgJy9lbmNyeXB0LmpzXCInICtcbiAgICAgICAgJyBcIicgKyBBTEdPUklUSE1fQ0lQSEVSICsgJ1wiIFwiJyArIHBhc3N3b3JkICsgJ1wiJyArXG4gICAgICAgICcgPlwiJyArIHBhdGhTdGRvdXQgKyAnXCInICtcbiAgICAgICc7IGVjaG8gMSA+XCInICsgcGF0aERvbmUgKyAnXCInXTtcbiAgfVxuICBpZiAoX0RCR19jaGVja01ldGhvZCkgeyBfREJHX2NoZWNrTWV0aG9kKCdfZXhlY0ZpbGVTeW5jJywgaG9zdEFyZ3MpOyB9XG4gIHRyeSB7XG4gICAgY2hpbGRQcm9jLnNwYXduKHNoZWxsUGF0aCwgc2hlbGxBcmdzLCBleGVjT3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXMuZXJyb3IgPSBuZXcgRXJyb3IoZS5tZXNzYWdlKTtcbiAgICByZXMuZXJyb3IubWV0aG9kID0gJ19leGVjRmlsZVN5bmMgLSBzcGF3bic7XG4gICAgcmVzLmVycm9yLnByb2dyYW0gPSBzaGVsbFBhdGg7XG4gICAgcmVzLmVycm9yLmFyZ3MgPSBzaGVsbEFyZ3M7XG4gIH1cblxuICB3aGlsZSAoZnMucmVhZEZpbGVTeW5jKHBhdGhEb25lLCB7ZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2Rpbmd9KS50cmltKCkgIT09ICcxJykge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuICBpZiAoKGV4aXRDb2RlID1cbiAgICAgIGZzLnJlYWRGaWxlU3luYyhwYXRoRXhpdCwge2VuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nfSkudHJpbSgpKSA9PT0gJzAnKSB7XG4gICAgcmVzLmlucHV0ID1cbiAgICAgIGRlY2lwaGVyLnVwZGF0ZShmcy5yZWFkRmlsZVN5bmMocGF0aFN0ZG91dCwge2VuY29kaW5nOiAnYmluYXJ5J30pLFxuICAgICAgICAnaGV4Jywgb3B0aW9ucy5lbmNvZGluZykgK1xuICAgICAgZGVjaXBoZXIuZmluYWwob3B0aW9ucy5lbmNvZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgZXh0TWVzc2FnZSA9IGZzLnJlYWRGaWxlU3luYyhwYXRoU3RkZXJyLCB7ZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2Rpbmd9KS50cmltKCk7XG4gICAgcmVzLmVycm9yID0gbmV3IEVycm9yKERFRkFVTFRfRVJSX01TRyArIChleHRNZXNzYWdlID8gJ1xcbicgKyBleHRNZXNzYWdlIDogJycpKTtcbiAgICByZXMuZXJyb3IubWV0aG9kID0gJ19leGVjRmlsZVN5bmMnO1xuICAgIHJlcy5lcnJvci5wcm9ncmFtID0gc2hlbGxQYXRoO1xuICAgIHJlcy5lcnJvci5hcmdzID0gc2hlbGxBcmdzO1xuICAgIHJlcy5lcnJvci5leHRNZXNzYWdlID0gZXh0TWVzc2FnZTtcbiAgICByZXMuZXJyb3IuZXhpdENvZGUgPSArZXhpdENvZGU7XG4gIH1cblxuICBmcy51bmxpbmtTeW5jKHBhdGhTdGRvdXQpO1xuICBmcy51bmxpbmtTeW5jKHBhdGhTdGRlcnIpO1xuICBmcy51bmxpbmtTeW5jKHBhdGhFeGl0KTtcbiAgZnMudW5saW5rU3luYyhwYXRoRG9uZSk7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcmVhZGxpbmVFeHQob3B0aW9ucykge1xuICB2YXIgaG9zdEFyZ3MsIHJlcyA9IHt9LCBleHRNZXNzYWdlLFxuICAgIGV4ZWNPcHRpb25zID0ge2VudjogcHJvY2Vzcy5lbnYsIGVuY29kaW5nOiBvcHRpb25zLmVuY29kaW5nfTtcblxuICBpZiAoIWV4dEhvc3RQYXRoKSB7XG4gICAgaWYgKElTX1dJTikge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LlBTTW9kdWxlUGF0aCkgeyAvLyBXaW5kb3dzIFBvd2VyU2hlbGxcbiAgICAgICAgZXh0SG9zdFBhdGggPSAncG93ZXJzaGVsbC5leGUnO1xuICAgICAgICBleHRIb3N0QXJncyA9IFsnLUV4ZWN1dGlvblBvbGljeScsICdCeXBhc3MnLCAnLUZpbGUnLCBfX2Rpcm5hbWUgKyAnXFxcXHJlYWQucHMxJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcbiAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2luZG93cyBTY3JpcHQgSG9zdFxuICAgICAgICBleHRIb3N0UGF0aCA9ICdjc2NyaXB0LmV4ZSc7XG4gICAgICAgIGV4dEhvc3RBcmdzID0gWycvL25vbG9nbycsIF9fZGlybmFtZSArICdcXFxccmVhZC5jcy5qcyddOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4dEhvc3RQYXRoID0gJy9iaW4vc2gnO1xuICAgICAgZXh0SG9zdEFyZ3MgPSBbX19kaXJuYW1lICsgJy9yZWFkLnNoJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcbiAgICB9XG4gIH1cbiAgaWYgKElTX1dJTiAmJiAhcHJvY2Vzcy5lbnYuUFNNb2R1bGVQYXRoKSB7IC8vIFdpbmRvd3MgU2NyaXB0IEhvc3RcbiAgICAvLyBTY3JpcHRQVyAoV2luIFhQIGFuZCBTZXJ2ZXIyMDAzKSBuZWVkcyBUVFkgc3RyZWFtIGFzIFNURElOLlxuICAgIC8vIEluIHRoaXMgY2FzZSwgSWYgU1RESU4gaXNuJ3QgVFRZLCBhbiBlcnJvciBpcyB0aHJvd24uXG4gICAgZXhlY09wdGlvbnMuc3RkaW8gPSBbcHJvY2Vzcy5zdGRpbl07XG4gIH1cblxuICBpZiAoY2hpbGRQcm9jLmV4ZWNGaWxlU3luYykge1xuICAgIGhvc3RBcmdzID0gZ2V0SG9zdEFyZ3Mob3B0aW9ucyk7XG4gICAgaWYgKF9EQkdfY2hlY2tNZXRob2QpIHsgX0RCR19jaGVja01ldGhvZCgnZXhlY0ZpbGVTeW5jJywgaG9zdEFyZ3MpOyB9XG4gICAgdHJ5IHtcbiAgICAgIHJlcy5pbnB1dCA9IGNoaWxkUHJvYy5leGVjRmlsZVN5bmMoZXh0SG9zdFBhdGgsIGhvc3RBcmdzLCBleGVjT3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkgeyAvLyBub24temVybyBleGl0IGNvZGVcbiAgICAgIGV4dE1lc3NhZ2UgPSBlLnN0ZGVyciA/IChlLnN0ZGVyciArICcnKS50cmltKCkgOiAnJztcbiAgICAgIHJlcy5lcnJvciA9IG5ldyBFcnJvcihERUZBVUxUX0VSUl9NU0cgKyAoZXh0TWVzc2FnZSA/ICdcXG4nICsgZXh0TWVzc2FnZSA6ICcnKSk7XG4gICAgICByZXMuZXJyb3IubWV0aG9kID0gJ2V4ZWNGaWxlU3luYyc7XG4gICAgICByZXMuZXJyb3IucHJvZ3JhbSA9IGV4dEhvc3RQYXRoO1xuICAgICAgcmVzLmVycm9yLmFyZ3MgPSBob3N0QXJncztcbiAgICAgIHJlcy5lcnJvci5leHRNZXNzYWdlID0gZXh0TWVzc2FnZTtcbiAgICAgIHJlcy5lcnJvci5leGl0Q29kZSA9IGUuc3RhdHVzO1xuICAgICAgcmVzLmVycm9yLmNvZGUgPSBlLmNvZGU7XG4gICAgICByZXMuZXJyb3Iuc2lnbmFsID0gZS5zaWduYWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcyA9IF9leGVjRmlsZVN5bmMob3B0aW9ucywgZXhlY09wdGlvbnMpO1xuICB9XG4gIGlmICghcmVzLmVycm9yKSB7XG4gICAgcmVzLmlucHV0ID0gcmVzLmlucHV0LnJlcGxhY2UoL15cXHMqJ3wnXFxzKiQvZywgJycpO1xuICAgIG9wdGlvbnMuZGlzcGxheSA9ICcnO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuLypcbiAgZGlzcGxheTogICAgICAgICAgICBzdHJpbmdcbiAgZGlzcGxheU9ubHk6ICAgICAgICBib29sZWFuXG4gIGtleUluOiAgICAgICAgICAgICAgYm9vbGVhblxuICBoaWRlRWNob0JhY2s6ICAgICAgIGJvb2xlYW5cbiAgbWFzazogICAgICAgICAgICAgICBzdHJpbmdcbiAgbGltaXQ6ICAgICAgICAgICAgICBzdHJpbmcgKHBhdHRlcm4pXG4gIGNhc2VTZW5zaXRpdmU6ICAgICAgYm9vbGVhblxuICBrZWVwV2hpdGVzcGFjZTogICAgIGJvb2xlYW5cbiAgZW5jb2RpbmcsIGJ1ZmZlclNpemUsIHByaW50XG4qL1xuZnVuY3Rpb24gX3JlYWRsaW5lU3luYyhvcHRpb25zKSB7XG4gIHZhciBpbnB1dCA9ICcnLCBkaXNwbGF5U2F2ZSA9IG9wdGlvbnMuZGlzcGxheSxcbiAgICBzaWxlbnQgPSAhb3B0aW9ucy5kaXNwbGF5ICYmXG4gICAgICBvcHRpb25zLmtleUluICYmIG9wdGlvbnMuaGlkZUVjaG9CYWNrICYmICFvcHRpb25zLm1hc2s7XG5cbiAgZnVuY3Rpb24gdHJ5RXh0KCkge1xuICAgIHZhciByZXMgPSByZWFkbGluZUV4dChvcHRpb25zKTtcbiAgICBpZiAocmVzLmVycm9yKSB7IHRocm93IHJlcy5lcnJvcjsgfVxuICAgIHJldHVybiByZXMuaW5wdXQ7XG4gIH1cblxuICBpZiAoX0RCR19jaGVja09wdGlvbnMpIHsgX0RCR19jaGVja09wdGlvbnMob3B0aW9ucyk7IH1cblxuICAoZnVuY3Rpb24oKSB7IC8vIG9wZW4gVFRZXG4gICAgdmFyIGZzQiwgY29uc3RhbnRzLCB2ZXJOdW07XG5cbiAgICBmdW5jdGlvbiBnZXRGc0IoKSB7XG4gICAgICBpZiAoIWZzQikge1xuICAgICAgICBmc0IgPSBwcm9jZXNzLmJpbmRpbmcoJ2ZzJyk7IC8vIEZvciByYXcgZGV2aWNlIHBhdGhcbiAgICAgICAgY29uc3RhbnRzID0gcHJvY2Vzcy5iaW5kaW5nKCdjb25zdGFudHMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmc0I7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmZFIgIT09ICdzdHJpbmcnKSB7IHJldHVybjsgfVxuICAgIGZkUiA9IG51bGw7XG5cbiAgICBpZiAoSVNfV0lOKSB7XG4gICAgICAvLyBpb2pzLXYyLjMuMisgaW5wdXQgc3RyZWFtIGNhbid0IHJlYWQgZmlyc3QgbGluZS4gKCMxOClcbiAgICAgIC8vICoqIERvbid0IGdldCBwcm9jZXNzLnN0ZGluIGJlZm9yZSBjaGVjayEgKipcbiAgICAgIC8vIEZpeGVkIHY1LjEuMFxuICAgICAgLy8gRml4ZWQgdjQuMi40XG4gICAgICAvLyBJdCByZWdyZXNzZWQgYWdhaW4gaW4gdjUuNi4wLCBpdCBpcyBmaXhlZCBpbiB2Ni4yLjAuXG4gICAgICB2ZXJOdW0gPSAoZnVuY3Rpb24odmVyKSB7IC8vIGdldFZlck51bVxuICAgICAgICB2YXIgbnVtcyA9IHZlci5yZXBsYWNlKC9eXFxEKy8sICcnKS5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgdmVyTnVtID0gMDtcbiAgICAgICAgaWYgKChudW1zWzBdID0gK251bXNbMF0pKSB7IHZlck51bSArPSBudW1zWzBdICogMTAwMDA7IH1cbiAgICAgICAgaWYgKChudW1zWzFdID0gK251bXNbMV0pKSB7IHZlck51bSArPSBudW1zWzFdICogMTAwOyB9XG4gICAgICAgIGlmICgobnVtc1syXSA9ICtudW1zWzJdKSkgeyB2ZXJOdW0gKz0gbnVtc1syXTsgfVxuICAgICAgICByZXR1cm4gdmVyTnVtO1xuICAgICAgfSkocHJvY2Vzcy52ZXJzaW9uKTtcbiAgICAgIGlmICghKHZlck51bSA+PSAyMDMwMiAmJiB2ZXJOdW0gPCA0MDIwNCB8fCB2ZXJOdW0gPj0gNTAwMDAgJiYgdmVyTnVtIDwgNTAxMDAgfHwgdmVyTnVtID49IDUwNjAwICYmIHZlck51bSA8IDYwMjAwKSAmJlxuICAgICAgICAgIHByb2Nlc3Muc3RkaW4uaXNUVFkpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRpbi5wYXVzZSgpO1xuICAgICAgICBmZFIgPSBwcm9jZXNzLnN0ZGluLmZkO1xuICAgICAgICB0dHlSID0gcHJvY2Vzcy5zdGRpbi5faGFuZGxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGUgc3RyZWFtIGJ5IGZzLm9wZW5TeW5jKCdcXFxcXFxcXC5cXFxcQ09OJywgJ3InKSBjYW4ndCBzd2l0Y2ggdG8gcmF3IG1vZGUuXG4gICAgICAgICAgLy8gJ0NPTklOJCcgbWlnaHQgZmFpbCBvbiBYUCwgMjAwMCwgNyAoeDg2KS5cbiAgICAgICAgICBmZFIgPSBnZXRGc0IoKS5vcGVuKCdDT05JTiQnLCBjb25zdGFudHMuT19SRFdSLCBwYXJzZUludCgnMDY2NicsIDgpKTtcbiAgICAgICAgICB0dHlSID0gbmV3IFRUWShmZFIsIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9jZXNzLnN0ZG91dC5pc1RUWSkge1xuICAgICAgICBmZFcgPSBwcm9jZXNzLnN0ZG91dC5mZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmRXID0gZnMub3BlblN5bmMoJ1xcXFxcXFxcLlxcXFxDT04nLCAndycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICAgIGlmICh0eXBlb2YgZmRXICE9PSAnbnVtYmVyJykgeyAvLyBSZXRyeVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZFcgPSBnZXRGc0IoKS5vcGVuKCdDT05PVVQkJywgY29uc3RhbnRzLk9fUkRXUiwgcGFyc2VJbnQoJzA2NjYnLCA4KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3Muc3RkaW4uaXNUVFkpIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRpbi5wYXVzZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZkUiA9IGZzLm9wZW5TeW5jKCcvZGV2L3R0eScsICdyJyk7IC8vIGRldmljZSBmaWxlLCBub3QgcHJvY2Vzcy5zdGRpblxuICAgICAgICAgIHR0eVIgPSBwcm9jZXNzLnN0ZGluLl9oYW5kbGU7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vZGUuanMgdjAuMTIgcmVhZCgpIGZhaWxzLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZkUiA9IGZzLm9wZW5TeW5jKCcvZGV2L3R0eScsICdyJyk7XG4gICAgICAgICAgdHR5UiA9IG5ldyBUVFkoZmRSLCBmYWxzZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG4gICAgICAgIGZkVyA9IHByb2Nlc3Muc3Rkb3V0LmZkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZFcgPSBmcy5vcGVuU3luYygnL2Rldi90dHknLCAndycpO1xuICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICB9XG4gICAgfVxuICB9KSgpO1xuXG4gIChmdW5jdGlvbigpIHsgLy8gdHJ5IHJlYWRcbiAgICB2YXIgYXRFb2wsIGxpbWl0LFxuICAgICAgaXNDb29rZWQgPSAhb3B0aW9ucy5oaWRlRWNob0JhY2sgJiYgIW9wdGlvbnMua2V5SW4sXG4gICAgICBidWZmZXIsIHJlcVNpemUsIHJlYWRTaXplLCBjaHVuaywgbGluZTtcbiAgICByYXdJbnB1dCA9ICcnO1xuXG4gICAgLy8gTm9kZS5qcyB2MC4xMC0gcmV0dXJucyBhbiBlcnJvciBpZiBzYW1lIG1vZGUgaXMgc2V0LlxuICAgIGZ1bmN0aW9uIHNldFJhd01vZGUobW9kZSkge1xuICAgICAgaWYgKG1vZGUgPT09IGlzUmF3TW9kZSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgaWYgKHR0eVIuc2V0UmF3TW9kZShtb2RlKSAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlzUmF3TW9kZSA9IG1vZGU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoX0RCR191c2VFeHQgfHwgIXR0eVIgfHxcbiAgICAgICAgdHlwZW9mIGZkVyAhPT0gJ251bWJlcicgJiYgKG9wdGlvbnMuZGlzcGxheSB8fCAhaXNDb29rZWQpKSB7XG4gICAgICBpbnB1dCA9IHRyeUV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGZzLndyaXRlU3luYyhmZFcsIG9wdGlvbnMuZGlzcGxheSk7XG4gICAgICBvcHRpb25zLmRpc3BsYXkgPSAnJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheU9ubHkpIHsgcmV0dXJuOyB9XG5cbiAgICBpZiAoIXNldFJhd01vZGUoIWlzQ29va2VkKSkge1xuICAgICAgaW5wdXQgPSB0cnlFeHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXFTaXplID0gb3B0aW9ucy5rZXlJbiA/IDEgOiBvcHRpb25zLmJ1ZmZlclNpemU7XG4gICAgLy8gQ2hlY2sgYGFsbG9jVW5zYWZlYCB0byBtYWtlIHN1cmUgb2YgdGhlIG5ldyBBUEkuXG4gICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvYyA/IEJ1ZmZlci5hbGxvYyhyZXFTaXplKSA6IG5ldyBCdWZmZXIocmVxU2l6ZSk7XG5cbiAgICBpZiAob3B0aW9ucy5rZXlJbiAmJiBvcHRpb25zLmxpbWl0KSB7XG4gICAgICBsaW1pdCA9IG5ldyBSZWdFeHAoJ1teJyArIG9wdGlvbnMubGltaXQgKyAnXScsXG4gICAgICAgICdnJyArIChvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyAnJyA6ICdpJykpO1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICByZWFkU2l6ZSA9IDA7XG4gICAgICB0cnkge1xuICAgICAgICByZWFkU2l6ZSA9IGZzLnJlYWRTeW5jKGZkUiwgYnVmZmVyLCAwLCByZXFTaXplKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUuY29kZSAhPT0gJ0VPRicpIHtcbiAgICAgICAgICBzZXRSYXdNb2RlKGZhbHNlKTtcbiAgICAgICAgICBpbnB1dCArPSB0cnlFeHQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZWFkU2l6ZSA+IDApIHtcbiAgICAgICAgY2h1bmsgPSBidWZmZXIudG9TdHJpbmcob3B0aW9ucy5lbmNvZGluZywgMCwgcmVhZFNpemUpO1xuICAgICAgICByYXdJbnB1dCArPSBjaHVuaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNodW5rID0gJ1xcbic7XG4gICAgICAgIHJhd0lucHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaHVuayAmJiB0eXBlb2YgKGxpbmUgPSAoY2h1bmsubWF0Y2goL14oLio/KVtcXHJcXG5dLykgfHwgW10pWzFdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2h1bmsgPSBsaW5lO1xuICAgICAgICBhdEVvbCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG90aGVyIGN0cmwtY2hhcnNcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgICBpZiAoY2h1bmspIHsgY2h1bmsgPSBjaHVuay5yZXBsYWNlKC9bXFx4MDAtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl0vZywgJycpOyB9XG4gICAgICBpZiAoY2h1bmsgJiYgbGltaXQpIHsgY2h1bmsgPSBjaHVuay5yZXBsYWNlKGxpbWl0LCAnJyk7IH1cblxuICAgICAgaWYgKGNodW5rKSB7XG4gICAgICAgIGlmICghaXNDb29rZWQpIHtcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuaGlkZUVjaG9CYWNrKSB7XG4gICAgICAgICAgICBmcy53cml0ZVN5bmMoZmRXLCBjaHVuayk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1hc2spIHtcbiAgICAgICAgICAgIGZzLndyaXRlU3luYyhmZFcsIChuZXcgQXJyYXkoY2h1bmsubGVuZ3RoICsgMSkpLmpvaW4ob3B0aW9ucy5tYXNrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0ICs9IGNodW5rO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMua2V5SW4gJiYgYXRFb2wgfHxcbiAgICAgICAgb3B0aW9ucy5rZXlJbiAmJiBpbnB1dC5sZW5ndGggPj0gcmVxU2l6ZSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIGlmICghaXNDb29rZWQgJiYgIXNpbGVudCkgeyBmcy53cml0ZVN5bmMoZmRXLCAnXFxuJyk7IH1cbiAgICBzZXRSYXdNb2RlKGZhbHNlKTtcbiAgfSkoKTtcblxuICBpZiAob3B0aW9ucy5wcmludCAmJiAhc2lsZW50KSB7XG4gICAgb3B0aW9ucy5wcmludChkaXNwbGF5U2F2ZSArIChvcHRpb25zLmRpc3BsYXlPbmx5ID8gJycgOlxuICAgICAgICAob3B0aW9ucy5oaWRlRWNob0JhY2sgPyAobmV3IEFycmF5KGlucHV0Lmxlbmd0aCArIDEpKS5qb2luKG9wdGlvbnMubWFzaylcbiAgICAgICAgICA6IGlucHV0KSArICdcXG4nKSwgLy8gbXVzdCBhdCBsZWFzdCB3cml0ZSAnXFxuJ1xuICAgICAgb3B0aW9ucy5lbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9ucy5kaXNwbGF5T25seSA/ICcnIDpcbiAgICAobGFzdElucHV0ID0gb3B0aW9ucy5rZWVwV2hpdGVzcGFjZSB8fCBvcHRpb25zLmtleUluID8gaW5wdXQgOiBpbnB1dC50cmltKCkpO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQXJyYXkoYXJyYXksIHZhbGlkYXRvcikge1xuICB2YXIgZmxhdEFycmF5ID0gW107XG4gIGZ1bmN0aW9uIF9mbGF0dGVuQXJyYXkoYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgIGFycmF5LmZvckVhY2goX2ZsYXR0ZW5BcnJheSk7XG4gICAgfSBlbHNlIGlmICghdmFsaWRhdG9yIHx8IHZhbGlkYXRvcihhcnJheSkpIHtcbiAgICAgIGZsYXRBcnJheS5wdXNoKGFycmF5KTtcbiAgICB9XG4gIH1cbiAgX2ZsYXR0ZW5BcnJheShhcnJheSk7XG4gIHJldHVybiBmbGF0QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVBhdHRlcm4ocGF0dGVybikge1xuICByZXR1cm4gcGF0dGVybi5yZXBsYWNlKC9bXFx4MDAtXFx4N2ZdL2csIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuICdcXFxceCcgKyAoJzAwJyArIHMuY2hhckNvZGVBdCgpLnRvU3RyaW5nKDE2KSkuc3Vic3RyKC0yKTsgfSk7XG59XG5cbi8vIG1hcmdlT3B0aW9ucyhvcHRpb25zMSwgb3B0aW9uczIgLi4uIClcbi8vIG1hcmdlT3B0aW9ucyh0cnVlLCBvcHRpb25zMSwgb3B0aW9uczIgLi4uIClcbi8vICAgIGFyZzE9dHJ1ZSA6IFN0YXJ0IGZyb20gZGVmYXVsdE9wdGlvbnMgYW5kIHBpY2sgZWxlbWVudHMgb2YgdGhhdC5cbmZ1bmN0aW9uIG1hcmdlT3B0aW9ucygpIHtcbiAgdmFyIG9wdGlvbnNMaXN0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICBvcHRpb25OYW1lcywgZnJvbURlZmF1bHQ7XG5cbiAgaWYgKG9wdGlvbnNMaXN0Lmxlbmd0aCAmJiB0eXBlb2Ygb3B0aW9uc0xpc3RbMF0gPT09ICdib29sZWFuJykge1xuICAgIGZyb21EZWZhdWx0ID0gb3B0aW9uc0xpc3Quc2hpZnQoKTtcbiAgICBpZiAoZnJvbURlZmF1bHQpIHtcbiAgICAgIG9wdGlvbk5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgb3B0aW9uc0xpc3QudW5zaGlmdChkZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9wdGlvbnNMaXN0LnJlZHVjZShmdW5jdGlvbihvcHRpb25zLCBvcHRpb25zUGFydCkge1xuICAgIGlmIChvcHRpb25zUGFydCA9PSBudWxsKSB7IHJldHVybiBvcHRpb25zOyB9XG5cbiAgICAvLyA9PT09PT09PSBERVBSRUNBVEVEID09PT09PT09XG4gICAgaWYgKG9wdGlvbnNQYXJ0Lmhhc093blByb3BlcnR5KCdub0VjaG9CYWNrJykgJiZcbiAgICAgICAgIW9wdGlvbnNQYXJ0Lmhhc093blByb3BlcnR5KCdoaWRlRWNob0JhY2snKSkge1xuICAgICAgb3B0aW9uc1BhcnQuaGlkZUVjaG9CYWNrID0gb3B0aW9uc1BhcnQubm9FY2hvQmFjaztcbiAgICAgIGRlbGV0ZSBvcHRpb25zUGFydC5ub0VjaG9CYWNrO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1BhcnQuaGFzT3duUHJvcGVydHkoJ25vVHJpbScpICYmXG4gICAgICAgICFvcHRpb25zUGFydC5oYXNPd25Qcm9wZXJ0eSgna2VlcFdoaXRlc3BhY2UnKSkge1xuICAgICAgb3B0aW9uc1BhcnQua2VlcFdoaXRlc3BhY2UgPSBvcHRpb25zUGFydC5ub1RyaW07XG4gICAgICBkZWxldGUgb3B0aW9uc1BhcnQubm9UcmltO1xuICAgIH1cbiAgICAvLyA9PT09PT09PSAvREVQUkVDQVRFRCA9PT09PT09PVxuXG4gICAgaWYgKCFmcm9tRGVmYXVsdCkgeyBvcHRpb25OYW1lcyA9IE9iamVjdC5rZXlzKG9wdGlvbnNQYXJ0KTsgfVxuICAgIG9wdGlvbk5hbWVzLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uTmFtZSkge1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKCFvcHRpb25zUGFydC5oYXNPd25Qcm9wZXJ0eShvcHRpb25OYW1lKSkgeyByZXR1cm47IH1cbiAgICAgIHZhbHVlID0gb3B0aW9uc1BhcnRbb3B0aW9uTmFtZV07XG4gICAgICBzd2l0Y2ggKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIF9yZWFkbGluZVN5bmMgPC0gKiAgICAqIC0+IGRlZmF1bHRPcHRpb25zXG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gc3RyaW5nXG4gICAgICAgIGNhc2UgJ21hc2snOiAgICAgICAgICAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICBjYXNlICdsaW1pdE1lc3NhZ2UnOiAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAnZGVmYXVsdElucHV0JzogICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ2VuY29kaW5nJzogICAgICAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICAgIHZhbHVlID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlICsgJycgOiAnJztcbiAgICAgICAgICBpZiAodmFsdWUgJiYgb3B0aW9uTmFtZSAhPT0gJ2xpbWl0TWVzc2FnZScpIHsgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXFxyXFxuXS9nLCAnJyk7IH1cbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gbnVtYmVyKGludClcbiAgICAgICAgY2FzZSAnYnVmZmVyU2l6ZSc6ICAgICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCkpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTsgLy8gbGltaXRlZCB1cGRhdGluZyAobnVtYmVyIGlzIG5lZWRlZClcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gYm9vbGVhblxuICAgICAgICBjYXNlICdkaXNwbGF5T25seSc6ICAgICAgICAgICAgICAgICAvLyAqXG4gICAgICAgIGNhc2UgJ2tleUluJzogICAgICAgICAgICAgICAgICAgICAgIC8vICpcbiAgICAgICAgY2FzZSAnaGlkZUVjaG9CYWNrJzogICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgIGNhc2UgJ2Nhc2VTZW5zaXRpdmUnOiAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICBjYXNlICdrZWVwV2hpdGVzcGFjZSc6ICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgY2FzZSAnaGlzdG9yeSc6ICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ2NkJzogICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSAhIXZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IGFycmF5XG4gICAgICAgIGNhc2UgJ2xpbWl0JzogICAgICAgICAgICAgICAgICAgICAgIC8vICogICAgKiAgICAgdG8gc3RyaW5nIGZvciByZWFkbGluZUV4dFxuICAgICAgICBjYXNlICd0cnVlVmFsdWUnOiAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAnZmFsc2VWYWx1ZSc6ICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IGZsYXR0ZW5BcnJheSh2YWx1ZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gICAgICAgICAgfSkubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKSA6IHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IGZ1bmN0aW9uXG4gICAgICAgIGNhc2UgJ3ByaW50JzogICAgICAgICAgICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICBjYXNlICdwaENvbnRlbnQnOiAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAncHJlQ2hlY2snOiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyA9PT09PT09PT09PT09PT09IG90aGVyXG4gICAgICAgIGNhc2UgJ3Byb21wdCc6ICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdkaXNwbGF5JzogICAgICAgICAgICAgICAgICAgICAvLyAqXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6ICcnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBubyBkZWZhdWx0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gaXNNYXRjaGVkKHJlcywgY29tcHMsIGNhc2VTZW5zaXRpdmUpIHtcbiAgcmV0dXJuIGNvbXBzLnNvbWUoZnVuY3Rpb24oY29tcCkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIGNvbXA7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnID9cbiAgICAgICAgKGNhc2VTZW5zaXRpdmUgPyByZXMgPT09IGNvbXAgOiByZXMudG9Mb3dlckNhc2UoKSA9PT0gY29tcC50b0xvd2VyQ2FzZSgpKSA6XG4gICAgICB0eXBlID09PSAnbnVtYmVyJyA/IHBhcnNlRmxvYXQocmVzKSA9PT0gY29tcCA6XG4gICAgICB0eXBlID09PSAnZnVuY3Rpb24nID8gY29tcChyZXMpIDpcbiAgICAgIGNvbXAgaW5zdGFuY2VvZiBSZWdFeHAgPyBjb21wLnRlc3QocmVzKSA6IGZhbHNlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhvbWVQYXRoKHBhdGgsIGV4cGFuZCkge1xuICB2YXIgaG9tZVBhdGggPSBwYXRoVXRpbC5ub3JtYWxpemUoXG4gICAgSVNfV0lOID8gKHByb2Nlc3MuZW52LkhPTUVEUklWRSB8fCAnJykgKyAocHJvY2Vzcy5lbnYuSE9NRVBBVEggfHwgJycpIDpcbiAgICBwcm9jZXNzLmVudi5IT01FIHx8ICcnKS5yZXBsYWNlKC9bXFwvXFxcXF0rJC8sICcnKTtcbiAgcGF0aCA9IHBhdGhVdGlsLm5vcm1hbGl6ZShwYXRoKTtcbiAgcmV0dXJuIGV4cGFuZCA/IHBhdGgucmVwbGFjZSgvXn4oPz1cXC98XFxcXHwkKS8sIGhvbWVQYXRoKSA6XG4gICAgcGF0aC5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgZXNjYXBlUGF0dGVybihob21lUGF0aCkgK1xuICAgICAgJyg/PVxcXFwvfFxcXFxcXFxcfCQpJywgSVNfV0lOID8gJ2knIDogJycpLCAnficpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlUGxhY2Vob2xkZXIodGV4dCwgZ2VuZXJhdG9yKSB7XG4gIHZhciBQVE5fSU5ORVIgPSAnKD86XFxcXCgoW1xcXFxzXFxcXFNdKj8pXFxcXCkpPyhcXFxcdyt8Li0uKSg/OlxcXFwoKFtcXFxcc1xcXFxTXSo/KVxcXFwpKT8nLFxuICAgIHJlUGxhY2Vob2xkZXIgPSBuZXcgUmVnRXhwKCcoXFxcXCQpPyhcXFxcJDwnICsgUFROX0lOTkVSICsgJz4pJywgJ2cnKSxcbiAgICByZVBsYWNlaG9sZGVyQ29tcGF0ID0gbmV3IFJlZ0V4cCgnKFxcXFwkKT8oXFxcXCRcXFxceycgKyBQVE5fSU5ORVIgKyAnXFxcXH0pJywgJ2cnKTtcblxuICBmdW5jdGlvbiBnZXRQbGFjZWhvbGRlclRleHQocywgZXNjYXBlLCBwbGFjZWhvbGRlciwgcHJlLCBwYXJhbSwgcG9zdCkge1xuICAgIHZhciB0ZXh0O1xuICAgIHJldHVybiBlc2NhcGUgfHwgdHlwZW9mICh0ZXh0ID0gZ2VuZXJhdG9yKHBhcmFtKSkgIT09ICdzdHJpbmcnID8gcGxhY2Vob2xkZXIgOlxuICAgICAgdGV4dCA/IChwcmUgfHwgJycpICsgdGV4dCArIChwb3N0IHx8ICcnKSA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIHRleHQucmVwbGFjZShyZVBsYWNlaG9sZGVyLCBnZXRQbGFjZWhvbGRlclRleHQpXG4gICAgLnJlcGxhY2UocmVQbGFjZWhvbGRlckNvbXBhdCwgZ2V0UGxhY2Vob2xkZXJUZXh0KTtcbn1cblxuZnVuY3Rpb24gYXJyYXkyY2hhcmxpc3QoYXJyYXksIGNhc2VTZW5zaXRpdmUsIGNvbGxlY3RTeW1ib2xzKSB7XG4gIHZhciB2YWx1ZXMsIGdyb3VwID0gW10sIGdyb3VwQ2xhc3MgPSAtMSwgY2hhckNvZGUgPSAwLCBzeW1ib2xzID0gJycsIHN1cHByZXNzZWQ7XG4gIGZ1bmN0aW9uIGFkZEdyb3VwKGdyb3VwcywgZ3JvdXApIHtcbiAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMykgeyAvLyBlbGxpcHNpc1xuICAgICAgZ3JvdXBzLnB1c2goZ3JvdXBbMF0gKyAnLi4uJyArIGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdKTtcbiAgICAgIHN1cHByZXNzZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAubGVuZ3RoKSB7XG4gICAgICBncm91cHMgPSBncm91cHMuY29uY2F0KGdyb3VwKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIHZhbHVlcyA9IGFycmF5LnJlZHVjZShcbiAgICAgIGZ1bmN0aW9uKGNoYXJzLCB2YWx1ZSkgeyByZXR1cm4gY2hhcnMuY29uY2F0KCh2YWx1ZSArICcnKS5zcGxpdCgnJykpOyB9LCBbXSlcbiAgICAucmVkdWNlKGZ1bmN0aW9uKGdyb3VwcywgY3VyQ2hhcikge1xuICAgICAgdmFyIGN1ckdyb3VwQ2xhc3MsIGN1ckNoYXJDb2RlO1xuICAgICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7IGN1ckNoYXIgPSBjdXJDaGFyLnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgIGN1ckdyb3VwQ2xhc3MgPSAvXlxcZCQvLnRlc3QoY3VyQ2hhcikgPyAxIDpcbiAgICAgICAgL15bQS1aXSQvLnRlc3QoY3VyQ2hhcikgPyAyIDogL15bYS16XSQvLnRlc3QoY3VyQ2hhcikgPyAzIDogMDtcbiAgICAgIGlmIChjb2xsZWN0U3ltYm9scyAmJiBjdXJHcm91cENsYXNzID09PSAwKSB7XG4gICAgICAgIHN5bWJvbHMgKz0gY3VyQ2hhcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1ckNoYXJDb2RlID0gY3VyQ2hhci5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAoY3VyR3JvdXBDbGFzcyAmJiBjdXJHcm91cENsYXNzID09PSBncm91cENsYXNzICYmXG4gICAgICAgICAgICBjdXJDaGFyQ29kZSA9PT0gY2hhckNvZGUgKyAxKSB7XG4gICAgICAgICAgZ3JvdXAucHVzaChjdXJDaGFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBncm91cHMgPSBhZGRHcm91cChncm91cHMsIGdyb3VwKTtcbiAgICAgICAgICBncm91cCA9IFtjdXJDaGFyXTtcbiAgICAgICAgICBncm91cENsYXNzID0gY3VyR3JvdXBDbGFzcztcbiAgICAgICAgfVxuICAgICAgICBjaGFyQ29kZSA9IGN1ckNoYXJDb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LCBbXSk7XG4gIHZhbHVlcyA9IGFkZEdyb3VwKHZhbHVlcywgZ3JvdXApOyAvLyBsYXN0IGdyb3VwXG4gIGlmIChzeW1ib2xzKSB7IHZhbHVlcy5wdXNoKHN5bWJvbHMpOyBzdXBwcmVzc2VkID0gdHJ1ZTsgfVxuICByZXR1cm4ge3ZhbHVlczogdmFsdWVzLCBzdXBwcmVzc2VkOiBzdXBwcmVzc2VkfTtcbn1cblxuZnVuY3Rpb24gam9pbkNodW5rcyhjaHVua3MsIHN1cHByZXNzZWQpIHtcbiAgcmV0dXJuIGNodW5rcy5qb2luKGNodW5rcy5sZW5ndGggPiAyID8gJywgJyA6IHN1cHByZXNzZWQgPyAnIC8gJyA6ICcvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFBoQ29udGVudChwYXJhbSwgb3B0aW9ucykge1xuICB2YXIgdGV4dCwgdmFsdWVzLCByZXNDaGFybGlzdCA9IHt9LCBhcmc7XG4gIGlmIChvcHRpb25zLnBoQ29udGVudCkge1xuICAgIHRleHQgPSBvcHRpb25zLnBoQ29udGVudChwYXJhbSwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgIHN3aXRjaCAocGFyYW0pIHtcbiAgICAgIGNhc2UgJ2hpZGVFY2hvQmFjayc6XG4gICAgICBjYXNlICdtYXNrJzpcbiAgICAgIGNhc2UgJ2RlZmF1bHRJbnB1dCc6XG4gICAgICBjYXNlICdjYXNlU2Vuc2l0aXZlJzpcbiAgICAgIGNhc2UgJ2tlZXBXaGl0ZXNwYWNlJzpcbiAgICAgIGNhc2UgJ2VuY29kaW5nJzpcbiAgICAgIGNhc2UgJ2J1ZmZlclNpemUnOlxuICAgICAgY2FzZSAnaGlzdG9yeSc6XG4gICAgICBjYXNlICdjZCc6XG4gICAgICAgIHRleHQgPSAhb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbSkgPyAnJyA6XG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnNbcGFyYW1dID09PSAnYm9vbGVhbicgPyAob3B0aW9uc1twYXJhbV0gPyAnb24nIDogJ29mZicpIDpcbiAgICAgICAgICBvcHRpb25zW3BhcmFtXSArICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGNhc2UgJ3Byb21wdCc6XG4gICAgICAvLyBjYXNlICdxdWVyeSc6XG4gICAgICAvLyBjYXNlICdkaXNwbGF5JzpcbiAgICAgIC8vICAgdGV4dCA9IG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Rpc3BsYXlTcmMnKSA/IG9wdGlvbnMuZGlzcGxheVNyYyArICcnIDogJyc7XG4gICAgICAvLyAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGltaXQnOlxuICAgICAgY2FzZSAndHJ1ZVZhbHVlJzpcbiAgICAgIGNhc2UgJ2ZhbHNlVmFsdWUnOlxuICAgICAgICB2YWx1ZXMgPSBvcHRpb25zW29wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0gKyAnU3JjJykgPyBwYXJhbSArICdTcmMnIDogcGFyYW1dO1xuICAgICAgICBpZiAob3B0aW9ucy5rZXlJbikgeyAvLyBzdXBwcmVzc1xuICAgICAgICAgIHJlc0NoYXJsaXN0ID0gYXJyYXkyY2hhcmxpc3QodmFsdWVzLCBvcHRpb25zLmNhc2VTZW5zaXRpdmUpO1xuICAgICAgICAgIHZhbHVlcyA9IHJlc0NoYXJsaXN0LnZhbHVlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXMgPSB2YWx1ZXMuZmlsdGVyKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gam9pbkNodW5rcyh2YWx1ZXMsIHJlc0NoYXJsaXN0LnN1cHByZXNzZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xpbWl0Q291bnQnOlxuICAgICAgY2FzZSAnbGltaXRDb3VudE5vdFplcm8nOlxuICAgICAgICB0ZXh0ID0gb3B0aW9uc1tvcHRpb25zLmhhc093blByb3BlcnR5KCdsaW1pdFNyYycpID9cbiAgICAgICAgICAnbGltaXRTcmMnIDogJ2xpbWl0J10ubGVuZ3RoO1xuICAgICAgICB0ZXh0ID0gdGV4dCB8fCBwYXJhbSAhPT0gJ2xpbWl0Q291bnROb3RaZXJvJyA/IHRleHQgKyAnJyA6ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xhc3RJbnB1dCc6XG4gICAgICAgIHRleHQgPSBsYXN0SW5wdXQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY3dkJzpcbiAgICAgIGNhc2UgJ0NXRCc6XG4gICAgICBjYXNlICdjd2RIb21lJzpcbiAgICAgICAgdGV4dCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgIGlmIChwYXJhbSA9PT0gJ0NXRCcpIHtcbiAgICAgICAgICB0ZXh0ID0gcGF0aFV0aWwuYmFzZW5hbWUodGV4dCk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW0gPT09ICdjd2RIb21lJykge1xuICAgICAgICAgIHRleHQgPSByZXBsYWNlSG9tZVBhdGgodGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3RpbWUnOlxuICAgICAgY2FzZSAnbG9jYWxlRGF0ZSc6XG4gICAgICBjYXNlICdsb2NhbGVUaW1lJzpcbiAgICAgICAgdGV4dCA9IChuZXcgRGF0ZSgpKVsndG8nICtcbiAgICAgICAgICBwYXJhbS5yZXBsYWNlKC9eLi8sIGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7IH0pICtcbiAgICAgICAgICAnU3RyaW5nJ10oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OiAvLyB3aXRoIGFyZ1xuICAgICAgICBpZiAodHlwZW9mIChhcmcgPSAocGFyYW0ubWF0Y2goL15oaXN0b3J5X20oXFxkKykkLykgfHwgW10pWzFdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0ZXh0ID0gaW5wdXRIaXN0b3J5W2lucHV0SGlzdG9yeS5sZW5ndGggLSBhcmddIHx8ICcnO1xuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRQaENoYXJsaXN0KHBhcmFtKSB7XG4gIHZhciBtYXRjaGVzID0gL14oLiktKC4pJC8uZXhlYyhwYXJhbSksIHRleHQgPSAnJywgZnJvbSwgdG8sIGNvZGUsIHN0ZXA7XG4gIGlmICghbWF0Y2hlcykgeyByZXR1cm4gbnVsbDsgfVxuICBmcm9tID0gbWF0Y2hlc1sxXS5jaGFyQ29kZUF0KDApO1xuICB0byA9IG1hdGNoZXNbMl0uY2hhckNvZGVBdCgwKTtcbiAgc3RlcCA9IGZyb20gPCB0byA/IDEgOiAtMTtcbiAgZm9yIChjb2RlID0gZnJvbTsgY29kZSAhPT0gdG8gKyBzdGVwOyBjb2RlICs9IHN0ZXApIHsgdGV4dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpOyB9XG4gIHJldHVybiB0ZXh0O1xufVxuXG4vLyBjbWQgXCJhcmdcIiBcIiBhIHIgZyBcIiBcIlwiICdhXCJyXCJnJyBcImFcIlwicmdcIiBcImFyZ1xuZnVuY3Rpb24gcGFyc2VDbChjbCkge1xuICB2YXIgcmVUb2tlbiA9IG5ldyBSZWdFeHAoLyhcXHMqKSg/OihcInwnKSguKj8pKD86XFwyfCQpfChcXFMrKSkvZyksIG1hdGNoZXMsXG4gICAgdGFrZW4gPSAnJywgYXJncyA9IFtdLCBwYXJ0O1xuICBjbCA9IGNsLnRyaW0oKTtcbiAgd2hpbGUgKChtYXRjaGVzID0gcmVUb2tlbi5leGVjKGNsKSkpIHtcbiAgICBwYXJ0ID0gbWF0Y2hlc1szXSB8fCBtYXRjaGVzWzRdIHx8ICcnO1xuICAgIGlmIChtYXRjaGVzWzFdKSB7XG4gICAgICBhcmdzLnB1c2godGFrZW4pO1xuICAgICAgdGFrZW4gPSAnJztcbiAgICB9XG4gICAgdGFrZW4gKz0gcGFydDtcbiAgfVxuICBpZiAodGFrZW4pIHsgYXJncy5wdXNoKHRha2VuKTsgfVxuICByZXR1cm4gYXJncztcbn1cblxuZnVuY3Rpb24gdG9Cb29sKHJlcywgb3B0aW9ucykge1xuICByZXR1cm4gKFxuICAgIChvcHRpb25zLnRydWVWYWx1ZS5sZW5ndGggJiZcbiAgICAgIGlzTWF0Y2hlZChyZXMsIG9wdGlvbnMudHJ1ZVZhbHVlLCBvcHRpb25zLmNhc2VTZW5zaXRpdmUpKSA/IHRydWUgOlxuICAgIChvcHRpb25zLmZhbHNlVmFsdWUubGVuZ3RoICYmXG4gICAgICBpc01hdGNoZWQocmVzLCBvcHRpb25zLmZhbHNlVmFsdWUsIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkpID8gZmFsc2UgOiByZXMpO1xufVxuXG5mdW5jdGlvbiBnZXRWYWxpZExpbmUob3B0aW9ucykge1xuICB2YXIgcmVzLCBmb3JjZU5leHQsIGxpbWl0TWVzc2FnZSxcbiAgICBtYXRjaGVzLCBoaXN0SW5wdXQsIGFyZ3MsIHJlc0NoZWNrO1xuXG4gIGZ1bmN0aW9uIF9nZXRQaENvbnRlbnQocGFyYW0pIHsgcmV0dXJuIGdldFBoQ29udGVudChwYXJhbSwgb3B0aW9ucyk7IH1cbiAgZnVuY3Rpb24gYWRkRGlzcGxheSh0ZXh0KSB7IG9wdGlvbnMuZGlzcGxheSArPSAoL1teXFxyXFxuXSQvLnRlc3Qob3B0aW9ucy5kaXNwbGF5KSA/ICdcXG4nIDogJycpICsgdGV4dDsgfVxuXG4gIG9wdGlvbnMubGltaXRTcmMgPSBvcHRpb25zLmxpbWl0O1xuICBvcHRpb25zLmRpc3BsYXlTcmMgPSBvcHRpb25zLmRpc3BsYXk7XG4gIG9wdGlvbnMubGltaXQgPSAnJzsgLy8gZm9yIHJlYWRsaW5lRXh0XG4gIG9wdGlvbnMuZGlzcGxheSA9IHJlcGxhY2VQbGFjZWhvbGRlcihvcHRpb25zLmRpc3BsYXkgKyAnJywgX2dldFBoQ29udGVudCk7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICByZXMgPSBfcmVhZGxpbmVTeW5jKG9wdGlvbnMpO1xuICAgIGZvcmNlTmV4dCA9IGZhbHNlO1xuICAgIGxpbWl0TWVzc2FnZSA9ICcnO1xuXG4gICAgaWYgKG9wdGlvbnMuZGVmYXVsdElucHV0ICYmICFyZXMpIHsgcmVzID0gb3B0aW9ucy5kZWZhdWx0SW5wdXQ7IH1cblxuICAgIGlmIChvcHRpb25zLmhpc3RvcnkpIHtcbiAgICAgIGlmICgobWF0Y2hlcyA9IC9eXFxzKlxcISg/OlxcIXwtMSkoOnApP1xccyokLy5leGVjKHJlcykpKSB7IC8vIGAhIWAgYCEtMWAgK2A6cGBcbiAgICAgICAgaGlzdElucHV0ID0gaW5wdXRIaXN0b3J5WzBdIHx8ICcnO1xuICAgICAgICBpZiAobWF0Y2hlc1sxXSkgeyAvLyBvbmx5IGRpc3BsYXlcbiAgICAgICAgICBmb3JjZU5leHQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgeyAvLyByZXBsYWNlIGlucHV0XG4gICAgICAgICAgcmVzID0gaGlzdElucHV0O1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3cgaXQgZXZlbiBpZiBpdCBpcyBlbXB0eSAoTkwgb25seSkuXG4gICAgICAgIGFkZERpc3BsYXkoaGlzdElucHV0ICsgJ1xcbicpO1xuICAgICAgICBpZiAoIWZvcmNlTmV4dCkgeyAvLyBMb29wIG1heSBicmVha1xuICAgICAgICAgIG9wdGlvbnMuZGlzcGxheU9ubHkgPSB0cnVlO1xuICAgICAgICAgIF9yZWFkbGluZVN5bmMob3B0aW9ucyk7XG4gICAgICAgICAgb3B0aW9ucy5kaXNwbGF5T25seSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlcyAmJiByZXMgIT09IGlucHV0SGlzdG9yeVtpbnB1dEhpc3RvcnkubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5wdXRIaXN0b3J5ID0gW3Jlc107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZU5leHQgJiYgb3B0aW9ucy5jZCAmJiByZXMpIHtcbiAgICAgIGFyZ3MgPSBwYXJzZUNsKHJlcyk7XG4gICAgICBzd2l0Y2ggKGFyZ3NbMF0udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlICdjZCc6XG4gICAgICAgICAgaWYgKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuY2hkaXIocmVwbGFjZUhvbWVQYXRoKGFyZ3NbMV0sIHRydWUpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgYWRkRGlzcGxheShlICsgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3JjZU5leHQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdwd2QnOlxuICAgICAgICAgIGFkZERpc3BsYXkocHJvY2Vzcy5jd2QoKSk7XG4gICAgICAgICAgZm9yY2VOZXh0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gbm8gZGVmYXVsdFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm9yY2VOZXh0ICYmIG9wdGlvbnMucHJlQ2hlY2spIHtcbiAgICAgIHJlc0NoZWNrID0gb3B0aW9ucy5wcmVDaGVjayhyZXMsIG9wdGlvbnMpO1xuICAgICAgcmVzID0gcmVzQ2hlY2sucmVzO1xuICAgICAgaWYgKHJlc0NoZWNrLmZvcmNlTmV4dCkgeyBmb3JjZU5leHQgPSB0cnVlOyB9IC8vIERvbid0IHN3aXRjaCB0byBmYWxzZS5cbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlTmV4dCkge1xuICAgICAgaWYgKCFvcHRpb25zLmxpbWl0U3JjLmxlbmd0aCB8fFxuICAgICAgICBpc01hdGNoZWQocmVzLCBvcHRpb25zLmxpbWl0U3JjLCBvcHRpb25zLmNhc2VTZW5zaXRpdmUpKSB7IGJyZWFrOyB9XG4gICAgICBpZiAob3B0aW9ucy5saW1pdE1lc3NhZ2UpIHtcbiAgICAgICAgbGltaXRNZXNzYWdlID0gcmVwbGFjZVBsYWNlaG9sZGVyKG9wdGlvbnMubGltaXRNZXNzYWdlLCBfZ2V0UGhDb250ZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhZGREaXNwbGF5KChsaW1pdE1lc3NhZ2UgPyBsaW1pdE1lc3NhZ2UgKyAnXFxuJyA6ICcnKSArXG4gICAgICByZXBsYWNlUGxhY2Vob2xkZXIob3B0aW9ucy5kaXNwbGF5U3JjICsgJycsIF9nZXRQaENvbnRlbnQpKTtcbiAgfVxuICByZXR1cm4gdG9Cb29sKHJlcywgb3B0aW9ucyk7XG59XG5cbi8vIGZvciBkZXZcbmV4cG9ydHMuX0RCR19zZXRfdXNlRXh0ID0gZnVuY3Rpb24odmFsKSB7IF9EQkdfdXNlRXh0ID0gdmFsOyB9O1xuZXhwb3J0cy5fREJHX3NldF9jaGVja09wdGlvbnMgPSBmdW5jdGlvbih2YWwpIHsgX0RCR19jaGVja09wdGlvbnMgPSB2YWw7IH07XG5leHBvcnRzLl9EQkdfc2V0X2NoZWNrTWV0aG9kID0gZnVuY3Rpb24odmFsKSB7IF9EQkdfY2hlY2tNZXRob2QgPSB2YWw7IH07XG5leHBvcnRzLl9EQkdfY2xlYXJIaXN0b3J5ID0gZnVuY3Rpb24oKSB7IGxhc3RJbnB1dCA9ICcnOyBpbnB1dEhpc3RvcnkgPSBbXTsgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuc2V0RGVmYXVsdE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIGRlZmF1bHRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHRydWUsIG9wdGlvbnMpO1xuICByZXR1cm4gbWFyZ2VPcHRpb25zKHRydWUpOyAvLyBjb3B5XG59O1xuXG5leHBvcnRzLnF1ZXN0aW9uID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuIGdldFZhbGlkTGluZShtYXJnZU9wdGlvbnMobWFyZ2VPcHRpb25zKHRydWUsIG9wdGlvbnMpLCB7XG4gICAgZGlzcGxheTogICAgICAgICAgICBxdWVyeVxuICB9KSk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbn07XG5cbmV4cG9ydHMucHJvbXB0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgcmVhZE9wdGlvbnMgPSBtYXJnZU9wdGlvbnModHJ1ZSwgb3B0aW9ucyk7XG4gIHJlYWRPcHRpb25zLmRpc3BsYXkgPSByZWFkT3B0aW9ucy5wcm9tcHQ7XG4gIHJldHVybiBnZXRWYWxpZExpbmUocmVhZE9wdGlvbnMpO1xufTtcblxuZXhwb3J0cy5rZXlJbiA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyhtYXJnZU9wdGlvbnModHJ1ZSwgb3B0aW9ucyksIHtcbiAgICBkaXNwbGF5OiAgICAgICAgICAgIHF1ZXJ5LFxuICAgIGtleUluOiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICBrZWVwV2hpdGVzcGFjZTogICAgIHRydWVcbiAgfSk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cblxuICAvLyBjaGFyIGxpc3RcbiAgcmVhZE9wdGlvbnMubGltaXRTcmMgPSByZWFkT3B0aW9ucy5saW1pdC5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcic7XG4gIH0pXG4gIC5tYXAoZnVuY3Rpb24odGV4dCkgeyByZXR1cm4gcmVwbGFjZVBsYWNlaG9sZGVyKHRleHQgKyAnJywgZ2V0UGhDaGFybGlzdCk7IH0pO1xuICAvLyBwYXR0ZXJuXG4gIHJlYWRPcHRpb25zLmxpbWl0ID0gZXNjYXBlUGF0dGVybihyZWFkT3B0aW9ucy5saW1pdFNyYy5qb2luKCcnKSk7XG5cbiAgWyd0cnVlVmFsdWUnLCAnZmFsc2VWYWx1ZSddLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uTmFtZSkge1xuICAgIHJlYWRPcHRpb25zW29wdGlvbk5hbWVdID0gcmVhZE9wdGlvbnNbb3B0aW9uTmFtZV0ucmVkdWNlKGZ1bmN0aW9uKGNvbXBzLCBjb21wKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBjb21wO1xuICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbXBzID0gY29tcHMuY29uY2F0KChjb21wICsgJycpLnNwbGl0KCcnKSk7XG4gICAgICB9IGVsc2UgeyBjb21wcy5wdXNoKGNvbXApOyB9XG4gICAgICByZXR1cm4gY29tcHM7XG4gICAgfSwgW10pO1xuICB9KTtcblxuICByZWFkT3B0aW9ucy5kaXNwbGF5ID0gcmVwbGFjZVBsYWNlaG9sZGVyKHJlYWRPcHRpb25zLmRpc3BsYXkgKyAnJyxcbiAgICBmdW5jdGlvbihwYXJhbSkgeyByZXR1cm4gZ2V0UGhDb250ZW50KHBhcmFtLCByZWFkT3B0aW9ucyk7IH0pO1xuXG4gIHJldHVybiB0b0Jvb2woX3JlYWRsaW5lU3luYyhyZWFkT3B0aW9ucyksIHJlYWRPcHRpb25zKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLnF1ZXN0aW9uRU1haWwgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdJbnB1dCBlLW1haWwgYWRkcmVzczogJzsgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm4gZXhwb3J0cy5xdWVzdGlvbihxdWVyeSwgbWFyZ2VPcHRpb25zKHtcbiAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG4gICAgbGltaXQ6ICAgICAgICAgICAgICAvXlthLXpBLVowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLyxcbiAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdJbnB1dCB2YWxpZCBlLW1haWwgYWRkcmVzcywgcGxlYXNlLicsXG4gICAgdHJ1ZVZhbHVlOiAgICAgICAgICBudWxsLFxuICAgIGZhbHNlVmFsdWU6ICAgICAgICAgbnVsbFxuICB9LCBvcHRpb25zLCB7XG4gICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAga2VlcFdoaXRlc3BhY2U6ICAgICBmYWxzZSxcbiAgICBjZDogICAgICAgICAgICAgICAgIGZhbHNlXG4gIH0pKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xufTtcblxuZXhwb3J0cy5xdWVzdGlvbk5ld1Bhc3N3b3JkID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlc0NoYXJsaXN0LCBtaW4sIG1heCxcbiAgICByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgICBoaWRlRWNob0JhY2s6ICAgICAgIHRydWUsXG4gICAgICBtYXNrOiAgICAgICAgICAgICAgICcqJyxcbiAgICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ0l0IGNhbiBpbmNsdWRlOiAkPGNoYXJsaXN0PlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdBbmQgdGhlIGxlbmd0aCBtdXN0IGJlOiAkPGxlbmd0aD4nLFxuICAgICAgdHJ1ZVZhbHVlOiAgICAgICAgICBudWxsLFxuICAgICAgZmFsc2VWYWx1ZTogICAgICAgICBudWxsLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogICAgICB0cnVlXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgICBoaXN0b3J5OiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgY2Q6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgIC8vIGxpbWl0IChieSBjaGFybGlzdCBldGMuKSxcbiAgICAgIHBoQ29udGVudDogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtID09PSAnY2hhcmxpc3QnID8gcmVzQ2hhcmxpc3QudGV4dCA6XG4gICAgICAgICAgcGFyYW0gPT09ICdsZW5ndGgnID8gbWluICsgJy4uLicgKyBtYXggOiBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIGFkZGVkOiAgICAgY2hhcmxpc3QsIG1pbiwgbWF4LCBjb25maXJtTWVzc2FnZSwgdW5tYXRjaE1lc3NhZ2VcbiAgICBjaGFybGlzdCwgY29uZmlybU1lc3NhZ2UsIHVubWF0Y2hNZXNzYWdlLFxuICAgIGxpbWl0LCBsaW1pdE1lc3NhZ2UsIHJlczEsIHJlczI7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgY2hhcmxpc3QgPSByZXBsYWNlUGxhY2Vob2xkZXIoXG4gICAgb3B0aW9ucy5jaGFybGlzdCA/IG9wdGlvbnMuY2hhcmxpc3QgKyAnJyA6ICckPCEtfj4nLCBnZXRQaENoYXJsaXN0KTtcbiAgaWYgKGlzTmFOKG1pbiA9IHBhcnNlSW50KG9wdGlvbnMubWluLCAxMCkpIHx8IHR5cGVvZiBtaW4gIT09ICdudW1iZXInKSB7IG1pbiA9IDEyOyB9XG4gIGlmIChpc05hTihtYXggPSBwYXJzZUludChvcHRpb25zLm1heCwgMTApKSB8fCB0eXBlb2YgbWF4ICE9PSAnbnVtYmVyJykgeyBtYXggPSAyNDsgfVxuICBsaW1pdCA9IG5ldyBSZWdFeHAoJ15bJyArIGVzY2FwZVBhdHRlcm4oY2hhcmxpc3QpICtcbiAgICAnXXsnICsgbWluICsgJywnICsgbWF4ICsgJ30kJyk7XG4gIHJlc0NoYXJsaXN0ID0gYXJyYXkyY2hhcmxpc3QoW2NoYXJsaXN0XSwgcmVhZE9wdGlvbnMuY2FzZVNlbnNpdGl2ZSwgdHJ1ZSk7XG4gIHJlc0NoYXJsaXN0LnRleHQgPSBqb2luQ2h1bmtzKHJlc0NoYXJsaXN0LnZhbHVlcywgcmVzQ2hhcmxpc3Quc3VwcHJlc3NlZCk7XG5cbiAgY29uZmlybU1lc3NhZ2UgPSBvcHRpb25zLmNvbmZpcm1NZXNzYWdlICE9IG51bGwgPyBvcHRpb25zLmNvbmZpcm1NZXNzYWdlIDpcbiAgICAnUmVpbnB1dCBhIHNhbWUgb25lIHRvIGNvbmZpcm0gaXQ6ICc7XG4gIHVubWF0Y2hNZXNzYWdlID0gb3B0aW9ucy51bm1hdGNoTWVzc2FnZSAhPSBudWxsID8gb3B0aW9ucy51bm1hdGNoTWVzc2FnZSA6XG4gICAgJ0l0IGRpZmZlcnMgZnJvbSBmaXJzdCBvbmUuJyArXG4gICAgICAnIEhpdCBvbmx5IHRoZSBFbnRlciBrZXkgaWYgeW91IHdhbnQgdG8gcmV0cnkgZnJvbSBmaXJzdCBvbmUuJztcblxuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdJbnB1dCBuZXcgcGFzc3dvcmQ6ICc7IH1cblxuICBsaW1pdE1lc3NhZ2UgPSByZWFkT3B0aW9ucy5saW1pdE1lc3NhZ2U7XG4gIHdoaWxlICghcmVzMikge1xuICAgIHJlYWRPcHRpb25zLmxpbWl0ID0gbGltaXQ7XG4gICAgcmVhZE9wdGlvbnMubGltaXRNZXNzYWdlID0gbGltaXRNZXNzYWdlO1xuICAgIHJlczEgPSBleHBvcnRzLnF1ZXN0aW9uKHF1ZXJ5LCByZWFkT3B0aW9ucyk7XG5cbiAgICByZWFkT3B0aW9ucy5saW1pdCA9IFtyZXMxLCAnJ107XG4gICAgcmVhZE9wdGlvbnMubGltaXRNZXNzYWdlID0gdW5tYXRjaE1lc3NhZ2U7XG4gICAgcmVzMiA9IGV4cG9ydHMucXVlc3Rpb24oY29uZmlybU1lc3NhZ2UsIHJlYWRPcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiByZXMxO1xufTtcblxuZnVuY3Rpb24gX3F1ZXN0aW9uTnVtKHF1ZXJ5LCBvcHRpb25zLCBwYXJzZXIpIHtcbiAgdmFyIHZhbGlkVmFsdWU7XG4gIGZ1bmN0aW9uIGdldFZhbGlkVmFsdWUodmFsdWUpIHtcbiAgICB2YWxpZFZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgICByZXR1cm4gIWlzTmFOKHZhbGlkVmFsdWUpICYmIHR5cGVvZiB2YWxpZFZhbHVlID09PSAnbnVtYmVyJztcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICBleHBvcnRzLnF1ZXN0aW9uKHF1ZXJ5LCBtYXJnZU9wdGlvbnMoe1xuICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdJbnB1dCB2YWxpZCBudW1iZXIsIHBsZWFzZS4nXG4gIH0sIG9wdGlvbnMsIHtcbiAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICBsaW1pdDogICAgICAgICAgICAgIGdldFZhbGlkVmFsdWUsXG4gICAgY2Q6ICAgICAgICAgICAgICAgICBmYWxzZVxuICAgIC8vIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSwgY2FzZVNlbnNpdGl2ZSwga2VlcFdoaXRlc3BhY2UgZG9uJ3Qgd29yay5cbiAgfSkpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybiB2YWxpZFZhbHVlO1xufVxuZXhwb3J0cy5xdWVzdGlvbkludCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiBfcXVlc3Rpb25OdW0ocXVlcnksIG9wdGlvbnMsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApOyB9KTtcbn07XG5leHBvcnRzLnF1ZXN0aW9uRmxvYXQgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICByZXR1cm4gX3F1ZXN0aW9uTnVtKHF1ZXJ5LCBvcHRpb25zLCBwYXJzZUZsb2F0KTtcbn07XG5cbmV4cG9ydHMucXVlc3Rpb25QYXRoID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHZhbGlkUGF0aCwgZXJyb3IgPSAnJyxcbiAgICByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgICAgbGltaXRNZXNzYWdlOiAgICAgICAnJDxlcnJvcihcXG4pPklucHV0IHZhbGlkIHBhdGgsIHBsZWFzZS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJDwoIE1pbjopbWluPiQ8KCBNYXg6KW1heD4nLFxuICAgICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlLFxuICAgICAgY2Q6ICAgICAgICAgICAgICAgICB0cnVlXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgICBrZWVwV2hpdGVzcGFjZTogICAgIGZhbHNlLFxuICAgICAgbGltaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBleGlzdHMsIHN0YXQsIHJlcztcbiAgICAgICAgdmFsdWUgPSByZXBsYWNlSG9tZVBhdGgodmFsdWUsIHRydWUpO1xuICAgICAgICBlcnJvciA9ICcnOyAvLyBmb3IgdmFsaWRhdGVcbiAgICAgICAgLy8gbWtkaXIgLXBcbiAgICAgICAgZnVuY3Rpb24gbWtkaXJQYXJlbnRzKGRpclBhdGgpIHtcbiAgICAgICAgICBkaXJQYXRoLnNwbGl0KC9cXC98XFxcXC8pLnJlZHVjZShmdW5jdGlvbihwYXJlbnRzLCBkaXIpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGF0aFV0aWwucmVzb2x2ZSgocGFyZW50cyArPSBkaXIgKyBwYXRoVXRpbC5zZXApKTtcbiAgICAgICAgICAgIGlmICghZnMuZXhpc3RzU3luYyhwYXRoKSkge1xuICAgICAgICAgICAgICBmcy5ta2RpclN5bmMocGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFmcy5zdGF0U3luYyhwYXRoKS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIGRpcmVjdG9yeSBhbHJlYWR5IGV4aXN0czogJyArIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgICAgICAgfSwgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGlzdHMgPSBmcy5leGlzdHNTeW5jKHZhbHVlKTtcbiAgICAgICAgICB2YWxpZFBhdGggPSBleGlzdHMgPyBmcy5yZWFscGF0aFN5bmModmFsdWUpIDogcGF0aFV0aWwucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgLy8gb3B0aW9ucy5leGlzdHMgZGVmYXVsdDogdHJ1ZSwgbm90LWJvb2w6IG5vLWNoZWNrXG4gICAgICAgICAgaWYgKCFvcHRpb25zLmhhc093blByb3BlcnR5KCdleGlzdHMnKSAmJiAhZXhpc3RzIHx8XG4gICAgICAgICAgICAgIHR5cGVvZiBvcHRpb25zLmV4aXN0cyA9PT0gJ2Jvb2xlYW4nICYmIG9wdGlvbnMuZXhpc3RzICE9PSBleGlzdHMpIHtcbiAgICAgICAgICAgIGVycm9yID0gKGV4aXN0cyA/ICdBbHJlYWR5IGV4aXN0cycgOiAnTm8gc3VjaCBmaWxlIG9yIGRpcmVjdG9yeScpICtcbiAgICAgICAgICAgICAgJzogJyArIHZhbGlkUGF0aDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFleGlzdHMgJiYgb3B0aW9ucy5jcmVhdGUpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgIG1rZGlyUGFyZW50cyh2YWxpZFBhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWtkaXJQYXJlbnRzKHBhdGhVdGlsLmRpcm5hbWUodmFsaWRQYXRoKSk7XG4gICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmcy5vcGVuU3luYyh2YWxpZFBhdGgsICd3JykpOyAvLyB0b3VjaFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRQYXRoID0gZnMucmVhbHBhdGhTeW5jKHZhbGlkUGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChleGlzdHMgJiYgKG9wdGlvbnMubWluIHx8IG9wdGlvbnMubWF4IHx8XG4gICAgICAgICAgICAgIG9wdGlvbnMuaXNGaWxlIHx8IG9wdGlvbnMuaXNEaXJlY3RvcnkpKSB7XG4gICAgICAgICAgICBzdGF0ID0gZnMuc3RhdFN5bmModmFsaWRQYXRoKTtcbiAgICAgICAgICAgIC8vIHR5cGUgY2hlY2sgZmlyc3QgKGRpcmVjdG9yeSBoYXMgemVybyBzaXplKVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNGaWxlICYmICFzdGF0LmlzRmlsZSgpKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gJ05vdCBmaWxlOiAnICsgdmFsaWRQYXRoO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuaXNEaXJlY3RvcnkgJiYgIXN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICBlcnJvciA9ICdOb3QgZGlyZWN0b3J5OiAnICsgdmFsaWRQYXRoO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWluICYmIHN0YXQuc2l6ZSA8ICtvcHRpb25zLm1pbiB8fFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4ICYmIHN0YXQuc2l6ZSA+ICtvcHRpb25zLm1heCkge1xuICAgICAgICAgICAgICBlcnJvciA9ICdTaXplICcgKyBzdGF0LnNpemUgKyAnIGlzIG91dCBvZiByYW5nZTogJyArIHZhbGlkUGF0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMudmFsaWRhdGUgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICAgICAgKHJlcyA9IG9wdGlvbnMudmFsaWRhdGUodmFsaWRQYXRoKSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnc3RyaW5nJykgeyBlcnJvciA9IHJlczsgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGVycm9yID0gZSArICcnO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAvLyB0cnVlVmFsdWUsIGZhbHNlVmFsdWUsIGNhc2VTZW5zaXRpdmUgZG9uJ3Qgd29yay5cbiAgICAgIHBoQ29udGVudDogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtID09PSAnZXJyb3InID8gZXJyb3IgOlxuICAgICAgICAgIHBhcmFtICE9PSAnbWluJyAmJiBwYXJhbSAhPT0gJ21heCcgPyBudWxsIDpcbiAgICAgICAgICBvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtKSA/IG9wdGlvbnNbcGFyYW1dICsgJycgOiAnJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBhZGRlZDogICAgIGV4aXN0cywgY3JlYXRlLCBtaW4sIG1heCwgaXNGaWxlLCBpc0RpcmVjdG9yeSwgdmFsaWRhdGVcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdJbnB1dCBwYXRoICh5b3UgY2FuIFwiY2RcIiBhbmQgXCJwd2RcIik6ICc7IH1cblxuICBleHBvcnRzLnF1ZXN0aW9uKHF1ZXJ5LCByZWFkT3B0aW9ucyk7XG4gIHJldHVybiB2YWxpZFBhdGg7XG59O1xuXG4vLyBwcm9wczogcHJlQ2hlY2ssIGFyZ3MsIGhSZXMsIGxpbWl0XG5mdW5jdGlvbiBnZXRDbEhhbmRsZXIoY29tbWFuZEhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGNsSGFuZGxlciA9IHt9LCBoSW5kZXggPSB7fTtcbiAgaWYgKHR5cGVvZiBjb21tYW5kSGFuZGxlciA9PT0gJ29iamVjdCcpIHtcbiAgICBPYmplY3Qua2V5cyhjb21tYW5kSGFuZGxlcikuZm9yRWFjaChmdW5jdGlvbihjbWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tbWFuZEhhbmRsZXJbY21kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoSW5kZXhbb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gY21kIDogY21kLnRvTG93ZXJDYXNlKCldID0gY29tbWFuZEhhbmRsZXJbY21kXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjbEhhbmRsZXIucHJlQ2hlY2sgPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgIHZhciBjbWRLZXk7XG4gICAgICBjbEhhbmRsZXIuYXJncyA9IHBhcnNlQ2wocmVzKTtcbiAgICAgIGNtZEtleSA9IGNsSGFuZGxlci5hcmdzWzBdIHx8ICcnO1xuICAgICAgaWYgKCFvcHRpb25zLmNhc2VTZW5zaXRpdmUpIHsgY21kS2V5ID0gY21kS2V5LnRvTG93ZXJDYXNlKCk7IH1cbiAgICAgIGNsSGFuZGxlci5oUmVzID1cbiAgICAgICAgY21kS2V5ICE9PSAnXycgJiYgaEluZGV4Lmhhc093blByb3BlcnR5KGNtZEtleSkgP1xuICAgICAgICAgIGhJbmRleFtjbWRLZXldLmFwcGx5KHJlcywgY2xIYW5kbGVyLmFyZ3Muc2xpY2UoMSkpIDpcbiAgICAgICAgaEluZGV4Lmhhc093blByb3BlcnR5KCdfJykgPyBoSW5kZXguXy5hcHBseShyZXMsIGNsSGFuZGxlci5hcmdzKSA6IG51bGw7XG4gICAgICByZXR1cm4ge3JlczogcmVzLCBmb3JjZU5leHQ6IGZhbHNlfTtcbiAgICB9O1xuICAgIGlmICghaEluZGV4Lmhhc093blByb3BlcnR5KCdfJykpIHtcbiAgICAgIGNsSGFuZGxlci5saW1pdCA9IGZ1bmN0aW9uKCkgeyAvLyBJdCdzIGNhbGxlZCBhZnRlciBwcmVDaGVjay5cbiAgICAgICAgdmFyIGNtZEtleSA9IGNsSGFuZGxlci5hcmdzWzBdIHx8ICcnO1xuICAgICAgICBpZiAoIW9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkgeyBjbWRLZXkgPSBjbWRLZXkudG9Mb3dlckNhc2UoKTsgfVxuICAgICAgICByZXR1cm4gaEluZGV4Lmhhc093blByb3BlcnR5KGNtZEtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjbEhhbmRsZXIucHJlQ2hlY2sgPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgIGNsSGFuZGxlci5hcmdzID0gcGFyc2VDbChyZXMpO1xuICAgICAgY2xIYW5kbGVyLmhSZXMgPSB0eXBlb2YgY29tbWFuZEhhbmRsZXIgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICBjb21tYW5kSGFuZGxlci5hcHBseShyZXMsIGNsSGFuZGxlci5hcmdzKSA6IHRydWU7IC8vIHRydWUgZm9yIGJyZWFrIGxvb3BcbiAgICAgIHJldHVybiB7cmVzOiByZXMsIGZvcmNlTmV4dDogZmFsc2V9O1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNsSGFuZGxlcjtcbn1cblxuZXhwb3J0cy5wcm9tcHRDTCA9IGZ1bmN0aW9uKGNvbW1hbmRIYW5kbGVyLCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgICAgbGltaXRNZXNzYWdlOiAgICAgICAnUmVxdWVzdGVkIGNvbW1hbmQgaXMgbm90IGF2YWlsYWJsZS4nLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZSxcbiAgICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZVxuICAgIH0sIG9wdGlvbnMpLFxuICAgICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgICAvLyB0cnVlVmFsdWUsIGZhbHNlVmFsdWUsIGtlZXBXaGl0ZXNwYWNlIGRvbid0IHdvcmsuXG4gICAgICAvLyBwcmVDaGVjaywgbGltaXQgKGJ5IGNsSGFuZGxlcilcbiAgICBjbEhhbmRsZXIgPSBnZXRDbEhhbmRsZXIoY29tbWFuZEhhbmRsZXIsIHJlYWRPcHRpb25zKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICByZWFkT3B0aW9ucy5saW1pdCA9IGNsSGFuZGxlci5saW1pdDtcbiAgcmVhZE9wdGlvbnMucHJlQ2hlY2sgPSBjbEhhbmRsZXIucHJlQ2hlY2s7XG4gIGV4cG9ydHMucHJvbXB0KHJlYWRPcHRpb25zKTtcbiAgcmV0dXJuIGNsSGFuZGxlci5hcmdzO1xufTtcblxuZXhwb3J0cy5wcm9tcHRMb29wID0gZnVuY3Rpb24oaW5wdXRIYW5kbGVyLCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgdHJ1ZVZhbHVlOiAgICAgICAgICBudWxsLFxuICAgIGZhbHNlVmFsdWU6ICAgICAgICAgbnVsbCxcbiAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlLFxuICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZVxuICB9LCBvcHRpb25zKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICB3aGlsZSAodHJ1ZSkgeyBpZiAoaW5wdXRIYW5kbGVyKGV4cG9ydHMucHJvbXB0KHJlYWRPcHRpb25zKSkpIHsgYnJlYWs7IH0gfVxuICByZXR1cm47XG59O1xuXG5leHBvcnRzLnByb21wdENMTG9vcCA9IGZ1bmN0aW9uKGNvbW1hbmRIYW5kbGVyLCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgICAgbGltaXRNZXNzYWdlOiAgICAgICAnUmVxdWVzdGVkIGNvbW1hbmQgaXMgbm90IGF2YWlsYWJsZS4nLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZSxcbiAgICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZVxuICAgIH0sIG9wdGlvbnMpLFxuICAgICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgICAvLyB0cnVlVmFsdWUsIGZhbHNlVmFsdWUsIGtlZXBXaGl0ZXNwYWNlIGRvbid0IHdvcmsuXG4gICAgICAvLyBwcmVDaGVjaywgbGltaXQgKGJ5IGNsSGFuZGxlcilcbiAgICBjbEhhbmRsZXIgPSBnZXRDbEhhbmRsZXIoY29tbWFuZEhhbmRsZXIsIHJlYWRPcHRpb25zKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICByZWFkT3B0aW9ucy5saW1pdCA9IGNsSGFuZGxlci5saW1pdDtcbiAgcmVhZE9wdGlvbnMucHJlQ2hlY2sgPSBjbEhhbmRsZXIucHJlQ2hlY2s7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgZXhwb3J0cy5wcm9tcHQocmVhZE9wdGlvbnMpO1xuICAgIGlmIChjbEhhbmRsZXIuaFJlcykgeyBicmVhazsgfVxuICB9XG4gIHJldHVybjtcbn07XG5cbmV4cG9ydHMucHJvbXB0U2ltU2hlbGwgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybiBleHBvcnRzLnByb21wdChtYXJnZU9wdGlvbnMoe1xuICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZVxuICB9LCBvcHRpb25zLCB7XG4gICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgcHJvbXB0OiAgICAgICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSVNfV0lOID9cbiAgICAgICAgJyQ8Y3dkPj4nIDpcbiAgICAgICAgLy8gJ3VzZXJAaG9zdDpjd2QkICdcbiAgICAgICAgKHByb2Nlc3MuZW52LlVTRVIgfHwgJycpICtcbiAgICAgICAgKHByb2Nlc3MuZW52LkhPU1ROQU1FID9cbiAgICAgICAgICAnQCcgKyBwcm9jZXNzLmVudi5IT1NUTkFNRS5yZXBsYWNlKC9cXC4uKiQvLCAnJykgOiAnJykgK1xuICAgICAgICAnOiQ8Y3dkSG9tZT4kICc7XG4gICAgfSkoKVxuICB9KSk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbn07XG5cbmZ1bmN0aW9uIF9rZXlJbllOKHF1ZXJ5LCBvcHRpb25zLCBsaW1pdCkge1xuICB2YXIgcmVzO1xuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdBcmUgeW91IHN1cmU/ICc7IH1cbiAgaWYgKCghb3B0aW9ucyB8fCBvcHRpb25zLmd1aWRlICE9PSBmYWxzZSkgJiYgKHF1ZXJ5ICs9ICcnKSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkucmVwbGFjZSgvXFxzKjo/XFxzKiQvLCAnJykgKyAnIFt5L25dOiAnO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHJlcyA9IGV4cG9ydHMua2V5SW4ocXVlcnksIG1hcmdlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICBsaW1pdDogICAgICAgICAgICAgIGxpbWl0LFxuICAgIHRydWVWYWx1ZTogICAgICAgICAgJ3knLFxuICAgIGZhbHNlVmFsdWU6ICAgICAgICAgJ24nLFxuICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2VcbiAgICAvLyBtYXNrIGRvZXNuJ3Qgd29yay5cbiAgfSkpO1xuICAvLyBhZGRlZDogICAgIGd1aWRlXG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuIHR5cGVvZiByZXMgPT09ICdib29sZWFuJyA/IHJlcyA6ICcnO1xufVxuZXhwb3J0cy5rZXlJbllOID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHsgcmV0dXJuIF9rZXlJbllOKHF1ZXJ5LCBvcHRpb25zKTsgfTtcbmV4cG9ydHMua2V5SW5ZTlN0cmljdCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7IHJldHVybiBfa2V5SW5ZTihxdWVyeSwgb3B0aW9ucywgJ3luJyk7IH07XG5cbmV4cG9ydHMua2V5SW5QYXVzZSA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0NvbnRpbnVlLi4uJzsgfVxuICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMuZ3VpZGUgIT09IGZhbHNlKSAmJiAocXVlcnkgKz0gJycpKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9cXHMrJC8sICcnKSArICcgKEhpdCBhbnkga2V5KSc7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgZXhwb3J0cy5rZXlJbihxdWVyeSwgbWFyZ2VPcHRpb25zKHtcbiAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgbGltaXQ6ICAgICAgICAgICAgICBudWxsXG4gIH0sIG9wdGlvbnMsIHtcbiAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIHRydWUsXG4gICAgbWFzazogICAgICAgICAgICAgICAnJ1xuICB9KSk7XG4gIC8vIGFkZGVkOiAgICAgZ3VpZGVcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm47XG59O1xuXG5leHBvcnRzLmtleUluU2VsZWN0ID0gZnVuY3Rpb24oaXRlbXMsIHF1ZXJ5LCBvcHRpb25zKSB7XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh7XG4gICAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlXG4gICAgfSwgb3B0aW9ucywge1xuICAgICAgLy8gLS0tLS0tLS0gZm9yY2VkXG4gICAgICB0cnVlVmFsdWU6ICAgICAgICAgIG51bGwsXG4gICAgICBmYWxzZVZhbHVlOiAgICAgICAgIG51bGwsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlLFxuICAgICAgLy8gbGltaXQgKGJ5IGl0ZW1zKSxcbiAgICAgIHBoQ29udGVudDogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtID09PSAnaXRlbXNDb3VudCcgPyBpdGVtcy5sZW5ndGggKyAnJyA6XG4gICAgICAgICAgcGFyYW0gPT09ICdmaXJzdEl0ZW0nID8gKGl0ZW1zWzBdICsgJycpLnRyaW0oKSA6XG4gICAgICAgICAgcGFyYW0gPT09ICdsYXN0SXRlbScgPyAoaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0gKyAnJykudHJpbSgpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBhZGRlZDogICAgIGd1aWRlLCBjYW5jZWxcbiAgICBrZXlsaXN0ID0gJycsIGtleTJpID0ge30sIGNoYXJDb2RlID0gNDkgLyogJzEnICovLCBkaXNwbGF5ID0gJ1xcbic7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSB8fCAhaXRlbXMubGVuZ3RoIHx8IGl0ZW1zLmxlbmd0aCA+IDM1KSB7XG4gICAgdGhyb3cgJ2BpdGVtc2AgbXVzdCBiZSBBcnJheSAobWF4IGxlbmd0aDogMzUpLic7XG4gIH1cblxuICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0sIGkpIHtcbiAgICB2YXIga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gICAga2V5bGlzdCArPSBrZXk7XG4gICAga2V5Mmlba2V5XSA9IGk7XG4gICAgZGlzcGxheSArPSAnWycgKyBrZXkgKyAnXSAnICsgKGl0ZW0gKyAnJykudHJpbSgpICsgJ1xcbic7XG4gICAgY2hhckNvZGUgPSBjaGFyQ29kZSA9PT0gNTcgLyogJzknICovID8gOTcgLyogJ2EnICovIDogY2hhckNvZGUgKyAxO1xuICB9KTtcbiAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuY2FuY2VsICE9PSBmYWxzZSkge1xuICAgIGtleWxpc3QgKz0gJzAnO1xuICAgIGtleTJpWycwJ10gPSAtMTtcbiAgICBkaXNwbGF5ICs9ICdbMF0gJyArXG4gICAgICAob3B0aW9ucyAmJiBvcHRpb25zLmNhbmNlbCAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zLmNhbmNlbCAhPT0gJ2Jvb2xlYW4nID9cbiAgICAgICAgKG9wdGlvbnMuY2FuY2VsICsgJycpLnRyaW0oKSA6ICdDQU5DRUwnKSArICdcXG4nO1xuICB9XG4gIHJlYWRPcHRpb25zLmxpbWl0ID0ga2V5bGlzdDtcbiAgZGlzcGxheSArPSAnXFxuJztcblxuICBpZiAocXVlcnkgPT0gbnVsbCkgeyBxdWVyeSA9ICdDaG9vc2Ugb25lIGZyb20gbGlzdDogJzsgfVxuICBpZiAoKHF1ZXJ5ICs9ICcnKSkge1xuICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zLmd1aWRlICE9PSBmYWxzZSkge1xuICAgICAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9cXHMqOj9cXHMqJC8sICcnKSArICcgWyQ8bGltaXQ+XTogJztcbiAgICB9XG4gICAgZGlzcGxheSArPSBxdWVyeTtcbiAgfVxuXG4gIHJldHVybiBrZXkyaVtleHBvcnRzLmtleUluKGRpc3BsYXksIHJlYWRPcHRpb25zKS50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbmV4cG9ydHMuZ2V0UmF3SW5wdXQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHJhd0lucHV0OyB9O1xuXG4vLyA9PT09PT09PSBERVBSRUNBVEVEID09PT09PT09XG5mdW5jdGlvbiBfc2V0T3B0aW9uKG9wdGlvbk5hbWUsIGFyZ3MpIHtcbiAgdmFyIG9wdGlvbnM7XG4gIGlmIChhcmdzLmxlbmd0aCkgeyBvcHRpb25zID0ge307IG9wdGlvbnNbb3B0aW9uTmFtZV0gPSBhcmdzWzBdOyB9XG4gIHJldHVybiBleHBvcnRzLnNldERlZmF1bHRPcHRpb25zKG9wdGlvbnMpW29wdGlvbk5hbWVdO1xufVxuZXhwb3J0cy5zZXRQcmludCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldE9wdGlvbigncHJpbnQnLCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5zZXRQcm9tcHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuIF9zZXRPcHRpb24oJ3Byb21wdCcsIGFyZ3VtZW50cyk7IH07XG5leHBvcnRzLnNldEVuY29kaW5nID0gZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0T3B0aW9uKCdlbmNvZGluZycsIGFyZ3VtZW50cyk7IH07XG5leHBvcnRzLnNldE1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIF9zZXRPcHRpb24oJ21hc2snLCBhcmd1bWVudHMpOyB9O1xuZXhwb3J0cy5zZXRCdWZmZXJTaXplID0gZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0T3B0aW9uKCdidWZmZXJTaXplJywgYXJndW1lbnRzKTsgfTtcbiIsIihmdW5jdGlvbigpIHtcclxuXHRcclxuXHQvLyBWRVJTSU9OXHJcblx0dmFyIHZlcnNpb24gPSB7IG1ham9yOiAwLCBtaW5vcjogMywgcGF0Y2g6IDQsIHN0YXR1czogXCJiZXRhXCIgfTtcclxuXHJcblxyXG5cclxuXHQvLyBJTyBGSUxFIFNZU1RFTVxyXG5cdFxyXG5cdC8vIFZpcnR1YWwgZmlsZVxyXG5cdGZ1bmN0aW9uIFRhdUZpbGUobmFtZSwgdHlwZSwgcGFyZW50LCB0ZXh0KSB7XHJcblx0XHR0ZXh0ID0gdGV4dCA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IHRleHQ7XHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cdFx0dGhpcy50ZXh0ID0gdGV4dDtcclxuXHRcdHRoaXMuY3JlYXRlZCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG5cdFx0dGhpcy5tb2RpZmllZCA9IHRoaXMuY3JlYXRlZDtcclxuXHR9XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGxlbmd0aCwgcG9zaXRpb24pIHtcclxuXHRcdGlmKHBvc2l0aW9uID09PSB0aGlzLnRleHQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBcImVuZF9vZl9zdHJlYW1cIjtcclxuXHRcdH0gZWxzZSBpZihwb3NpdGlvbiA+IHRoaXMudGV4dC5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIFwiZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGV4dC5zdWJzdHJpbmcocG9zaXRpb24sIHBvc2l0aW9uK2xlbmd0aCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuZW9mID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuXHRcdHJldHVybiBwb3NpdGlvbiA9PT0gdGhpcy50ZXh0Lmxlbmd0aDtcclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbih0ZXh0LCBwb3NpdGlvbikge1xyXG5cdFx0aWYocG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdHRoaXMudGV4dCArPSB0ZXh0O1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZihwb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcoMCwgcG9zaXRpb24pICsgdGV4dCArIHRoaXMudGV4dC5zdWJzdHJpbmcocG9zaXRpb24rdGV4dC5sZW5ndGgpO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5nZXRfYnl0ZSA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcblx0XHRpZihwb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdHZhciBpbmRleCA9IE1hdGguZmxvb3IocG9zaXRpb24vMik7XHJcblx0XHRpZih0aGlzLnRleHQubGVuZ3RoIDw9IGluZGV4KVxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR2YXIgY29kZSA9IGNvZGVQb2ludEF0KHRoaXMudGV4dFtNYXRoLmZsb29yKHBvc2l0aW9uLzIpXSwgMCk7XHJcblx0XHRpZihwb3NpdGlvbiAlIDIgPT09IDApXHJcblx0XHRcdHJldHVybiBjb2RlICYgMHhmZjtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIGNvZGUgLyAyNTYgPj4+IDA7XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUucHV0X2J5dGUgPSBmdW5jdGlvbihieXRlLCBwb3NpdGlvbikge1xyXG5cdFx0dmFyIGluZGV4ID0gcG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiID8gdGhpcy50ZXh0Lmxlbmd0aCA6IE1hdGguZmxvb3IocG9zaXRpb24vMik7XHJcblx0XHRpZih0aGlzLnRleHQubGVuZ3RoIDwgaW5kZXgpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIGNvZGUgPSB0aGlzLnRleHQubGVuZ3RoID09PSBpbmRleCA/IC0xIDogY29kZVBvaW50QXQodGhpcy50ZXh0W01hdGguZmxvb3IocG9zaXRpb24vMildLCAwKTtcclxuXHRcdGlmKHBvc2l0aW9uICUgMiA9PT0gMCkge1xyXG5cdFx0XHRjb2RlID0gY29kZSAvIDI1NiA+Pj4gMDtcclxuXHRcdFx0Y29kZSA9ICgoY29kZSAmIDB4ZmYpIDw8IDgpIHwgKGJ5dGUgJiAweGZmKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvZGUgPSBjb2RlICYgMHhmZjtcclxuXHRcdFx0Y29kZSA9ICgoYnl0ZSAmIDB4ZmYpIDw8IDgpIHwgKGNvZGUgJiAweGZmKTtcclxuXHRcdH1cclxuXHRcdGlmKHRoaXMudGV4dC5sZW5ndGggPT09IGluZGV4KVxyXG5cdFx0XHR0aGlzLnRleHQgKz0gZnJvbUNvZGVQb2ludChjb2RlKTtcclxuXHRcdGVsc2UgXHJcblx0XHRcdHRoaXMudGV4dCA9IHRoaXMudGV4dC5zdWJzdHJpbmcoMCwgaW5kZXgpICsgZnJvbUNvZGVQb2ludChjb2RlKSArIHRoaXMudGV4dC5zdWJzdHJpbmcoaW5kZXgrMSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMubW9kaWZpZWQgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xyXG5cdH07XHJcblxyXG5cdC8vIFZpcnR1YWwgZGlyZWN0b3J5XHJcblx0ZnVuY3Rpb24gVGF1RGlyZWN0b3J5KG5hbWUsIHBhcmVudCkge1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG5cdFx0dGhpcy5maWxlcyA9IHt9O1xyXG5cdFx0dGhpcy5sZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5jcmVhdGVkID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcblx0XHR0aGlzLm1vZGlmaWVkID0gdGhpcy5jcmVhdGVkO1xyXG5cdH1cclxuXHJcblx0VGF1RGlyZWN0b3J5LnByb3RvdHlwZS5sb29rdXAgPSBmdW5jdGlvbihmaWxlKSB7XHJcblx0XHRpZih0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KGZpbGUpKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5maWxlc1tmaWxlXTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdFRhdURpcmVjdG9yeS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKG5hbWUsIGZpbGUpIHtcclxuXHRcdGlmKCF0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KG5hbWUpKVxyXG5cdFx0XHR0aGlzLmxlbmd0aCsrO1xyXG5cdFx0dGhpcy5maWxlc1tuYW1lXSA9IGZpbGU7XHJcblx0XHR0aGlzLm1vZGlmaWVkID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcblx0fTtcclxuXHJcblx0VGF1RGlyZWN0b3J5LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7XHJcblx0XHRpZih0aGlzLmZpbGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcblx0XHRcdHRoaXMubGVuZ3RoLS07XHJcblx0XHRcdGRlbGV0ZSB0aGlzLmZpbGVzW25hbWVdO1xyXG5cdFx0XHR0aGlzLm1vZGlmaWVkID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0VGF1RGlyZWN0b3J5LnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xyXG5cdH07XHJcblxyXG5cdFRhdURpcmVjdG9yeS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIDQwOTY7XHJcblx0fTtcclxuXHJcblx0Ly8gVmlydHVhbCBmaWxlIHN5c3RlbSBmb3IgYnJvd3NlclxyXG5cdHRhdV9maWxlX3N5c3RlbSA9IHtcclxuXHRcdC8vIEN1cnJlbnQgZmlsZXNcclxuXHRcdGZpbGVzOiBuZXcgVGF1RGlyZWN0b3J5KFwiL1wiLCBcIi9cIiwgbnVsbCksXHJcblx0XHQvLyBPcGVuIGZpbGVcclxuXHRcdG9wZW46IGZ1bmN0aW9uKHBhdGgsIHR5cGUsIG1vZGUpIHtcclxuXHRcdFx0dmFyIGRpcnMgPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XHJcblx0XHRcdHZhciBkaXIgPSB0YXVfZmlsZV9zeXN0ZW0uZmlsZXM7XHJcblx0XHRcdHZhciBuYW1lID0gZGlyc1tkaXJzLmxlbmd0aC0xXTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMTsgaSA8IGRpcnMubGVuZ3RoLTE7IGkrKykge1xyXG5cdFx0XHRcdGRpciA9IGRpci5sb29rdXAoZGlyc1tpXSk7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfZGlyZWN0b3J5KGRpcikpXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZmlsZSA9IGRpci5sb29rdXAobmFtZSk7XHJcblx0XHRcdGlmKGZpbGUgPT09IG51bGwpIHtcclxuXHRcdFx0XHRpZihtb2RlID09PSBcInJlYWRcIilcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdGZpbGUgPSBuZXcgVGF1RmlsZShuYW1lLCB0eXBlLCBkaXIpO1xyXG5cdFx0XHRcdGRpci5wdXNoKG5hbWUsIGZpbGUpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfZmlsZShmaWxlKSkge1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG1vZGUgPT09IFwid3JpdGVcIilcclxuXHRcdFx0XHRmaWxlLnRleHQgPSBcIlwiO1xyXG5cdFx0XHRyZXR1cm4gZmlsZTtcclxuXHRcdH0sXHJcblx0XHQvLyBHZXQgaXRlbVxyXG5cdFx0Z2V0OiBmdW5jdGlvbihwYXRoKSB7XHJcblx0XHRcdHZhciBkaXJzID0gcGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIikuc3BsaXQoXCIvXCIpO1xyXG5cdFx0XHR2YXIgZmlsZSA9IHRhdV9maWxlX3N5c3RlbS5maWxlcztcclxuXHRcdFx0Zm9yKHZhciBpID0gMTsgaSA8IGRpcnMubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19kaXJlY3RvcnkoZmlsZSkpXHJcblx0XHRcdFx0XHRmaWxlID0gZmlsZS5sb29rdXAoZGlyc1tpXSk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdHJldHVybiBmaWxlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgaW5wdXQgZm9yIGJyb3dzZXJcclxuXHR0YXVfdXNlcl9pbnB1dCA9IHtcclxuXHRcdGJ1ZmZlcjogXCJcIixcclxuXHRcdGdldDogZnVuY3Rpb24oIGxlbmd0aCwgXyApIHtcclxuXHRcdFx0dmFyIHRleHQ7XHJcblx0XHRcdHdoaWxlKCB0YXVfdXNlcl9pbnB1dC5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoICkge1xyXG5cdFx0XHRcdHRleHQgPSB3aW5kb3cucHJvbXB0KCk7XHJcblx0XHRcdFx0aWYoIHRleHQubGVuZ3RoID09PSAwIClcclxuXHRcdFx0XHRcdHJldHVybiBcImVuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRpZiggdGV4dCApIHtcclxuXHRcdFx0XHRcdHRhdV91c2VyX2lucHV0LmJ1ZmZlciArPSB0ZXh0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0ZXh0ID0gdGF1X3VzZXJfaW5wdXQuYnVmZmVyLnN1YnN0ciggMCwgbGVuZ3RoICk7XHJcblx0XHRcdHRhdV91c2VyX2lucHV0LmJ1ZmZlciA9IHRhdV91c2VyX2lucHV0LmJ1ZmZlci5zdWJzdHIoIGxlbmd0aCApO1xyXG5cdFx0XHRyZXR1cm4gdGV4dDtcclxuXHRcdH0sXHJcblx0XHRlb2Y6IGZ1bmN0aW9uKF8pIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgb3V0cHV0IGZvciBicm93c2VyXHJcblx0dGF1X3VzZXJfb3V0cHV0ID0ge1xyXG5cdFx0cHV0OiBmdW5jdGlvbiggdGV4dCwgXyApIHtcclxuXHRcdFx0Y29uc29sZS5sb2coIHRleHQgKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0Zmx1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gXHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBlcnJvciBmb3IgYnJvd3NlclxyXG5cdHRhdV91c2VyX2Vycm9yID0ge1xyXG5cdFx0cHV0OiBmdW5jdGlvbiggdGV4dCwgXyApIHtcclxuXHRcdFx0KGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKCB0ZXh0ICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdGZsdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9IFxyXG5cdH07XHJcblxyXG5cdC8vIFZpcnR1YWwgZmlsZSBzeXN0ZW0gZm9yIE5vZGUuanNcclxuXHRub2RlanNfZmlsZV9zeXN0ZW0gPSB7XHJcblx0XHQvLyBPcGVuIGZpbGVcclxuXHRcdG9wZW46IGZ1bmN0aW9uKCBwYXRoLCB0eXBlLCBtb2RlICkge1xyXG5cdFx0XHR2YXIgZmQsIGZzID0gcmVxdWlyZSgnZnMnKTtcclxuXHRcdFx0aWYoIG1vZGUgPT09IFwicmVhZFwiICYmICFmcy5leGlzdHNTeW5jKCBwYXRoICkgKVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGZkID0gZnMub3BlblN5bmMoIHBhdGgsIG1vZGVbMF0gKTtcclxuXHRcdFx0fSBjYXRjaChleCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oIGxlbmd0aCwgcG9zaXRpb24gKSB7XHJcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlciggbGVuZ3RoICk7XHJcblx0XHRcdFx0XHRmcy5yZWFkU3luYyggZmQsIGJ1ZmZlciwgMCwgbGVuZ3RoLCBwb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0dmFyIGVuZF9vZl9maWxlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHZhciB0ZXh0ID0gYnVmZmVyLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICYmIGVuZF9vZl9maWxlOyBpKyspXHJcblx0XHRcdFx0XHRcdGVuZF9vZl9maWxlID0gdGV4dFtpXSA9PT0gXCJcXHUwMDAwXCI7XHJcblx0XHRcdFx0XHRyZXR1cm4gZW5kX29mX2ZpbGUgPyBcImVuZF9vZl9zdHJlYW1cIiA6IGJ1ZmZlci50b1N0cmluZygpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0ZW9mOiBmdW5jdGlvbihwb3NpdGlvbikge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRzID0gZnMuc3RhdFN5bmMocGF0aClcclxuXHRcdFx0XHRcdHJldHVybiBwb3NpdGlvbiA9PT0gc3RhdHNbXCJzaXplXCJdO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0cHV0OiBmdW5jdGlvbiggdGV4dCwgcG9zaXRpb24gKSB7XHJcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oIHRleHQgKTtcclxuXHRcdFx0XHRcdGlmKCBwb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKVxyXG5cdFx0XHRcdFx0XHRmcy53cml0ZVN5bmMoIGZkLCBidWZmZXIgKTtcclxuXHRcdFx0XHRcdGVsc2UgaWYoIHBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGZzLndyaXRlU3luYyggZmQsIGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCwgcG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Z2V0X2J5dGU6IGZ1bmN0aW9uKCBwb3NpdGlvbiApIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMSk7XHJcblx0XHRcdFx0XHRcdHZhciBieXRlc1JlYWQgPSBmcy5yZWFkU3luYyhmZCwgYnVmZmVyLCAwLCAxLCBwb3NpdGlvbik7XHJcblx0XHRcdFx0XHRcdC8vdmFyIF90ZXh0ID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCAwLCBieXRlc1JlYWQpO1xyXG5cdFx0XHRcdFx0XHR2YXIgZW5kX29mX2ZpbGUgPSBieXRlc1JlYWQgPCAxO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZW5kX29mX2ZpbGUgPyBcImVuZF9vZl9zdHJlYW1cIiA6IGJ1ZmZlci5yZWFkVUludDgoMCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoKGV4KSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBcImVuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHB1dF9ieXRlOiBmdW5jdGlvbihieXRlLCBwb3NpdGlvbikge1xyXG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFtieXRlXSk7XHJcblx0XHRcdFx0XHRpZihwb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpXHJcblx0XHRcdFx0XHRcdGZzLndyaXRlU3luYyhmZCwgYnVmZmVyKTtcclxuXHRcdFx0XHRcdGVsc2UgaWYocG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIpXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRmcy53cml0ZVN5bmMoZmQsIGJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCwgcG9zaXRpb24pO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmbHVzaDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGNsb3NlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGZzLmNsb3NlU3luYyggZmQgKTtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIGlucHV0IGZvciBOb2RlLmpzXHJcblx0bm9kZWpzX3VzZXJfaW5wdXQgPSB7XHJcblx0XHRidWZmZXI6IFwiXCIsXHJcblx0XHRnZXQ6IGZ1bmN0aW9uKCBsZW5ndGgsIF8gKSB7XHJcblx0XHRcdHZhciB0ZXh0O1xyXG5cdFx0XHR2YXIgcmVhZGxpbmVTeW5jID0gcmVxdWlyZSgncmVhZGxpbmUtc3luYycpO1xyXG5cdFx0XHR3aGlsZSggbm9kZWpzX3VzZXJfaW5wdXQuYnVmZmVyLmxlbmd0aCA8IGxlbmd0aCApXHJcblx0XHRcdFx0bm9kZWpzX3VzZXJfaW5wdXQuYnVmZmVyICs9IHJlYWRsaW5lU3luYy5xdWVzdGlvbihcIlwiLCB7a2VlcFdoaXRlc3BhY2U6IHRydWV9KSArIFwiXFxuXCI7XHJcblx0XHRcdHRleHQgPSBub2RlanNfdXNlcl9pbnB1dC5idWZmZXIuc3Vic3RyKCAwLCBsZW5ndGggKTtcclxuXHRcdFx0bm9kZWpzX3VzZXJfaW5wdXQuYnVmZmVyID0gbm9kZWpzX3VzZXJfaW5wdXQuYnVmZmVyLnN1YnN0ciggbGVuZ3RoICk7XHJcblx0XHRcdHJldHVybiB0ZXh0O1xyXG5cdFx0fSxcclxuXHRcdGVvZjogZnVuY3Rpb24obGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIG91dHB1dCBmb3IgTm9kZS5qc1xyXG5cdG5vZGVqc191c2VyX291dHB1dCA9IHtcclxuXHRcdHB1dDogZnVuY3Rpb24oIHRleHQsIF8gKSB7XHJcblx0XHRcdHByb2Nlc3Muc3Rkb3V0LndyaXRlKCB0ZXh0ICk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdGZsdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBlcnJvciBmb3IgTm9kZS5qc1xyXG5cdG5vZGVqc191c2VyX2Vycm9yID0ge1xyXG5cdFx0cHV0OiBmdW5jdGlvbiggdGV4dCwgXyApIHtcclxuXHRcdFx0cHJvY2Vzcy5zdGRlcnIud3JpdGUoIHRleHQgKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0Zmx1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gXHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBDT01QQVRJVEJJTElUWVxyXG5cdFxyXG5cdHZhciBpbmRleE9mO1xyXG5cdGlmKCFBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xyXG5cdFx0aW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBlbGVtKSB7XHJcblx0XHRcdHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGlmKGVsZW0gPT09IGFycmF5W2ldKSByZXR1cm4gaTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGVsZW0pIHtcclxuXHRcdFx0cmV0dXJuIGFycmF5LmluZGV4T2YoZWxlbSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dmFyIHJlZHVjZSA9IGZ1bmN0aW9uKGFycmF5LCBmbikge1xyXG5cdFx0aWYoYXJyYXkubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGVsZW0gPSBhcnJheVswXTtcclxuXHRcdHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcblx0XHRmb3IodmFyIGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0ZWxlbSA9IGZuKGVsZW0sIGFycmF5W2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBlbGVtO1xyXG5cdH07XHJcblxyXG5cdHZhciBtYXA7XHJcblx0aWYoIUFycmF5LnByb3RvdHlwZS5tYXApIHtcclxuXHRcdG1hcCA9IGZ1bmN0aW9uKGFycmF5LCBmbikge1xyXG5cdFx0XHR2YXIgYSA9IFtdO1xyXG5cdFx0XHR2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRhLnB1c2goIGZuKGFycmF5W2ldKSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bWFwID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcblx0XHRcdHJldHVybiBhcnJheS5tYXAoZm4pO1xyXG5cdFx0fTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGZpbHRlcjtcclxuXHRpZighQXJyYXkucHJvdG90eXBlLmZpbHRlcikge1xyXG5cdFx0ZmlsdGVyID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcblx0XHRcdHZhciBhID0gW107XHJcblx0XHRcdHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGlmKGZuKGFycmF5W2ldKSlcclxuXHRcdFx0XHRcdGEucHVzaCggYXJyYXlbaV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gYTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGZpbHRlciA9IGZ1bmN0aW9uKGFycmF5LCBmbikge1xyXG5cdFx0XHRyZXR1cm4gYXJyYXkuZmlsdGVyKGZuKTtcclxuXHRcdH07XHJcblx0fVxyXG5cdFxyXG5cdHZhciBjb2RlUG9pbnRBdDtcclxuXHRpZighU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdCkge1xyXG5cdFx0Y29kZVBvaW50QXQgPSBmdW5jdGlvbihzdHIsIGkpIHtcclxuXHRcdFx0cmV0dXJuIHN0ci5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29kZVBvaW50QXQgPSBmdW5jdGlvbihzdHIsIGkpIHtcclxuXHRcdFx0cmV0dXJuIHN0ci5jb2RlUG9pbnRBdChpKTtcclxuXHRcdH07XHJcblx0fVxyXG5cdFxyXG5cdHZhciBmcm9tQ29kZVBvaW50O1xyXG5cdGlmKCFTdHJpbmcuZnJvbUNvZGVQb2ludCkge1xyXG5cdFx0ZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR2YXIgc3RyaW5nTGVuZ3RoO1xyXG5cdHZhciByZWdleEFzdHJhbFN5bWJvbHMgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nO1xyXG5cdGlmKEFycmF5LmZyb20pXHJcblx0XHRzdHJpbmdMZW5ndGggPSBmdW5jdGlvbihzdHIpIHtcclxuXHRcdFx0cmV0dXJuIEFycmF5LmZyb20oc3RyKS5sZW5ndGg7XHJcblx0XHR9O1xyXG5cdGVsc2VcclxuXHRcdHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UocmVnZXhBc3RyYWxTeW1ib2xzLCAnXycpLmxlbmd0aDtcclxuXHRcdH07XHJcblxyXG5cdFxyXG5cdFxyXG5cdC8vIFBBUlNFUlxyXG5cclxuXHR2YXIgRVJST1IgPSAwO1xyXG5cdHZhciBTVUNDRVNTID0gMTtcclxuXHJcblx0dmFyIHJlZ2V4X2VzY2FwZSA9IC8oXFxcXGEpfChcXFxcYil8KFxcXFxkKXwoXFxcXGUpfChcXFxcZil8KFxcXFxuKXwoXFxcXHIpfChcXFxccyl8KFxcXFx0KXwoXFxcXHYpfFxcXFx4KFswLTlhLWZBLUZdKylcXFxcfFxcXFwoWzAtN10rKVxcXFx8KFxcXFxcXFxcKXwoXFxcXCcpfCgnJyl8KFxcXFxcIil8KFxcXFxgKXwoXFxcXC4pfCguKS9nO1xyXG5cdHZhciBlc2NhcGVfbWFwID0ge1wiXFxcXGFcIjogNywgXCJcXFxcYlwiOiA4LCBcIlxcXFxkXCI6IDEyNywgXCJcXFxcZVwiOiAyNywgXCJcXFxcZlwiOiAxMiwgXCJcXFxcblwiOiAxMCwgXCJcXFxcclwiOiAxMywgXCJcXFxcc1wiOiAzMiwgXCJcXFxcdFwiOiA5LCBcIlxcXFx2XCI6IDExfTtcclxuXHRmdW5jdGlvbiBlc2NhcGUoc3RyKSB7XHJcblx0XHR2YXIgc3RhY2sgPSBbXTtcclxuXHRcdHZhciBfZXJyb3IgPSBmYWxzZTtcclxuXHRcdHN0ci5yZXBsYWNlKHJlZ2V4X2VzY2FwZSwgZnVuY3Rpb24obWF0Y2gsIGEsIGIsIGQsIGUsIGYsIG4sIHIsIHMsIHQsIHYsIGhleCwgb2N0YWwsIGJhY2ssIHNpbmdsZSwgZHNpbmdsZSwgZG91YmxlLCBiYWNrcXVvdGUsIGVycm9yLCBjaGFyKSB7XHJcblx0XHRcdHN3aXRjaCh0cnVlKSB7XHJcblx0XHRcdFx0Y2FzZSBoZXggIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIHBhcnNlSW50KGhleCwgMTYpICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0XHRjYXNlIG9jdGFsICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKCBwYXJzZUludChvY3RhbCwgOCkgKTtcclxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHRcdGNhc2UgYmFjayAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdGNhc2Ugc2luZ2xlICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0Y2FzZSBkc2luZ2xlICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0Y2FzZSBkb3VibGUgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRjYXNlIGJhY2txdW90ZSAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdFx0c3RhY2sucHVzaCggY29kZVBvaW50QXQobWF0Y2guc3Vic3RyKDEpLDApICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0XHRjYXNlIGNoYXIgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIGNvZGVQb2ludEF0KGNoYXIsMCkgKTtcclxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHRcdGNhc2UgZXJyb3IgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRcdF9lcnJvciA9IHRydWU7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdHN0YWNrLnB1c2goZXNjYXBlX21hcFttYXRjaF0pO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdFx0aWYoX2Vycm9yKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdHJldHVybiBzdGFjaztcclxuXHR9XHJcblxyXG5cdC8vIEVzY2FwZSBhdG9tc1xyXG5cdGZ1bmN0aW9uIGVzY2FwZUF0b20oc3RyLCBxdW90ZSkge1xyXG5cdFx0dmFyIGF0b20gPSAnJztcclxuXHRcdGlmKCBzdHIgPT09IFwiXFxcXFwiICkgcmV0dXJuIG51bGw7XHJcblx0XHRpZiggc3RyLmxlbmd0aCA8IDIgKSByZXR1cm4gc3RyO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoLygoPzpcXFxcXFxcXCkrKXxcXFxcKFswLTddKylcXFxcL2csIGZ1bmN0aW9uKG1hdGNoLCBnMSwgZzIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZzEgfHwgZnJvbUNvZGVQb2ludChwYXJzZUludChnMiwgOCkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoLygoPzpcXFxcXFxcXCkrKXxcXFxceChbMC05YS1mQS1GXSspXFxcXC9nLCBmdW5jdGlvbihtYXRjaCwgZzEsIGcyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGcxIHx8IGZyb21Db2RlUG9pbnQocGFyc2VJbnQoZzIsIDE2KSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvKCg/OlxcXFxcXFxcKSspfFxcXFx1KFswLTlhLWZBLUZdezR9KS9nLCBmdW5jdGlvbihtYXRjaCwgZzEsIGcyKSB7XHJcblx0XHRcdFx0cmV0dXJuIGcxIHx8IGZyb21Db2RlUG9pbnQocGFyc2VJbnQoZzIsIDE2KSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBjYXRjaChlcnJvcikge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBhID0gc3RyLmNoYXJBdChpKTtcclxuXHRcdFx0dmFyIGIgPSBzdHIuY2hhckF0KGkrMSk7XHJcblx0XHRcdGlmKCBhID09PSBxdW90ZSAmJiBiID09PSBxdW90ZSApIHtcclxuXHRcdFx0XHRpKys7XHJcblx0XHRcdFx0YXRvbSArPSBxdW90ZTtcclxuXHRcdFx0fSBlbHNlIGlmKCBhID09PSAnXFxcXCcgKSB7XHJcblx0XHRcdFx0aWYoIFsnYScsJ2InLCdmJywnbicsJ3InLCd0JywndicsXCInXCIsJ1wiJywnXFxcXCcsJ1xcYScsJ1xcYicsJ1xcZicsJ1xcbicsJ1xccicsJ1xcdCcsJ1xcdiddLmluZGV4T2YoYikgIT09IC0xICkge1xyXG5cdFx0XHRcdFx0aSArPSAxO1xyXG5cdFx0XHRcdFx0c3dpdGNoKCBiICkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdhJzogYXRvbSArPSAnXFxhJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2InOiBhdG9tICs9ICdcXGInOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnZic6IGF0b20gKz0gJ1xcZic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICduJzogYXRvbSArPSAnXFxuJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3InOiBhdG9tICs9ICdcXHInOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAndCc6IGF0b20gKz0gJ1xcdCc7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd2JzogYXRvbSArPSAnXFx2JzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCInXCI6IGF0b20gKz0gXCInXCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdcIic6IGF0b20gKz0gJ1wiJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1xcXFwnOiBhdG9tICs9ICdcXFxcJzsgYnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRhdG9tICs9IGE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhdG9tO1xyXG5cdH1cclxuXHRcclxuXHQvLyBSZWRvIGVzY2FwZVxyXG5cdGZ1bmN0aW9uIHJlZG9Fc2NhcGUoc3RyKSB7XHJcblx0XHR2YXIgYXRvbSA9ICcnO1xyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0c3dpdGNoKCBzdHIuY2hhckF0KGkpICkge1xyXG5cdFx0XHRcdGNhc2UgXCInXCI6IGF0b20gKz0gXCJcXFxcJ1wiOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXFxcJzogYXRvbSArPSAnXFxcXFxcXFwnOyBicmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgJ1xcYSc6IGF0b20gKz0gJ1xcXFxhJzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFxiJzogYXRvbSArPSAnXFxcXGInOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXGYnOiBhdG9tICs9ICdcXFxcZic7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcbic6IGF0b20gKz0gJ1xcXFxuJzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFxyJzogYXRvbSArPSAnXFxcXHInOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXHQnOiBhdG9tICs9ICdcXFxcdCc7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcdic6IGF0b20gKz0gJ1xcXFx2JzsgYnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDogYXRvbSArPSBzdHIuY2hhckF0KGkpOyBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGF0b207XHJcblx0fVxyXG5cclxuXHQvLyBTdHJpbmcgdG8gbnVtXHJcblx0ZnVuY3Rpb24gY29udmVydE51bShudW0pIHtcclxuXHRcdHZhciBuID0gbnVtLnN1YnN0cigyKTtcclxuXHRcdHN3aXRjaChudW0uc3Vic3RyKDAsMikudG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRjYXNlIFwiMHhcIjpcclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQobiwgMTYpO1xyXG5cdFx0XHRjYXNlIFwiMGJcIjpcclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VJbnQobiwgMik7XHJcblx0XHRcdGNhc2UgXCIwb1wiOlxyXG5cdFx0XHRcdHJldHVybiBwYXJzZUludChuLCA4KTtcclxuXHRcdFx0Y2FzZSBcIjAnXCI6XHJcblx0XHRcdFx0cmV0dXJuIGVzY2FwZShuKVswXTtcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRyZXR1cm4gcGFyc2VGbG9hdChudW0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gSXMgZ3JhcGhpYyB0b2tlblxyXG5cdGZ1bmN0aW9uIGlzX2dyYXBoaWNfdG9rZW4oc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gL15bI1xcJFxcJlxcKlxcK1xcLVxcLlxcL1xcOlxcPFxcPVxcPlxcP1xcQFxcXlxcflxcXFxdKy8udGVzdChzdHJpbmcpO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVndWxhciBleHByZXNzaW9ucyBmb3IgdG9rZW5zXHJcblx0dmFyIHJ1bGVzID0ge1xyXG5cdFx0d2hpdGVzcGFjZTogL15cXHMqKD86KD86JS4qKXwoPzpcXC9cXCooPzpcXG58XFxyfC4pKj8oPzpcXCpcXC98JCkpfCg/OlxccyspKVxccyovLFxyXG5cdFx0dmFyaWFibGU6IC9eKD86W0EtWl9dW2EtekEtWjAtOV9dKikvLFxyXG5cdFx0YXRvbTogL14oXFwhfCx8O3xbYS16XVswLTlhLXpBLVpfXSp8WyNcXCRcXCZcXCpcXCtcXC1cXC5cXC9cXDpcXDxcXD1cXD5cXD9cXEBcXF5cXH5cXFxcXSt8Jyg/Oig/OicnKXwoPzpcXFxcXFxcXCl8KD86XFxcXCcpfFteJ10pKicpLyxcclxuXHRcdG51bWJlcjogL14oPzowb1swLTddK3wweFswLTlhLWZBLUZdK3wwYlswMV0rfDAnKD86Jyd8XFxcXFthYmRlZm5yc3R2XFxcXCdcImBdfFxcXFx4P1xcZCtcXFxcfFteXFxcXF0pfFxcZCsoPzpcXC5cXGQrKD86W2VFXVsrLV0/XFxkKyk/KT8pLyxcclxuXHRcdHN0cmluZzogL14oPzpcIihbXlwiXXxcIlwifFxcXFxcIikqXCJ8YChbXmBdfGBgfFxcXFxgKSpgKS8sXHJcblx0XHRsX2JyYWNlOiAvXig/OlxcWykvLFxyXG5cdFx0cl9icmFjZTogL14oPzpcXF0pLyxcclxuXHRcdGxfYnJhY2tldDogL14oPzpcXHspLyxcclxuXHRcdHJfYnJhY2tldDogL14oPzpcXH0pLyxcclxuXHRcdGJhcjogL14oPzpcXHwpLyxcclxuXHRcdGxfcGFyZW46IC9eKD86XFwoKS8sXHJcblx0XHRyX3BhcmVuOiAvXig/OlxcKSkvXHJcblx0fTtcclxuXHJcblx0Ly8gUmVwbGFjZSBjaGFycyBvZiBjaGFyX2NvbnZlcnNpb24gc2Vzc2lvblxyXG5cdGZ1bmN0aW9uIHJlcGxhY2UoIHRocmVhZCwgdGV4dCApIHtcclxuXHRcdGlmKCB0aHJlYWQuZ2V0X2ZsYWcoIFwiY2hhcl9jb252ZXJzaW9uXCIgKS5pZCA9PT0gXCJvblwiICkge1xyXG5cdFx0XHRyZXR1cm4gdGV4dC5yZXBsYWNlKC8uL2csIGZ1bmN0aW9uKGNoYXIpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhyZWFkLmdldF9jaGFyX2NvbnZlcnNpb24oIGNoYXIgKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGV4dDtcclxuXHR9XHJcblxyXG5cdC8vIFRva2VuaXplIHN0cmluZ3NcclxuXHRmdW5jdGlvbiBUb2tlbml6ZXIodGhyZWFkKSB7XHJcblx0XHR0aGlzLnRocmVhZCA9IHRocmVhZDtcclxuXHRcdHRoaXMudGV4dCA9IFwiXCI7IC8vIEN1cnJlbnQgdGV4dCB0byBiZSBhbmFsaXplZFxyXG5cdFx0dGhpcy50b2tlbnMgPSBbXTsgLy8gQ29uc3VtZWQgdG9rZW5zXHJcblx0fVxyXG5cclxuXHRUb2tlbml6ZXIucHJvdG90eXBlLnNldF9sYXN0X3Rva2VucyA9IGZ1bmN0aW9uKHRva2Vucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9rZW5zID0gdG9rZW5zO1xyXG5cdH07XHJcblxyXG5cdFRva2VuaXplci5wcm90b3R5cGUubmV3X3RleHQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdFx0dGhpcy50b2tlbnMgPSBbXTtcclxuXHR9O1xyXG5cclxuXHRUb2tlbml6ZXIucHJvdG90eXBlLmdldF90b2tlbnMgPSBmdW5jdGlvbihpbml0KSB7XHJcblx0XHR2YXIgdGV4dDtcclxuXHRcdHZhciBsZW4gPSAwOyAvLyBUb3RhbCBsZW5ndGggcmVzcGVjdCB0byB0ZXh0XHJcblx0XHR2YXIgbGluZSA9IDA7XHJcblx0XHR2YXIgc3RhcnQgPSAwO1xyXG5cdFx0dmFyIHRva2VucyA9IFtdO1xyXG5cdFx0dmFyIGxhc3RfaXNfYmxhbms7XHJcblxyXG5cdFx0aWYoaW5pdCkge1xyXG5cdFx0XHR2YXIgdG9rZW4gPSB0aGlzLnRva2Vuc1tpbml0LTFdO1xyXG5cdFx0XHRsZW4gPSB0b2tlbi5sZW47XHJcblx0XHRcdHRleHQgPSByZXBsYWNlKCB0aGlzLnRocmVhZCwgdGhpcy50ZXh0LnN1YnN0cih0b2tlbi5sZW4pICk7XHJcblx0XHRcdGxpbmUgPSB0b2tlbi5saW5lO1xyXG5cdFx0XHRzdGFydCA9IHRva2VuLnN0YXJ0O1xyXG5cdFx0fVxyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0ZXh0ID0gdGhpcy50ZXh0O1xyXG5cclxuXHJcblx0XHQvLyBJZiB0aGVyZSBpcyBub3RoaW5nIHRvIGJlIGFuYWxpemVkLCByZXR1cm4gbnVsbFxyXG5cdFx0aWYoL15cXHMqJC8udGVzdCh0ZXh0KSlcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0d2hpbGUodGV4dCAhPT0gXCJcIikge1xyXG5cdFx0XHR2YXIgbWF0Y2hlcyA9IFtdO1xyXG5cdFx0XHRsYXN0X2lzX2JsYW5rID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZigvXlxcbi8uZXhlYyh0ZXh0KSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdGxpbmUrKztcclxuXHRcdFx0XHRzdGFydCA9IDA7XHJcblx0XHRcdFx0bGVuKys7XHJcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuLywgXCJcIik7XHJcblx0XHRcdFx0bGFzdF9pc19ibGFuayA9IHRydWU7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvcih2YXIgcnVsZSBpbiBydWxlcykge1xyXG5cdFx0XHRcdGlmKHJ1bGVzLmhhc093blByb3BlcnR5KHJ1bGUpKSB7XHJcblx0XHRcdFx0XHR2YXIgbWF0Y2hzID0gcnVsZXNbcnVsZV0uZXhlYyggdGV4dCApO1xyXG5cdFx0XHRcdFx0aWYobWF0Y2hzKSB7XHJcblx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaCh7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG1hdGNoc1swXSxcclxuXHRcdFx0XHRcdFx0XHRuYW1lOiBydWxlLFxyXG5cdFx0XHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoc1xyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExleGljYWwgZXJyb3JcclxuXHRcdFx0aWYoIW1hdGNoZXMubGVuZ3RoKVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnNldF9sYXN0X3Rva2VucyggW3sgdmFsdWU6IHRleHQsIG1hdGNoZXM6IFtdLCBuYW1lOiBcImxleGljYWxcIiwgbGluZTogbGluZSwgc3RhcnQ6IHN0YXJ0IH1dICk7XHJcblxyXG5cdFx0XHR2YXIgdG9rZW4gPSByZWR1Y2UoIG1hdGNoZXMsIGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRyZXR1cm4gYS52YWx1ZS5sZW5ndGggPj0gYi52YWx1ZS5sZW5ndGggPyBhIDogYjtcclxuXHRcdFx0fSApO1xyXG5cclxuXHRcdFx0dG9rZW4uc3RhcnQgPSBzdGFydDtcclxuXHRcdFx0dG9rZW4ubGluZSA9IGxpbmU7XHJcblxyXG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKHRva2VuLnZhbHVlLCBcIlwiKTtcclxuXHRcdFx0c3RhcnQgKz0gdG9rZW4udmFsdWUubGVuZ3RoO1xyXG5cdFx0XHRsZW4gKz0gdG9rZW4udmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0dmFyIG5sID0gKHRva2VuLnZhbHVlLm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcclxuXHRcdFx0bGluZSArPSBubDtcclxuXHRcdFx0aWYobmwgPiAwKSBcclxuXHRcdFx0XHRzdGFydCA9IHRva2VuLnZhbHVlLmxlbmd0aCAtIHRva2VuLnZhbHVlLmxhc3RJbmRleE9mKFwiXFxuXCIpIC0gMTtcclxuXHRcdFx0dG9rZW4ubGluZV9jb3VudCA9IGxpbmU7XHJcblx0XHRcdHRva2VuLmxpbmVfcG9zaXRpb24gPSBzdGFydDtcclxuXHJcblx0XHRcdHN3aXRjaCh0b2tlbi5uYW1lKSB7XHJcblx0XHRcdFx0Y2FzZSBcImF0b21cIjpcclxuXHRcdFx0XHRcdHRva2VuLnJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYodG9rZW4udmFsdWUuY2hhckF0KDApID09PSBcIidcIikge1xyXG5cdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IGVzY2FwZUF0b20oIHRva2VuLnZhbHVlLnN1YnN0cmluZygxLCB0b2tlbi52YWx1ZS5sZW5ndGggLSAxKSwgXCInXCIgKTtcclxuXHRcdFx0XHRcdFx0aWYoIHRva2VuLnZhbHVlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHRcdHRva2VuLm5hbWUgPSBcImxleGljYWxcIjtcclxuXHRcdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRva2VuLnJhdztcclxuXHRcdFx0XHRcdFx0XHR0b2tlbi5lcnJvciA9IFwidW5rbm93bl9lc2NhcGVfc2VxdWVuY2VcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBcIm51bWJlclwiOlxyXG5cdFx0XHRcdFx0dmFyIHN1YnN0ciA9IHRva2VuLnZhbHVlLnN1YnN0cmluZygwLDIpO1xyXG5cdFx0XHRcdFx0dG9rZW4ucmF3ID0gdG9rZW4udmFsdWU7XHJcblx0XHRcdFx0XHR0b2tlbi5mbG9hdCA9IHN1YnN0ciAhPT0gXCIweFwiICYmIHN1YnN0ciAhPT0gXCIwJ1wiICYmIHRva2VuLnZhbHVlLm1hdGNoKC9bLmVFXS8pICE9PSBudWxsO1xyXG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBjb252ZXJ0TnVtKCB0b2tlbi52YWx1ZSApO1xyXG5cdFx0XHRcdFx0dG9rZW4uYmxhbmsgPSBsYXN0X2lzX2JsYW5rO1xyXG5cdFx0XHRcdFx0aWYoIXRva2VuLmZsb2F0ICYmIHBsLmZsYWcuYm91bmRlZC52YWx1ZS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCIgJiYgdG9rZW4udmFsdWUgPiBwbC5mbGFnLm1heF9pbnRlZ2VyLnZhbHVlLnZhbHVlKSB7XHJcblx0XHRcdFx0XHRcdHRva2VuLm5hbWUgPSBcImxleGljYWxcIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSB0b2tlbi5yYXc7XHJcblx0XHRcdFx0XHRcdHRva2VuLmVycm9yID0gXCJpbnRfb3ZlcmZsb3dcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJzdHJpbmdcIjpcclxuXHRcdFx0XHRcdHZhciBkZWwgPSB0b2tlbi52YWx1ZS5jaGFyQXQoMCk7XHJcblx0XHRcdFx0XHR0b2tlbi5yYXcgPSB0b2tlbi52YWx1ZTtcclxuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gZXNjYXBlQXRvbSggdG9rZW4udmFsdWUuc3Vic3RyaW5nKDEsIHRva2VuLnZhbHVlLmxlbmd0aCAtIDEpLCBkZWwgKTtcclxuXHRcdFx0XHRcdGlmKCB0b2tlbi52YWx1ZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dG9rZW4ubmFtZSA9IFwibGV4aWNhbFwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRva2VuLnJhdztcclxuXHRcdFx0XHRcdFx0dG9rZW4uZXJyb3IgPSBcInVua25vd25fZXNjYXBlX3NlcXVlbmNlXCJcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJ3aGl0ZXNwYWNlXCI6XHJcblx0XHRcdFx0XHR2YXIgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdO1xyXG5cdFx0XHRcdFx0aWYobGFzdCkgbGFzdC5zcGFjZSA9IHRydWU7XHJcblx0XHRcdFx0XHRsYXN0X2lzX2JsYW5rID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdGNhc2UgXCJyX2JyYWNrZXRcIjpcclxuXHRcdFx0XHRcdGlmKCB0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXS5uYW1lID09PSBcImxfYnJhY2tldFwiICkge1xyXG5cdFx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5wb3AoKTtcclxuXHRcdFx0XHRcdFx0dG9rZW4ubmFtZSA9IFwiYXRvbVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IFwie31cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4ucmF3ID0gXCJ7fVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5zcGFjZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBcInJfYnJhY2VcIjpcclxuXHRcdFx0XHRcdGlmKCB0b2tlbnMubGVuZ3RoID4gMCAmJiB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXS5uYW1lID09PSBcImxfYnJhY2VcIiApIHtcclxuXHRcdFx0XHRcdFx0dG9rZW4gPSB0b2tlbnMucG9wKCk7XHJcblx0XHRcdFx0XHRcdHRva2VuLm5hbWUgPSBcImF0b21cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBcIltdXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnJhdyA9IFwiW11cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4uc3BhY2UgPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRva2VuLmxlbiA9IGxlbjtcclxuXHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XHJcblx0XHRcdGxhc3RfaXNfYmxhbmsgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuc2V0X2xhc3RfdG9rZW5zKCB0b2tlbnMgKTtcclxuXHRcdHJldHVybiB0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiB0O1xyXG5cdH07XHJcblxyXG5cdC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cclxuXHRmdW5jdGlvbiBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCBwcmlvcml0eSwgdG9wbGV2ZWwpIHtcclxuXHRcdGlmKCF0b2tlbnNbc3RhcnRdKSByZXR1cm4ge3R5cGU6IEVSUk9SLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydC0xXSwgXCJleHByZXNzaW9uIGV4cGVjdGVkXCIsIHRydWUpfTtcclxuXHRcdHZhciBlcnJvcjtcclxuXHJcblx0XHRpZihwcmlvcml0eSA9PT0gXCIwXCIpIHtcclxuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW3N0YXJ0XTtcclxuXHRcdFx0c3dpdGNoKHRva2VuLm5hbWUpIHtcclxuXHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQrMSwgdmFsdWU6IG5ldyBwbC50eXBlLk51bSh0b2tlbi52YWx1ZSwgdG9rZW4uZmxvYXQpfTtcclxuXHRcdFx0XHRjYXNlIFwidmFyaWFibGVcIjpcclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCsxLCB2YWx1ZTogbmV3IHBsLnR5cGUuVmFyKHRva2VuLnZhbHVlKX07XHJcblx0XHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxyXG5cdFx0XHRcdFx0dmFyIHN0cjtcclxuXHRcdFx0XHRcdHN3aXRjaCggdGhyZWFkLmdldF9mbGFnKCBcImRvdWJsZV9xdW90ZXNcIiApLmlkICkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiYXRvbVwiOjtcclxuXHRcdFx0XHRcdFx0XHRzdHIgPSBuZXcgVGVybSggdG9rZW4udmFsdWUsIFtdICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJjb2Rlc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHN0ciA9IG5ldyBUZXJtKCBcIltdXCIsIFtdICk7XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gdG9rZW4udmFsdWUubGVuZ3RoLTE7IGkgPj0gMDsgaS0tIClcclxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBwbC50eXBlLk51bSggY29kZVBvaW50QXQodG9rZW4udmFsdWUsaSksIGZhbHNlICksIHN0cl0gKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcImNoYXJzXCI6XHJcblx0XHRcdFx0XHRcdFx0c3RyID0gbmV3IFRlcm0oIFwiW11cIiwgW10gKTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSB0b2tlbi52YWx1ZS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IHBsLnR5cGUuVGVybSggdG9rZW4udmFsdWUuY2hhckF0KGkpLCBbXSApLCBzdHJdICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQrMSwgdmFsdWU6IHN0cn07XHJcblx0XHRcdFx0Y2FzZSBcImxfcGFyZW5cIjpcclxuXHRcdFx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCsxLCB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCksIHRydWUpO1xyXG5cdFx0XHRcdFx0aWYoZXhwci50eXBlICE9PSBTVUNDRVNTKSByZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdGlmKHRva2Vuc1tleHByLmxlbl0gJiYgdG9rZW5zW2V4cHIubGVuXS5uYW1lID09PSBcInJfcGFyZW5cIikge1xyXG5cdFx0XHRcdFx0XHRleHByLmxlbisrO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW2V4cHIubGVuXSA/IHRva2Vuc1tleHByLmxlbl0gOiB0b2tlbnNbZXhwci5sZW4tMV0sIFwiKSBvciBvcGVyYXRvciBleHBlY3RlZFwiLCAhdG9rZW5zW2V4cHIubGVuXSl9XHJcblx0XHRcdFx0Y2FzZSBcImxfYnJhY2tldFwiOlxyXG5cdFx0XHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KzEsIHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZihleHByLnR5cGUgIT09IFNVQ0NFU1MpIHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0aWYodG9rZW5zW2V4cHIubGVuXSAmJiB0b2tlbnNbZXhwci5sZW5dLm5hbWUgPT09IFwicl9icmFja2V0XCIpIHtcclxuXHRcdFx0XHRcdFx0ZXhwci5sZW4rKztcclxuXHRcdFx0XHRcdFx0ZXhwci52YWx1ZSA9IG5ldyBUZXJtKCBcInt9XCIsIFtleHByLnZhbHVlXSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW2V4cHIubGVuXSA/IHRva2Vuc1tleHByLmxlbl0gOiB0b2tlbnNbZXhwci5sZW4tMV0sIFwifSBvciBvcGVyYXRvciBleHBlY3RlZFwiLCAhdG9rZW5zW2V4cHIubGVuXSl9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gQ29tcG91bmQgdGVybVxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gcGFyc2VUZXJtKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRpZihyZXN1bHQudHlwZSA9PT0gU1VDQ0VTUyB8fCByZXN1bHQuZGVyaXZlZClcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHQvLyBMaXN0XHJcblx0XHRcdHJlc3VsdCA9IHBhcnNlTGlzdCh0aHJlYWQsIHRva2Vucywgc3RhcnQpO1xyXG5cdFx0XHRpZihyZXN1bHQudHlwZSA9PT0gU1VDQ0VTUyB8fCByZXN1bHQuZGVyaXZlZClcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0XHQvLyBVbmV4cGVjdGVkXHJcblx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IGZhbHNlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0sIHRva2VuLmVycm9yIHx8IFwidW5leHBlY3RlZCB0b2tlblwiKX07XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1heF9wcmlvcml0eSA9IHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKTtcclxuXHRcdHZhciBuZXh0X3ByaW9yaXR5ID0gdGhyZWFkLl9fZ2V0X25leHRfcHJpb3JpdHkocHJpb3JpdHkpO1xyXG5cdFx0dmFyIGF1eF9zdGFydCA9IHN0YXJ0O1xyXG5cdFx0XHJcblx0XHQvLyBQcmVmaXggb3BlcmF0b3JzXHJcblx0XHRpZih0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydCsxXSAmJiAodG9rZW5zW3N0YXJ0XS5zcGFjZSB8fCB0b2tlbnNbc3RhcnQrMV0ubmFtZSAhPT0gXCJsX3BhcmVuXCIpKSB7XHJcblx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tzdGFydCsrXTtcclxuXHRcdFx0dmFyIGNsYXNzZXMgPSB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgdG9rZW4udmFsdWUpO1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQXNzb2NpYXRpdmUgcHJlZml4IG9wZXJhdG9yXHJcblx0XHRcdGlmKGNsYXNzZXMgJiYgY2xhc3Nlcy5pbmRleE9mKFwiZnlcIikgPiAtMSkge1xyXG5cdFx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgcHJpb3JpdHksIHRvcGxldmVsKTtcclxuXHRcdFx0XHRpZihleHByLnR5cGUgIT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRpZiggdG9rZW4udmFsdWUgPT09IFwiLVwiICYmICF0b2tlbi5zcGFjZSAmJiBwbC50eXBlLmlzX251bWJlciggZXhwci52YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5OdW0oLWV4cHIudmFsdWUudmFsdWUsIGV4cHIudmFsdWUuaXNfZmxvYXQpLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogZXhwci5sZW4sXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IGV4cHIubGVuLFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXJyb3IgPSBleHByO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0Ly8gTm9uLWFzc29jaWF0aXZlIHByZWZpeCBvcGVyYXRvclxyXG5cdFx0XHR9IGVsc2UgaWYoY2xhc3NlcyAmJiBjbGFzc2VzLmluZGV4T2YoXCJmeFwiKSA+IC0xKSB7XHJcblx0XHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCBuZXh0X3ByaW9yaXR5LCB0b3BsZXZlbCk7XHJcblx0XHRcdFx0aWYoZXhwci50eXBlICE9PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdGxlbjogZXhwci5sZW4sXHJcblx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGVycm9yID0gZXhwcjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRzdGFydCA9IGF1eF9zdGFydDtcclxuXHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgbmV4dF9wcmlvcml0eSwgdG9wbGV2ZWwpO1xyXG5cdFx0aWYoZXhwci50eXBlID09PSBTVUNDRVNTKSB7XHJcblx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tzdGFydF07XHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgKFxyXG5cdFx0XHRcdHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIHRva2VuLnZhbHVlKSB8fFxyXG5cdFx0XHRcdHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJiYXJcIiAmJiB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgXCJ8XCIpXHJcblx0XHRcdCkgKSB7XHJcblx0XHRcdFx0dmFyIG5leHRfcHJpb3JpdHlfbHQgPSBuZXh0X3ByaW9yaXR5O1xyXG5cdFx0XHRcdHZhciBuZXh0X3ByaW9yaXR5X2VxID0gcHJpb3JpdHk7XHJcblx0XHRcdFx0dmFyIGNsYXNzZXMgPSB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgdG9rZW4udmFsdWUpO1xyXG5cclxuXHRcdFx0XHRpZihjbGFzc2VzLmluZGV4T2YoXCJ4ZlwiKSA+IC0xKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0bGVuOiArK2V4cHIubGVuLFxyXG5cdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH0gZWxzZSBpZihjbGFzc2VzLmluZGV4T2YoXCJ4ZnhcIikgPiAtMSkge1xyXG5cdFx0XHRcdFx0dmFyIGV4cHIyID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCArIDEsIG5leHRfcHJpb3JpdHlfbHQsIHRvcGxldmVsKTtcclxuXHRcdFx0XHRcdGlmKGV4cHIyLnR5cGUgPT09IFNVQ0NFU1MpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWUsIGV4cHIyLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBleHByMi5sZW4sXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZXhwcjIuZGVyaXZlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByMjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoY2xhc3Nlcy5pbmRleE9mKFwieGZ5XCIpID4gLTEpIHtcclxuXHRcdFx0XHRcdHZhciBleHByMiA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQgKyAxLCBuZXh0X3ByaW9yaXR5X2VxLCB0b3BsZXZlbCk7XHJcblx0XHRcdFx0XHRpZihleHByMi50eXBlID09PSBTVUNDRVNTKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlLCBleHByMi52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogZXhwcjIubGVuLFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGV4cHIyLmRlcml2ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKGV4cHIudHlwZSAhPT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdHdoaWxlKHRydWUpIHtcclxuXHRcdFx0XHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0XHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW3N0YXJ0XTtcclxuXHRcdFx0XHRcdFx0aWYodG9rZW4gJiYgdG9rZW4ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIHRva2VuLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbGFzc2VzID0gdGhyZWFkLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMocHJpb3JpdHksIHRva2VuLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0XHRpZiggY2xhc3Nlcy5pbmRleE9mKFwieWZcIikgPiAtMSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGV4cHIgPSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsZW46ICsrc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBjbGFzc2VzLmluZGV4T2YoXCJ5ZnhcIikgPiAtMSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBleHByMiA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2VucywgKytzdGFydCwgbmV4dF9wcmlvcml0eV9sdCwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoZXhwcjIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZXhwcjIuZGVyaXZlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBleHByMjtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZXhwcjIubGVuO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwciA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlLCBleHByMi52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsZW46IHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7IGJyZWFrOyB9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVycm9yID0ge3R5cGU6IEVSUk9SLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tleHByLmxlbi0xXSwgXCJvcGVyYXRvciBleHBlY3RlZFwiKX07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZXhwcjtcclxuXHR9XHJcblxyXG5cdC8vIFBhcnNlIGEgY29tcG91bmQgdGVybVxyXG5cdGZ1bmN0aW9uIHBhcnNlVGVybSh0aHJlYWQsIHRva2Vucywgc3RhcnQsIHRvcGxldmVsKSB7XHJcblx0XHRpZighdG9rZW5zW3N0YXJ0XSB8fCAodG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnRdLnJhdyA9PT0gXCIuXCIgJiYgIXRvcGxldmVsICYmICh0b2tlbnNbc3RhcnRdLnNwYWNlIHx8ICF0b2tlbnNbc3RhcnQrMV0gfHwgdG9rZW5zW3N0YXJ0KzFdLm5hbWUgIT09IFwibF9wYXJlblwiKSkpXHJcblx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IGZhbHNlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydC0xXSwgXCJ1bmZvdW5kZWQgdG9rZW5cIil9O1xyXG5cdFx0dmFyIGF0b20gPSB0b2tlbnNbc3RhcnRdO1xyXG5cdFx0dmFyIGV4cHJzID0gW107XHJcblx0XHRpZih0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydF0ucmF3ICE9PSBcIixcIikge1xyXG5cdFx0XHRzdGFydCsrO1xyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnQtMV0uc3BhY2UpIHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCwgdmFsdWU6IG5ldyBwbC50eXBlLlRlcm0oYXRvbS52YWx1ZSwgZXhwcnMpfTtcclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwibF9wYXJlblwiKSB7XHJcblx0XHRcdFx0aWYodG9rZW5zW3N0YXJ0KzFdICYmIHRva2Vuc1tzdGFydCsxXS5uYW1lID09PSBcInJfcGFyZW5cIikgXHJcblx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydCsxXSwgXCJhcmd1bWVudCBleHBlY3RlZFwiKX07XHJcblx0XHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsICsrc3RhcnQsIFwiOTk5XCIsIHRydWUpO1xyXG5cdFx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdGlmKCBleHByLmRlcml2ZWQgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdID8gdG9rZW5zW3N0YXJ0XSA6IHRva2Vuc1tzdGFydC0xXSwgXCJhcmd1bWVudCBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0XSl9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRleHBycy5wdXNoKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdFx0d2hpbGUodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydF0udmFsdWUgPT09IFwiLFwiKSB7XHJcblx0XHRcdFx0XHRleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCsxLCBcIjk5OVwiLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdFx0aWYoIGV4cHIuZGVyaXZlZCApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydCsxXSA/IHRva2Vuc1tzdGFydCsxXSA6IHRva2Vuc1tzdGFydF0sIFwiYXJndW1lbnQgZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydCsxXSl9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZXhwcnMucHVzaChleHByLnZhbHVlKTtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcInJfcGFyZW5cIikgc3RhcnQrKztcclxuXHRcdFx0XHRlbHNlIHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSA/IHRva2Vuc1tzdGFydF0gOiB0b2tlbnNbc3RhcnQtMV0sIFwiLCBvciApIGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnRdKX07XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0LCB2YWx1ZTogbmV3IHBsLnR5cGUuVGVybShhdG9tLnZhbHVlLCBleHBycyl9O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogZmFsc2UsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSwgXCJ0ZXJtIGV4cGVjdGVkXCIpfTtcclxuXHR9XHJcblxyXG5cdC8vIFBhcnNlIGEgbGlzdFxyXG5cdGZ1bmN0aW9uIHBhcnNlTGlzdCh0aHJlYWQsIHRva2Vucywgc3RhcnQpIHtcclxuXHRcdGlmKCF0b2tlbnNbc3RhcnRdKSBcclxuXHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogZmFsc2UsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0LTFdLCBcIlsgZXhwZWN0ZWRcIil9O1xyXG5cdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwibF9icmFjZVwiKSB7XHJcblx0XHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCArK3N0YXJ0LCBcIjk5OVwiLCB0cnVlKTtcclxuXHRcdFx0dmFyIGV4cHJzID0gW2V4cHIudmFsdWVdO1xyXG5cdFx0XHR2YXIgY29ucyA9IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJyX2JyYWNlXCIpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCsxLCB2YWx1ZTogbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKX07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSwgXCJdIGV4cGVjdGVkXCIpfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHJcblx0XHRcdHdoaWxlKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbc3RhcnRdLnZhbHVlID09PSBcIixcIikge1xyXG5cdFx0XHRcdGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KzEsIFwiOTk5XCIsIHRydWUpO1xyXG5cdFx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdGlmKCBleHByLmRlcml2ZWQgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQrMV0gPyB0b2tlbnNbc3RhcnQrMV0gOiB0b2tlbnNbc3RhcnRdLCBcImFyZ3VtZW50IGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnQrMV0pfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZXhwcnMucHVzaChleHByLnZhbHVlKTtcclxuXHRcdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBiYXIgPSBmYWxzZVxyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJiYXJcIikge1xyXG5cdFx0XHRcdGJhciA9IHRydWU7XHJcblx0XHRcdFx0ZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQrMSwgXCI5OTlcIiwgdHJ1ZSk7XHJcblx0XHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0aWYoIGV4cHIuZGVyaXZlZCApXHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydCsxXSA/IHRva2Vuc1tzdGFydCsxXSA6IHRva2Vuc1tzdGFydF0sIFwiYXJndW1lbnQgZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydCsxXSl9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb25zID0gZXhwci52YWx1ZTtcclxuXHRcdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcInJfYnJhY2VcIilcclxuXHRcdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQrMSwgdmFsdWU6IGFycmF5VG9MaXN0KGV4cHJzLCBjb25zKSB9O1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdID8gdG9rZW5zW3N0YXJ0XSA6IHRva2Vuc1tzdGFydC0xXSwgYmFyID8gXCJdIGV4cGVjdGVkXCIgOiBcIiwgb3IgfCBvciBdIGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnRdKX07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiBmYWxzZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdLCBcImxpc3QgZXhwZWN0ZWRcIil9O1xyXG5cdH1cclxuXHJcblx0Ly8gUGFyc2UgYSBydWxlXHJcblx0ZnVuY3Rpb24gcGFyc2VSdWxlKHRocmVhZCwgdG9rZW5zLCBzdGFydCkge1xyXG5cdFx0dmFyIGxpbmUgPSB0b2tlbnNbc3RhcnRdLmxpbmU7XHJcblx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQsIHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKSwgZmFsc2UpO1xyXG5cdFx0dmFyIHJ1bGUgPSBudWxsO1xyXG5cdFx0dmFyIG9iajtcclxuXHRcdGlmKGV4cHIudHlwZSAhPT0gRVJST1IpIHtcclxuXHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydF0ucmF3ID09PSBcIi5cIikge1xyXG5cdFx0XHRcdHN0YXJ0Kys7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybShleHByLnZhbHVlKSApIHtcclxuXHRcdFx0XHRcdGlmKGV4cHIudmFsdWUuaW5kaWNhdG9yID09PSBcIjotLzJcIikge1xyXG5cdFx0XHRcdFx0XHRydWxlID0gbmV3IHBsLnR5cGUuUnVsZShleHByLnZhbHVlLmFyZ3NbMF0sIGJvZHlfY29udmVyc2lvbihleHByLnZhbHVlLmFyZ3NbMV0pKTtcclxuXHRcdFx0XHRcdFx0b2JqID0ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBydWxlLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKGV4cHIudmFsdWUuaW5kaWNhdG9yID09PSBcIi0tPi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0cnVsZSA9IG5ldyBwbC50eXBlLlJ1bGUoZXhwci52YWx1ZS5hcmdzWzBdLCBib2R5X2NvbnZlcnNpb24oZXhwci52YWx1ZS5hcmdzWzFdKSk7XHJcblx0XHRcdFx0XHRcdHJ1bGUgPSBydWxlX3RvX2RjZyhydWxlLCB0aHJlYWQpO1xyXG5cdFx0XHRcdFx0XHRydWxlLmJvZHkgPSBib2R5X2NvbnZlcnNpb24ocnVsZS5ib2R5KTtcclxuXHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfcnVsZShydWxlKSlcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWU6IHJ1bGUsXHJcblx0XHRcdFx0XHRcdFx0XHRsZW46IHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdFx0dHlwZTogRVJST1JcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRvYmogPSB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHJ1bGUsXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBzdGFydCxcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBwbC50eXBlLmlzX3J1bGUoIHJ1bGUgKSA/IFNVQ0NFU1MgOiBFUlJPUlxyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cnVsZSA9IG5ldyBwbC50eXBlLlJ1bGUoZXhwci52YWx1ZSwgbnVsbCk7XHJcblx0XHRcdFx0XHRcdG9iaiA9IHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogcnVsZSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBydWxlICkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc2luZ2xldG9uID0gcnVsZS5zaW5nbGV0b25fdmFyaWFibGVzKCk7XHJcblx0XHRcdFx0XHRcdGlmKCBzaW5nbGV0b24ubGVuZ3RoID4gMCApXHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLndhcm5pbmcuc2luZ2xldG9uKCBzaW5nbGV0b24sIHJ1bGUuaGVhZC5pbmRpY2F0b3IsIGxpbmUgKSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHsgdHlwZTogRVJST1IsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSwgXCJjYWxsYWJsZSBleHBlY3RlZFwiKSB9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4geyB0eXBlOiBFUlJPUiwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdID8gdG9rZW5zW3N0YXJ0XSA6IHRva2Vuc1tzdGFydC0xXSwgXCIuIG9yIG9wZXJhdG9yIGV4cGVjdGVkXCIpIH07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBleHByO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFyc2UgYSBwcm9ncmFtXHJcblx0ZnVuY3Rpb24gcGFyc2VQcm9ncmFtKHRocmVhZCwgc3RyaW5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3B0cyA9IHt9O1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XHJcblx0XHRvcHRzLnN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgPyBvcHRpb25zLnN1Y2Nlc3MgOiBmdW5jdGlvbigpe307XHJcblx0XHRvcHRzLmVycm9yID0gb3B0aW9ucy5lcnJvciA/IG9wdGlvbnMuZXJyb3IgOiBmdW5jdGlvbigpe307XHJcblx0XHRvcHRzLmZyb20gPSBvcHRpb25zLmZyb20gPyBvcHRpb25zLmZyb20gOiBcIiR0YXUtanNcIjtcclxuXHRcdG9wdHMucmVjb25zdWx0ID0gb3B0aW9ucy5yZWNvbnN1bHQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVjb25zdWx0IDogdHJ1ZTtcclxuXHRcdG9wdHMucmVjb25zdWx0ZWQgPSBvcHRpb25zLnJlY29uc3VsdGVkID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMucmVjb25zdWx0ZWQ7XHJcblx0XHRvcHRzLmNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZSA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0b3B0cy5pbml0aWFsaXphdGlvbiA9IG9wdGlvbnMuaW5pdGlhbGl6YXRpb24gPT09IHVuZGVmaW5lZCA/IFtdIDogb3B0aW9ucy5pbml0aWFsaXphdGlvbjtcclxuXHRcdG9wdHMuY3VycmVudF90b2tlbiA9IG9wdGlvbnMuY3VycmVudF90b2tlbiA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY3VycmVudF90b2tlbjtcclxuXHRcdG9wdHMudG9rZW5pemVyID0gb3B0aW9ucy50b2tlbml6ZXIgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLnRva2VuaXplcjtcclxuXHRcdG9wdHMudG9rZW5zID0gb3B0aW9ucy50b2tlbnMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLnRva2VucztcclxuXHRcdG9wdHMuc3RyaW5nID0gc3RyaW5nO1xyXG5cdFx0b3B0cy50ZXJtX2V4cGFuc2lvbiA9IGZhbHNlO1xyXG5cdFx0dmFyIHJlY29uc3VsdGVkID0gb3B0cy5yZWNvbnN1bHRlZDtcclxuXHRcdHZhciB0b2tlbml6ZXIgPSBvcHRzLnRva2VuaXplcjtcclxuXHRcdHZhciB0b2tlbnMgPSBvcHRzLnRva2VucztcclxuXHRcdGlmKHRva2VuaXplciA9PT0gbnVsbCkge1xyXG5cdFx0XHR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHRocmVhZCk7XHJcblx0XHRcdHRva2VuaXplci5uZXdfdGV4dChzdHJpbmcpO1xyXG5cdFx0XHRvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcclxuXHRcdFx0dG9rZW5zID0gdG9rZW5pemVyLmdldF90b2tlbnMoMCk7XHJcblx0XHRcdG9wdHMudG9rZW5zID0gdG9rZW5zO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG4gPSBvcHRzLmN1cnJlbnRfdG9rZW47XHJcblx0XHR3aGlsZSh0b2tlbnMgIT09IG51bGwgJiYgdG9rZW5zW25dKSB7XHJcblx0XHRcdHZhciBleHByID0gcGFyc2VSdWxlKHRocmVhZCwgdG9rZW5zLCBuKTtcclxuXHRcdFx0b3B0cy5jdXJyZW50X3Rva2VuID0gZXhwci5sZW47XHJcblx0XHRcdGlmKGV4cHIudHlwZSA9PT0gRVJST1IpIHtcclxuXHRcdFx0XHRpZihvcHRzLmVycm9yICE9PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0b3B0cy5lcnJvcihuZXcgVGVybShcInRocm93XCIsIFtleHByLnZhbHVlXSkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBUZXJtIGV4cGFuc2lvblxyXG5cdFx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IG9wdHMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdFx0dmFyIHRlcm1fZXhwYW5zaW9uID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV0ucnVsZXNbXCJ0ZXJtX2V4cGFuc2lvbi8yXCJdO1xyXG5cdFx0XHRcdGlmKHRlcm1fZXhwYW5zaW9uICYmIHRlcm1fZXhwYW5zaW9uLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdG9wdHMudGVybV9leHBhbnNpb24gPSB0cnVlO1xyXG5cdFx0XHRcdFx0dmFyIG5fdGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRcdFx0XHR2YXIgdGVybSA9IGV4cHIudmFsdWUuYm9keSA/IG5ldyBUZXJtKFwiOi1cIiwgW2V4cHIudmFsdWUuaGVhZCwgZXhwci52YWx1ZS5ib2R5XSkgOiBleHByLnZhbHVlLmhlYWQ7XHJcblx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdFx0dGVybSA9IHRlcm0ucmVuYW1lKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdFx0XHRcdG5fdGhyZWFkLnF1ZXJ5KGNvbnRleHRfbW9kdWxlICsgXCI6dGVybV9leHBhbnNpb24oXCIgKyB0ZXJtLnRvU3RyaW5nKHtxdW90ZWQ6IHRydWV9KSArIFwiLCBYKS5cIik7XHJcblx0XHRcdFx0XHRuX3RocmVhZC5hbnN3ZXIoKGZ1bmN0aW9uKHRocmVhZCwgb3B0cywgcmVjb25zdWx0ZWQsIGV4cHIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRcdFx0XHRcdGlmKGFuc3dlciAmJiAhcGwudHlwZS5pc19lcnJvcihhbnN3ZXIpICYmIHBsLnR5cGUuaXNfdGVybShhbnN3ZXIubGlua3NbJ1gnXSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB0ZXJtID0gYW5zd2VyLmxpbmtzWydYJ107XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgcnVsZSA9IHRlcm0uaW5kaWNhdG9yID09PSBcIjotLzJcIiA/IG5ldyBSdWxlKHRlcm0uYXJnc1swXSwgdGVybS5hcmdzWzFdKSA6IG5ldyBSdWxlKHRlcm0sIG51bGwpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VQcm9ncmFtRXhwYW5zaW9uKHRocmVhZCwgb3B0cywgcmVjb25zdWx0ZWQsIHt2YWx1ZTogcnVsZSwgbGVuOiBleHByLmxlbiwgdHlwZTogZXhwci50eXBlfSk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlUHJvZ3JhbUV4cGFuc2lvbih0aHJlYWQsIG9wdHMsIHJlY29uc3VsdGVkLCBleHByKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pKHRocmVhZCwgb3B0cywgcmVjb25zdWx0ZWQsIGV4cHIpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0b3B0cy50ZXJtX2V4cGFuc2lvbiA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0dmFyIGFzeW5jID0gcGFyc2VQcm9ncmFtRXhwYW5zaW9uKHRocmVhZCwgb3B0cywgcmVjb25zdWx0ZWQsIGV4cHIpO1xyXG5cdFx0XHRcdFx0aWYoYXN5bmMpXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdG4gPSBleHByLmxlbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vIHJ1biBnb2FscyBmcm9tIGluaXRpYWxpemF0aW9uLzEgZGlyZWN0aXZlXHJcblx0XHR2YXIgY2FsbGJhY2sgPSBvcHRzLnN1Y2Nlc3M7XHJcblx0XHR2YXIgbnRocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0Zm9yKHZhciBpID0gb3B0cy5pbml0aWFsaXphdGlvbi5sZW5ndGgtMTsgaSA+IDA7IGktLSkge1xyXG5cdFx0XHR2YXIgbmV4dF9jYWxsYmFjayA9IChmdW5jdGlvbihpbml0LCBjYWxsYmFjaykge1xyXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0XHRcdGlmKGFuc3dlciA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRudGhyZWFkLmFuc3dlcigpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSkge1xyXG5cdFx0XHRcdFx0XHRvcHRzLmVycm9yKGFuc3dlcik7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRudGhyZWFkLmFkZF9nb2FsKGluaXQpO1xyXG5cdFx0XHRcdFx0XHRudGhyZWFkLmFuc3dlcihjYWxsYmFjayk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSkob3B0cy5pbml0aWFsaXphdGlvbltpXSwgY2FsbGJhY2spO1xyXG5cdFx0XHRjYWxsYmFjayA9IG5leHRfY2FsbGJhY2s7XHJcblx0XHR9XHJcblx0XHRpZihvcHRzLmluaXRpYWxpemF0aW9uLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0bnRocmVhZC5hZGRfZ29hbChvcHRzLmluaXRpYWxpemF0aW9uWzBdKTtcclxuXHRcdFx0bnRocmVhZC5hbnN3ZXIoY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlR29hbEV4cGFuc2lvbih0aHJlYWQsIG9wdGlvbnMsIGV4cHIpIHtcclxuXHRcdHZhciBuX3RocmVhZCA9IG5ldyBUaHJlYWQoIHRocmVhZC5zZXNzaW9uICk7XHJcblx0XHRuX3RocmVhZC5fX2dvYWxfZXhwYW5zaW9uID0gdHJ1ZTtcclxuXHRcdHZhciB2YXJ0ZXJtID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0dmFyIHZhcmhlYWQgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHR2YXIgZ29hbCA9IHZhcmhlYWQgKyBcIiA9IFwiICsgZXhwci52YWx1ZS5oZWFkICsgXCIsIGdvYWxfZXhwYW5zaW9uKFwiICsgZXhwci52YWx1ZS5ib2R5LnRvU3RyaW5nKHtcclxuXHRcdFx0cXVvdGVkOiB0cnVlXHJcblx0XHR9KSArIFwiLCBcIiArIHZhcnRlcm0udG9TdHJpbmcoe1xyXG5cdFx0XHRxdW90ZWQ6IHRydWVcclxuXHRcdH0pICsgXCIpLlwiO1xyXG5cdFx0bl90aHJlYWQucXVlcnkoZ29hbCk7XHJcblx0XHRuX3RocmVhZC5hbnN3ZXIoZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdGlmKGFuc3dlciAmJiAhcGwudHlwZS5pc19lcnJvcihhbnN3ZXIpICYmIGFuc3dlci5saW5rc1t2YXJ0ZXJtXSkge1xyXG5cdFx0XHRcdGV4cHIudmFsdWUuaGVhZCA9IGFuc3dlci5saW5rc1t2YXJoZWFkXTtcclxuXHRcdFx0XHRleHByLnZhbHVlLmJvZHkgPSBib2R5X2NvbnZlcnNpb24oYW5zd2VyLmxpbmtzW3ZhcnRlcm1dKTtcclxuXHRcdFx0XHRwYXJzZUdvYWxFeHBhbnNpb24odGhyZWFkLCBvcHRpb25zLCBleHByKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuYWRkX3J1bGUoZXhwci52YWx1ZSwgb3B0aW9ucyk7XHJcblx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlUXVlcnlFeHBhbnNpb24odGhyZWFkLCB0ZXJtLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgbl90aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdG5fdGhyZWFkLl9fZ29hbF9leHBhbnNpb24gPSB0cnVlO1xyXG5cdFx0dmFyIHZhcnRlcm0gPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHR2YXIgZ29hbCA9IFwiZ29hbF9leHBhbnNpb24oXCIgKyB0ZXJtLnRvU3RyaW5nKHtcclxuXHRcdFx0cXVvdGVkOiB0cnVlXHJcblx0XHR9KSArIFwiLCBcIiArIHZhcnRlcm0udG9TdHJpbmcoe1xyXG5cdFx0XHRxdW90ZWQ6IHRydWVcclxuXHRcdH0pICsgXCIpLlwiO1xyXG5cdFx0bl90aHJlYWQucXVlcnkoZ29hbCk7XHJcblx0XHR2YXIgdmFyaWFibGVzID0gbl90aHJlYWQuaGVhZF9wb2ludCgpLnN1YnN0aXR1dGlvbi5kb21haW4oKTtcclxuXHRcdG5fdGhyZWFkLmFuc3dlcihmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0aWYoYW5zd2VyICYmICFwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikgJiYgYW5zd2VyLmxpbmtzW3ZhcnRlcm1dKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYodmFyaWFibGVzW2ldICE9PSB2YXJ0ZXJtLmlkICYmIGFuc3dlci5saW5rc1t2YXJpYWJsZXNbaV1dKSB7XHJcblx0XHRcdFx0XHRcdHZhciBzdWJzID0gbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0XHRcdFx0XHRzdWJzLmxpbmtzW2Fuc3dlci5saW5rc1t2YXJpYWJsZXNbaV1dXSA9IHZhcmlhYmxlc1tpXTtcclxuXHRcdFx0XHRcdFx0YW5zd2VyLmxpbmtzW3ZhcnRlcm1dID0gYW5zd2VyLmxpbmtzW3ZhcnRlcm1dLmFwcGx5KCBzdWJzICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhcnNlUXVlcnlFeHBhbnNpb24odGhyZWFkLCBib2R5X2NvbnZlcnNpb24oYW5zd2VyLmxpbmtzW3ZhcnRlcm1dKSwgb3B0aW9ucyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLmFkZF9nb2FsKHRlcm0pO1xyXG5cdFx0XHRcdG9wdGlvbnMuc3VjY2Vzcyh0ZXJtKTtcclxuXHRcdFx0XHRwYXJzZVF1ZXJ5KHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlUHJvZ3JhbUV4cGFuc2lvbih0aHJlYWQsIG9wdGlvbnMsIHJlY29uc3VsdGVkLCBleHByKSB7XHJcblx0XHR2YXIgYXN5bmMgPSBvcHRpb25zLnRlcm1fZXhwYW5zaW9uID09PSB0cnVlO1xyXG5cdFx0aWYoZXhwci52YWx1ZS5ib2R5ID09PSBudWxsICYmIGV4cHIudmFsdWUuaGVhZC5pbmRpY2F0b3IgPT09IFwiPy0vMVwiKSB7XHJcblx0XHRcdGFzeW5jID0gdHJ1ZTtcclxuXHRcdFx0dmFyIG5fdGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRcdG5fdGhyZWFkLmFkZF9nb2FsKGV4cHIudmFsdWUuaGVhZC5hcmdzWzBdKTtcclxuXHRcdFx0bl90aHJlYWQuYW5zd2VyKGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoYW5zd2VyLmFyZ3NbMF0pO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihhbnN3ZXIgPT09IGZhbHNlIHx8IGFuc3dlciA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwud2FybmluZy5mYWlsZWRfZ29hbChleHByLnZhbHVlLmhlYWQuYXJnc1swXSwgZXhwci5sZW4pKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZihleHByLnZhbHVlLmJvZHkgPT09IG51bGwgJiYgZXhwci52YWx1ZS5oZWFkLmluZGljYXRvciA9PT0gXCI6LS8xXCIpIHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IHRocmVhZC5ydW5fZGlyZWN0aXZlKGV4cHIudmFsdWUuaGVhZC5hcmdzWzBdLCBvcHRpb25zKTtcclxuXHRcdFx0YXN5bmMgPSBhc3luYyB8fCAocmVzdWx0ID09PSB0cnVlKTtcclxuXHRcdFx0aWYoYXN5bmMpXHJcblx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdFx0dmFyIGluZGljYXRvciA9IGV4cHIudmFsdWUuaGVhZC5pbmRpY2F0b3I7XHJcblx0XHRcdGlmKGV4cHIudmFsdWUuaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGV4cHIudmFsdWUuaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGluZGljYXRvciA9IGV4cHIudmFsdWUuaGVhZC5hcmdzWzFdLmluZGljYXRvcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighcmVjb25zdWx0ZWQuaGFzT3duUHJvcGVydHkoY29udGV4dF9tb2R1bGUpKVxyXG5cdFx0XHRcdHJlY29uc3VsdGVkW2NvbnRleHRfbW9kdWxlXSA9IHt9O1xyXG5cdFx0XHRpZihvcHRpb25zLnJlY29uc3VsdCAhPT0gZmFsc2UgJiYgcmVjb25zdWx0ZWRbY29udGV4dF9tb2R1bGVdW2luZGljYXRvcl0gIT09IHRydWUgJiYgIXRocmVhZC5pc19tdWx0aWZpbGVfcHJlZGljYXRlKGluZGljYXRvcikpIHtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdO1xyXG5cdFx0XHRcdGlmKGNvbnRleHRfbW9kdWxlICE9PSBcInN5c3RlbVwiICYmIGdldF9tb2R1bGUgJiYgZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdKSB7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0gPSBmaWx0ZXIoZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdLCBmdW5jdGlvbihydWxlKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBydWxlLmR5bmFtaWM7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUudXBkYXRlX2luZGljZXNfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJlY29uc3VsdGVkW2NvbnRleHRfbW9kdWxlXVtpbmRpY2F0b3JdID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZ29hbF9leHBhbnNpb24gPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnVzZXIucnVsZXNbXCJnb2FsX2V4cGFuc2lvbi8yXCJdO1xyXG5cdFx0XHRpZihleHByLnZhbHVlLmJvZHkgIT09IG51bGwgJiYgZ29hbF9leHBhbnNpb24gJiYgZ29hbF9leHBhbnNpb24ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdGFzeW5jID0gdHJ1ZTtcclxuXHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdHZhciBvcmlnaW4gPSB7XHJcblx0XHRcdFx0XHRoZWFkOiBmdW5jdGlvbigpIHsgcmV0dXJuIGV4cHIudmFsdWUuaGVhZDsgfSxcclxuXHRcdFx0XHRcdHRlcm06IGZ1bmN0aW9uKCkgeyByZXR1cm4gZXhwci52YWx1ZS5ib2R5OyB9LFxyXG5cdFx0XHRcdFx0c2V0OiBmdW5jdGlvbihoLCBwKXtcclxuXHRcdFx0XHRcdFx0ZXhwci52YWx1ZS5oZWFkID0gaDtcclxuXHRcdFx0XHRcdFx0ZXhwci52YWx1ZS5ib2R5ID0gcDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdHBhcnNlR29hbEV4cGFuc2lvbih0aHJlYWQsIG9wdGlvbnMsIGV4cHIsIGJvZHlfY29udmVyc2lvbihleHByLnZhbHVlLmJvZHkpLCBvcmlnaW4uc2V0LCBvcmlnaW4pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5hZGRfcnVsZShleHByLnZhbHVlLCBvcHRpb25zKTtcclxuXHRcdFx0XHRpZihhc3luYylcclxuXHRcdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFzeW5jO1xyXG5cdH1cclxuXHRcclxuXHQvLyBQYXJzZSBhIHF1ZXJ5XHJcblx0ZnVuY3Rpb24gcGFyc2VRdWVyeSh0aHJlYWQsIHN0cmluZywgb3B0aW9ucykge1xyXG5cdFx0dmFyIG9wdHMgPSB7fTtcclxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zIDogZnVuY3Rpb24oKXt9O1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBvcHRpb25zO1xyXG5cdFx0b3B0cy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzID09PSB1bmRlZmluZWQgPyBjYWxsYmFjayA6IG9wdGlvbnMuc3VjY2VzcztcclxuXHRcdG9wdHMuZXJyb3IgPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBjYWxsYmFjayA6IG9wdGlvbnMuZXJyb3I7XHJcblx0XHRvcHRzLnRva2VuaXplciA9IG9wdGlvbnMudG9rZW5pemVyID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy50b2tlbml6ZXI7XHJcblx0XHRvcHRzLmN1cnJlbnRfdG9rZW4gPSBvcHRpb25zLmN1cnJlbnRfdG9rZW4gPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRpb25zLmN1cnJlbnRfdG9rZW47XHJcblx0XHRvcHRzLnN0cmluZyA9IHN0cmluZztcclxuXHRcdHZhciB0b2tlbml6ZXIgPSBvcHRzLnRva2VuaXplcjtcclxuXHRcdHZhciBuID0gb3B0cy5jdXJyZW50X3Rva2VuO1xyXG5cdFx0aWYodG9rZW5pemVyID09PSBudWxsKSB7XHJcblx0XHRcdHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIodGhyZWFkKTtcclxuXHRcdFx0b3B0cy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XHJcblx0XHRcdHRva2VuaXplci5uZXdfdGV4dChzdHJpbmcpO1xyXG5cdFx0fVxyXG5cdFx0ZG8ge1xyXG5cdFx0XHR2YXIgdG9rZW5zID0gdG9rZW5pemVyLmdldF90b2tlbnMobik7XHJcblx0XHRcdGlmKHRva2VucyA9PT0gbnVsbClcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIDAsIHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKSwgZmFsc2UpO1xyXG5cdFx0XHRpZihleHByLnR5cGUgIT09IEVSUk9SKSB7XHJcblx0XHRcdFx0dmFyIGV4cHJfcG9zaXRpb24gPSBleHByLmxlbjtcclxuXHRcdFx0XHRuID0gZXhwci5sZW4gKyAxO1xyXG5cdFx0XHRcdG9wdHMuY3VycmVudF90b2tlbiA9IG47XHJcblx0XHRcdFx0aWYodG9rZW5zW2V4cHJfcG9zaXRpb25dICYmIHRva2Vuc1tleHByX3Bvc2l0aW9uXS5uYW1lID09PSBcImF0b21cIiAmJiB0b2tlbnNbZXhwcl9wb3NpdGlvbl0ucmF3ID09PSBcIi5cIikge1xyXG5cdFx0XHRcdFx0ZXhwci52YWx1ZSA9IGJvZHlfY29udmVyc2lvbihleHByLnZhbHVlKTtcclxuXHRcdFx0XHRcdC8vIEdvYWwgZXhwYW5zaW9uXHJcblx0XHRcdFx0XHR2YXIgZ29hbF9leHBhbnNpb24gPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnVzZXIucnVsZXNbXCJnb2FsX2V4cGFuc2lvbi8yXCJdO1xyXG5cdFx0XHRcdFx0aWYoIXRocmVhZC5fX2dvYWxfZXhwYW5zaW9uICYmIGdvYWxfZXhwYW5zaW9uICYmIGdvYWxfZXhwYW5zaW9uLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdFx0cGFyc2VRdWVyeUV4cGFuc2lvbih0aHJlYWQsIGV4cHIudmFsdWUsIG9wdHMpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuYWRkX2dvYWwoZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdG9wdHMuc3VjY2VzcyhleHByLnZhbHVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW2V4cHJfcG9zaXRpb25dO1xyXG5cdFx0XHRcdFx0b3B0cy5lcnJvcihcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ0aHJvd1wiLCBbXHJcblx0XHRcdFx0XHRcdFx0cGwuZXJyb3Iuc3ludGF4KFxyXG5cdFx0XHRcdFx0XHRcdFx0dG9rZW4gPyB0b2tlbiA6IHRva2Vuc1tleHByX3Bvc2l0aW9uLTFdLFxyXG5cdFx0XHRcdFx0XHRcdFx0dG9rZW4gJiYgdG9rZW4uZXJyb3IgPyB0b2tlbi5lcnJvciA6IFwiLiBvciBvcGVyYXRvciBleHBlY3RlZFwiLFxyXG5cdFx0XHRcdFx0XHRcdFx0IXRva2VuXHJcblx0XHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b3B0cy5lcnJvcihuZXcgVGVybShcInRocm93XCIsIFtleHByLnZhbHVlXSkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fSB3aGlsZSh0cnVlKTtcclxuXHR9XHJcblxyXG5cclxuXHRcclxuXHQvLyBVVElMU1xyXG5cclxuXHQvLyBSdWxlIHRvIERDR1xyXG5cdGZ1bmN0aW9uIHJ1bGVfdG9fZGNnKHJ1bGUsIHRocmVhZCkge1xyXG5cdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdHJ1bGUgPSBydWxlLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0dmFyIGJlZ2luID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0dmFyIGRjZyA9IGJvZHlfdG9fZGNnKCBydWxlLmJvZHksIGJlZ2luLCB0aHJlYWQgKTtcclxuXHRcdGlmKCBkY2cuZXJyb3IgKVxyXG5cdFx0XHRyZXR1cm4gZGNnLnZhbHVlO1xyXG5cdFx0cnVsZS5ib2R5ID0gZGNnLnZhbHVlO1xyXG5cdFx0Ly8gcHVzaC1iYWNrIGxpc3RzXHJcblx0XHRpZihydWxlLmhlYWQuaW5kaWNhdG9yID09PSBcIiwvMlwiKSB7XHJcblx0XHRcdHZhciB0ZXJtaW5hbHMgPSBydWxlLmhlYWQuYXJnc1sxXTtcclxuXHRcdFx0cnVsZS5oZWFkID0gcnVsZS5oZWFkLmFyZ3NbMF07XHJcblx0XHRcdHZhciBsYXN0ID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRlcm1pbmFscztcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfbGlzdChwb2ludGVyKSkge1xyXG5cdFx0XHRcdHJldHVybiBwbC5lcnJvci50eXBlKFwibGlzdFwiLCBwb2ludGVyLCBcIkRDRy8wXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIltdLzBcIikge1xyXG5cdFx0XHRcdHRlcm1pbmFscyA9IGRjZy52YXJpYWJsZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR3aGlsZShwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiAmJiBwbC50eXBlLmlzX2xpc3QocG9pbnRlcikgJiYgcG9pbnRlci5hcmdzWzFdLmluZGljYXRvciAhPT0gXCJbXS8wXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpXHJcblx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IuaW5zdGFudGlhdGlvbihcIkRDRy8wXCIpO1xyXG5cdFx0XHRcdGVsc2UgaWYoIXBsLnR5cGUuaXNfbGlzdChwb2ludGVyKSlcclxuXHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci50eXBlKFwibGlzdFwiLCB0ZXJtaW5hbHMsIFwiRENHLzBcIik7XHJcblx0XHRcdFx0cG9pbnRlci5hcmdzWzFdID0gZGNnLnZhcmlhYmxlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJ1bGUuYm9keSA9IG5ldyBUZXJtKFwiLFwiLCBbcnVsZS5ib2R5LCBuZXcgVGVybShcIj1cIiwgW2xhc3QsIHRlcm1pbmFsc10pXSk7XHJcblx0XHRcdHJ1bGUuaGVhZCA9IG5ldyBUZXJtKHJ1bGUuaGVhZC5pZCwgcnVsZS5oZWFkLmFyZ3MuY29uY2F0KFtiZWdpbiwgbGFzdF0pKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHJlcGxhY2UgZmlyc3QgYXNzaWdubWVudFxyXG5cdFx0XHR2YXIgZmlyc3RfYXNzaWduID0gcnVsZS5ib2R5O1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oZmlyc3RfYXNzaWduKSAmJiBmaXJzdF9hc3NpZ24uaW5kaWNhdG9yID09PSBcIiwvMlwiKVxyXG5cdFx0XHRcdGZpcnN0X2Fzc2lnbiA9IGZpcnN0X2Fzc2lnbi5hcmdzWzBdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oZmlyc3RfYXNzaWduKSAmJiBmaXJzdF9hc3NpZ24uaW5kaWNhdG9yID09PSBcIj0vMlwiICYmXHJcblx0XHRcdCAgIHBsLnR5cGUuaXNfdmFyaWFibGUoZmlyc3RfYXNzaWduLmFyZ3NbMF0pICYmIGZpcnN0X2Fzc2lnbi5hcmdzWzBdID09PSBiZWdpbikge1xyXG5cdFx0XHRcdGJlZ2luID0gZmlyc3RfYXNzaWduLmFyZ3NbMV07XHJcblx0XHRcdFx0cnVsZS5ib2R5ID0gcnVsZS5ib2R5LnJlcGxhY2UobnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gYWRkIGZpcnN0IGFuZCBsYXN0IHZhcmlhYmxlcyB0byB0aGUgaGVhZFxyXG5cdFx0XHRpZihydWxlLmhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKVxyXG5cdFx0XHRcdHJ1bGUuaGVhZCA9IG5ldyBUZXJtKFwiOlwiLCBbXHJcblx0XHRcdFx0XHRuZXcgVGVybShydWxlLmhlYWQuYXJnc1swXS5pZCwgW10pLFxyXG5cdFx0XHRcdFx0bmV3IFRlcm0ocnVsZS5oZWFkLmFyZ3NbMV0uaWQsIHJ1bGUuaGVhZC5hcmdzWzFdLmFyZ3MuY29uY2F0KFtiZWdpbiwgZGNnLnZhcmlhYmxlXSkpXHJcblx0XHRcdFx0XSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRydWxlLmhlYWQgPSBuZXcgVGVybShydWxlLmhlYWQuaWQsIHJ1bGUuaGVhZC5hcmdzLmNvbmNhdChbYmVnaW4sIGRjZy52YXJpYWJsZV0pKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBydWxlO1xyXG5cdH1cclxuXHJcblx0Ly8gQm9keSB0byBEQ0dcclxuXHRmdW5jdGlvbiBib2R5X3RvX2RjZyhleHByLCBsYXN0LCB0aHJlYWQpIHtcclxuXHRcdHZhciBmcmVlO1xyXG5cdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIGV4cHIuaW5kaWNhdG9yID09PSBcIiEvMFwiICkge1xyXG5cdFx0XHRmcmVlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIixcIiwgW2V4cHIsIG5ldyBUZXJtKFwiPVwiLCBbbGFzdCwgZnJlZV0pXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IGZyZWUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIGV4cHIuaW5kaWNhdG9yID09PSBcIjovMlwiICkge1xyXG5cdFx0XHR2YXIgcmlnaHQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMV0sIGxhc3QsIHRocmVhZCk7XHJcblx0XHRcdGlmKCByaWdodC5lcnJvciApIHJldHVybiByaWdodDtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCI6XCIsIFtleHByLmFyZ3NbMF0sIHJpZ2h0LnZhbHVlXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IHJpZ2h0LnZhcmlhYmxlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBleHByLmluZGljYXRvciA9PT0gXCJcXFxcKy8xXCIgKSB7XHJcblx0XHRcdHZhciBsZWZ0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzBdLCBsYXN0LCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggbGVmdC5lcnJvciApIHJldHVybiBsZWZ0O1xyXG5cdFx0XHRmcmVlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKGV4cHIuaWQsIFtsZWZ0LnZhbHVlXSksIG5ldyBUZXJtKFwiPVwiLCBbbGFzdCwgZnJlZV0pXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IGZyZWUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIChleHByLmluZGljYXRvciA9PT0gXCIsLzJcIiB8fCBleHByLmluZGljYXRvciA9PT0gXCItPi8yXCIpICkge1xyXG5cdFx0XHR2YXIgbGVmdCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1swXSwgbGFzdCwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIGxlZnQuZXJyb3IgKSByZXR1cm4gbGVmdDtcclxuXHRcdFx0dmFyIHJpZ2h0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzFdLCBsZWZ0LnZhcmlhYmxlLCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggcmlnaHQuZXJyb3IgKSByZXR1cm4gcmlnaHQ7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKGV4cHIuaWQsIFtsZWZ0LnZhbHVlLCByaWdodC52YWx1ZV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiByaWdodC52YXJpYWJsZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwiOy8yXCIgKSB7XHJcblx0XHRcdHZhciBsZWZ0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzBdLCBsYXN0LCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggbGVmdC5lcnJvciApIHJldHVybiBsZWZ0O1xyXG5cdFx0XHR2YXIgcmlnaHQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMV0sIGxhc3QsIHRocmVhZCk7XHJcblx0XHRcdGlmKCByaWdodC5lcnJvciApIHJldHVybiByaWdodDtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIjtcIiwgW2xlZnQudmFsdWUsIHJpZ2h0LnZhbHVlXSksIG5ldyBUZXJtKFwiPVwiLCBbbGVmdC52YXJpYWJsZSwgcmlnaHQudmFyaWFibGVdKV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiByaWdodC52YXJpYWJsZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwie30vMVwiICkge1xyXG5cdFx0XHRmcmVlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIixcIiwgW2V4cHIuYXJnc1swXSwgbmV3IFRlcm0oXCI9XCIsIFtsYXN0LCBmcmVlXSldKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogZnJlZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19lbXB0eV9saXN0KCBleHByICkgKSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwidHJ1ZVwiLCBbXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IGxhc3QsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfbGlzdCggZXhwciApICkge1xyXG5cdFx0XHRmcmVlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IGV4cHI7XHJcblx0XHRcdHZhciBwcmV2O1xyXG5cdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0cHJldiA9IHBvaW50ZXI7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHR2YWx1ZTogcGwuZXJyb3IuaW5zdGFudGlhdGlvbihcIkRDRy8wXCIpLFxyXG5cdFx0XHRcdFx0dmFyaWFibGU6IGxhc3QsXHJcblx0XHRcdFx0XHRlcnJvcjogdHJ1ZVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHR2YWx1ZTogcGwuZXJyb3IudHlwZShcImxpc3RcIiwgZXhwciwgXCJEQ0cvMFwiKSxcclxuXHRcdFx0XHRcdHZhcmlhYmxlOiBsYXN0LFxyXG5cdFx0XHRcdFx0ZXJyb3I6IHRydWVcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHByZXYuYXJnc1sxXSA9IGZyZWU7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIj1cIiwgW2xhc3QsIGV4cHJdKSxcclxuXHRcdFx0XHRcdHZhcmlhYmxlOiBmcmVlLFxyXG5cdFx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2NhbGxhYmxlKCBleHByICkgKSB7XHJcblx0XHRcdGZyZWUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdGV4cHIgPSBuZXcgVGVybSggZXhwci5pZCwgZXhwci5hcmdzLmNvbmNhdChbbGFzdCxmcmVlXSkgKTtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogZXhwcixcclxuXHRcdFx0XHR2YXJpYWJsZTogZnJlZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IHBsLmVycm9yLnR5cGUoIFwiY2FsbGFibGVcIiwgZXhwciwgXCJEQ0cvMFwiICksXHJcblx0XHRcdFx0dmFyaWFibGU6IGxhc3QsXHJcblx0XHRcdFx0ZXJyb3I6IHRydWVcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9XHJcblx0XHJcblx0Ly8gQm9keSBjb252ZXJzaW9uXHJcblx0ZnVuY3Rpb24gYm9keV9jb252ZXJzaW9uKCBleHByICkge1xyXG5cdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGV4cHIgKSApXHJcblx0XHRcdHJldHVybiBuZXcgVGVybSggXCJjYWxsXCIsIFtleHByXSApO1xyXG5cdFx0ZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgW1wiLC8yXCIsIFwiOy8yXCIsIFwiLT4vMlwiXS5pbmRleE9mKGV4cHIuaW5kaWNhdG9yKSAhPT0gLTEgKVxyXG5cdFx0XHRyZXR1cm4gbmV3IFRlcm0oIGV4cHIuaWQsIFtib2R5X2NvbnZlcnNpb24oIGV4cHIuYXJnc1swXSApLCBib2R5X2NvbnZlcnNpb24oIGV4cHIuYXJnc1sxXSApXSApO1xyXG5cdFx0ZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKGV4cHIpICYmIGV4cHIuaW5kaWNhdG9yID09PSBcIjovMlwiICkge1xyXG5cdFx0XHR2YXIgYm9keSA9IGJvZHlfY29udmVyc2lvbihleHByLmFyZ3NbMV0pO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFRlcm0oXCI6XCIsIFtleHByLmFyZ3NbMF0sIGJvZHldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBleHByO1xyXG5cdH1cclxuXHRcclxuXHQvLyBMaXN0IHRvIFByb2xvZyBsaXN0XHJcblx0ZnVuY3Rpb24gYXJyYXlUb0xpc3QoIGFycmF5LCBjb25zICkge1xyXG5cdFx0dmFyIGxpc3QgPSBjb25zID8gY29ucyA6IG5ldyBUZXJtKCBcIltdXCIsIFtdICk7XHJcblx0XHRmb3IodmFyIGkgPSBhcnJheS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKVxyXG5cdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbYXJyYXlbaV0sIGxpc3RdICk7XHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHR9XHJcblxyXG5cdC8vIEFycmF5IGRpZmZlcmVuY2VcclxuXHRmdW5jdGlvbiBkaWZmZXJlbmNlKHhzLCB5cykge1xyXG5cdFx0dmFyIHpzID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYoaW5kZXhPZih6cywgeHNbaV0pID09PSAtMSAmJiBpbmRleE9mKHlzLCB4c1tpXSkgPT09IC0xKVxyXG5cdFx0XHRcdHpzLnB1c2goeHNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHpzO1xyXG5cdH1cclxuXHRcclxuXHQvLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5XHJcblx0ZnVuY3Rpb24gcmVtb3ZlKCBhcnJheSwgZWxlbWVudCApIHtcclxuXHRcdGZvciggdmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0aWYoIGFycmF5W2ldID09PSBlbGVtZW50ICkge1xyXG5cdFx0XHRcdGFycmF5LnNwbGljZShpLCAxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHQvLyBSZW1vdmUgZHVwbGljYXRlIGVsZW1lbnRzXHJcblx0ZnVuY3Rpb24gbnViKCBhcnJheSApIHtcclxuXHRcdHZhciBzZWVuID0ge307XHJcblx0XHR2YXIgdW5pcXVlID0gW107XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRpZiggIShhcnJheVtpXSBpbiBzZWVuKSApIHtcclxuXHRcdFx0XHR1bmlxdWUucHVzaCggYXJyYXlbaV0gKTtcclxuXHRcdFx0XHRzZWVuW2FycmF5W2ldXSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB1bmlxdWU7XHJcblx0fVxyXG5cclxuXHQvLyBSZXRyYWN0IGEgcnVsZVxyXG5cdGZ1bmN0aW9uIHJldHJhY3QodGhyZWFkLCBwb2ludCwgaW5kaWNhdG9yLCBydWxlLCBnZXRfbW9kdWxlKSB7XHJcblx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0pIHtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXVtpXSA9PT0gcnVsZSkge1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUudXBkYXRlX2luZGljZXNfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHQvLyBjYWxsL25cclxuXHRmdW5jdGlvbiBjYWxsTihuKSB7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY2xvc3VyZSA9IGF0b20uYXJnc1swXSwgYXJncyA9IGF0b20uYXJncy5zbGljZSgxLCBuKTtcclxuXHRcdFx0dmFyIG1vZHVsZV9hdG9tO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oY2xvc3VyZSkgJiYgY2xvc3VyZS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKGNsb3N1cmUuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIGNsb3N1cmUuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2F0b20gPSBjbG9zdXJlLmFyZ3NbMF07XHJcblx0XHRcdFx0Y2xvc3VyZSA9IGNsb3N1cmUuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGNsb3N1cmUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsb3N1cmUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbG9zdXJlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBnb2FsID0gYm9keV9jb252ZXJzaW9uKG5ldyBUZXJtKGNsb3N1cmUuaWQsIGNsb3N1cmUuYXJncy5jb25jYXQoYXJncykpKTtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19jYWxsYWJsZShnb2FsKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBnb2FsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihtb2R1bGVfYXRvbSlcclxuXHRcdFx0XHRcdGdvYWwgPSBuZXcgVGVybShcIjpcIiwgW21vZHVsZV9hdG9tLCBnb2FsXSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UoZ29hbCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cdFxyXG5cdC8vIFN0cmluZyB0byBpbmRpY2F0b3JcclxuXHRmdW5jdGlvbiBzdHJfaW5kaWNhdG9yKCBzdHIgKSB7XHJcblx0XHRmb3IoIHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tIClcclxuXHRcdFx0aWYoIHN0ci5jaGFyQXQoaSkgPT09IFwiL1wiIClcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiL1wiLCBbbmV3IFRlcm0oIHN0ci5zdWJzdHJpbmcoMCwgaSkgKSwgbmV3IE51bSggcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpKzEpKSwgZmFsc2UgKV0gKTtcclxuXHR9XHJcblxyXG5cdC8vIEdyZWF0ZXN0IGNvbW1vbiBkaXZpc29yXHJcblx0ZnVuY3Rpb24gZ2NkKGEsIGIpIHtcclxuXHRcdGlmKGIgPT09IDApXHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKGdjZChiLCBhICUgYikpO1xyXG5cdH1cclxuXHRcclxuXHRcclxuXHJcblx0Ly8gUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRmdW5jdGlvbiBWYXIoIGlkICkge1xyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy5ncm91bmQgPSBmYWxzZTtcclxuXHR9XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdGZ1bmN0aW9uIE51bSggdmFsdWUsIGlzX2Zsb2F0ICkge1xyXG5cdFx0dGhpcy5pc19mbG9hdCA9IGlzX2Zsb2F0ICE9PSB1bmRlZmluZWQgPyBpc19mbG9hdCA6IE1hdGgudHJ1bmModmFsdWUpICE9PSB2YWx1ZTtcclxuXHRcdHRoaXMudmFsdWUgPSB0aGlzLmlzX2Zsb2F0ID8gdmFsdWUgOiBNYXRoLnRydW5jKHZhbHVlKTtcclxuXHRcdHRoaXMuaW5kZXggPSB0aGlzLnZhbHVlO1xyXG5cdFx0dGhpcy5ncm91bmQgPSB0cnVlO1xyXG5cdH1cclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdHZhciB0ZXJtX3JlZiA9IDA7XHJcblx0ZnVuY3Rpb24gVGVybSggaWQsIGFyZ3MsIHJlZiApIHtcclxuXHRcdHRlcm1fcmVmKys7XHJcblx0XHR0aGlzLnJlZiA9IHJlZiB8fCB0ZXJtX3JlZjtcclxuXHRcdHRoaXMuaWQgPSBpZDtcclxuXHRcdHRoaXMuYXJncyA9IGFyZ3MgfHwgW107XHJcblx0XHR0aGlzLmluZGljYXRvciA9IGlkICsgXCIvXCIgKyB0aGlzLmFyZ3MubGVuZ3RoO1xyXG5cdFx0dGhpcy5pbmRleCA9IHRoaXMuaW5kaWNhdG9yO1xyXG5cdFx0dGhpcy5ncm91bmQgPSB0cnVlO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZih0aGlzLmFyZ3NbaV0uaGFzT3duUHJvcGVydHkoXCJncm91bmRcIikgJiYgdGhpcy5hcmdzW2ldLmdyb3VuZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHR0aGlzLmdyb3VuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0dmFyIHN0cmVhbV9yZWYgPSAwO1xyXG5cdGZ1bmN0aW9uIFN0cmVhbSggc3RyZWFtLCBtb2RlLCBhbGlhcywgdHlwZSwgcmVwb3NpdGlvbiwgZW9mX2FjdGlvbiApIHtcclxuXHRcdHRoaXMuaWQgPSBzdHJlYW1fcmVmKys7XHJcblx0XHR0aGlzLnN0cmVhbSA9IHN0cmVhbTtcclxuXHRcdHRoaXMubW9kZSA9IG1vZGU7IC8vIFwicmVhZFwiIG9yIFwid3JpdGVcIiBvciBcImFwcGVuZFwiXHJcblx0XHR0aGlzLmFsaWFzID0gYWxpYXM7XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogXCJ0ZXh0XCI7IC8vIFwidGV4dFwiIG9yIFwiYmluYXJ5XCJcclxuXHRcdHRoaXMucmVwb3NpdGlvbiA9IHJlcG9zaXRpb24gIT09IHVuZGVmaW5lZCA/IHJlcG9zaXRpb24gOiB0cnVlOyAvLyB0cnVlIG9yIGZhbHNlXHJcblx0XHR0aGlzLmVvZl9hY3Rpb24gPSBlb2ZfYWN0aW9uICE9PSB1bmRlZmluZWQgPyBlb2ZfYWN0aW9uIDogXCJlb2ZfY29kZVwiOyAvLyBcImVycm9yXCIgb3IgXCJlb2ZfY29kZVwiIG9yIFwicmVzZXRcIlxyXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMubW9kZSA9PT0gXCJhcHBlbmRcIiA/IFwiZW5kX29mX3N0cmVhbVwiIDogMDtcclxuXHRcdHRoaXMub3V0cHV0ID0gdGhpcy5tb2RlID09PSBcIndyaXRlXCIgfHwgdGhpcy5tb2RlID09PSBcImFwcGVuZFwiO1xyXG5cdFx0dGhpcy5pbnB1dCA9IHRoaXMubW9kZSA9PT0gXCJyZWFkXCI7XHJcblx0XHR0aGlzLmxpbmVfcG9zaXRpb24gPSAwO1xyXG5cdFx0dGhpcy5saW5lX2NvdW50ID0gMTtcclxuXHRcdHRoaXMuY2hhcl9jb3VudCA9IDA7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFN1YnN0aXR1dGlvbnNcclxuXHRmdW5jdGlvbiBTdWJzdGl0dXRpb24oIGxpbmtzLCBhdHRycyApIHtcclxuXHRcdGxpbmtzID0gbGlua3MgfHwge307XHJcblx0XHRhdHRycyA9IGF0dHJzIHx8IHt9O1xyXG5cdFx0dGhpcy5saW5rcyA9IGxpbmtzO1xyXG5cdFx0dGhpcy5hdHRycyA9IGF0dHJzO1xyXG5cdH1cclxuXHRcclxuXHQvLyBTdGF0ZXNcclxuXHRmdW5jdGlvbiBTdGF0ZSggZ29hbCwgc3VicywgcGFyZW50ICkge1xyXG5cdFx0c3VicyA9IHN1YnMgfHwgbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0cGFyZW50ID0gcGFyZW50IHx8IG51bGw7XHJcblx0XHR0aGlzLmdvYWwgPSBnb2FsO1xyXG5cdFx0dGhpcy5zdWJzdGl0dXRpb24gPSBzdWJzO1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0ZnVuY3Rpb24gUnVsZSggaGVhZCwgYm9keSwgZHluYW1pYyApIHtcclxuXHRcdHRoaXMuaGVhZCA9IGhlYWQ7XHJcblx0XHR0aGlzLmJvZHkgPSBib2R5O1xyXG5cdFx0dGhpcy5keW5hbWljID0gZHluYW1pYyA/IGR5bmFtaWMgOiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdC8vIFNlc3Npb25cclxuXHRmdW5jdGlvbiBTZXNzaW9uKCBsaW1pdCApIHtcclxuXHRcdGxpbWl0ID0gdHlwZW9mIGxpbWl0ID09PSBcIm51bWJlclwiICYmIGxpbWl0ID4gMCA/IGxpbWl0IDogbnVsbDtcclxuXHRcdHRoaXMucmVuYW1lID0gMDtcclxuXHRcdHRoaXMubW9kdWxlcyA9IHt9O1xyXG5cdFx0dGhpcy5tb2R1bGVzLnVzZXIgPSBuZXcgTW9kdWxlKFwidXNlclwiLCB7fSwgXCJhbGxcIiwge1xyXG5cdFx0XHRzZXNzaW9uOiB0aGlzLFxyXG5cdFx0XHRkZXBlbmRlbmNpZXM6IFtcInN5c3RlbVwiXVxyXG5cdFx0fSk7XHJcblx0XHR0aGlzLm1vZHVsZXMuc3lzdGVtID0gcGwubW9kdWxlcy5zeXN0ZW07XHJcblx0XHR0aGlzLnJ1bGVzID0gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXM7XHJcblx0XHR0aGlzLnRvdGFsX3RocmVhZHMgPSAwO1xyXG5cdFx0dGhpcy5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0dGhpcy5wdWJsaWNfcHJlZGljYXRlcyA9IHRoaXMubW9kdWxlcy51c2VyLnB1YmxpY19wcmVkaWNhdGVzO1xyXG5cdFx0dGhpcy5tdWx0aWZpbGVfcHJlZGljYXRlcyA9IHRoaXMubW9kdWxlcy51c2VyLm11bHRpZmlsZV9wcmVkaWNhdGVzO1xyXG5cdFx0dGhpcy5saW1pdCA9IGxpbWl0O1xyXG5cdFx0dGhpcy5zdHJlYW1zID0ge1xyXG5cdFx0XHRcInVzZXJfaW5wdXRcIjogbmV3IFN0cmVhbShcclxuXHRcdFx0XHRub2RlanNfZmxhZyA/IG5vZGVqc191c2VyX2lucHV0IDogdGF1X3VzZXJfaW5wdXQsXHJcblx0XHRcdFx0XCJyZWFkXCIsIFwidXNlcl9pbnB1dFwiLCBcInRleHRcIiwgZmFsc2UsIFwicmVzZXRcIiApLFxyXG5cdFx0XHRcInVzZXJfb3V0cHV0XCI6IG5ldyBTdHJlYW0oXHJcblx0XHRcdFx0bm9kZWpzX2ZsYWcgPyBub2RlanNfdXNlcl9vdXRwdXQgOiB0YXVfdXNlcl9vdXRwdXQsXHJcblx0XHRcdFx0XCJhcHBlbmRcIiwgXCJ1c2VyX291dHB1dFwiLCBcInRleHRcIiwgZmFsc2UsIFwicmVzZXRcIiApLFxyXG5cdFx0XHRcInVzZXJfZXJyb3JcIjogbmV3IFN0cmVhbShcclxuXHRcdFx0XHRub2RlanNfZmxhZyA/IG5vZGVqc191c2VyX2Vycm9yIDogdGF1X3VzZXJfZXJyb3IsXHJcblx0XHRcdFx0XCJhcHBlbmRcIiwgXCJ1c2VyX2Vycm9yXCIsIFwidGV4dFwiLCBmYWxzZSwgXCJyZXNldFwiICksXHJcblx0XHR9O1xyXG5cdFx0dGhpcy5maWxlX3N5c3RlbSA9IG5vZGVqc19mbGFnID8gbm9kZWpzX2ZpbGVfc3lzdGVtIDogdGF1X2ZpbGVfc3lzdGVtO1xyXG5cdFx0dGhpcy5zdGFuZGFyZF9pbnB1dCA9IHRoaXMuc3RyZWFtc1tcInVzZXJfaW5wdXRcIl07XHJcblx0XHR0aGlzLnN0YW5kYXJkX291dHB1dCA9IHRoaXMuc3RyZWFtc1tcInVzZXJfb3V0cHV0XCJdO1xyXG5cdFx0dGhpcy5zdGFuZGFyZF9lcnJvciA9IHRoaXMuc3RyZWFtc1tcInVzZXJfZXJyb3JcIl07XHJcblx0XHR0aGlzLmN1cnJlbnRfaW5wdXQgPSB0aGlzLnN0cmVhbXNbXCJ1c2VyX2lucHV0XCJdO1xyXG5cdFx0dGhpcy5jdXJyZW50X291dHB1dCA9IHRoaXMuc3RyZWFtc1tcInVzZXJfb3V0cHV0XCJdO1xyXG5cdFx0dGhpcy53b3JraW5nX2RpcmVjdG9yeSA9IFwiL1wiOyAvLyBvbmx5IGZvciBicm93c2VyXHJcblx0XHR0aGlzLmZvcm1hdF9zdWNjZXNzID0gZnVuY3Rpb24oIHN0YXRlICkgeyByZXR1cm4gc3RhdGUuc3Vic3RpdHV0aW9uOyB9O1xyXG5cdFx0dGhpcy5mb3JtYXRfZXJyb3IgPSBmdW5jdGlvbiggc3RhdGUgKSB7IHJldHVybiBzdGF0ZS5nb2FsOyB9O1xyXG5cdFx0dGhpcy5mbGFnID0ge1x0XHJcblx0XHRcdGJvdW5kZWQ6IHBsLmZsYWcuYm91bmRlZC52YWx1ZSxcclxuXHRcdFx0bWF4X2ludGVnZXI6IHBsLmZsYWcubWF4X2ludGVnZXIudmFsdWUsXHJcblx0XHRcdG1pbl9pbnRlZ2VyOiBwbC5mbGFnLm1pbl9pbnRlZ2VyLnZhbHVlLFxyXG5cdFx0XHRpbnRlZ2VyX3JvdW5kaW5nX2Z1bmN0aW9uOiBwbC5mbGFnLmludGVnZXJfcm91bmRpbmdfZnVuY3Rpb24udmFsdWUsXHJcblx0XHRcdGNoYXJfY29udmVyc2lvbjogcGwuZmxhZy5jaGFyX2NvbnZlcnNpb24udmFsdWUsXHJcblx0XHRcdGRlYnVnOiBwbC5mbGFnLmRlYnVnLnZhbHVlLFxyXG5cdFx0XHRtYXhfYXJpdHk6IHBsLmZsYWcubWF4X2FyaXR5LnZhbHVlLFxyXG5cdFx0XHR1bmtub3duOiBwbC5mbGFnLnVua25vd24udmFsdWUsXHJcblx0XHRcdGRvdWJsZV9xdW90ZXM6IHBsLmZsYWcuZG91YmxlX3F1b3Rlcy52YWx1ZSxcclxuXHRcdFx0b2NjdXJzX2NoZWNrOiBwbC5mbGFnLm9jY3Vyc19jaGVjay52YWx1ZSxcclxuXHRcdFx0ZGlhbGVjdDogcGwuZmxhZy5kaWFsZWN0LnZhbHVlLFxyXG5cdFx0XHR2ZXJzaW9uX2RhdGE6IHBsLmZsYWcudmVyc2lvbl9kYXRhLnZhbHVlLFxyXG5cdFx0XHRub2RlanM6IHBsLmZsYWcubm9kZWpzLnZhbHVlLFxyXG5cdFx0XHRhcmd2OiBwbC5mbGFnLmFyZ3YudmFsdWVcclxuXHRcdH07XHJcblx0XHR0aGlzLl9fbG9hZGVkX21vZHVsZXMgPSBbXTtcclxuXHRcdHRoaXMuX19jaGFyX2NvbnZlcnNpb24gPSB7fTtcclxuXHRcdHRoaXMuX19vcGVyYXRvcnMgPSB7XHJcblx0XHRcdDEyMDA6IHsgXCI6LVwiOiBbXCJmeFwiLCBcInhmeFwiXSwgIFwiLS0+XCI6IFtcInhmeFwiXSwgXCI/LVwiOiBbXCJmeFwiXSB9LFxyXG5cdFx0XHQxMTUwOiB7IFwibWV0YV9wcmVkaWNhdGVcIjogW1wiZnhcIl0gfSxcclxuXHRcdFx0MTEwMDogeyBcIjtcIjogW1wieGZ5XCJdIH0sXHJcblx0XHRcdDEwNTA6IHsgXCItPlwiOiBbXCJ4ZnlcIl0sIFwiKi0+XCI6IFtcInhmeVwiXSB9LFxyXG5cdFx0XHQxMDAwOiB7IFwiLFwiOiBbXCJ4ZnlcIl0gfSxcclxuXHRcdFx0OTAwOiB7IFwiXFxcXCtcIjogW1wiZnlcIl0gfSxcclxuXHRcdFx0NzAwOiB7XHJcblx0XHRcdFx0XCI9XCI6IFtcInhmeFwiXSwgXCJcXFxcPVwiOiBbXCJ4ZnhcIl0sIFwiPT1cIjogW1wieGZ4XCJdLCBcIlxcXFw9PVwiOiBbXCJ4ZnhcIl0sXHJcblx0XHRcdFx0XCJAPFwiOiBbXCJ4ZnhcIl0sIFwiQD08XCI6IFtcInhmeFwiXSwgXCJAPlwiOiBbXCJ4ZnhcIl0sIFwiQD49XCI6IFtcInhmeFwiXSxcclxuXHRcdFx0XHRcIj0uLlwiOiBbXCJ4ZnhcIl0sIFwiaXNcIjogW1wieGZ4XCJdLCBcIj06PVwiOiBbXCJ4ZnhcIl0sIFwiPVxcXFw9XCI6IFtcInhmeFwiXSxcclxuXHRcdFx0XHRcIjxcIjogW1wieGZ4XCJdLCBcIj08XCI6IFtcInhmeFwiXSwgXCI+XCI6IFtcInhmeFwiXSwgXCI+PVwiOiBbXCJ4ZnhcIl1cclxuXHRcdFx0fSxcclxuXHRcdFx0NjAwOiB7IFwiOlwiOiBbXCJ4ZnlcIl0gfSxcclxuXHRcdFx0NTAwOiB7IFwiK1wiOiBbXCJ5ZnhcIl0sIFwiLVwiOiBbXCJ5ZnhcIl0sIFwiL1xcXFxcIjogW1wieWZ4XCJdLCBcIlxcXFwvXCI6IFtcInlmeFwiXSB9LFxyXG5cdFx0XHQ0MDA6IHtcclxuXHRcdFx0XHRcIipcIjogW1wieWZ4XCJdLCBcIi9cIjogW1wieWZ4XCJdLCBcIi8vXCI6IFtcInlmeFwiXSwgXCJyZW1cIjogW1wieWZ4XCJdLFxyXG5cdFx0XHRcdFwibW9kXCI6IFtcInlmeFwiXSwgXCI8PFwiOiBbXCJ5ZnhcIl0sIFwiPj5cIjogW1wieWZ4XCJdLCBcImRpdlwiOiBbXCJ5ZnhcIl1cclxuXHRcdFx0fSxcclxuXHRcdFx0MjAwOiB7IFwiKipcIjogW1wieGZ4XCJdLCBcIl5cIjogW1wieGZ5XCJdLCBcIi1cIjogW1wiZnlcIl0sIFwiK1wiOiBbXCJmeVwiXSwgXCJcXFxcXCI6IFtcImZ5XCJdIH1cclxuXHRcdH07XHJcblx0XHR0aGlzLnRocmVhZCA9IG5ldyBUaHJlYWQoIHRoaXMgKTtcclxuXHR9XHJcblx0XHJcblx0Ly8gVGhyZWFkc1xyXG5cdGZ1bmN0aW9uIFRocmVhZCggc2Vzc2lvbiApIHtcclxuXHRcdHRoaXMuZXBvY2ggPSBEYXRlLm5vdygpO1xyXG5cdFx0dGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcclxuXHRcdHRoaXMuc2Vzc2lvbi50b3RhbF90aHJlYWRzKys7XHJcblx0XHR0aGlzLmZvcm1hdF9zdWNjZXNzID0gc2Vzc2lvbi5mb3JtYXRfc3VjY2VzcztcclxuXHRcdHRoaXMuZm9ybWF0X2Vycm9yID0gc2Vzc2lvbi5mb3JtYXRfZXJyb3I7XHJcblx0XHR0aGlzLnRvdGFsX3N0ZXBzID0gMDtcclxuXHRcdHRoaXMuY3B1X3RpbWUgPSAwO1xyXG5cdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHRcdHRoaXMuZGVidWdnZXIgPSBmYWxzZTtcclxuXHRcdHRoaXMuZGVidWdnZXJfc3RhdGVzID0gW107XHJcblx0XHR0aGlzLmxldmVsID0gbmV3IFRlcm0oXCJ0b3BfbGV2ZWxcIik7XHJcblx0XHR0aGlzLmN1cnJlbnRfbGltaXQgPSB0aGlzLnNlc3Npb24ubGltaXQ7XHJcblx0XHR0aGlzLmhhc19saW1pdCA9IHRoaXMuc2Vzc2lvbi5saW1pdCAhPT0gbnVsbDtcclxuXHRcdHRoaXMud2FybmluZ3MgPSBbXTtcclxuXHRcdHRoaXMuX19jYWxscyA9IFtdO1xyXG5cdFx0dGhpcy5fX2dvYWxfZXhwYW5zaW9uID0gZmFsc2U7XHJcblx0XHR0aGlzLl9fc3RhY2tzID0ge307XHJcblx0fVxyXG5cdFxyXG5cdC8vIE1vZHVsZXNcclxuXHRmdW5jdGlvbiBNb2R1bGUoaWQsIHJ1bGVzLCBleHBvcnRzLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0b3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlcyA9IG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlcztcclxuXHRcdG9wdGlvbnMubXVsdGlmaWxlX3ByZWRpY2F0ZXMgPSBvcHRpb25zLm11bHRpZmlsZV9wcmVkaWNhdGVzID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMubXVsdGlmaWxlX3ByZWRpY2F0ZXM7XHJcblx0XHRvcHRpb25zLm1ldGFfcHJlZGljYXRlcyA9IG9wdGlvbnMubWV0YV9wcmVkaWNhdGVzID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnMubWV0YV9wcmVkaWNhdGVzO1xyXG5cdFx0b3B0aW9ucy5zZXNzaW9uID0gb3B0aW9ucy5zZXNzaW9uID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5zZXNzaW9uO1xyXG5cdFx0b3B0aW9ucy5kZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcyA9PT0gdW5kZWZpbmVkID8gW10gOiBvcHRpb25zLmRlcGVuZGVuY2llcztcclxuXHRcdHRoaXMuaWQgPSBpZDtcclxuXHRcdHRoaXMucnVsZXMgPSBydWxlcztcclxuXHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzID0ge307XHJcblx0XHR0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlcyA9IHt9O1xyXG5cdFx0dGhpcy5wdWJsaWNfcHJlZGljYXRlcyA9IG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXM7XHJcblx0XHR0aGlzLm11bHRpZmlsZV9wcmVkaWNhdGVzID0gb3B0aW9ucy5tdWx0aWZpbGVfcHJlZGljYXRlcztcclxuXHRcdHRoaXMubWV0YV9wcmVkaWNhdGVzID0gb3B0aW9ucy5tZXRhX3ByZWRpY2F0ZXM7XHJcblx0XHR0aGlzLnNyY19wcmVkaWNhdGVzID0ge307XHJcblx0XHR0aGlzLmRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xyXG5cdFx0dGhpcy5leHBvcnRzID0gZXhwb3J0cztcclxuXHRcdHRoaXMuaXNfbGlicmFyeSA9IG9wdGlvbnMuc2Vzc2lvbiA9PT0gbnVsbDtcclxuXHRcdHRoaXMubW9kdWxlcyA9IHt9O1xyXG5cdFx0aWYob3B0aW9ucy5zZXNzaW9uKSB7XHJcblx0XHRcdG9wdGlvbnMuc2Vzc2lvbi5tb2R1bGVzW2lkXSA9IHRoaXM7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBsaWIgPSBvcHRpb25zLmRlcGVuZGVuY2llc1tpXTtcclxuXHRcdFx0XHRpZighb3B0aW9ucy5zZXNzaW9uLm1vZHVsZXMuaGFzT3duUHJvcGVydHkobGliKSlcclxuXHRcdFx0XHRcdG9wdGlvbnMuc2Vzc2lvbi5tb2R1bGVzW2xpYl0gPSBwbC5tb2R1bGVzW2xpYl07XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBsLm1vZHVsZXNbaWRdID0gdGhpcztcclxuXHRcdH1cclxuXHRcdGlmKGV4cG9ydHMgIT09IFwiYWxsXCIpIHtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGV4cG9ydHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR0aGlzLnB1YmxpY19wcmVkaWNhdGVzW2V4cG9ydHNbaV1dID1cclxuXHRcdFx0XHRcdG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkoZXhwb3J0c1tpXSkgJiZcclxuXHRcdFx0XHRcdG9wdGlvbnMucHVibGljX3ByZWRpY2F0ZXNbZXhwb3J0c1tpXV0gPT09IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHRoaXMudXBkYXRlX2luZGljZXNfY2xhdXNlcygpO1xyXG5cdH1cclxuXHRcclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBleHBvcnRlZFxyXG5cdE1vZHVsZS5wcm90b3R5cGUuZXhwb3J0c19wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IpIHtcclxuXHRcdHJldHVybiB0aGlzLmV4cG9ydHMgPT09IFwiYWxsXCIgfHwgaW5kZXhPZih0aGlzLmV4cG9ydHMsIGluZGljYXRvcikgIT09IC0xO1xyXG5cdH07XHJcblxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIHB1YmxpY1xyXG5cdE1vZHVsZS5wcm90b3R5cGUuaXNfcHVibGljX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvcikge1xyXG5cdFx0cmV0dXJuICF0aGlzLnB1YmxpY19wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KGluZGljYXRvcikgfHwgdGhpcy5wdWJsaWNfcHJlZGljYXRlc1tpbmRpY2F0b3JdID09PSB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgbXVsdGlmaWxlXHJcblx0TW9kdWxlLnByb3RvdHlwZS5pc19tdWx0aWZpbGVfcHJlZGljYXRlID0gZnVuY3Rpb24oIGluZGljYXRvciApIHtcclxuXHRcdHJldHVybiB0aGlzLm11bHRpZmlsZV9wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KGluZGljYXRvcikgJiYgdGhpcy5tdWx0aWZpbGVfcHJlZGljYXRlc1tpbmRpY2F0b3JdID09PSB0cnVlO1xyXG5cdH07XHJcblxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIGEgbWV0YS1wcmVkaWNhdGVcclxuXHRNb2R1bGUucHJvdG90eXBlLmlzX21ldGFfcHJlZGljYXRlID0gZnVuY3Rpb24oIGluZGljYXRvciApIHtcclxuXHRcdGlmKHRoaXMubWV0YV9wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpXHJcblx0XHRcdHJldHVybiB0aGlzLm1ldGFfcHJlZGljYXRlc1tpbmRpY2F0b3JdO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0Ly8gVXBkYXRlIGluZGljZXMgb2YgYWxsIHByZWRpY2F0ZXNcclxuXHRNb2R1bGUucHJvdG90eXBlLnVwZGF0ZV9pbmRpY2VzX2NsYXVzZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzID0ge307XHJcblx0XHR0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpbmRpY2F0b3IgaW4gdGhpcy5ydWxlcylcclxuXHRcdFx0dGhpcy51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHR9O1xyXG5cclxuXHQvLyBVcGRhdGUgaW5kaWNlcyBvZiBhIHByZWRpY2F0ZVxyXG5cdE1vZHVsZS5wcm90b3R5cGUudXBkYXRlX2luZGljZXNfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yKSB7XHJcblx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdID0ge307XHJcblx0XHR0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdID0gW107XHJcblx0XHRpZighQXJyYXkuaXNBcnJheSh0aGlzLnJ1bGVzW2luZGljYXRvcl0pKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5ydWxlc1tpbmRpY2F0b3JdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBjbGF1c2UgPSB0aGlzLnJ1bGVzW2luZGljYXRvcl1baV07XHJcblx0XHRcdHRoaXMuYWRkX2luZGV4X3ByZWRpY2F0ZShjbGF1c2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIEFkZCBpbmRleGVkIGNsdXVzZSB0byBhIHByZWRpY2F0ZVxyXG5cdE1vZHVsZS5wcm90b3R5cGUuYWRkX2luZGV4X3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGNsYXVzZSkge1xyXG5cdFx0dmFyIGluZGljYXRvciA9IGNsYXVzZS5oZWFkLmluZGljYXRvcjtcclxuXHRcdHZhciBpbmRleCA9IGNsYXVzZS5oZWFkLmFyZ3MubGVuZ3RoID4gMCA/IGNsYXVzZS5oZWFkLmFyZ3NbMF0uaW5kZXggOiB1bmRlZmluZWQ7XHJcblx0XHRpZihpbmRleCkge1xyXG5cdFx0XHRpZighdGhpcy5pbmRleGVkX2NsYXVzZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSlcclxuXHRcdFx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdID0ge307XHJcblx0XHRcdGlmKCF0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdLmhhc093blByb3BlcnR5KGluZGV4KSkge1xyXG5cdFx0XHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl1baW5kZXhdID0gW107XHJcblx0XHRcdFx0aWYodGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSlcclxuXHRcdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCB0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdW2luZGV4XS5wdXNoKHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl1baW5kZXhdLnB1c2goY2xhdXNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmKCF0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKVxyXG5cdFx0XHRcdHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl0gPSBbXTtcclxuXHRcdFx0dGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXS5wdXNoKGNsYXVzZSk7XHJcblx0XHRcdGZvcih2YXIgaW5kZXggaW4gdGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXSlcclxuXHRcdFx0XHR0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdW2luZGV4XS5wdXNoKGNsYXVzZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvLyBVTklGWSBQUk9MT0cgT0JKRUNUU1xyXG5cclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLnVuaWZ5ID0gZnVuY3Rpb24ob2JqLCBvY2N1cnNfY2hlY2spIHtcclxuXHRcdGlmKG9jY3Vyc19jaGVjayAmJiBpbmRleE9mKG9iai52YXJpYWJsZXMoKSwgdGhpcy5pZCkgIT09IC0xICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKG9iaikpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHRsaW5rc1t0aGlzLmlkXSA9IG9iajtcclxuXHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKGxpbmtzKTtcclxuXHR9O1xyXG5cclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS51bmlmeSA9IGZ1bmN0aW9uKG9iaiwgb2NjdXJzX2NoZWNrKSB7XHJcblx0XHRpZihwbC50eXBlLmlzX251bWJlcihvYmopICYmIHRoaXMudmFsdWUgPT09IG9iai52YWx1ZSAmJiB0aGlzLmlzX2Zsb2F0ID09PSBvYmouaXNfZmxvYXQpXHJcblx0XHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLnVuaWZ5ID0gZnVuY3Rpb24ob2JqLCBvY2N1cnNfY2hlY2spIHtcclxuXHRcdGlmKCFwbC50eXBlLmlzX3Rlcm0ob2JqKSAmJiBvYmoudW5pZnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gb2JqLnVuaWZ5KHRoaXMsIG9jY3Vyc19jaGVjayk7XHJcblx0XHR9IGVsc2UgaWYocGwudHlwZS5pc190ZXJtKG9iaikgJiYgdGhpcy5pbmRpY2F0b3IgPT09IG9iai5pbmRpY2F0b3IpIHtcclxuXHRcdFx0dmFyIHN1YnMgPSBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkodGhpcy5hcmdzW2ldLmFwcGx5KHN1YnMpLCBvYmouYXJnc1tpXS5hcHBseShzdWJzKSwgb2NjdXJzX2NoZWNrKTtcclxuXHRcdFx0XHRpZihtZ3UgPT09IG51bGwpXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRmb3IodmFyIHggaW4gbWd1LmxpbmtzKVxyXG5cdFx0XHRcdFx0c3Vicy5saW5rc1t4XSA9IG1ndS5saW5rc1t4XTtcclxuXHRcdFx0XHRzdWJzID0gc3Vicy5hcHBseShtZ3UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdWJzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbihvYmosIF9vY2N1cnNfY2hlY2spIHtcclxuXHRcdGlmKHBsLnR5cGUuaXNfc3RyZWFtKG9iaikgJiYgdGhpcy5pZCA9PT0gb2JqLmlkKVxyXG5cdFx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbigpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0U3RyZWFtLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRpZih0aGlzLmlkIDwgb2JqLmlkKVxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRlbHNlIGlmKHRoaXMuaWQgPT09IG9iai5pZClcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHRlbHNlXHJcblx0XHRcdHJldHVybiAxO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblxyXG5cdC8vIFBST0xPRyBPQkpFQ1RTIFRPIFNUUklOR1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRpZihvcHRpb25zLnZhcmlhYmxlX25hbWVzKSB7XHJcblx0XHRcdHZhciBwb2ludGVyID0gb3B0aW9ucy52YXJpYWJsZV9uYW1lcztcclxuXHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0dmFyIGhlYWQgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGhlYWQpICYmIGhlYWQuaW5kaWNhdG9yID09PSBcIj0vMlwiXHJcblx0XHRcdFx0JiYgcGwudHlwZS5pc192YXJpYWJsZShoZWFkLmFyZ3NbMV0pICYmIGhlYWQuYXJnc1sxXS5pZCA9PT0gdGhpcy5pZFxyXG5cdFx0XHRcdCYmIHBsLnR5cGUuaXNfYXRvbShoZWFkLmFyZ3NbMF0pKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5pZDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIF8gKSB7XHJcblx0XHR2YXIgc3RyID0gdGhpcy52YWx1ZS50b1N0cmluZygpO1xyXG5cdFx0dmFyIGUgPSBzdHIuaW5kZXhPZihcImVcIik7XHJcblx0XHRpZihlICE9PSAtMSkge1xyXG5cdFx0XHRpZihzdHIuaW5kZXhPZihcIi5cIikgIT09IC0xKVxyXG5cdFx0XHRcdHJldHVybiBzdHI7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoXCJlXCIsIFwiLjBlXCIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuaXNfZmxvYXQgJiYgaW5kZXhPZihzdHIsIFwiLlwiKSA9PT0gLTEgPyB0aGlzLnZhbHVlICsgXCIuMFwiIDogc3RyO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zLCBwcmlvcml0eSwgZnJvbSApIHtcclxuXHRcdG9wdGlvbnMgPSAhb3B0aW9ucyA/IHt9IDogb3B0aW9ucztcclxuXHRcdG9wdGlvbnMucXVvdGVkID0gb3B0aW9ucy5xdW90ZWQgPT09IHVuZGVmaW5lZCA/IGZhbHNlOiBvcHRpb25zLnF1b3RlZDtcclxuXHRcdG9wdGlvbnMuaWdub3JlX29wcyA9IG9wdGlvbnMuaWdub3JlX29wcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLmlnbm9yZV9vcHM7XHJcblx0XHRvcHRpb25zLm51bWJlcnZhcnMgPSBvcHRpb25zLm51bWJlcnZhcnMgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy5udW1iZXJ2YXJzO1xyXG5cdFx0b3B0aW9ucy52YXJpYWJsZV9uYW1lcyA9IG9wdGlvbnMudmFyaWFibGVfbmFtZXMgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb3B0aW9ucy52YXJpYWJsZV9uYW1lcztcclxuXHRcdHByaW9yaXR5ID0gcHJpb3JpdHkgPT09IHVuZGVmaW5lZCA/IHtwcmlvcml0eTogMTIwMCwgY2xhc3M6IFwiXCIsIGluZGljYXRvcjogXCJcIn0gOiBwcmlvcml0eTtcclxuXHRcdGZyb20gPSBmcm9tID09PSB1bmRlZmluZWQgPyBcIlwiIDogZnJvbTtcclxuXHRcdHZhciBhcmdfcHJpb3JpdHkgPSB7cHJpb3JpdHk6IDk5OSwgY2xhc3M6IFwiXCIsIGluZGljYXRvcjogXCJcIn07XHJcblx0XHRpZiggb3B0aW9ucy5udW1iZXJ2YXJzICYmIHRoaXMuaW5kaWNhdG9yID09PSBcIiRWQVIvMVwiICYmIHBsLnR5cGUuaXNfaW50ZWdlciggdGhpcy5hcmdzWzBdICkgJiYgdGhpcy5hcmdzWzBdLnZhbHVlID49IDAgKSB7XHJcblx0XHRcdHZhciBpID0gdGhpcy5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHR2YXIgbnVtYmVyID0gTWF0aC5mbG9vciggaS8yNiApO1xyXG5cdFx0XHR2YXIgbGV0dGVyID0gIGkgJSAyNjtcclxuXHRcdFx0cmV0dXJuIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIltsZXR0ZXJdICsgKG51bWJlciAhPT0gMCA/IG51bWJlciA6IFwiXCIpO1xyXG5cdFx0fVxyXG5cdFx0c3dpdGNoKCB0aGlzLmluZGljYXRvciApe1xyXG5cdFx0XHRjYXNlIFwiW10vMFwiOlxyXG5cdFx0XHRjYXNlIFwie30vMFwiOlxyXG5cdFx0XHRjYXNlIFwiIS8wXCI6XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuaWQ7XHJcblx0XHRcdGNhc2UgXCJ7fS8xXCI6XHJcblx0XHRcdFx0aWYoIG9wdGlvbnMuaWdub3JlX29wcyA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ7XCIgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMgKSArIFwifVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ7fShcIiArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucyApICsgXCIpXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRjYXNlIFwiLi8yXCI6XHJcblx0XHRcdFx0aWYoIG9wdGlvbnMuaWdub3JlX29wcyA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHR2YXIgbGlzdCA9IFwiW1wiICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zLCBhcmdfcHJpb3JpdHkgKTtcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gdGhpcy5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0ICs9IFwiLFwiICsgcG9pbnRlci5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zLCBhcmdfcHJpb3JpdHkgKTtcclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QgKz0gXCJ8XCIgKyBwb2ludGVyLnRvU3RyaW5nKCBvcHRpb25zLCBhcmdfcHJpb3JpdHkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3QgKz0gXCJdXCI7XHJcblx0XHRcdFx0XHRyZXR1cm4gbGlzdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dmFyIGlkID0gdGhpcy5pZDtcclxuXHRcdFx0XHR2YXIgb3BlcmF0b3IgPSBvcHRpb25zLnNlc3Npb24gPyBvcHRpb25zLnNlc3Npb24ubG9va3VwX29wZXJhdG9yKCB0aGlzLmlkLCB0aGlzLmFyZ3MubGVuZ3RoICkgOiBudWxsO1xyXG5cdFx0XHRcdGlmKCBvcHRpb25zLnNlc3Npb24gPT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZV9vcHMgfHwgb3BlcmF0b3IgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRpZiggb3B0aW9ucy5xdW90ZWQgJiYgKCEgL14oIXxbYS16XVswLTlhLXpBLVpfXSp8WyNcXCRcXCZcXCpcXCtcXC1cXC5cXC9cXDpcXDxcXD1cXD5cXD9cXEBcXF5cXH5cXFxcXSspJC8udGVzdCggaWQgKSAmJiBpZCAhPT0gXCJ7fVwiICYmIGlkICE9PSBcIltdXCIgfHwgaW5kZXhPZihbXCIuXCIsXCIsXCIsXCI7XCJdLCBpZCkgIT09IC0xIHx8IGlkLnN1YnN0cmluZygwLDIpID09PSBcIi8qXCIpIClcclxuXHRcdFx0XHRcdFx0aWQgPSBcIidcIiArIHJlZG9Fc2NhcGUoaWQpICsgXCInXCI7XHJcblx0XHRcdFx0XHRpZiggdGhpcy5hcmdzLmxlbmd0aCA9PT0gMCAmJiBpc19ncmFwaGljX3Rva2VuKHRoaXMuaWQpICYmIHByaW9yaXR5LmluZGljYXRvciAhPT0gXCJcIilcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiKFwiICsgaWQgKyBcIilcIjtcclxuXHRcdFx0XHRcdHJldHVybiBpZCArICh0aGlzLmFyZ3MubGVuZ3RoID4gMCA/IFwiKFwiICsgbWFwKCB0aGlzLmFyZ3MsXHJcblx0XHRcdFx0XHRcdGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHgudG9TdHJpbmcob3B0aW9ucywgYXJnX3ByaW9yaXR5KTsgfVxyXG5cdFx0XHRcdFx0KS5qb2luKFwiLFwiKSArIFwiKVwiIDogXCJcIik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBwcmlvcml0eV9vcCA9IHBhcnNlSW50KG9wZXJhdG9yLnByaW9yaXR5KTtcclxuXHRcdFx0XHRcdHZhciBwcmlvcml0eV9hcmcgPSBwYXJzZUludChwcmlvcml0eS5wcmlvcml0eSk7XHJcblx0XHRcdFx0XHR2YXIgY29uZCA9IHByaW9yaXR5X29wID4gcHJpb3JpdHlfYXJnIHx8IHByaW9yaXR5X29wID09PSBwcmlvcml0eV9hcmcgJiYgKFxyXG5cdFx0XHRcdFx0XHRvcGVyYXRvci5jbGFzcyA9PT0gXCJ4ZnhcIiB8fFxyXG5cdFx0XHRcdFx0XHRvcGVyYXRvci5jbGFzcyA9PT0gXCJ4ZnlcIiAmJiB0aGlzLmluZGljYXRvciAhPT0gcHJpb3JpdHkuaW5kaWNhdG9yIHx8XHJcblx0XHRcdFx0XHRcdG9wZXJhdG9yLmNsYXNzID09PSBcInlmeFwiICYmIHRoaXMuaW5kaWNhdG9yICE9PSBwcmlvcml0eS5pbmRpY2F0b3IgfHxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3IgPT09IHByaW9yaXR5LmluZGljYXRvciAmJiBvcGVyYXRvci5jbGFzcyA9PT0gXCJ5ZnhcIiAmJiBmcm9tID09PSBcInJpZ2h0XCIgfHxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3IgPT09IHByaW9yaXR5LmluZGljYXRvciAmJiBvcGVyYXRvci5jbGFzcyA9PT0gXCJ4ZnlcIiAmJiBmcm9tID09PSBcImxlZnRcIiB8fFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGljYXRvciA9PT0gcHJpb3JpdHkuaW5kaWNhdG9yICYmIG9wZXJhdG9yLmNsYXNzID09PSBcInhmXCIgJiYgZnJvbSA9PT0gXCJsZWZ0XCIgfHxcclxuXHRcdFx0XHRcdFx0dGhpcy5pbmRpY2F0b3IgPT09IHByaW9yaXR5LmluZGljYXRvciAmJiBvcGVyYXRvci5jbGFzcyA9PT0gXCJmeFwiICYmIGZyb20gPT09IFwicmlnaHRcIik7XHJcblx0XHRcdFx0XHRvcGVyYXRvci5pbmRpY2F0b3IgPSB0aGlzLmluZGljYXRvcjtcclxuXHRcdFx0XHRcdHZhciBscGFyID0gY29uZCA/IFwiKFwiIDogXCJcIjtcclxuXHRcdFx0XHRcdHZhciBycGFyID0gY29uZCA/IFwiKVwiIDogXCJcIjtcclxuXHRcdFx0XHRcdHZhciBzcGFjZSA9ICEoaXNfZ3JhcGhpY190b2tlbih0aGlzLmlkKSB8fCB0aGlzLmlkID09PSBcIixcIiB8fCB0aGlzLmlkID09PSBcIjtcIilcclxuXHRcdFx0XHRcdFx0fHwgb3BlcmF0b3IuY2xhc3MubGVuZ3RoID09PSAyXHJcblx0XHRcdFx0XHRcdHx8IG9wZXJhdG9yLmNsYXNzLmxlbmd0aCA9PT0gMyAmJiBwbC50eXBlLmlzX251bWJlcih0aGlzLmFyZ3NbMV0pICYmIHRoaXMuYXJnc1sxXS52YWx1ZSA8IDAgPyBcIiBcIiA6IFwiXCI7XHJcblx0XHRcdFx0XHRpZiggdGhpcy5hcmdzLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGxwYXIgKyB0aGlzLmlkICsgcnBhcjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggW1wiZnlcIixcImZ4XCJdLmluZGV4T2YoIG9wZXJhdG9yLmNsYXNzKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBscGFyICsgaWQgKyBzcGFjZSArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucywgb3BlcmF0b3IsIFwicmlnaHRcIiApICsgcnBhcjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggW1wieWZcIixcInhmXCJdLmluZGV4T2YoIG9wZXJhdG9yLmNsYXNzKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBscGFyICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zLCBvcGVyYXRvciwgXCJsZWZ0XCIgKSArIHNwYWNlICsgaWQgKyBycGFyO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGxwYXIgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMsIG9wZXJhdG9yLCBcImxlZnRcIiApICsgc3BhY2UgKyB0aGlzLmlkICsgc3BhY2UgKyB0aGlzLmFyZ3NbMV0udG9TdHJpbmcoIG9wdGlvbnMsIG9wZXJhdG9yLCBcInJpZ2h0XCIgKSArICBycGFyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBfICkge1xyXG5cdFx0cmV0dXJuIFwiPHN0cmVhbT4oXCIgKyB0aGlzLmlkICsgXCIpXCI7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdWJzdGl0dXRpb25zXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0dmFyIHN0ciA9IFwie1wiO1xyXG5cdFx0Zm9yKCB2YXIgbGluayBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSkgY29udGludWU7XHJcblx0XHRcdGlmKCBzdHIgIT09IFwie1wiICkge1xyXG5cdFx0XHRcdHN0ciArPSBcIiwgXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyICs9IGxpbmsgKyBcIi9cIiArIHRoaXMubGlua3NbbGlua10udG9TdHJpbmcoIG9wdGlvbnMgKTtcclxuXHRcdH1cclxuXHRcdHN0ciArPSBcIn1cIjtcclxuXHRcdHJldHVybiBzdHI7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdGF0ZXNcclxuXHRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHRcdGlmKCB0aGlzLmdvYWwgPT09IG51bGwgKSB7XHJcblx0XHRcdHJldHVybiBcIjxcIiArIHRoaXMuc3Vic3RpdHV0aW9uLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIj5cIjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBcIjxcIiArIHRoaXMuZ29hbC50b1N0cmluZyggb3B0aW9ucyApICsgXCIsIFwiICsgdGhpcy5zdWJzdGl0dXRpb24udG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiPlwiO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0aWYoICF0aGlzLmJvZHkgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmhlYWQudG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiLlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC50b1N0cmluZyggb3B0aW9ucywgMTIwMCwgXCJsZWZ0XCIgKSArIFwiIDotIFwiICsgdGhpcy5ib2R5LnRvU3RyaW5nKCBvcHRpb25zLCAxMjAwLCBcInJpZ2h0XCIgKSArIFwiLlwiO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gU2Vzc2lvblxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiB0aGlzLm1vZHVsZXMpIHtcclxuXHRcdFx0aWYodGhpcy5tb2R1bGVzLmhhc093blByb3BlcnR5KHByb3ApICYmIHRoaXMubW9kdWxlc1twcm9wXS5pc19saWJyYXJ5KVxyXG5cdFx0XHRcdHN0ciArPSBcIjotIHVzZV9tb2R1bGUobGlicmFyeShcIiArIHRoaXMubW9kdWxlc1twcm9wXSArIFwiKSkuXFxuXCI7XHJcblx0XHR9XHJcblx0XHRzdHIgKz0gXCJcXG5cIjtcclxuXHRcdGZvcih2YXIga2V5IGluIHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzKSB7XHJcblx0XHRcdGlmKCF0aGlzLm1vZHVsZXMudXNlci5ydWxlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcclxuXHRcdFx0Zm9yKGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLnVzZXIucnVsZXNba2V5XS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHN0ciArPSB0aGlzLm1vZHVsZXMudXNlci5ydWxlc1trZXldW2ldLnRvU3RyaW5nKG9wdGlvbnMpO1xyXG5cdFx0XHRcdHN0ciArPSBcIlxcblwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQ0xPTkUgUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFZhciggdGhpcy5pZCApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgTnVtKCB0aGlzLnZhbHVlLCB0aGlzLmlzX2Zsb2F0ICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGVybSA9IG5ldyBUZXJtKCB0aGlzLmlkLCBtYXAoIHRoaXMuYXJncywgZnVuY3Rpb24oIGFyZyApIHtcclxuXHRcdFx0cmV0dXJuIGFyZy5jbG9uZSgpO1xyXG5cdFx0fSApICk7XHJcblx0XHRpZih0aGlzLmRlZmluaXRpb25fbW9kdWxlKVxyXG5cdFx0XHR0ZXJtLmRlZmluaXRpb25fbW9kdWxlID0gdGhpcy5kZWZpbml0aW9uX21vZHVsZTtcclxuXHRcdHJldHVybiB0ZXJtO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0cmVhbSggdGhpcy5zdHJlYW0sIHRoaXMubW9kZSwgdGhpcy5hbGlhcywgdGhpcy50eXBlLCB0aGlzLnJlcG9zaXRpb24sIHRoaXMuZW9mX2FjdGlvbiApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3Vic3RpdHV0aW9uc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBsaW5rcyA9IHt9O1xyXG5cdFx0dmFyIGF0dHJzID0ge307XHJcblx0XHRmb3IoIHZhciBsaW5rIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKSBjb250aW51ZTtcclxuXHRcdFx0bGlua3NbbGlua10gPSB0aGlzLmxpbmtzW2xpbmtdLmNsb25lKCk7XHJcblx0XHR9XHJcblx0XHRmb3IoIHZhciBhdHRyIGluIHRoaXMuYXR0cnMgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmF0dHJzLmhhc093blByb3BlcnR5KGF0dHJzKSkgY29udGludWU7XHJcblx0XHRcdGF0dHJzW2F0dHJdID0ge307XHJcblx0XHRcdGZvciggdmFyIG0gaW4gdGhpcy5hdHRyc1thdHRyXSApIHtcclxuXHRcdFx0XHRpZighdGhpcy5hdHRyc1thdHRyXS5oYXNPd25Qcm9wZXJ0eShtKSkgY29udGludWU7XHJcblx0XHRcdFx0YXR0cnNbYXR0cl1bbV0gPSB0aGlzLmF0dHJzW2F0dHJdW21dLmNsb25lKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCBsaW5rcywgYXR0cnMgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN0YXRlc1xyXG5cdFN0YXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBTdGF0ZSggdGhpcy5nb2FsLmNsb25lKCksIHRoaXMuc3Vic3RpdHV0aW9uLmNsb25lKCksIHRoaXMucGFyZW50ICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJ1bGUoIHRoaXMuaGVhZC5jbG9uZSgpLCB0aGlzLmJvZHkgIT09IG51bGwgPyB0aGlzLmJvZHkuY2xvbmUoKSA6IG51bGwgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIENPTVBBUkUgUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc192YXJpYWJsZSggb2JqICkgJiYgdGhpcy5pZCA9PT0gb2JqLmlkO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX251bWJlciggb2JqICkgJiYgdGhpcy52YWx1ZSA9PT0gb2JqLnZhbHVlICYmIHRoaXMuaXNfZmxvYXQgPT09IG9iai5pc19mbG9hdDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdGlmKCAhcGwudHlwZS5pc190ZXJtKCBvYmogKSB8fCB0aGlzLmluZGljYXRvciAhPT0gb2JqLmluZGljYXRvciApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdGlmKCAhdGhpcy5hcmdzW2ldLmVxdWFscyggb2JqLmFyZ3NbaV0gKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19zdHJlYW0oIG9iaiApICYmIHRoaXMuaWQgPT09IG9iai5pZDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN1YnN0aXR1dGlvbnNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0dmFyIGxpbms7XHJcblx0XHRpZiggIXBsLnR5cGUuaXNfc3Vic3RpdHV0aW9uKCBvYmogKSApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKCBsaW5rIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKSBjb250aW51ZTtcclxuXHRcdFx0aWYoICFvYmoubGlua3NbbGlua10gfHwgIXRoaXMubGlua3NbbGlua10uZXF1YWxzKCBvYmoubGlua3NbbGlua10gKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciggbGluayBpbiBvYmoubGlua3MgKSB7XHJcblx0XHRcdGlmKCFvYmoubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpIGNvbnRpbnVlO1xyXG5cdFx0XHRpZiggIXRoaXMubGlua3NbbGlua10gKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN0YXRlc1xyXG5cdFN0YXRlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfc3RhdGUoIG9iaiApICYmIHRoaXMuZ29hbC5lcXVhbHMoIG9iai5nb2FsICkgJiYgdGhpcy5zdWJzdGl0dXRpb24uZXF1YWxzKCBvYmouc3Vic3RpdHV0aW9uICkgJiYgdGhpcy5wYXJlbnQgPT09IG9iai5wYXJlbnQ7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19ydWxlKCBvYmogKSAmJiB0aGlzLmhlYWQuZXF1YWxzKCBvYmouaGVhZCApICYmICh0aGlzLmJvZHkgPT09IG51bGwgJiYgb2JqLmJvZHkgPT09IG51bGwgfHwgdGhpcy5ib2R5ICE9PSBudWxsICYmIHRoaXMuYm9keS5lcXVhbHMoIG9iai5ib2R5ICkpO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gUkVOQU1FIFZBUklBQkxFUyBPRiBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdHJldHVybiB0aHJlYWQuZ2V0X2ZyZWVfdmFyaWFibGUoIHRoaXMgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKCBfICkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHQvLyBncm91bmRcclxuXHRcdGlmKHRoaXMuZ3JvdW5kKVxyXG5cdFx0XHRyZXR1cm4gbmV3IFRlcm0odGhpcy5pZCwgdGhpcy5hcmdzKTtcclxuXHRcdC8vIGxpc3RcclxuXHRcdGlmKHRoaXMuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzO1xyXG5cdFx0XHR3aGlsZShwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiAmJiAhcG9pbnRlci5ncm91bmQpIHtcclxuXHRcdFx0XHR2YXIgYXBwID0gcG9pbnRlci5hcmdzWzBdLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHRcdGFyci5wdXNoKGFwcCk7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbGlzdCA9IHBvaW50ZXIucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdGZvcih2YXIgaSA9IGFyci5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pXHJcblx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKFwiLlwiLCBbYXJyW2ldLCBsaXN0XSk7XHJcblx0XHRcdHJldHVybiBsaXN0O1xyXG5cdFx0fVxyXG5cdFx0Ly8gY29tcG91bmQgdGVybVxyXG5cdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGFwcCA9IHRoaXMuYXJnc1tpXS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0YXJncy5wdXNoKGFwcCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFRlcm0odGhpcy5pZCwgYXJncyk7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0cmV0dXJuIG5ldyBSdWxlKCB0aGlzLmhlYWQucmVuYW1lKCB0aHJlYWQgKSwgdGhpcy5ib2R5ICE9PSBudWxsID8gdGhpcy5ib2R5LnJlbmFtZSggdGhyZWFkICkgOiBudWxsICk7XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvLyBDSEVDSyBJRiBSRU5BTUVcclxuXHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5pc19yZW5hbWUgPSBmdW5jdGlvbihvYmosIGxpbmtzKSB7XHJcblx0XHRsaW5rcyA9IGxpbmtzIHx8IHt9O1xyXG5cdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUob2JqKVxyXG5cdFx0fHwgbGlua3MuaGFzT3duUHJvcGVydHkodGhpcy5pZCkgJiYgbGlua3NbdGhpcy5pZF0gIT09IG9iai5pZFxyXG5cdFx0fHwgbGlua3MuaGFzT3duUHJvcGVydHkob2JqLmlkKSAmJiBsaW5rc1tvYmouaWRdICE9PSB0aGlzLmlkKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRsaW5rc1t0aGlzLmlkXSA9IG9iai5pZDtcclxuXHRcdGxpbmtzW29iai5pZF0gPSB0aGlzLmlkO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5pc19yZW5hbWUgPSBmdW5jdGlvbihvYmosIF9saW5rcykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXF1YWxzKG9iaik7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmlzX3JlbmFtZSA9IGZ1bmN0aW9uKG9iaiwgbGlua3MpIHtcclxuXHRcdGxpbmtzID0gbGlua3MgfHwge307XHJcblx0XHRpZighcGwudHlwZS5pc190ZXJtKG9iaikgfHwgdGhpcy5pbmRpY2F0b3IgIT09IG9iai5pbmRpY2F0b3IpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYoIXBsLmlzX3JlbmFtZSh0aGlzLmFyZ3NbaV0sIG9iai5hcmdzW2ldLCBsaW5rcykpXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUuaXNfcmVuYW1lID0gZnVuY3Rpb24ob2JqLCBfbGlua3MpIHtcclxuXHRcdHJldHVybiB0aGlzLmVxdWFscyhvYmopO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gR0VUIElEIE9GIFZBUklBQkxFUyBGUk9NIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBbdGhpcy5pZF07XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBbXTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLmdyb3VuZClcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0cmV0dXJuIFtdLmNvbmNhdC5hcHBseSggW10sIG1hcCggdGhpcy5hcmdzLCBmdW5jdGlvbiggYXJnICkge1xyXG5cdFx0XHRyZXR1cm4gYXJnLnZhcmlhYmxlcygpO1xyXG5cdFx0fSApICk7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gW107XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoIHRoaXMuYm9keSA9PT0gbnVsbCApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC52YXJpYWJsZXMoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmhlYWQudmFyaWFibGVzKCkuY29uY2F0KCB0aGlzLmJvZHkudmFyaWFibGVzKCkgKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIEFQUExZIFNVQlNUSVRVVElPTlMgVE8gUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIHN1YnMgKSB7XHJcblx0XHRpZiggc3Vicy5sb29rdXAoIHRoaXMuaWQgKSApIHtcclxuXHRcdFx0cmV0dXJuIHN1YnMubG9va3VwKCB0aGlzLmlkICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIF8gKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggc3VicyApIHtcclxuXHRcdC8vIGdyb3VuZCBhdG9tXHJcblx0XHRpZih0aGlzLmdyb3VuZClcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHQvLyBsaXN0XHJcblx0XHRpZih0aGlzLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdHZhciBwb2ludGVyID0gdGhpcztcclxuXHRcdFx0d2hpbGUocG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgJiYgIXBvaW50ZXIuZ3JvdW5kKSB7XHJcblx0XHRcdFx0dmFyIGFwcCA9IHBvaW50ZXIuYXJnc1swXS5hcHBseShzdWJzKTtcclxuXHRcdFx0XHRhcnIucHVzaChhcHApO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGxpc3QgPSBwb2ludGVyLmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRmb3IodmFyIGkgPSBhcnIubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxyXG5cdFx0XHRcdGxpc3QgPSBuZXcgVGVybShcIi5cIiwgW2FycltpXSwgbGlzdF0pO1xyXG5cdFx0XHRyZXR1cm4gbGlzdDtcclxuXHRcdH1cclxuXHRcdC8vIGNvbXBvdW5kIHRlcm1cclxuXHRcdHZhciBhcmdzID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBhcHAgPSB0aGlzLmFyZ3NbaV0uYXBwbHkoc3Vicyk7XHJcblx0XHRcdGFyZ3MucHVzaChhcHApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBUZXJtKHRoaXMuaWQsIGFyZ3MsIHRoaXMucmVmKTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBfICkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIHN1YnMgKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJ1bGUoIHRoaXMuaGVhZC5hcHBseSggc3VicyApLCB0aGlzLmJvZHkgIT09IG51bGwgPyB0aGlzLmJvZHkuYXBwbHkoIHN1YnMgKSA6IG51bGwgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN1YnN0aXR1dGlvbnNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIHN1YnMgKSB7XHJcblx0XHR2YXIgbGluaywgbGlua3MgPSB7fSwgYXR0ciwgYXR0cnMgPSB7fSwgbTtcclxuXHRcdGZvciggbGluayBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSkgY29udGludWU7XHJcblx0XHRcdGxpbmtzW2xpbmtdID0gdGhpcy5saW5rc1tsaW5rXS5hcHBseShzdWJzKTtcclxuXHRcdH1cclxuXHRcdGZvciggYXR0ciBpbiB0aGlzLmF0dHJzICkge1xyXG5cdFx0XHRpZighdGhpcy5hdHRycy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgY29udGludWU7XHJcblx0XHRcdGF0dHJzW2F0dHJdID0ge307XHJcblx0XHRcdGZvciggbSBpbiB0aGlzLmF0dHJzW2F0dHJdICkge1xyXG5cdFx0XHRcdGlmKCF0aGlzLmF0dHJzW2F0dHJdLmhhc093blByb3BlcnR5KG0pKSBjb250aW51ZTtcclxuXHRcdFx0XHRhdHRyc1thdHRyXVttXSA9IHRoaXMuYXR0cnNbYXR0cl1bbV0uYXBwbHkoc3Vicyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCBsaW5rcywgYXR0cnMgKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFNFTEVDVElPTiBGVU5DVElPTlxyXG5cdFxyXG5cdC8vIFNlbGVjdCB0ZXJtXHJcblx0VGVybS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcG9pbnRlciA9IHRoaXM7XHJcblx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLC8yXCIpXHJcblx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRyZXR1cm4gcG9pbnRlcjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJlcGxhY2UgdGVybVxyXG5cdFRlcm0ucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbiggZXhwciApIHtcclxuXHRcdGlmKCB0aGlzLmluZGljYXRvciA9PT0gXCIsLzJcIiApIHtcclxuXHRcdFx0aWYoIHRoaXMuYXJnc1swXS5pbmRpY2F0b3IgPT09IFwiLC8yXCIgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcIixcIiwgW3RoaXMuYXJnc1swXS5yZXBsYWNlKCBleHByICksIHRoaXMuYXJnc1sxXV0gKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gZXhwciA9PT0gbnVsbCA/IHRoaXMuYXJnc1sxXSA6IG5ldyBUZXJtKCBcIixcIiwgW2V4cHIsIHRoaXMuYXJnc1sxXV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gU2VhcmNoIHRlcm1cclxuXHRUZXJtLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiggZXhwciApIHtcclxuXHRcdGlmKHRoaXMgPT0gZXhwciB8fCB0aGlzLnJlZiA9PT0gZXhwci5yZWYpXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKysgKVxyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCB0aGlzLmFyZ3NbaV0gKSAmJiB0aGlzLmFyZ3NbaV0uc2VhcmNoKCBleHByICkgKVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gUFJPTE9HIFNFU1NJT05TIEFORCBUSFJFQURTXHJcblxyXG5cdC8vIFB1c2ggdG8gYSBnbG9iYWwgc3RhY2tcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5wdXNoX2dsb2JhbF9zdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnB1c2hfZ2xvYmFsX3N0YWNrKHN0YWNrLCB2YWx1ZSk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnB1c2hfZ2xvYmFsX3N0YWNrID0gZnVuY3Rpb24oc3RhY2ssIHZhbHVlKSB7XHJcblx0XHRpZighdGhpcy5fX3N0YWNrcy5oYXNPd25Qcm9wZXJ0eShzdGFjaykpXHJcblx0XHRcdHRoaXMuX19zdGFja3Nbc3RhY2tdID0gW107XHJcblx0XHR0aGlzLl9fc3RhY2tzW3N0YWNrXS5wdXNoKHZhbHVlKTtcclxuXHR9O1xyXG5cclxuXHQvLyBQb3AgYWxsIGZyb20gYSBnbG9iYWwgc3RhY2tcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5mbHVzaF9nbG9iYWxfc3RhY2sgPSBmdW5jdGlvbihzdGFjaywgdGFpbCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnB1c2hfZ2xvYmFsX3N0YWNrKHN0YWNrLCB0YWlsKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZmx1c2hfZ2xvYmFsX3N0YWNrID0gZnVuY3Rpb24oc3RhY2ssIHRhaWwpIHtcclxuXHRcdHZhciBsaXN0ID0gdGFpbCB8fCBuZXcgVGVybShcIltdXCIsIFtdKTtcclxuXHRcdGlmKHRoaXMuX19zdGFja3MuaGFzT3duUHJvcGVydHkoc3RhY2spKSB7XHJcblx0XHRcdHdoaWxlKHRoaXMuX19zdGFja3Nbc3RhY2tdLmxlbmd0aCA+IDApXHJcblx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKFwiLlwiLCBbdGhpcy5fX3N0YWNrc1tzdGFja10ucG9wKCksIGxpc3RdKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX19zdGFja3Nbc3RhY2tdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGxpc3Q7XHJcblx0fTtcclxuXHJcblx0Ly8gU2V0IG1heCBpbmZlcmVuY2VzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuc2V0TWF4SW5mZXJlbmNlcyA9IGZ1bmN0aW9uKG1heCkge1xyXG5cdFx0dGhpcy5saW1pdCA9IHR5cGVvZiBtYXggPT09IFwibnVtYmVyXCIgJiYgbWF4ID4gMCA/IG1heCA6IG51bGw7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnNldE1heEluZmVyZW5jZXMgPSBmdW5jdGlvbihtYXgpIHtcclxuXHRcdHRoaXMuc2Vzc2lvbi5zZXRNYXhJbmZlcmVuY2VzKG1heCk7XHJcblx0XHR0aGlzLmN1cnJlbnRfbGltaXQgPSB0aGlzLnNlc3Npb24ubGltaXQ7XHJcblx0XHR0aGlzLmhhc19saW1pdCA9IHRoaXMuc2Vzc2lvbi5saW1pdCAhPT0gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvLyBGb3JtYXQgYW5zd2VyXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZm9ybWF0X2Fuc3dlciA9IGZ1bmN0aW9uKGFuc3dlciwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmZvcm1hdF9hbnN3ZXIoYW5zd2VyLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZm9ybWF0X2Fuc3dlciA9IGZ1bmN0aW9uKGFuc3dlciwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHBsLmZvcm1hdF9hbnN3ZXIoYW5zd2VyLCB0aGlzLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgY3VycmVudCBpbnB1dFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9jdXJyZW50X2lucHV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50X2lucHV0O1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfY3VycmVudF9pbnB1dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRfY3VycmVudF9pbnB1dCgpO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBjdXJyZW50IG91dHB1dFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9jdXJyZW50X291dHB1dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY3VycmVudF9vdXRwdXQ7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9jdXJyZW50X291dHB1dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRfY3VycmVudF9vdXRwdXQoKTtcclxuXHR9O1xyXG5cclxuXHQvLyBTZXQgY3VycmVudCBpbnB1dFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnNldF9jdXJyZW50X2lucHV0ID0gZnVuY3Rpb24oIGlucHV0ICkge1xyXG5cdFx0dGhpcy5jdXJyZW50X2lucHV0ID0gaW5wdXQ7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnNldF9jdXJyZW50X2lucHV0ID0gZnVuY3Rpb24oIGlucHV0ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5zZXRfY3VycmVudF9pbnB1dCggaW5wdXQgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBTZXQgY3VycmVudCBvdXRwdXRcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5zZXRfY3VycmVudF9vdXRwdXQgPSBmdW5jdGlvbiggb3V0cHV0ICkge1xyXG5cdFx0dGhpcy5jdXJyZW50X291dHB1dCA9IG91dHB1dDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuc2V0X2N1cnJlbnRfb3V0cHV0ID0gZnVuY3Rpb24oIG91dHB1dCApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uc2V0X2N1cnJlbnRfb3V0cHV0KCBvdXRwdXQpO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBzdHJlYW0gYnkgYWxpYXNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfc3RyZWFtX2J5X2FsaWFzID0gZnVuY3Rpb24oIGFsaWFzICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc3RyZWFtc1thbGlhc107XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9zdHJlYW1fYnlfYWxpYXMgPSBmdW5jdGlvbiggYWxpYXMgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmdldF9zdHJlYW1fYnlfYWxpYXMoIGFsaWFzICk7XHJcblx0fTtcclxuXHJcblx0Ly8gT3BlbiBmaWxlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZmlsZV9zeXN0ZW1fb3BlbiA9IGZ1bmN0aW9uKCBwYXRoLCB0eXBlLCBtb2RlICkge1xyXG5cdFx0aWYodGhpcy5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwiZmFsc2UvMFwiKVxyXG5cdFx0XHRwYXRoID0gdGhpcy5hYnNvbHV0ZV9maWxlX25hbWUocGF0aCk7XHJcblx0XHRyZXR1cm4gdGhpcy5maWxlX3N5c3RlbS5vcGVuKCBwYXRoLCB0eXBlLCBtb2RlICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmZpbGVfc3lzdGVtX29wZW4gPSBmdW5jdGlvbiggcGF0aCwgdHlwZSwgbW9kZSApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZmlsZV9zeXN0ZW1fb3BlbiggcGF0aCwgdHlwZSwgbW9kZSApO1xyXG5cdH07XHJcblxyXG5cdC8vIEFic29sdXRlIGZpbGUgbmFtZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFic29sdXRlX2ZpbGVfbmFtZSA9IGZ1bmN0aW9uKGZpbGVuYW1lKSB7XHJcblx0XHR2YXIgYWJzb2x1dGU7XHJcblx0XHQvLyBub2RlLmpzXHJcblx0XHRpZih0aGlzLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIikge1xyXG5cdFx0XHR2YXIgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xyXG5cdFx0XHRhYnNvbHV0ZSA9IGZpbGVuYW1lO1xyXG5cdFx0XHRmb3IodmFyIHByb3AgaW4gcHJvY2Vzcy5lbnYpIHtcclxuXHRcdFx0XHRpZighcHJvY2Vzcy5lbnYuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRhYnNvbHV0ZSA9IGFic29sdXRlLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFwkXCIgKyBwcm9wLCBcImdcIiksIHByb2Nlc3MuZW52W3Byb3BdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcGF0aC5yZXNvbHZlKGFic29sdXRlKTtcclxuXHRcdC8vIGJyb3dzZXJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBjd2QgPSB0aGlzLndvcmtpbmdfZGlyZWN0b3J5O1xyXG5cdFx0XHRpZihmaWxlbmFtZVswXSA9PT0gXCIvXCIpXHJcblx0XHRcdFx0YWJzb2x1dGUgPSBmaWxlbmFtZTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdGFic29sdXRlID0gY3dkICsgKGN3ZFtjd2QubGVuZ3RoLTFdID09PSBcIi9cIiA/IGZpbGVuYW1lIDogXCIvXCIgKyBmaWxlbmFtZSk7XHJcblx0XHRcdGFic29sdXRlID0gYWJzb2x1dGUucmVwbGFjZSgvXFwvXFwuXFwvL2csIFwiL1wiKTtcclxuXHRcdFx0dmFyIGRpcnMgPSBhYnNvbHV0ZS5zcGxpdChcIi9cIik7XHJcblx0XHRcdHZhciBkaXJzMiA9IFtdO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmKGRpcnNbaV0gIT09IFwiLi5cIikge1xyXG5cdFx0XHRcdFx0ZGlyczIucHVzaChkaXJzW2ldKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoZGlyczIubGVuZ3RoICE9PSAwKVxyXG5cdFx0XHRcdFx0XHRkaXJzMi5wb3AoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0YWJzb2x1dGUgPSBkaXJzMi5qb2luKFwiL1wiKS5yZXBsYWNlKC9cXC9cXC4kLywgXCIvXCIpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFic29sdXRlO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hYnNvbHV0ZV9maWxlX25hbWUgPSBmdW5jdGlvbihwYXRoLCBjd2QpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uYWJzb2x1dGVfZmlsZV9uYW1lKHBhdGgsIGN3ZCk7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IGNvbnZlcnNpb24gb2YgdGhlIGNoYXJcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfY2hhcl9jb252ZXJzaW9uID0gZnVuY3Rpb24oIGNoYXIgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fX2NoYXJfY29udmVyc2lvbltjaGFyXSB8fCBjaGFyO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfY2hhcl9jb252ZXJzaW9uID0gZnVuY3Rpb24oIGNoYXIgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmdldF9jaGFyX2NvbnZlcnNpb24oIGNoYXIgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cclxuXHRTZXNzaW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucGFyc2UoIHN0cmluZyApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XHJcblx0XHR2YXIgdG9rZW5pemVyID0gbmV3IFRva2VuaXplciggdGhpcyApO1xyXG5cdFx0dG9rZW5pemVyLm5ld190ZXh0KCBzdHJpbmcgKTtcclxuXHRcdHZhciB0b2tlbnMgPSB0b2tlbml6ZXIuZ2V0X3Rva2VucygpO1xyXG5cdFx0aWYoIHRva2VucyA9PT0gbnVsbCApXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdHZhciBleHByID0gcGFyc2VFeHByKHRoaXMsIHRva2VucywgMCwgdGhpcy5fX2dldF9tYXhfcHJpb3JpdHkoKSwgZmFsc2UpO1xyXG5cdFx0aWYoIGV4cHIubGVuICE9PSB0b2tlbnMubGVuZ3RoIClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0cmV0dXJuIHsgdmFsdWU6IGV4cHIudmFsdWUsIGV4cHI6IGV4cHIsIHRva2VuczogdG9rZW5zIH07XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgZmxhZyB2YWx1ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9mbGFnID0gZnVuY3Rpb24oIGZsYWcgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5mbGFnW2ZsYWddO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfZmxhZyA9IGZ1bmN0aW9uKCBmbGFnICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5nZXRfZmxhZyggZmxhZyApO1xyXG5cdH07XHJcblxyXG5cdC8vIEFkZCBhIHJ1bGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hZGRfcnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5hZGRfcnVsZShydWxlLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuYWRkX3J1bGUgPSBmdW5jdGlvbihydWxlLCBvcHRpb25zKSB7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcclxuXHRcdG9wdGlvbnMuZnJvbSA9IG9wdGlvbnMuZnJvbSA/IG9wdGlvbnMuZnJvbSA6IFwiJHRhdS1qc1wiO1xyXG5cdFx0dmFyIG1vZHVsZV9pZCwgZ2V0X21vZHVsZTtcclxuXHRcdGlmKHBsLnR5cGUuaXNfdGVybShydWxlLmhlYWQpICYmIHJ1bGUuaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShydWxlLmhlYWQuYXJnc1swXSkpIHtcclxuXHRcdFx0XHR0aGlzLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBydWxlLmhlYWQuYXJnc1swXSwgXCJ0b3BfbGV2ZWwvMFwiKSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1vZHVsZV9pZCA9IHJ1bGUuaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRydWxlLmhlYWQgPSBydWxlLmhlYWQuYXJnc1sxXTtcclxuXHRcdH1cclxuXHRcdGlmKG1vZHVsZV9pZCkge1xyXG5cdFx0XHRnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0Z2V0X21vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlX2lkLCB7fSwgXCJhbGxcIiwge3Nlc3Npb246IHRoaXMuc2Vzc2lvbn0pO1xyXG5cdFx0XHRcdHRoaXMuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0gPSBnZXRfbW9kdWxlO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV07XHJcblx0XHR9XHJcblx0XHRnZXRfbW9kdWxlLnNyY19wcmVkaWNhdGVzW3J1bGUuaGVhZC5pbmRpY2F0b3JdID0gb3B0aW9ucy5mcm9tO1xyXG5cdFx0aWYoIWdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkocnVsZS5oZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0Z2V0X21vZHVsZS5ydWxlc1tydWxlLmhlYWQuaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0fVxyXG5cdFx0Z2V0X21vZHVsZS5ydWxlc1tydWxlLmhlYWQuaW5kaWNhdG9yXS5wdXNoKHJ1bGUpO1xyXG5cdFx0aWYoIWdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkocnVsZS5oZWFkLmluZGljYXRvcikpXHJcblx0XHRcdGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNbcnVsZS5oZWFkLmluZGljYXRvcl0gPSBmYWxzZTtcclxuXHRcdC8vIHVwZGF0ZSB0ZXJtIGluZGV4aW5nXHJcblx0XHRnZXRfbW9kdWxlLmFkZF9pbmRleF9wcmVkaWNhdGUocnVsZSk7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvLyBSdW4gYSBkaXJlY3RpdmVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5ydW5fZGlyZWN0aXZlID0gZnVuY3Rpb24oZGlyZWN0aXZlLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucnVuX2RpcmVjdGl2ZShkaXJlY3RpdmUsIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5ydW5fZGlyZWN0aXZlID0gZnVuY3Rpb24oZGlyZWN0aXZlLCBvcHRpb25zKSB7XHJcblx0XHRpZihwbC50eXBlLmlzX2RpcmVjdGl2ZShkaXJlY3RpdmUpKSB7XHJcblx0XHRcdGlmKHBsLmRpcmVjdGl2ZVtkaXJlY3RpdmUuaW5kaWNhdG9yXSlcclxuXHRcdFx0XHRyZXR1cm4gcGwuZGlyZWN0aXZlW2RpcmVjdGl2ZS5pbmRpY2F0b3JdKHRoaXMsIGRpcmVjdGl2ZSwgb3B0aW9ucyk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXR1cm4gcGwuZGlyZWN0aXZlW2RpcmVjdGl2ZS5pZCArIFwiLypcIl0odGhpcywgZGlyZWN0aXZlLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBtYXhpbXVtIHByaW9yaXR5IG9mIHRoZSBvcGVyYXRvcnNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5fX2dldF9tYXhfcHJpb3JpdHkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBcIjEyMDBcIjtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuX19nZXRfbWF4X3ByaW9yaXR5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLl9fZ2V0X21heF9wcmlvcml0eSgpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IG5leHQgcHJpb3JpdHkgb2YgdGhlIG9wZXJhdG9yc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLl9fZ2V0X25leHRfcHJpb3JpdHkgPSBmdW5jdGlvbiggcHJpb3JpdHkgKSB7XHJcblx0XHR2YXIgbWF4ID0gMDtcclxuXHRcdHByaW9yaXR5ID0gcGFyc2VJbnQoIHByaW9yaXR5ICk7XHJcblx0XHRmb3IoIHZhciBrZXkgaW4gdGhpcy5fX29wZXJhdG9ycyApIHtcclxuXHRcdFx0aWYoICF0aGlzLl9fb3BlcmF0b3JzLmhhc093blByb3BlcnR5KGtleSkgKSBjb250aW51ZTtcclxuXHRcdFx0dmFyIG4gPSBwYXJzZUludChrZXkpO1xyXG5cdFx0XHRpZiggbiA+IG1heCAmJiBuIDwgcHJpb3JpdHkgKSBtYXggPSBuO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1heC50b1N0cmluZygpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5fX2dldF9uZXh0X3ByaW9yaXR5ID0gZnVuY3Rpb24oIHByaW9yaXR5ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5fX2dldF9uZXh0X3ByaW9yaXR5KCBwcmlvcml0eSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IGNsYXNzZXMgb2YgYW4gb3BlcmF0b3JcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzID0gZnVuY3Rpb24oIHByaW9yaXR5LCBvcGVyYXRvciApIHtcclxuXHRcdGlmKCB0aGlzLl9fb3BlcmF0b3JzLmhhc093blByb3BlcnR5KCBwcmlvcml0eSApICYmIHRoaXMuX19vcGVyYXRvcnNbcHJpb3JpdHldW29wZXJhdG9yXSBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fX29wZXJhdG9yc1twcmlvcml0eV1bb3BlcmF0b3JdICB8fCBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuX19sb29rdXBfb3BlcmF0b3JfY2xhc3NlcyA9IGZ1bmN0aW9uKCBwcmlvcml0eSwgb3BlcmF0b3IgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMoIHByaW9yaXR5LCBvcGVyYXRvciApO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBvcGVyYXRvclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmxvb2t1cF9vcGVyYXRvciA9IGZ1bmN0aW9uKCBuYW1lLCBhcml0eSApIHtcclxuXHRcdGZvcih2YXIgcCBpbiB0aGlzLl9fb3BlcmF0b3JzKVxyXG5cdFx0XHRpZih0aGlzLl9fb3BlcmF0b3JzW3BdW25hbWVdKVxyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9fb3BlcmF0b3JzW3BdW25hbWVdLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0aWYoIHRoaXMuX19vcGVyYXRvcnNbcF1bbmFtZV1baV0ubGVuZ3RoID09PSBhcml0eSsxIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtwcmlvcml0eTogcCwgY2xhc3M6IHRoaXMuX19vcGVyYXRvcnNbcF1bbmFtZV1baV19O1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmxvb2t1cF9vcGVyYXRvciA9IGZ1bmN0aW9uKCBuYW1lLCBhcml0eSApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24ubG9va3VwX29wZXJhdG9yKCBuYW1lLCBhcml0eSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGhyb3cgYSB3YXJuaW5nXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUudGhyb3dfd2FybmluZyA9IGZ1bmN0aW9uKCB3YXJuaW5nICkge1xyXG5cdFx0dGhpcy50aHJlYWQudGhyb3dfd2FybmluZyggd2FybmluZyApO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS50aHJvd193YXJuaW5nID0gZnVuY3Rpb24oIHdhcm5pbmcgKSB7XHJcblx0XHR0aGlzLndhcm5pbmdzLnB1c2goIHdhcm5pbmcgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCB3YXJuaW5nc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF93YXJuaW5ncyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmdldF93YXJuaW5ncygpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5nZXRfd2FybmluZ3MgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLndhcm5pbmdzO1xyXG5cdH07XHJcblxyXG5cdC8vIEFkZCBhIGdvYWxcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hZGRfZ29hbCA9IGZ1bmN0aW9uKCBnb2FsLCB1bmlxdWUgKSB7XHJcblx0XHR0aGlzLnRocmVhZC5hZGRfZ29hbCggZ29hbCwgdW5pcXVlICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmFkZF9nb2FsID0gZnVuY3Rpb24oIGdvYWwsIHVuaXF1ZSwgcGFyZW50ICkge1xyXG5cdFx0cGFyZW50ID0gcGFyZW50ID8gcGFyZW50IDogbnVsbDtcclxuXHRcdGlmKCB1bmlxdWUgPT09IHRydWUgKVxyXG5cdFx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0dmFyIHZhcnMgPSBnb2FsLnZhcmlhYmxlcygpO1xyXG5cdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKysgKVxyXG5cdFx0XHRsaW5rc1t2YXJzW2ldXSA9IG5ldyBWYXIodmFyc1tpXSk7XHJcblx0XHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgU3RhdGUoIGdvYWwsIG5ldyBTdWJzdGl0dXRpb24obGlua3MpLCBwYXJlbnQgKSApO1xyXG5cdH07XHJcblxyXG5cdC8vIENvbnN1bHQgYSBwcm9ncmFtIGZyb20gYSBzdHJpbmdcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5jb25zdWx0ID0gZnVuY3Rpb24ocHJvZ3JhbSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmNvbnN1bHQocHJvZ3JhbSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmNvbnN1bHQgPSBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc3RyaW5nID0gXCJcIiwgc3VjY2VzcyA9IGZhbHNlO1xyXG5cdFx0dmFyIG9wdHMgPSB7fTtcclxuXHRcdHZhciBjYWxsYmFjayA9IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zIDogZnVuY3Rpb24oKXt9O1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJmdW5jdGlvblwiID8ge30gOiBvcHRpb25zO1xyXG5cdFx0b3B0cy5jb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdG9wdHMudGV4dCA9IG9wdGlvbnMudGV4dCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMudGV4dDtcclxuXHRcdG9wdHMuaHRtbCA9IG9wdGlvbnMuaHRtbCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaHRtbDtcclxuXHRcdG9wdHMudXJsID0gb3B0aW9ucy51cmwgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnVybDtcclxuXHRcdG9wdHMuZmlsZSA9IG9wdGlvbnMuZmlsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuZmlsZTtcclxuXHRcdG9wdHMuc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLnNjcmlwdDtcclxuXHRcdG9wdHMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyA9PT0gdW5kZWZpbmVkID8gY2FsbGJhY2sgOiBvcHRpb25zLnN1Y2Nlc3M7XHJcblx0XHRvcHRzLmVycm9yID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gY2FsbGJhY2sgOiBvcHRpb25zLmVycm9yO1xyXG5cdFx0Ly8gc3RyaW5nXHJcblx0XHRpZih0eXBlb2YgcHJvZ3JhbSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHRzdHJpbmcgPSBwcm9ncmFtO1xyXG5cdFx0XHQvLyBzY3JpcHQgaWRcclxuXHRcdFx0aWYob3B0cy5zY3JpcHQgJiYgdGhpcy5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwiZmFsc2UvMFwiICYmIHByb2dyYW0gIT0gXCJcIiAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHJpbmcpKSB7XHJcblx0XHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cmluZyk7XHJcblx0XHRcdFx0dmFyIHR5cGUgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwidHlwZVwiKTtcclxuXHRcdFx0XHRpZih0eXBlICE9PSBudWxsICYmIHR5cGUucmVwbGFjZSgvIC9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInRleHQvcHJvbG9nXCIpIHtcclxuXHRcdFx0XHRcdHN0cmluZyA9IHNjcmlwdC50ZXh0O1xyXG5cdFx0XHRcdFx0c3VjY2VzcyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGZpbGUgKG5vZGUuanMpXHJcblx0XHRcdGlmKCFzdWNjZXNzICYmIG9wdHMuZmlsZSAmJiB0aGlzLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIikge1xyXG5cdFx0XHRcdHZhciBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcclxuXHRcdFx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdFx0XHRmcy5yZWFkRmlsZShwcm9ncmFtLCBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xyXG5cdFx0XHRcdFx0aWYoZXJyb3IpIHtcclxuXHRcdFx0XHRcdFx0b3B0cy5maWxlID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5jb25zdWx0KHByb2dyYW0sIG9wdHMpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgZGF0YS50b1N0cmluZygpLCBvcHRzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaHR0cCByZXF1ZXN0XHJcblx0XHRcdGlmKCFzdWNjZXNzICYmIHRoaXMuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcImZhbHNlLzBcIiAmJiBvcHRzLnVybCAmJiBwcm9ncmFtICE9PSBcIlwiICYmICEoL1xccy8udGVzdChwcm9ncmFtKSkpIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIHhodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHRcdFx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdFx0XHRcdHhodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRpZih0aGlzLnJlYWR5U3RhdGUgPT0gNCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuc3RhdHVzID09IDIwMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RyaW5nID0geGh0dHAucmVzcG9uc2VUZXh0O1xyXG5cdFx0XHRcdFx0XHRcdFx0c3VjY2VzcyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBzdHJpbmcsIG9wdHMpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRvcHRzLnVybCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLmNvbnN1bHQocHJvZ3JhbSwgb3B0cyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR4aHR0cC5vcGVuKFwiR0VUXCIsIHByb2dyYW0sIHRydWUpO1xyXG5cdFx0XHRcdFx0eGh0dHAuc2VuZCgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gY2F0Y2goZXgpIHtcclxuXHRcdFx0XHRcdG9wdHMuZXJyb3IoZXgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyB0ZXh0XHJcblx0XHRcdGlmKCFzdWNjZXNzICYmIG9wdHMudGV4dCkge1xyXG5cdFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHQvLyBodG1sXHJcblx0XHR9IGVsc2UgaWYob3B0cy5odG1sICYmIHByb2dyYW0ubm9kZU5hbWUpIHtcclxuXHRcdFx0c3dpdGNoKHByb2dyYW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xyXG5cdFx0XHRcdGNhc2UgXCJpbnB1dFwiOlxyXG5cdFx0XHRcdGNhc2UgXCJ0ZXh0YXJlYVwiOlxyXG5cdFx0XHRcdFx0c3RyaW5nID0gcHJvZ3JhbS52YWx1ZTtcclxuXHRcdFx0XHRcdHN1Y2Nlc3MgPSB0cnVlO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdHN0cmluZyA9IHByb2dyYW0uaW5uZXJIVE1MO1xyXG5cdFx0XHRcdFx0c3VjY2VzcyA9IHRydWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3B0cy5lcnJvcihwbC5lcnJvci5leGlzdGVuY2UoXCJzb3VyY2Vfc2lua1wiLCBuZXcgVGVybShzdHJpbmcpLCBcInRvcF9sZXZlbC8wXCIpKTtcclxuXHRcdH1cclxuXHRcdHRoaXMud2FybmluZ3MgPSBbXTtcclxuXHRcdHBhcnNlUHJvZ3JhbSh0aGlzLCBzdHJpbmcsIG9wdHMpO1xyXG5cdH07XHJcblxyXG5cdC8vIFF1ZXJ5IGdvYWwgZnJvbSBhIHN0cmluZyAod2l0aG91dCA/LSlcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHN0cmluZywgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnF1ZXJ5KHN0cmluZywgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0dGhpcy5kZWJ1Z2dlcl9zdGF0ZXMgPSBbXTtcclxuXHRcdHRoaXMubGV2ZWwgPSBuZXcgVGVybShcInRvcF9sZXZlbFwiKTtcclxuXHRcdHJldHVybiBwYXJzZVF1ZXJ5KHRoaXMsIHN0cmluZywgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgZmlyc3QgY2hvaWNlIHBvaW50XHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuaGVhZF9wb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmhlYWRfcG9pbnQoKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuaGVhZF9wb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aC0xXTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBmcmVlIHZhcmlhYmxlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2ZyZWVfdmFyaWFibGUgPSBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuZ2V0X2ZyZWVfdmFyaWFibGUoIHZhcmlhYmxlICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9mcmVlX3ZhcmlhYmxlID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG5cdFx0dmFyIHZhcmlhYmxlcyA9IFtdO1xyXG5cdFx0aWYoIHZhcmlhYmxlLmlkID09PSBcIl9cIiB8fCB0aGlzLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXNbdmFyaWFibGUuaWRdID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWUrKztcclxuXHRcdFx0aWYoIHRoaXMuY3VycmVudF9wb2ludCApXHJcblx0XHRcdFx0dmFyaWFibGVzID0gdGhpcy5jdXJyZW50X3BvaW50LnN1YnN0aXR1dGlvbi5kb21haW4oKTtcclxuXHRcdFx0d2hpbGUoIGluZGV4T2YoIHZhcmlhYmxlcywgcGwuZm9ybWF0X3ZhcmlhYmxlKCB0aGlzLnNlc3Npb24ucmVuYW1lLCB2YXJpYWJsZS5pZCApICkgIT09IC0xICkge1xyXG5cdFx0XHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWUrKztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiggdmFyaWFibGUuaWQgPT09IFwiX1wiICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVmFyKCBwbC5mb3JtYXRfdmFyaWFibGUoIHRoaXMuc2Vzc2lvbi5yZW5hbWUsIHZhcmlhYmxlLmlkICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXNbdmFyaWFibGUuaWRdID0gcGwuZm9ybWF0X3ZhcmlhYmxlKCB0aGlzLnNlc3Npb24ucmVuYW1lLCB2YXJpYWJsZS5pZCApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFZhciggdGhpcy5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzW3ZhcmlhYmxlLmlkXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IG5leHQgZnJlZSB2YXJpYWJsZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLm5leHRfZnJlZV92YXJpYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5uZXh0X2ZyZWVfdmFyaWFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWUrKztcclxuXHRcdHZhciB2YXJpYWJsZXMgPSBbXTtcclxuXHRcdGlmKCB0aGlzLmN1cnJlbnRfcG9pbnQgKVxyXG5cdFx0XHR2YXJpYWJsZXMgPSB0aGlzLmN1cnJlbnRfcG9pbnQuc3Vic3RpdHV0aW9uLmRvbWFpbigpO1xyXG5cdFx0d2hpbGUoIGluZGV4T2YoIHZhcmlhYmxlcywgcGwuZm9ybWF0X3ZhcmlhYmxlKCB0aGlzLnNlc3Npb24ucmVuYW1lICkgKSAhPT0gLTEgKSB7XHJcblx0XHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWUrKztcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVmFyKCBwbC5mb3JtYXRfdmFyaWFibGUoIHRoaXMuc2Vzc2lvbi5yZW5hbWUgKSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgcHVibGljXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuaXNfcHVibGljX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRtb2R1bGVfaWQgPSBtb2R1bGVfaWQgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogbW9kdWxlX2lkO1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfbW9kdWxlKHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdKSAmJiB0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXS5pc19wdWJsaWNfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmlzX3B1YmxpY19wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5pc19wdWJsaWNfcHJlZGljYXRlKGluZGljYXRvciwgbW9kdWxlX2lkKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIG11bHRpZmlsZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmlzX211bHRpZmlsZV9wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0bW9kdWxlX2lkID0gbW9kdWxlX2lkID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG1vZHVsZV9pZDtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX21vZHVsZSh0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXSkgJiYgdGhpcy5tb2R1bGVzW21vZHVsZV9pZF0uaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5pc19tdWx0aWZpbGVfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZShpbmRpY2F0b3IsIG1vZHVsZV9pZCk7XHJcblx0fTtcclxuXHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgYSBtZXRhLXByZWRpY2F0ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmlzX21ldGFfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdG1vZHVsZV9pZCA9IG1vZHVsZV9pZCA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBtb2R1bGVfaWQ7XHJcblx0XHRpZihwbC50eXBlLmlzX21vZHVsZSh0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXSkpXHJcblx0XHRcdHJldHVybiB0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXS5pc19tZXRhX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmlzX21ldGFfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uaXNfbWV0YV9wcmVkaWNhdGUoaW5kaWNhdG9yLCBtb2R1bGVfaWQpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gSW5zZXJ0IHN0YXRlcyBhdCB0aGUgYmVnaW5uaW5nXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKCBzdGF0ZXMgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiggc3RhdGVzICkge1xyXG5cdFx0Zm9yKHZhciBpID0gc3RhdGVzLmxlbmd0aC0xOyBpID49IDA7IGktLSlcclxuXHRcdFx0dGhpcy5wb2ludHMucHVzaCggc3RhdGVzW2ldICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSZW1vdmUgdGhlIHNlbGVjdGVkIHRlcm0gYW5kIHByZXBlbmQgdGhlIGN1cnJlbnQgc3RhdGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5zdWNjZXNzID0gZnVuY3Rpb24oIHBvaW50LCBwYXJlbnQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuc3VjY2VzcyggcG9pbnQsIHBhcmVudCApO1xyXG5cdH1cclxuXHRUaHJlYWQucHJvdG90eXBlLnN1Y2Nlc3MgPSBmdW5jdGlvbiggcG9pbnQsIHBhcmVudCApIHtcclxuXHRcdHZhciBwYXJlbnQgPSB0eXBlb2YgcGFyZW50ID09PSBcInVuZGVmaW5lZFwiID8gcG9pbnQgOiBwYXJlbnQ7XHJcblx0XHR0aGlzLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbnVsbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBhcmVudCApIF0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRocm93IGVycm9yXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUudGhyb3dfZXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnRocm93X2Vycm9yKGVycm9yKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUudGhyb3dfZXJyb3IgPSBmdW5jdGlvbihlcnJvcikge1xyXG5cdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShlcnJvcikpXHJcblx0XHRcdGVycm9yID0gcGwuZXJyb3IuaW5zdGFudGlhdGlvbih0aGlzLmxldmVsLmluZGljYXRvcik7XHJcblx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdG5ldyBUZXJtKFwidGhyb3dcIiwgW2Vycm9yXSksXHJcblx0XHRcdG5ldyBTdWJzdGl0dXRpb24oKSxcclxuXHRcdFx0bnVsbFxyXG5cdFx0KTtcclxuXHRcdHN0YXRlLmVycm9yID0gdHJ1ZTtcclxuXHRcdHRoaXMucHJlcGVuZChbc3RhdGVdKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCB0aGUgbW9kdWxlIG9mIGEgcHJlZGljYXRlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUubG9va3VwX21vZHVsZSA9IGZ1bmN0aW9uKGF0b20sIGNvbnRleHRfbW9kdWxlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQubG9va3VwX21vZHVsZShhdG9tLCBjb250ZXh0X21vZHVsZSk7XHJcblx0fVxyXG5cdFRocmVhZC5wcm90b3R5cGUubG9va3VwX21vZHVsZSA9IGZ1bmN0aW9uKGF0b20sIGNvbnRleHRfbW9kdWxlKSB7XHJcblx0XHR2YXIgZ2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXTtcclxuXHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSlcclxuXHRcdFx0Z2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzLnVzZXI7XHJcblx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KGF0b20uaW5kaWNhdG9yKSAmJiAoXHJcblx0XHRcdGdldF9tb2R1bGUuZXhwb3J0c19wcmVkaWNhdGUoYXRvbS5pbmRpY2F0b3IpIHx8XHJcblx0XHRcdGdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkodGhpcy5sZXZlbC5pbmRpY2F0b3IpIHx8XHJcblx0XHRcdGNvbnRleHRfbW9kdWxlID09PSBnZXRfbW9kdWxlLmlkKSlcclxuXHRcdFx0XHRyZXR1cm4gZ2V0X21vZHVsZTtcclxuXHRcdGdldF9tb2R1bGUubW9kdWxlcy5zeXN0ZW0gPSBwbC5tb2R1bGVzLnN5c3RlbTtcclxuXHRcdGdldF9tb2R1bGUubW9kdWxlcy51c2VyID0gdGhpcy5zZXNzaW9uLm1vZHVsZXMudXNlcjtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiBnZXRfbW9kdWxlLm1vZHVsZXMpIHtcclxuXHRcdFx0aWYoIXRoaXMuc2Vzc2lvbi5tb2R1bGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzW3Byb3BdO1xyXG5cdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KGF0b20uaW5kaWNhdG9yKSAmJiAoXHJcblx0XHRcdFx0Z2V0X21vZHVsZS5leHBvcnRzX3ByZWRpY2F0ZShhdG9tLmluZGljYXRvcikgfHxcclxuXHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHRoaXMubGV2ZWwuaW5kaWNhdG9yKSB8fFxyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID09PSBnZXRfbW9kdWxlLmlkKSlcclxuXHRcdFx0XHRcdHJldHVybiBnZXRfbW9kdWxlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0Ly8gRXhwYW5kIGEgbWV0YS1wcmVkaWNhdGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5leHBhbmRfbWV0YV9wcmVkaWNhdGUgPSBmdW5jdGlvbihhdG9tLCBkZWZpbml0aW9uX21vZHVsZSwgY29udGV4dF9tb2R1bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5leHBhbmRfbWV0YV9wcmVkaWNhdGUoYXRvbSwgZGVmaW5pdGlvbl9tb2R1bGUsIGNvbnRleHRfbW9kdWxlKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZXhwYW5kX21ldGFfcHJlZGljYXRlID0gZnVuY3Rpb24oYXRvbSwgZGVmaW5pdGlvbl9tb2R1bGUsIGNvbnRleHRfbW9kdWxlKSB7XHJcblx0XHR2YXIgZ2V0X21vZHVsZSA9IHRoaXMuc2Vzc2lvbi5tb2R1bGVzW2RlZmluaXRpb25fbW9kdWxlXTtcclxuXHRcdGlmKCFnZXRfbW9kdWxlKVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR2YXIgbWV0YSA9IGdldF9tb2R1bGUuaXNfbWV0YV9wcmVkaWNhdGUoYXRvbS5pbmRpY2F0b3IpO1xyXG5cdFx0aWYoIW1ldGEpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtZXRhLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYocGwudHlwZS5pc19pbnRlZ2VyKG1ldGEuYXJnc1tpXSkgfHwgcGwudHlwZS5pc19hdG9tKG1ldGEuYXJnc1tpXSkgJiYgaW5kZXhPZihbXCI6XCJdLCBtZXRhLmFyZ3NbaV0uaWQpICE9PSAtMSkge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX3Rlcm0oYXRvbS5hcmdzW2ldKSB8fCBhdG9tLmFyZ3NbaV0uaW5kaWNhdG9yICE9PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0XHRhdG9tLmFyZ3NbaV0gPSBuZXcgVGVybShcIjpcIiwgW25ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSwgYXRvbS5hcmdzW2ldXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19hdG9tKG1ldGEuYXJnc1tpXSkgJiYgbWV0YS5hcmdzW2ldLmlkID09PSBcIl5cIikge1xyXG5cdFx0XHRcdHZhciBwb2ludGVyX2xhc3QgPSBhdG9tO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyX2luZGV4ID0gaTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGF0b20uYXJnc1tpXTtcclxuXHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiXi8yXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ZXJfbGFzdCA9IHBvaW50ZXI7XHJcblx0XHRcdFx0XHRwb2ludGVyX2luZGV4ID0gMTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgfHwgcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ZXJfbGFzdC5hcmdzW3BvaW50ZXJfaW5kZXhdID0gbmV3IFRlcm0oXCI6XCIsIFtuZXcgVGVybShjb250ZXh0X21vZHVsZSksIHBvaW50ZXJdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJlc29sdXRpb24gc3RlcFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5zdGVwKCk7XHJcblx0fVxyXG5cdFRocmVhZC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5wb2ludHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHZhciBhc3luID0gZmFsc2U7XHJcblx0XHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50cy5wb3AoKTtcclxuXHRcdHRoaXMuY3VycmVudF9wb2ludCA9IHBvaW50O1xyXG5cdFx0aWYodGhpcy5kZWJ1Z2dlcilcclxuXHRcdFx0dGhpcy5kZWJ1Z2dlcl9zdGF0ZXMucHVzaChwb2ludCk7XHJcblx0XHR2YXIgYXRvbSA9IHBsLnR5cGUuaXNfdGVybShwb2ludC5nb2FsKSA/IHBvaW50LmdvYWwuc2VsZWN0KCkgOiBwb2ludC5nb2FsO1xyXG5cdFx0aWYocGwudHlwZS5pc190ZXJtKGF0b20pICYmIChhdG9tLmluZGljYXRvciAhPT0gXCI6LzJcIiB8fCBwbC50eXBlLmlzX3Rlcm0oYXRvbS5hcmdzWzFdKSkpIHtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gbnVsbDtcclxuXHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRpZihhdG9tICE9PSBudWxsKSB7XHJcblx0XHRcdFx0dGhpcy50b3RhbF9zdGVwcysrO1xyXG5cdFx0XHRcdHZhciBsZXZlbCA9IHBvaW50O1xyXG5cdFx0XHRcdHdoaWxlKGxldmVsLnBhcmVudCAhPT0gbnVsbCAmJiBsZXZlbC5wYXJlbnQuZ29hbC5zZWFyY2goYXRvbSkpXHJcblx0XHRcdFx0XHRsZXZlbCA9IGxldmVsLnBhcmVudDtcclxuXHRcdFx0XHRpZihsZXZlbC5wYXJlbnQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRoaXMubGV2ZWwgPSBuZXcgVGVybShcInRvcF9sZXZlbFwiKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5sZXZlbCA9IGxldmVsLnBhcmVudC5nb2FsLnNlbGVjdCgpO1xyXG5cdFx0XHRcdFx0aWYodGhpcy5sZXZlbC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpXHJcblx0XHRcdFx0XHRcdHRoaXMubGV2ZWwgPSB0aGlzLmxldmVsLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShhdG9tKSAmJiBhdG9tLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRhdG9tID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShjb250ZXh0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIGNvbnRleHRfbW9kdWxlLCB0aGlzLmxldmVsLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGNvbnRleHRfbW9kdWxlLmlkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZih0aGlzLmxldmVsLmRlZmluaXRpb25fbW9kdWxlKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gdGhpcy5sZXZlbC5kZWZpbml0aW9uX21vZHVsZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gXCJ1c2VyXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGF0b20uY29udGV4dF9tb2R1bGUgPSBjb250ZXh0X21vZHVsZTtcclxuXHRcdFx0XHRpZihhdG9tLmluZGljYXRvciA9PT0gXCIsLzJcIikge1xyXG5cdFx0XHRcdFx0dGhpcy5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiOlwiLCBbbmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLCBhdG9tLmFyZ3NbMF1dKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIjpcIiwgW25ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSwgYXRvbS5hcmdzWzFdXSldKSksXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCldKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5fX2NhbGxfaW5kaWNhdG9yID0gYXRvbS5pbmRpY2F0b3I7XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aGlzLmxvb2t1cF9tb2R1bGUoYXRvbSwgY29udGV4dF9tb2R1bGUpO1xyXG5cdFx0XHRcdGF0b20uZGVmaW5pdGlvbl9tb2R1bGUgPSBwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSA/IGdldF9tb2R1bGUuaWQgOiBcInVzZXJcIjtcclxuXHRcdFx0XHR0aGlzLmV4cGFuZF9tZXRhX3ByZWRpY2F0ZShhdG9tLCBhdG9tLmRlZmluaXRpb25fbW9kdWxlLCBjb250ZXh0X21vZHVsZSk7XHJcblx0XHRcdFx0dmFyIGNsYXVzZXMgPSBudWxsO1xyXG5cdFx0XHRcdGlmKGdldF9tb2R1bGUgJiYgYXRvbS5hcmdzLmxlbmd0aCA+IDAgJiYgYXRvbS5hcmdzWzBdLmluZGV4ICYmIGdldF9tb2R1bGUuaW5kZXhlZF9jbGF1c2VzLmhhc093blByb3BlcnR5KGF0b20uaW5kaWNhdG9yKSAmJiBnZXRfbW9kdWxlLmluZGV4ZWRfY2xhdXNlc1thdG9tLmluZGljYXRvcl0uaGFzT3duUHJvcGVydHkoYXRvbS5hcmdzWzBdLmluZGV4KSlcclxuXHRcdFx0XHRcdGNsYXVzZXMgPSBnZXRfbW9kdWxlLmluZGV4ZWRfY2xhdXNlc1thdG9tLmluZGljYXRvcl1bYXRvbS5hcmdzWzBdLmluZGV4XTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRjbGF1c2VzID0gZ2V0X21vZHVsZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRfbW9kdWxlLnJ1bGVzW2F0b20uaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRpZihjbGF1c2VzID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRpZighdGhpcy5zZXNzaW9uLm1vZHVsZXMudXNlci5ydWxlcy5oYXNPd25Qcm9wZXJ0eShhdG9tLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5nZXRfZmxhZyhcInVua25vd25cIikuaWQgPT09IFwiZXJyb3JcIikge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJwcm9jZWR1cmVcIiwgYXRvbS5pbmRpY2F0b3IsIHRoaXMubGV2ZWwuaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZih0aGlzLmdldF9mbGFnKFwidW5rbm93blwiKS5pZCA9PT0gXCJ3YXJuaW5nXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnRocm93X3dhcm5pbmcoXCJ1bmtub3duIHByb2NlZHVyZSBcIiArIGF0b20uaW5kaWNhdG9yICsgXCIgKGZyb20gXCIgKyB0aGlzLmxldmVsLmluZGljYXRvciArIFwiKVwiKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZihjbGF1c2VzIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuXHRcdFx0XHRcdGFzeW4gPSBjbGF1c2VzKHRoaXMsIHBvaW50LCBhdG9tKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gR29hbCBleHBhbnNpb25cclxuXHRcdFx0XHRcdGlmKHRoaXMuX19nb2FsX2V4cGFuc2lvbiAmJiBhdG9tLmluZGljYXRvciA9PT0gXCJnb2FsX2V4cGFuc2lvbi8yXCIpXHJcblx0XHRcdFx0XHRcdGNsYXVzZXMgPSBjbGF1c2VzLmNvbmNhdChwbC5idWlsdGluLnJ1bGVzW1wiZ29hbF9leHBhbnNpb24vMlwiXSk7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY2xhdXNlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHRcdFx0dmFyIGNsYXVzZSA9IGNsYXVzZXNbaV0ucmVuYW1lKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHR2YXIgb2NjdXJzX2NoZWNrID0gdGhpcy5nZXRfZmxhZyhcIm9jY3Vyc19jaGVja1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCI7XHJcblx0XHRcdFx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeShhdG9tLCBjbGF1c2UuaGVhZCwgb2NjdXJzX2NoZWNrKTtcclxuXHRcdFx0XHRcdFx0aWYobWd1ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuZ29hbCA9IHBvaW50LmdvYWwucmVwbGFjZShjbGF1c2UuYm9keSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoc3RhdGUuZ29hbCAhPT0gbnVsbClcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXRlLmdvYWwgPSBzdGF0ZS5nb2FsLmFwcGx5KG1ndSk7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uID0gcG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KG1ndSk7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUucGFyZW50ID0gcG9pbnQ7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goc3RhdGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciB0ZXJtID0gcGwudHlwZS5pc190ZXJtKGF0b20pICYmIGF0b20uaW5kaWNhdG9yID09PSBcIjovMlwiID8gYXRvbS5hcmdzWzFdIDogYXRvbTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0ZXJtKSlcclxuXHRcdFx0XHR0aGlzLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24odGhpcy5sZXZlbC5pbmRpY2F0b3IpKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHRoaXMudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIHRlcm0sIHRoaXMubGV2ZWwuaW5kaWNhdG9yKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXN5bjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEZpbmQgbmV4dCBjb21wdXRlZCBhbnN3ZXJcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hbnN3ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuYW5zd2VyKG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hbnN3ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHR2YXIgb3B0cyA9IHt9O1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHRcdGlmKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0b3B0cyA9IHtcclxuXHRcdFx0XHRzdWNjZXNzOiBvcHRpb25zLFxyXG5cdFx0XHRcdGVycm9yOiBvcHRpb25zLFxyXG5cdFx0XHRcdGZhaWw6IG9wdGlvbnMsXHJcblx0XHRcdFx0bGltaXQ6IG9wdGlvbnNcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9wdHMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24oKSB7fSA6IG9wdGlvbnMuc3VjY2VzcztcclxuXHRcdFx0b3B0cy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uKCkge30gOiBvcHRpb25zLmVycm9yO1xyXG5cdFx0XHRvcHRzLmZhaWwgPSBvcHRpb25zLmZhaWwgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uKCkge30gOiBvcHRpb25zLmZhaWw7XHJcblx0XHRcdG9wdHMubGltaXQgPSBvcHRpb25zLmxpbWl0ID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbigpIHt9IDogb3B0aW9ucy5saW1pdDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX19jYWxscy5wdXNoKG9wdHMpO1xyXG5cdFx0aWYoIHRoaXMuX19jYWxscy5sZW5ndGggPiAxICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLmFnYWluKCk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBGaW5kIGFsbCBjb21wdXRlZCBhbnN3ZXJzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYW5zd2VycyA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgbWF4LCBhZnRlciApIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5hbnN3ZXJzKCBjYWxsYmFjaywgbWF4LCBhZnRlciApO1xyXG5cdH1cclxuXHRUaHJlYWQucHJvdG90eXBlLmFuc3dlcnMgPSBmdW5jdGlvbiggY2FsbGJhY2ssIG1heCwgYWZ0ZXIgKSB7XHJcblx0XHR2YXIgYW5zd2VycyA9IG1heCA9PT0gdW5kZWZpbmVkID8gMTAwMCA6IG1heDtcclxuXHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0aWYoIGFuc3dlcnMgPD0gMCApIHtcclxuXHRcdFx0aWYoYWZ0ZXIpXHJcblx0XHRcdFx0YWZ0ZXIoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5hbnN3ZXIoIGZ1bmN0aW9uKCBhbnN3ZXIgKSB7XHJcblx0XHRcdGNhbGxiYWNrKCBhbnN3ZXIgKTtcclxuXHRcdFx0aWYoIGFuc3dlciAhPT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQuYW5zd2VycyggY2FsbGJhY2ssIGFuc3dlcnMtMSwgYWZ0ZXIgKTtcclxuXHRcdFx0XHR9LCAwICk7XHJcblx0XHRcdH0gZWxzZSBpZihhZnRlcikge1xyXG5cdFx0XHRcdGFmdGVyKCk7XHJcblx0XHRcdH1cclxuXHRcdH0gKTtcclxuXHR9O1xyXG5cclxuXHQvLyBBZ2FpbiBmaW5kaW5nIG5leHQgY29tcHV0ZWQgYW5zd2VyXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYWdhaW4gPSBmdW5jdGlvbihyZXNldF9saW1pdCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmFnYWluKHJlc2V0X2xpbWl0KTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuYWdhaW4gPSBmdW5jdGlvbihyZXNldF9saW1pdCkge1xyXG5cdFx0d2hpbGUodGhpcy5fX2NhbGxzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0dGhpcy53YXJuaW5ncyA9IFtdO1xyXG5cdFx0XHRpZihyZXNldF9saW1pdCAhPT0gZmFsc2UpXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50X2xpbWl0ID0gdGhpcy5zZXNzaW9uLmxpbWl0O1xyXG5cdFx0XHR3aGlsZSgoIXRoaXMuaGFzX2xpbWl0IHx8IHRoaXMuY3VycmVudF9saW1pdCA+IDApICYmIHRoaXMucG9pbnRzLmxlbmd0aCA+IDAgJiYgdGhpcy5oZWFkX3BvaW50KCkuZ29hbCAhPT0gbnVsbCAmJiAhcGwudHlwZS5pc19lcnJvcl9zdGF0ZSh0aGlzLmhlYWRfcG9pbnQoKSkpIHtcclxuXHRcdFx0XHRpZih0aGlzLmhhc19saW1pdClcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudF9saW1pdC0tO1xyXG5cdFx0XHRcdHZhciB0MCA9IERhdGUubm93KCk7XHJcblx0XHRcdFx0dmFyIGFzeW4gPSB0aGlzLnN0ZXAoKTtcclxuXHRcdFx0XHR2YXIgdDEgPSBEYXRlLm5vdygpO1xyXG5cdFx0XHRcdHRoaXMuY3B1X3RpbWUgKz0gdDEtdDA7XHJcblx0XHRcdFx0aWYoYXN5biA9PT0gdHJ1ZSlcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgY2FsbCA9IHRoaXMuX19jYWxscy5zaGlmdCgpO1xyXG5cdFx0XHQvLyBsaW1pdCBvZiBpbmZlcmVuY2VzXHJcblx0XHRcdGlmKHRoaXMuaGFzX2xpbWl0ICYmIHRoaXMuY3VycmVudF9saW1pdCA8PSAwKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGNhbGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsLmxpbWl0KG51bGwpO1xyXG5cdFx0XHRcdFx0fSwgMCk7XHJcblx0XHRcdFx0fSkoY2FsbCk7XHJcblx0XHRcdC8vIG5vIGFuc3dlclxyXG5cdFx0XHR9IGVsc2UgaWYodGhpcy5wb2ludHMubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGNhbGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsLmZhaWwoZmFsc2UpO1xyXG5cdFx0XHRcdFx0fSwgMCk7XHJcblx0XHRcdFx0fSkoY2FsbCk7XHJcblx0XHRcdC8vIGVycm9yXHJcblx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX2Vycm9yKHRoaXMuaGVhZF9wb2ludCgpLmdvYWwpKSB7XHJcblx0XHRcdFx0dmFyIGVycm9yID0gdGhpcy5mb3JtYXRfZXJyb3IodGhpcy5wb2ludHMucG9wKCkpO1xyXG5cdFx0XHRcdHRoaXMucG9pbnRzID0gW107XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGVycm9yLCBjYWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbC5lcnJvcihlcnJvcik7XHJcblx0XHRcdFx0XHR9LCAwKTtcclxuXHRcdFx0XHR9KShlcnJvciwgY2FsbCk7XHJcblx0XHRcdC8vIGNvbXB1dGVkIGFuc3dlclxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHRoaXMuZGVidWdnZXIpXHJcblx0XHRcdFx0XHR0aGlzLmRlYnVnZ2VyX3N0YXRlcy5wdXNoKHRoaXMuaGVhZF9wb2ludCgpKTtcclxuXHRcdFx0XHR2YXIgYW5zd2VyID0gdGhpcy5mb3JtYXRfc3VjY2Vzcyh0aGlzLnBvaW50cy5wb3AoKSk7XHJcblx0XHRcdFx0KGZ1bmN0aW9uKGFuc3dlciwgY2FsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGNhbGwuc3VjY2VzcyhhbnN3ZXIpO1xyXG5cdFx0XHRcdFx0fSwgMCk7XHJcblx0XHRcdFx0fSkoYW5zd2VyLCBjYWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gVW5mb2xkaW5nIHRyYW5zZm9ybWF0aW9uXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUudW5mb2xkID0gZnVuY3Rpb24oIHJ1bGUgKSB7XHJcblx0XHRpZihydWxlLmJvZHkgPT09IG51bGwpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdHZhciBoZWFkID0gcnVsZS5oZWFkO1xyXG5cdFx0dmFyIGJvZHkgPSBydWxlLmJvZHk7XHJcblx0XHR2YXIgYXRvbSA9IGJvZHkuc2VsZWN0KCk7XHJcblx0XHR2YXIgdGhyZWFkID0gbmV3IFRocmVhZCggdGhpcyApO1xyXG5cdFx0dmFyIHVuZm9sZGVkID0gW107XHJcblx0XHR0aHJlYWQuYWRkX2dvYWwoIGF0b20gKTtcclxuXHRcdHRocmVhZC5zdGVwKCk7XHJcblx0XHRmb3IoIHZhciBpID0gdGhyZWFkLnBvaW50cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdHZhciBwb2ludCA9IHRocmVhZC5wb2ludHNbaV07XHJcblx0XHRcdHZhciBoZWFkMiA9IGhlYWQuYXBwbHkoIHBvaW50LnN1YnN0aXR1dGlvbiApO1xyXG5cdFx0XHR2YXIgYm9keTIgPSBib2R5LnJlcGxhY2UoIHBvaW50LmdvYWwgKTtcclxuXHRcdFx0aWYoIGJvZHkyICE9PSBudWxsIClcclxuXHRcdFx0XHRib2R5MiA9IGJvZHkyLmFwcGx5KCBwb2ludC5zdWJzdGl0dXRpb24gKTtcclxuXHRcdFx0dW5mb2xkZWQucHVzaCggbmV3IFJ1bGUoIGhlYWQyLCBib2R5MiApICk7XHJcblx0XHR9XHJcblx0XHR2YXIgcnVsZXMgPSB0aGlzLm1vZHVsZXMudXNlci5ydWxlc1toZWFkLmluZGljYXRvcl07XHJcblx0XHR2YXIgaW5kZXggPSBpbmRleE9mKCBydWxlcywgcnVsZSApO1xyXG5cdFx0aWYoIHVuZm9sZGVkLmxlbmd0aCA+IDAgJiYgaW5kZXggIT09IC0xICkge1xyXG5cdFx0XHRydWxlcy5zcGxpY2UuYXBwbHkoIHJ1bGVzLCBbaW5kZXgsIDFdLmNvbmNhdCh1bmZvbGRlZCkgKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnVuZm9sZCA9IGZ1bmN0aW9uKHJ1bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24udW5mb2xkKHJ1bGUpO1xyXG5cdH07XHJcblxyXG5cdFxyXG5cdFxyXG5cdC8vIElOVEVSUFJFVCBFWFBSRVNTSU9OU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuaW50ZXJwcmV0ID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdHJldHVybiBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCB0aHJlYWQubGV2ZWwuaW5kaWNhdG9yICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5pbnRlcnByZXQgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmludGVycHJldCA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRpZiggcGwudHlwZS5pc191bml0YXJ5X2xpc3QoIHRoaXMgKSApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXJnc1swXS5pbnRlcnByZXQoIHRocmVhZCApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHBsLm9wZXJhdGUoIHRocmVhZCwgdGhpcyApO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQ09NUEFSRSBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRpZiggdGhpcy5pZCA8IG9iai5pZCApIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fSBlbHNlIGlmKCB0aGlzLmlkID4gb2JqLmlkICkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRpZiggdGhpcy52YWx1ZSA9PT0gb2JqLnZhbHVlICYmIHRoaXMuaXNfZmxvYXQgPT09IG9iai5pc19mbG9hdCApIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9IGVsc2UgaWYoIHRoaXMudmFsdWUgPCBvYmoudmFsdWUgfHwgdGhpcy52YWx1ZSA9PT0gb2JqLnZhbHVlICYmIHRoaXMuaXNfZmxvYXQgJiYgIW9iai5pc19mbG9hdCApIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fSBlbHNlIGlmKCB0aGlzLnZhbHVlID4gb2JqLnZhbHVlICkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRpZiggdGhpcy5hcmdzLmxlbmd0aCA8IG9iai5hcmdzLmxlbmd0aCB8fCB0aGlzLmFyZ3MubGVuZ3RoID09PSBvYmouYXJncy5sZW5ndGggJiYgdGhpcy5pZCA8IG9iai5pZCApIHtcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fSBlbHNlIGlmKCB0aGlzLmFyZ3MubGVuZ3RoID4gb2JqLmFyZ3MubGVuZ3RoIHx8IHRoaXMuYXJncy5sZW5ndGggPT09IG9iai5hcmdzLmxlbmd0aCAmJiB0aGlzLmlkID4gb2JqLmlkICkge1xyXG5cdFx0XHRyZXR1cm4gMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdHZhciBhcmcgPSBwbC5jb21wYXJlKCB0aGlzLmFyZ3NbaV0sIG9iai5hcmdzW2ldICk7XHJcblx0XHRcdFx0aWYoIGFyZyAhPT0gMCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBhcmc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAwO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblxyXG5cdFxyXG5cdC8vIFNVQlNUSVRVVElPTlNcclxuXHRcclxuXHQvLyBMb29rdXAgdmFyaWFibGVcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuXHRcdGlmKCB0aGlzLmxpbmtzW3ZhcmlhYmxlXSApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMubGlua3NbdmFyaWFibGVdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBGaWx0ZXIgdmFyaWFibGVzXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiggcHJlZGljYXRlICkge1xyXG5cdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHRmb3IoIHZhciBpZCBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eShpZCkpIGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmxpbmtzW2lkXTtcclxuXHRcdFx0aWYoIHByZWRpY2F0ZSggaWQsIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0bGlua3NbaWRdID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCBsaW5rcywgdGhpcy5hdHRycyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gRXhjbHVkZSB2YXJpYWJsZXNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmV4Y2x1ZGUgPSBmdW5jdGlvbiggdmFyaWFibGVzICkge1xyXG5cdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHRmb3IoIHZhciB2YXJpYWJsZSBpbiB0aGlzLmxpbmtzICkge1xyXG5cdFx0XHRpZighdGhpcy5saW5rcy5oYXNPd25Qcm9wZXJ0eSh2YXJpYWJsZSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRpZiggaW5kZXhPZiggdmFyaWFibGVzLCB2YXJpYWJsZSApID09PSAtMSApIHtcclxuXHRcdFx0XHRsaW5rc1t2YXJpYWJsZV0gPSB0aGlzLmxpbmtzW3ZhcmlhYmxlXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oIGxpbmtzLCB0aGlzLmF0dHJzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBBZGQgbGlua1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oIHZhcmlhYmxlLCB2YWx1ZSApIHtcclxuXHRcdHRoaXMubGlua3NbdmFyaWFibGVdID0gdmFsdWU7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgZG9tYWluXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5kb21haW4gPSBmdW5jdGlvbiggcGxhaW4gKSB7XHJcblx0XHR2YXIgZiA9IHBsYWluID09PSB0cnVlID8gZnVuY3Rpb24oeCl7cmV0dXJuIHg7fSA6IGZ1bmN0aW9uKHgpe3JldHVybiBuZXcgVmFyKHgpO307XHJcblx0XHR2YXIgdmFycyA9IFtdO1xyXG5cdFx0Zm9yKCB2YXIgeCBpbiB0aGlzLmxpbmtzIClcclxuXHRcdFx0dmFycy5wdXNoKCBmKHgpICk7XHJcblx0XHRyZXR1cm4gdmFycztcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgYW4gYXR0cmlidXRlXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRfYXR0cmlidXRlID0gZnVuY3Rpb24oIHZhcmlhYmxlLCBtb2R1bGUgKSB7XHJcblx0XHRpZiggdGhpcy5hdHRyc1t2YXJpYWJsZV0gKVxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyc1t2YXJpYWJsZV1bbW9kdWxlXTtcclxuXHR9XHJcblxyXG5cdC8vIFNldCBhbiBhdHRyaWJ1dGUgKGluIGEgbmV3IHN1YnN0aXR1dGlvbilcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLnNldF9hdHRyaWJ1dGUgPSBmdW5jdGlvbiggdmFyaWFibGUsIG1vZHVsZSwgdmFsdWUgKSB7XHJcblx0XHR2YXIgc3VicyA9IG5ldyBTdWJzdGl0dXRpb24oIHRoaXMubGlua3MgKTtcclxuXHRcdGZvciggdmFyIHYgaW4gdGhpcy5hdHRycyApIHtcclxuXHRcdFx0aWYoIHYgPT09IHZhcmlhYmxlICkge1xyXG5cdFx0XHRcdHN1YnMuYXR0cnNbdl0gPSB7fTtcclxuXHRcdFx0XHRmb3IoIHZhciBtIGluIHRoaXMuYXR0cnNbdl0gKSB7XHJcblx0XHRcdFx0XHRzdWJzLmF0dHJzW3ZdW21dID0gdGhpcy5hdHRyc1t2XVttXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3Vicy5hdHRyc1t2XSA9IHRoaXMuYXR0cnNbdl07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKCAhc3Vicy5hdHRyc1t2YXJpYWJsZV0gKSB7XHJcblx0XHRcdHN1YnMuYXR0cnNbdmFyaWFibGVdID0ge307XHJcblx0XHR9XHJcblx0XHRzdWJzLmF0dHJzW3ZhcmlhYmxlXVttb2R1bGVdID0gdmFsdWU7XHJcblx0XHRyZXR1cm4gc3VicztcclxuXHR9XHJcblxyXG5cdC8vIENoZWNrIGlmIGEgdmFyaWFibGVzIGhhcyBhdHRyaWJ1dGVzXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5oYXNfYXR0cmlidXRlcyA9IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuXHRcdHJldHVybiB0aGlzLmF0dHJzW3ZhcmlhYmxlXSAmJiB0aGlzLmF0dHJzW3ZhcmlhYmxlXSAhPT0ge307XHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIEdFTkVSQVRFIEpBVkFTQ1JJUFQgQ09ERSBGUk9NIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ25ldyBwbC50eXBlLlZhcihcIicgKyB0aGlzLmlkLnRvU3RyaW5nKCkgKyAnXCIpJztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnbmV3IHBsLnR5cGUuTnVtKCcgKyB0aGlzLnZhbHVlLnRvU3RyaW5nKCkgKyAnLCAnICsgdGhpcy5pc19mbG9hdC50b1N0cmluZygpICsgJyknO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ25ldyBwbC50eXBlLlRlcm0oXCInICsgdGhpcy5pZC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykgKyAnXCIsIFsnICsgbWFwKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBhcmcgKSB7XHJcblx0XHRcdHJldHVybiBhcmcuY29tcGlsZSgpO1xyXG5cdFx0fSApICsgJ10pJztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICduZXcgcGwudHlwZS5SdWxlKCcgKyB0aGlzLmhlYWQuY29tcGlsZSgpICsgJywgJyArICh0aGlzLmJvZHkgPT09IG51bGwgPyAnbnVsbCcgOiB0aGlzLmJvZHkuY29tcGlsZSgpKSArICcpJztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFNlc3Npb25zXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHN0ciwgb2JqID0gW10sIHJ1bGVzO1xyXG5cdFx0Zm9yKCB2YXIgX2luZGljYXRvciBpbiB0aGlzLm1vZHVsZXMudXNlci5ydWxlcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubW9kdWxlcy51c2VyLnJ1bGVzLmhhc093blByb3BlcnR5KF9pbmRpY2F0b3IpKSBjb250aW51ZTtcclxuXHRcdFx0dmFyIGluZGljYXRvciA9IHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzW19pbmRpY2F0b3JdO1xyXG5cdFx0XHRydWxlcyA9IFtdO1xyXG5cdFx0XHRzdHIgPSBcIlxcXCJcIiArIF9pbmRpY2F0b3IgKyBcIlxcXCI6IFtcIjtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGluZGljYXRvci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHJ1bGVzLnB1c2goaW5kaWNhdG9yW2ldLmNvbXBpbGUoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyICs9IHJ1bGVzLmpvaW4oKTtcclxuXHRcdFx0c3RyICs9IFwiXVwiO1xyXG5cdFx0XHRvYmoucHVzaCggc3RyICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCJ7XCIgKyBvYmouam9pbigpICsgXCJ9O1wiO1xyXG5cdH07XHJcblxyXG5cdC8vIE1vZHVsZVxyXG5cdE1vZHVsZS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGxlbmd0aCA9IDA7XHJcblx0XHR2YXIgZGVwZW5kZW5jaWVzID0gMDtcclxuXHRcdHZhciBzdHIgPSBcInZhciBwbDtcXG5cIjtcclxuXHRcdHN0ciArPSBcIihmdW5jdGlvbihwbCkge1xcblwiO1xyXG5cdFx0Ly8gbmFtZVxyXG5cdFx0c3RyICs9IFwiXFx0dmFyIG5hbWUgPSBcXFwiXCIgKyB0aGlzLmlkICsgXCJcXFwiO1xcblwiO1xyXG5cdFx0Ly8gcHJlZGljYXRlc1xyXG5cdFx0c3RyICs9IFwiXFx0dmFyIHByZWRpY2F0ZXMgPSBmdW5jdGlvbigpIHtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdHJldHVybiB7XFxuXCI7XHJcblx0XHRmb3IodmFyIHByb3AgaW4gdGhpcy5ydWxlcykge1xyXG5cdFx0XHRpZihsZW5ndGggPiAwKVxyXG5cdFx0XHRcdHN0ciArPSBcIixcXG5cIjtcclxuXHRcdFx0c3RyICs9IFwiXFx0XFx0XFx0XFxcIlwiICsgcHJvcCArIFwiXFxcIjogXCI7XHJcblx0XHRcdGlmKHR5cGVvZiB0aGlzLnJ1bGVzW3Byb3BdID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRzdHIgKz0gdGhpcy5ydWxlc1twcm9wXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdHIgKz0gXCJbXFxuXCI7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMucnVsZXNbcHJvcF0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHN0ciArPSBcIlxcdFxcdFxcdFxcdFwiICsgdGhpcy5ydWxlc1twcm9wXVtpXS5jb21waWxlKCk7XHJcblx0XHRcdFx0XHRpZihpIDwgdGhpcy5ydWxlc1twcm9wXS5sZW5ndGgtMSlcclxuXHRcdFx0XHRcdFx0c3RyICs9IFwiLFwiO1xyXG5cdFx0XHRcdFx0c3RyICs9IFwiXFxuXCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN0ciArPSBcIlxcdFxcdFxcdF1cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZW5ndGgrKztcclxuXHRcdH1cclxuXHRcdHN0ciArPSBcIlxcblxcdFxcdH07XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHR9O1xcblwiO1xyXG5cdFx0Ly8gZXhwb3J0c1xyXG5cdFx0c3RyICs9IFwiXFx0dmFyIGV4cG9ydHMgPSBbXCI7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5leHBvcnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGkgPiAwKVxyXG5cdFx0XHRcdHN0ciArPSBcIiwgXCI7XHJcblx0XHRcdHN0ciArPSBcIlxcXCJcIiArIHRoaXMuZXhwb3J0c1tpXSArIFwiXFxcIlwiO1xyXG5cdFx0fVxyXG5cdFx0c3RyICs9IFwiXTtcXG5cIjtcclxuXHRcdC8vIG9wdGlvbnNcclxuXHRcdHN0ciArPSBcIlxcdHZhciBvcHRpb25zID0gZnVuY3Rpb24oKSB7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRyZXR1cm4ge1xcblwiO1xyXG5cdFx0Ly8gZGVwZW5kZW5jaWVzXHJcblx0XHRzdHIgKz0gXCJcXHRcXHRcXHRkZXBlbmRlbmNpZXM6IFtcIjtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiB0aGlzLm1vZHVsZXMpIHtcclxuXHRcdFx0aWYoZGVwZW5kZW5jaWVzID4gMClcclxuXHRcdFx0XHRzdHIgKz0gXCIsIFwiO1xyXG5cdFx0XHRzdHIgKz0gXCJcXFwiXCIgKyBwcm9wICsgXCJcXFwiXCI7XHJcblx0XHRcdGRlcGVuZGVuY2llcysrO1xyXG5cdFx0fVxyXG5cdFx0c3RyICs9IFwiXVxcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0fTtcXG5cIjtcclxuXHRcdHN0ciArPSBcIn07XFxuXCI7XHJcblx0XHQvLyBmaXhlZCBjb2RlXHJcblx0XHRzdHIgKz0gXCJcXHRpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwKSB7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRcXHRwbCA9IHA7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRcXHRuZXcgcGwudHlwZS5Nb2R1bGUobmFtZSwgcHJlZGljYXRlcygpLCBleHBvcnRzLCBvcHRpb25zKCkpO1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0fTtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdH0gZWxzZSB7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRuZXcgcGwudHlwZS5Nb2R1bGUobmFtZSwgcHJlZGljYXRlcygpLCBleHBvcnRzLCBvcHRpb25zKCkpO1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0fVxcblwiO1xyXG5cdFx0c3RyICs9IFwifSkocGwpO1xcblwiO1xyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFBST0xPRyBUTyBKQVZBU0NSSVBUXHJcblx0VmFyLnByb3RvdHlwZS50b0phdmFTY3JpcHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS50b0phdmFTY3JpcHQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS50b0phdmFTY3JpcHQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHQvLyBBdG9tID0+IFN0cmluZ1xyXG5cdFx0aWYoIHRoaXMuYXJncy5sZW5ndGggPT09IDAgJiYgdGhpcy5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50b1N0cmluZyhvcHRpb25zKTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19saXN0KCB0aGlzICkgKSB7XHJcblx0XHRcdC8vIExpc3QgPT4gQXJyYXlcclxuXHRcdFx0dmFyIGFsbF9vYmogPSB0cnVlO1xyXG5cdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdHZhciBvYmogPSB7fTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzO1xyXG5cdFx0XHR2YXIgdmFsdWU7XHJcblx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHBvaW50ZXIuYXJnc1swXS50b0phdmFTY3JpcHQob3B0aW9ucyk7XHJcblx0XHRcdFx0YXJyLnB1c2goIHZhbHVlICk7XHJcblx0XHRcdFx0YWxsX29iaiA9IGFsbF9vYmogJiYgcGwudHlwZS5pc190ZXJtKHBvaW50ZXIuYXJnc1swXSkgJiYgcG9pbnRlci5hcmdzWzBdLmluZGljYXRvciA9PT0gXCItLzJcIiAmJiBwbC50eXBlLmlzX2F0b20ocG9pbnRlci5hcmdzWzBdLmFyZ3NbMF0pO1xyXG5cdFx0XHRcdGlmKGFsbF9vYmopXHJcblx0XHRcdFx0XHRvYmpbcG9pbnRlci5hcmdzWzBdLmFyZ3NbMF0uaWRdID0gcG9pbnRlci5hcmdzWzBdLmFyZ3NbMV0udG9KYXZhU2NyaXB0KG9wdGlvbnMpO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIltdLzBcIiApXHJcblx0XHRcdFx0cmV0dXJuIGFsbF9vYmogJiYgYXJyLmxlbmd0aCA+IDAgPyBvYmogOiBhcnI7XHJcblxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcob3B0aW9ucyk7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBSVUxFU1xyXG5cdFxyXG5cdC8vIFJldHVybiBzaW5nbGV0b24gdmFyaWFibGVzIGluIHRoZSBzZXNzaW9uXHJcblx0UnVsZS5wcm90b3R5cGUuc2luZ2xldG9uX3ZhcmlhYmxlcyA9IGZ1bmN0aW9uKGluY2x1ZGVfbmFtZWQpIHtcclxuXHRcdGluY2x1ZGVfbmFtZWQgPSBpbmNsdWRlX25hbWVkIHx8IGZhbHNlO1xyXG5cdFx0dmFyIHZhcmlhYmxlcyA9IHRoaXMuaGVhZC52YXJpYWJsZXMoKTtcclxuXHRcdHZhciBjb3VudCA9IHt9O1xyXG5cdFx0dmFyIHNpbmdsZXRvbiA9IFtdO1xyXG5cdFx0aWYodGhpcy5ib2R5ICE9PSBudWxsKVxyXG5cdFx0XHR2YXJpYWJsZXMgPSB2YXJpYWJsZXMuY29uY2F0KHRoaXMuYm9keS52YXJpYWJsZXMoKSk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKGNvdW50W3ZhcmlhYmxlc1tpXV0gPT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRjb3VudFt2YXJpYWJsZXNbaV1dID0gMDtcclxuXHRcdFx0Y291bnRbdmFyaWFibGVzW2ldXSsrO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKHZhciBrZXkgaW4gY291bnQpIHtcclxuXHRcdFx0aWYoIWNvdW50Lmhhc093blByb3BlcnR5KGtleSkpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdGlmKGNvdW50W2tleV0gPT09IDEpIHtcclxuXHRcdFx0XHR2YXIgY2hhcmNvZGUgPSBjb2RlUG9pbnRBdChrZXksIDEpO1xyXG5cdFx0XHRcdGlmKCFpbmNsdWRlX25hbWVkIHx8IGtleSA9PT0gXCJfXCIpXHJcblx0XHRcdFx0XHRpZihrZXkgPT09IFwiX1wiIHx8IGtleVswXSA9PT0gXCJfXCIgJiYgKGNoYXJjb2RlID09PSA5NSB8fCBjaGFyY29kZSA+PSA2NSAmJiBjaGFyY29kZSA8PSA5MCkpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdHNpbmdsZXRvbi5wdXNoKGtleSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzaW5nbGV0b247XHJcblx0fTtcclxuXHJcblxyXG5cclxuXHQvLyBOT0RFSlNcclxuXHJcblx0dmFyIG5vZGVqc19mbGFnID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICFwcm9jZXNzLmJyb3dzZXJcclxuXHJcblx0dmFyIG5vZGVqc19hcmd1bWVudHMgPSBub2RlanNfZmxhZyA/XHJcblx0XHRhcnJheVRvTGlzdCggbWFwKHByb2Nlc3MuYXJndi5zbGljZSgxKSwgZnVuY3Rpb24oYXJnKSB7IHJldHVybiBuZXcgVGVybSggYXJnICk7IH0pKSA6XHJcblx0XHRuZXcgVGVybShcIltdXCIsIFtdKTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBQUk9MT0dcclxuXHJcblx0dmFyIHBsID0ge1xyXG5cdFx0XHJcblx0XHQvLyBFbnZpcm9ubWVudFxyXG5cdFx0X19lbnY6IG5vZGVqc19mbGFnID8gZ2xvYmFsIDogd2luZG93LFxyXG5cdFx0XHJcblx0XHQvLyBNb2R1bGVzXHJcblx0XHRtb2R1bGVzOiB7fSxcclxuXHRcdFxyXG5cdFx0Ly8gVmVyc2lvblxyXG5cdFx0dmVyc2lvbjogdmVyc2lvbixcclxuXHRcdFxyXG5cdFx0Ly8gUGFyc2VyXHJcblx0XHRwYXJzZXI6IHtcclxuXHRcdFx0dG9rZW5pemVyOiBUb2tlbml6ZXIsXHJcblx0XHRcdGV4cHJlc3Npb246IHBhcnNlRXhwclxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVXRpbHNcclxuXHRcdHV0aWxzOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTdHJpbmcgdG8gaW5kaWNhdG9yXHJcblx0XHRcdHN0cl9pbmRpY2F0b3I6IHN0cl9pbmRpY2F0b3IsXHJcblx0XHRcdC8vIENvZGUgcG9pbnQgYXRcclxuXHRcdFx0Y29kZVBvaW50QXQ6IGNvZGVQb2ludEF0LFxyXG5cdFx0XHQvLyBGcm9tIGNvZGUgcG9pbnRcclxuXHRcdFx0ZnJvbUNvZGVQb2ludDogZnJvbUNvZGVQb2ludCxcclxuXHRcdFx0Ly8gTGVuZ3RoIG9mIHN0cmluZ1xyXG5cdFx0XHRzdHJpbmdMZW5ndGg6IHN0cmluZ0xlbmd0aFxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFN0YXRpc3RpY3NcclxuXHRcdHN0YXRpc3RpY3M6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE51bWJlciBvZiBjcmVhdGVkIHRlcm1zXHJcblx0XHRcdGdldENvdW50VGVybXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiB0ZXJtX3JlZjtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEphdmFTY3JpcHQgdG8gUHJvbG9nXHJcblx0XHRmcm9tSmF2YVNjcmlwdDoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVHlwZSB0ZXN0aW5nXHJcblx0XHRcdHRlc3Q6IHtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBCb29sZWFuXHJcblx0XHRcdFx0Ym9vbGVhbjogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIE51bWJlclxyXG5cdFx0XHRcdG51bWJlcjogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gU3RyaW5nXHJcblx0XHRcdFx0c3RyaW5nOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCI7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBMaXN0XHJcblx0XHRcdFx0bGlzdDogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFZhcmlhYmxlXHJcblx0XHRcdFx0dmFyaWFibGU6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqID09PSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gT2JqZWN0XHJcblx0XHRcdFx0b2JqZWN0OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0dG9iaiA9IHRvYmogPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdG9iajtcclxuXHRcdFx0XHRcdHJldHVybiB0b2JqICYmICEob2JqIGluc3RhbmNlb2YgQXJyYXkpICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCI7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBBbnlcclxuXHRcdFx0XHRhbnk6IGZ1bmN0aW9uKCBfLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRnVuY3Rpb24gY29udmVyc2lvblxyXG5cdFx0XHRjb252ZXJzaW9uOiB7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQm9sZWFuXHJcblx0XHRcdFx0Ym9vbGVhbjogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVGVybSggb2JqID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIFtdICk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBOdW1iZXJcclxuXHRcdFx0XHRudW1iZXI6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE51bSggb2JqLCBvYmogJSAxICE9PSAwICk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBTdHJpbmdcclxuXHRcdFx0XHRzdHJpbmc6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIG9iaiwgW10gKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIExpc3RcclxuXHRcdFx0XHRsaXN0OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0dG9iaiA9IHRvYmogPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdG9iajtcclxuXHRcdFx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0XHRcdHZhciBlbGVtO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdGVsZW0gPSBwbC5mcm9tSmF2YVNjcmlwdC5hcHBseSggb2JqW2ldLCB0b2JqICk7XHJcblx0XHRcdFx0XHRcdGlmKCBlbGVtID09PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHRcdGFyci5wdXNoKCBlbGVtICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gYXJyYXlUb0xpc3QoIGFyciApO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gVmFyaWFibGVcclxuXHRcdFx0XHR2YXJpYWJsZTogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVmFyKCBcIl9cIiApO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIE9iamVjdFxyXG5cdFx0XHRcdG9iamVjdDogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHRvYmogPSB0b2JqID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRvYmo7XHJcblx0XHRcdFx0XHR2YXIgbGlzdCA9IG5ldyBUZXJtKFwiW11cIiwgW10pO1xyXG5cdFx0XHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBwcm9wIGluIG9iaikge1xyXG5cdFx0XHRcdFx0XHRpZighb2JqLmhhc093blByb3BlcnR5KHByb3ApKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0YXJyLnB1c2gobmV3IFRlcm0oXCItXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRwbC5mcm9tSmF2YVNjcmlwdC5hcHBseShwcm9wLCB0b2JqKSxcclxuXHRcdFx0XHRcdFx0XHRwbC5mcm9tSmF2YVNjcmlwdC5hcHBseShvYmpbcHJvcF0sIHRvYmopXHJcblx0XHRcdFx0XHRcdF0pKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBhcnJheVRvTGlzdChhcnIpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gQW55XHJcblx0XHRcdFx0YW55OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBUcmFuc2Zvcm0gb2JqZWN0XHJcblx0XHRcdGFwcGx5OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdHRvYmogPSB0b2JqID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IHRvYmo7XHJcblx0XHRcdFx0Zm9yKCB2YXIgaSBpbiBwbC5mcm9tSmF2YVNjcmlwdC50ZXN0IClcclxuXHRcdFx0XHRcdGlmKCBpICE9PSBcImFueVwiICYmIHBsLmZyb21KYXZhU2NyaXB0LnRlc3RbaV0oIG9iaiwgdG9iaiApIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHBsLmZyb21KYXZhU2NyaXB0LmNvbnZlcnNpb25baV0oIG9iaiwgdG9iaiApO1xyXG5cdFx0XHRcdHJldHVybiBwbC5mcm9tSmF2YVNjcmlwdC5jb252ZXJzaW9uLmFueSggb2JqLCB0b2JqICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFR5cGVzXHJcblx0XHR0eXBlOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBPYmplY3RzXHJcblx0XHRcdFZhcjogVmFyLFxyXG5cdFx0XHROdW06IE51bSxcclxuXHRcdFx0VGVybTogVGVybSxcclxuXHRcdFx0UnVsZTogUnVsZSxcclxuXHRcdFx0U3RhdGU6IFN0YXRlLFxyXG5cdFx0XHRTdHJlYW06IFN0cmVhbSxcclxuXHRcdFx0TW9kdWxlOiBNb2R1bGUsXHJcblx0XHRcdFRocmVhZDogVGhyZWFkLFxyXG5cdFx0XHRTZXNzaW9uOiBTZXNzaW9uLFxyXG5cdFx0XHRTdWJzdGl0dXRpb246IFN1YnN0aXR1dGlvbixcclxuXHRcdFx0RmlsZTogVGF1RmlsZSxcclxuXHRcdFx0RGlyZWN0b3J5OiBUYXVEaXJlY3RvcnksXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBPcmRlclxyXG5cdFx0XHRvcmRlcjogW1ZhciwgTnVtLCBUZXJtLCBTdHJlYW1dLFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ29tcGFyZSB0eXBlc1xyXG5cdFx0XHRjb21wYXJlOiBmdW5jdGlvbiggeCwgeSApIHtcclxuXHRcdFx0XHR2YXIgb3JkX3ggPSBpbmRleE9mKCBwbC50eXBlLm9yZGVyLCB4LmNvbnN0cnVjdG9yICk7XHJcblx0XHRcdFx0dmFyIG9yZF95ID0gaW5kZXhPZiggcGwudHlwZS5vcmRlciwgeS5jb25zdHJ1Y3RvciApO1xyXG5cdFx0XHRcdGlmKCBvcmRfeCA8IG9yZF95ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggb3JkX3ggPiBvcmRfeSApIHtcclxuXHRcdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiggeC5jb25zdHJ1Y3RvciA9PT0gTnVtIClcclxuXHRcdFx0XHRcdFx0aWYoIHguaXNfZmxvYXQgJiYgeS5pc19mbG9hdCApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdFx0XHRcdGVsc2UgaWYoIHguaXNfZmxvYXQgKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiggeS5pc19mbG9hdCApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIDE7XHJcblx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHN1YnN0aXR1dGlvblxyXG5cdFx0XHRpc19zdWJzdGl0dXRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFN1YnN0aXR1dGlvbjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgc3RhdGVcclxuXHRcdFx0aXNfc3RhdGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFN0YXRlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBydWxlXHJcblx0XHRcdGlzX3J1bGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFJ1bGU7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHZhcmlhYmxlXHJcblx0XHRcdGlzX3ZhcmlhYmxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBWYXI7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHN0cmVhbVxyXG5cdFx0XHRpc19zdHJlYW06IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFN0cmVhbTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIGFub255bW91cyB2YXJpYWJsZVxyXG5cdFx0XHRpc19hbm9ueW1vdXNfdmFyOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBWYXIgJiYgb2JqLmlkID09PSBcIl9cIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgY2FsbGFibGUgdGVybVxyXG5cdFx0XHRpc19jYWxsYWJsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybVxyXG5cdFx0XHRcdCYmIChpbmRleE9mKFtcIiwvMlwiLFwiOy8yXCIsXCItPi8yXCJdLCBvYmouaW5kaWNhdG9yKSA9PT0gLTFcclxuXHRcdFx0XHR8fCBwbC50eXBlLmlzX2NhbGxhYmxlKG9iai5hcmdzWzBdKSAmJiBwbC50eXBlLmlzX2NhbGxhYmxlKG9iai5hcmdzWzFdKSlcclxuXHRcdFx0XHR8fCBvYmogaW5zdGFuY2VvZiBWYXI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIG51bWJlclxyXG5cdFx0XHRpc19udW1iZXI6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIGludGVnZXJcclxuXHRcdFx0aXNfaW50ZWdlcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmICFvYmouaXNfZmxvYXQ7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGZsb2F0XHJcblx0XHRcdGlzX2Zsb2F0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgb2JqLmlzX2Zsb2F0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSB0ZXJtXHJcblx0XHRcdGlzX3Rlcm06IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm07XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBhdG9tXHJcblx0XHRcdGlzX2F0b206IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3MubGVuZ3RoID09PSAwO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBncm91bmQgdGVybVxyXG5cdFx0XHRpc19ncm91bmQ6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0aWYoIG9iaiBpbnN0YW5jZW9mIFZhciApIHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRpZiggb2JqIGluc3RhbmNlb2YgVGVybSApXHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IG9iai5hcmdzLmxlbmd0aDsgaSsrIClcclxuXHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2dyb3VuZCggb2JqLmFyZ3NbaV0gKSApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYXRvbWljXHJcblx0XHRcdGlzX2F0b21pYzogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJncy5sZW5ndGggPT09IDAgfHwgb2JqIGluc3RhbmNlb2YgTnVtO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgY29tcG91bmRcclxuXHRcdFx0aXNfY29tcG91bmQ6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3MubGVuZ3RoID4gMDtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgbGlzdFxyXG5cdFx0XHRpc19saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIChvYmouaW5kaWNhdG9yID09PSBcIltdLzBcIiB8fCBvYmouaW5kaWNhdG9yID09PSBcIi4vMlwiKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIGVtcHR5IGxpc3RcclxuXHRcdFx0aXNfZW1wdHlfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIltdLzBcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgbm9uIGVtcHR5IGxpc3RcclxuXHRcdFx0aXNfbm9uX2VtcHR5X2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCIuLzJcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgZnVsbHkgbGlzdFxyXG5cdFx0XHRpc19mdWxseV9saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHdoaWxlKCBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRvYmogPSBvYmouYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFZhciB8fCBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiW10vMFwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBpbnN0YW50aWF0ZWQgbGlzdFxyXG5cdFx0XHRpc19pbnN0YW50aWF0ZWRfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHR3aGlsZSggb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0b2JqID0gb2JqLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiW10vMFwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gdW5pdGFyeSBsaXN0XHJcblx0XHRcdGlzX3VuaXRhcnlfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIi4vMlwiICYmIG9iai5hcmdzWzFdIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJnc1sxXS5pbmRpY2F0b3IgPT09IFwiW10vMFwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBjaGFyYWN0ZXJcclxuXHRcdFx0aXNfY2hhcmFjdGVyOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzLmxlbmd0aCA9PT0gMCAmJiAob2JqLmlkLmxlbmd0aCA9PT0gMSB8fCBvYmouaWQubGVuZ3RoID4gMCAmJiBvYmouaWQubGVuZ3RoIDw9IDIgJiYgY29kZVBvaW50QXQoIG9iai5pZCwgMCApID49IDY1NTM2KTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgaW5fY2hhcmFjdGVyXHJcblx0XHRcdGlzX2luX2NoYXJhY3RlcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiAob2JqLmluZGljYXRvciA9PT0gXCJlbmRfb2ZfZmlsZS8wXCJcclxuXHRcdFx0XHR8fCBvYmouaWQubGVuZ3RoID09PSAxXHJcblx0XHRcdFx0fHwgb2JqLmlkLmxlbmd0aCA+IDAgJiYgb2JqLmlkLmxlbmd0aCA8PSAyICYmIGNvZGVQb2ludEF0KG9iai5pZCwgMCkgPj0gNjU1MzYpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBjaGFyYWN0ZXJfY29kZVxyXG5cdFx0XHRpc19jaGFyYWN0ZXJfY29kZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmICFvYmouaXNfZmxvYXQgJiYgb2JqLnZhbHVlID49IDAgJiYgb2JqLnZhbHVlIDw9IDExMTQxMTE7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGluX2NoYXJhY3Rlcl9jb2RlXHJcblx0XHRcdGlzX2luX2NoYXJhY3Rlcl9jb2RlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgIW9iai5pc19mbG9hdCAmJiBvYmoudmFsdWUgPj0gLTEgJiYgb2JqLnZhbHVlIDw9IDExMTQxMTE7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIGJ5dGVcclxuXHRcdFx0aXNfYnl0ZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtICYmICFvYmouaXNfZmxvYXQgJiYgb2JqLnZhbHVlID49IDAgJiYgb2JqLnZhbHVlIDw9IDI1NTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgaW5fYnl0ZVxyXG5cdFx0XHRpc19pbl9ieXRlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgIW9iai5pc19mbG9hdCAmJiBvYmoudmFsdWUgPj0gLTEgJiYgb2JqLnZhbHVlIDw9IDI1NTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIG9wZXJhdG9yXHJcblx0XHRcdGlzX29wZXJhdG9yOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIHBsLmFyaXRobWV0aWMuZXZhbHVhdGlvbltvYmouaW5kaWNhdG9yXTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgZGlyZWN0aXZlXHJcblx0XHRcdGlzX2RpcmVjdGl2ZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiAocGwuZGlyZWN0aXZlW29iai5pbmRpY2F0b3JdICE9PSB1bmRlZmluZWQgfHwgcGwuZGlyZWN0aXZlW29iai5pZCArIFwiLypcIl0gIT09IHVuZGVmaW5lZCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGJ1aWx0LWluIHByZWRpY2F0ZVxyXG5cdFx0XHRpc19idWlsdGluOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIHBsLmJ1aWx0aW4ucnVsZXMuaGFzT3duUHJvcGVydHkob2JqLmluZGljYXRvcikgJiYgb2JqLmluZGljYXRvciAhPT0gXCJnb2FsX2V4cGFuc2lvbi8yXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiBlcnJvclxyXG5cdFx0XHRpc19lcnJvcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcInRocm93LzFcIjtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGFuIGVycm9yIHN0YXRlXHJcblx0XHRcdGlzX2Vycm9yX3N0YXRlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3N0YXRlKCBvYmogKSAmJiBvYmouZXJyb3IgJiYgb2JqLmVycm9yID09PSB0cnVlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBwcmVkaWNhdGUgaW5kaWNhdG9yXHJcblx0XHRcdGlzX3ByZWRpY2F0ZV9pbmRpY2F0b3I6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCIvLzJcIiAmJiBvYmouYXJnc1swXSBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3NbMF0uYXJncy5sZW5ndGggPT09IDAgJiYgb2JqLmFyZ3NbMV0gaW5zdGFuY2VvZiBOdW0gJiYgb2JqLmFyZ3NbMV0uaXNfZmxvYXQgPT09IGZhbHNlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBmbGFnXHJcblx0XHRcdGlzX2ZsYWc6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3MubGVuZ3RoID09PSAwICYmIHBsLmZsYWdbb2JqLmlkXSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSB2YWxpZCB2YWx1ZSBmb3IgYSBmbGFnXHJcblx0XHRcdGlzX3ZhbHVlX2ZsYWc6IGZ1bmN0aW9uKCBmbGFnLCBvYmogKSB7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2ZsYWcoIGZsYWcgKSApIHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRmb3IoIHZhciB2YWx1ZSBpbiBwbC5mbGFnW2ZsYWcuaWRdLmFsbG93ZWQgKSB7XHJcblx0XHRcdFx0XHRpZighcGwuZmxhZ1tmbGFnLmlkXS5hbGxvd2VkLmhhc093blByb3BlcnR5KHZhbHVlKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRpZiggcGwuZmxhZ1tmbGFnLmlkXS5hbGxvd2VkW3ZhbHVlXS5lcXVhbHMoIG9iaiApICkgcmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgaW8gbW9kZVxyXG5cdFx0XHRpc19pb19tb2RlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX2F0b20oIG9iaiApICYmIFtcInJlYWRcIixcIndyaXRlXCIsXCJhcHBlbmRcIl0uaW5kZXhPZiggb2JqLmlkICkgIT09IC0xO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBzdHJlYW0gb3B0aW9uXHJcblx0XHRcdGlzX3N0cmVhbV9vcHRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybSggb2JqICkgJiYgKFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJhbGlhcy8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJyZXBvc2l0aW9uLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIikgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwidHlwZS8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidGV4dFwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImJpbmFyeVwiKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJlb2ZfYWN0aW9uLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJlcnJvclwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImVvZl9jb2RlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwicmVzZXRcIilcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBzdHJlYW0gcG9zaXRpb25cclxuXHRcdFx0aXNfc3RyZWFtX3Bvc2l0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0ob2JqKSAmJiAoXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImVuZF9vZl9zdHJlYW0vMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInBhc3RfZW5kX29mX3N0cmVhbS8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicG9zaXRpb24vM1wiXHJcblx0XHRcdFx0XHRcdCYmIHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1swXSlcclxuXHRcdFx0XHRcdFx0JiYgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzFdKVxyXG5cdFx0XHRcdFx0XHQmJiBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMl0pXHJcblx0XHRcdFx0KVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBzdHJlYW0gcHJvcGVydHlcclxuXHRcdFx0aXNfc3RyZWFtX3Byb3BlcnR5OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0oIG9iaiApICYmIChcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiaW5wdXQvMFwiIHx8IFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJvdXRwdXQvMFwiIHx8IFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJhbGlhcy8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKCBvYmouYXJnc1swXSApKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJmaWxlX25hbWUvMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbSggb2JqLmFyZ3NbMF0gKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicmVwb3NpdGlvbi8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJ0eXBlLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0ZXh0XCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiYmluYXJ5XCIpKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJtb2RlLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJyZWFkXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwid3JpdGVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJhcHBlbmRcIikpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImVvZl9hY3Rpb24vMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcImVycm9yXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZW9mX2NvZGVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJyZXNldFwiKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZW5kX29mX3N0cmVhbS8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwiYXRcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJwYXN0XCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwibm90XCIpKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJwb3NpdGlvbi8xXCJcclxuXHRcdFx0XHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUob2JqLmFyZ3NbMF0pIHx8IHBsLnR5cGUuaXNfdGVybShvYmouYXJnc1swXSkgJiYgb2JqLmFyZ3NbMF0uaW5kaWNhdG9yID09PSBcInBvc2l0aW9uLzNcIlxyXG5cdFx0XHRcdFx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKG9iai5hcmdzWzBdLmFyZ3NbMF0pIHx8IHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1swXS5hcmdzWzBdKSlcclxuXHRcdFx0XHRcdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShvYmouYXJnc1swXS5hcmdzWzFdKSB8fCBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMF0uYXJnc1sxXSkpXHJcblx0XHRcdFx0XHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUob2JqLmFyZ3NbMF0uYXJnc1syXSkgfHwgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzBdLmFyZ3NbMl0pKSlcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBzdHJlYW1hYmxlIHRlcm1cclxuXHRcdFx0aXNfc3RyZWFtYWJsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqLl9fcHJvdG9fXy5zdHJlYW0gIT09IHVuZGVmaW5lZDtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgcmVhZCBvcHRpb25cclxuXHRcdFx0aXNfcmVhZF9vcHRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybSggb2JqICkgJiYgW1widmFyaWFibGVzLzFcIixcInZhcmlhYmxlX25hbWVzLzFcIixcInNpbmdsZXRvbnMvMVwiXS5pbmRleE9mKCBvYmouaW5kaWNhdG9yICkgIT09IC0xO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSB3cml0ZSBvcHRpb25cclxuXHRcdFx0aXNfd3JpdGVfb3B0aW9uOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0oIG9iaiApICYmIChcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicXVvdGVkLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIikgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiaWdub3JlX29wcy8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm51bWJlcnZhcnMvMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJ2YXJpYWJsZV9uYW1lcy8xXCIgJiYgcGwudHlwZS5pc19mdWxseV9saXN0KG9iai5hcmdzWzBdKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIGNsb3NlIG9wdGlvblxyXG5cdFx0XHRpc19jbG9zZV9vcHRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybSggb2JqICkgJiZcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZm9yY2UvMVwiICYmXHJcblx0XHRcdFx0XHRwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmXHJcblx0XHRcdFx0XHQob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBtb2RpZmlhYmxlIGZsYWdcclxuXHRcdFx0aXNfbW9kaWZpYWJsZV9mbGFnOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX2ZsYWcoIG9iaiApICYmIHBsLmZsYWdbb2JqLmlkXS5jaGFuZ2VhYmxlO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBtb2R1bGVcclxuXHRcdFx0aXNfbW9kdWxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBNb2R1bGU7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHZpcnR1YWwgZmlsZVxyXG5cdFx0XHRpc19maWxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUYXVGaWxlO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSB2aXJ0dWFsIGRpcmVjdG9yeVxyXG5cdFx0XHRpc19kaXJlY3Rvcnk6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRhdURpcmVjdG9yeTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgcHJlZGljYXRlIHByb3BlcnR5XHJcblx0XHRcdGlzX3ByZWRpY2F0ZV9wcm9wZXJ0eTogZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybShvYmopICYmIChcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiYnVpbHRfaW4vMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInN0YXRpYy8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZHluYW1pYy8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwibmF0aXZlX2NvZGUvMFwiIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm11bHRpZmlsZS8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwibWV0YV9wcmVkaWNhdGUvMVwiXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgbWV0YS1hcmd1bWVudCBzcGVjaWZpZXJcclxuXHRcdFx0aXNfbWV0YV9hcmd1bWVudF9zcGVjaWZpZXI6IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX2ludGVnZXIob2JqKSAmJiBvYmoudmFsdWUgPj0gMCB8fFxyXG5cdFx0XHRcdFx0cGwudHlwZS5pc19hdG9tKG9iaikgJiYgaW5kZXhPZihbXCIrXCIsIFwiLVwiLCBcIj9cIiwgXCIqXCIsIFwiXlwiLCBcIjpcIiwgXCIvL1wiXSwgb2JqLmlkKSAhPT0gLTE7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHRpbWUgcHJvcGVydHlcclxuXHRcdFx0aXNfdGltZV9wcm9wZXJ0eTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKG9iaikgJiYgb2JqLmFyZ3MubGVuZ3RoID09PSAxIFxyXG5cdFx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKG9iai5hcmdzWzBdKSB8fCBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMF0pKVxyXG5cdFx0XHRcdCYmIGluZGV4T2YoW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiLCBcIndlZWtkYXlcIl0sIG9iai5pZCkgIT09IC0xO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gQXJpdGhtZXRpYyBmdW5jdGlvbnNcclxuXHRcdGFyaXRobWV0aWM6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEV2YWx1YXRpb25cclxuXHRcdFx0ZXZhbHVhdGlvbjoge1xyXG5cdFx0XHRcdFwiZS8wXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCBfICkgeyByZXR1cm4gTWF0aC5FOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInBpLzBcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIF8gKSB7IHJldHVybiBNYXRoLlBJOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInRhdS8wXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCBfICkgeyByZXR1cm4gMipNYXRoLlBJOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImVwc2lsb24vMFwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggXyApIHsgcmV0dXJuIE51bWJlci5FUFNJTE9OOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIisvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIHg7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiLS8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gLXg7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiXFxcXC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiB+eDsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhYnMvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguYWJzKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwic2lnbi8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5zaWduKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZmxvYXRfaW50ZWdlcl9wYXJ0LzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gcGFyc2VJbnQoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJmbG9hdF9mcmFjdGlvbmFsX3BhcnQvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIHggLSBwYXJzZUludCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImZsb2F0LzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBwYXJzZUZsb2F0KCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZmxvb3IvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmZsb29yKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwidHJ1bmNhdGUvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBwYXJzZUludCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInJvdW5kLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiB0cnVlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5yb3VuZCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImNlaWxpbmcvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmNlaWwoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJzaW4vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguc2luKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiY29zLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmNvcyggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInRhbi8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC50YW4oIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhc2luLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIE1hdGguYWJzKHgpIDw9IDEgPyBNYXRoLmFzaW4oeCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhY29zLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIE1hdGguYWJzKHgpIDw9IDEgPyBNYXRoLmFjb3MoeCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhdGFuLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmF0YW4oIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhdGFuMi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB4ID09PSAwICYmIHkgPT09IDAgPyBwbC5lcnJvci5ldmFsdWF0aW9uKFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKSA6IE1hdGguYXRhbjIoeCwgeSk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYWNvc2gvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4geCA+PSAxID8gTWF0aC5hY29zaCh4KSA6IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImFzaW5oLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmFzaW5oKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYXRhbmgvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4gTWF0aC5hYnMoeCkgPCAxID8gTWF0aC5hdGFuaCh4KSA6IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImNvc2gvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguY29zaCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInNpbmgvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguc2luaCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInRhbmgvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGgudGFuaCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImV4cC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5leHAoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJzcXJ0LzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHRocmVhZCApIHsgcmV0dXJuIHggPj0gMCA/IE1hdGguc3FydCggeCApIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJsb2cvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4geCA+IDAgPyBNYXRoLmxvZyggeCApIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJsb2cvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geCA+IDAgJiYgeSA+IDAgPyBNYXRoLmxvZyh5KS9NYXRoLmxvZyh4KSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibG9nMTAvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4geCA+IDAgPyBNYXRoLmxvZyh4KS9NYXRoLmxvZygxMCkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIisvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggKyB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIi0vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiAgZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4IC0geTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIqLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4ICogeTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIvLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHkgPyB4IC8geSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiLy8vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB5ID8gTWF0aC50cnVuYyggeCAvIHkgKSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZGl2LzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geSA/IE1hdGguZmxvb3IoIHggLyB5ICkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIioqLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHggPT0gMCAmJiB5IDwgMCA/IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpIDogTWF0aC5wb3coeCwgeSk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiXi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB4ID09IDAgJiYgeSA8IDAgPyBwbC5lcnJvci5ldmFsdWF0aW9uKFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yKSA6IE1hdGgucG93KHgsIHkpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIjw8LzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggPDwgeTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCI+Pi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4ID4+IHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiL1xcXFwvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCAmIHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiXFxcXC8vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCB8IHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwieG9yLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggXiB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInJlbS8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHkgPyB4ICUgeSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibW9kLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geSA/IHggLSBNYXRoLmZsb29yKCB4IC8geSApICogeSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibWF4LzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiBNYXRoLm1heCggeCwgeSApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIm1pbi8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4gTWF0aC5taW4oIHgsIHkgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJnY2QvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4gZ2NkKHgsIHkpOyB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRGlyZWN0aXZlc1xyXG5cdFx0ZGlyZWN0aXZlOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBkeW5hbWljLzFcclxuXHRcdFx0XCJkeW5hbWljLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgYXRvbSwgb3B0aW9ucyApIHtcclxuXHRcdFx0XHR2YXIgaW5kaWNhdG9ycyA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19saXN0KGluZGljYXRvcnMpKVxyXG5cdFx0XHRcdFx0aW5kaWNhdG9ycyA9IGFycmF5VG9MaXN0KFtpbmRpY2F0b3JzXSk7XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBpbmRpY2F0b3JzO1xyXG5cdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0aW5kaWNhdG9yID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jb21wb3VuZCggaW5kaWNhdG9yICkgfHwgaW5kaWNhdG9yLmluZGljYXRvciAhPT0gXCIvLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwicHJlZGljYXRlX2luZGljYXRvclwiLCBpbmRpY2F0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IuYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBpbmRpY2F0b3IuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGluZGljYXRvci5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGluZGljYXRvci5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgaW5kaWNhdG9yLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHZhciBrZXkgPSBpbmRpY2F0b3IuYXJnc1swXS5pZCArIFwiL1wiICsgaW5kaWNhdG9yLmFyZ3NbMV0udmFsdWU7XHJcblx0XHRcdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXTtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1trZXldID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0aWYoICFnZXRfbW9kdWxlLnJ1bGVzW2tleV0gKVxyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2tleV0gPSBbXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgfHwgcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIGluZGljYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIGR5bmFtaWMvWzIuLl1cclxuXHRcdFx0XCJkeW5hbWljLypcIjogZnVuY3Rpb24oIHRocmVhZCwgYXRvbSApIHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXRvbS5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRwbC5kaXJlY3RpdmVbXCJkeW5hbWljLzFcIl0odGhyZWFkLCBuZXcgVGVybShcImR5bmFtaWNcIiwgW2F0b20uYXJnc1tpXV0pKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBtdWx0aWZpbGUvMVxyXG5cdFx0XHRcIm11bHRpZmlsZS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIGF0b20sIG9wdGlvbnMgKSB7XHJcblx0XHRcdFx0dmFyIGluZGljYXRvciA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY29tcG91bmQoIGluZGljYXRvciApIHx8IGluZGljYXRvci5pbmRpY2F0b3IgIT09IFwiLy8yXCIgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIGluZGljYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IuYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGluZGljYXRvci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGluZGljYXRvci5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBpbmRpY2F0b3IuYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBpbmRpY2F0b3IuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgcHJlZGljYXRlX2luZGljYXRvciA9IGF0b20uYXJnc1swXS5hcmdzWzBdLmlkICsgXCIvXCIgKyBhdG9tLmFyZ3NbMF0uYXJnc1sxXS52YWx1ZTtcclxuXHRcdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUubXVsdGlmaWxlX3ByZWRpY2F0ZXNbcHJlZGljYXRlX2luZGljYXRvcl0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYoIWdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkocHJlZGljYXRlX2luZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1twcmVkaWNhdGVfaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW3ByZWRpY2F0ZV9pbmRpY2F0b3JdID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gbWV0YV9wcmVkaWNhdGUvMVxyXG5cdFx0XHRcIm1ldGFfcHJlZGljYXRlLzFcIjogZnVuY3Rpb24odGhyZWFkLCBhdG9tLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRcdFx0dmFyIGhlYWQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhlYWQuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR2YXIgYXJnID0gaGVhZC5hcmdzW2ldO1xyXG5cdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc19tZXRhX2FyZ3VtZW50X3NwZWNpZmllcihhcmcpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcIm1ldGFfYXJndW1lbnRfc3BlY2lmaWVyXCIsIGFyZywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV0ubWV0YV9wcmVkaWNhdGVzW2hlYWQuaW5kaWNhdG9yXSA9IGhlYWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gc2V0X3Byb2xvZ19mbGFnXHJcblx0XHRcdFwic2V0X3Byb2xvZ19mbGFnLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgYXRvbSApIHtcclxuXHRcdFx0XHR2YXIgZmxhZyA9IGF0b20uYXJnc1swXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGZsYWcgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGZsYWcgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZmxhZyggZmxhZyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmRvbWFpbiggXCJwcm9sb2dfZmxhZ1wiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19tb2RpZmlhYmxlX2ZsYWcoIGZsYWcgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm1vZGlmeVwiLCBcImZsYWdcIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFsdWVfZmxhZyggZmxhZywgdmFsdWUgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5kb21haW4oIFwiZmxhZ192YWx1ZVwiLCBuZXcgVGVybSggXCIrXCIsIFtmbGFnLCB2YWx1ZV0gKSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5mbGFnW2ZsYWcuaWRdID0gdmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gbW9kdWxlLzJcclxuXHRcdFx0XCJtb2R1bGUvMlwiOiBmdW5jdGlvbih0aHJlYWQsIGF0b20sIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdFx0XHRvcHRpb25zLmNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZSA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHRcdHZhciBtb2R1bGVfaWQgPSBhdG9tLmFyZ3NbMF0sIGV4cG9ydHMgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShtb2R1bGVfaWQpIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoZXhwb3J0cykpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfYXRvbShtb2R1bGVfaWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwiYXRvbVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2xpc3QoZXhwb3J0cykpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGV4cG9ydHMsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZC5pbmRpY2F0b3JdKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGV4cG9ydHM7XHJcblx0XHRcdFx0XHRcdHZhciBpbmRpY2F0b3JzID0gW107XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwcmVkaWNhdGUgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfcHJlZGljYXRlX2luZGljYXRvcihwcmVkaWNhdGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwicHJlZGljYXRlX2luZGljYXRvclwiLCBwcmVkaWNhdGUsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGluZGljYXRvcnMucHVzaChwcmVkaWNhdGUuYXJnc1swXS5pZCArIFwiL1wiICsgcHJlZGljYXRlLmFyZ3NbMV0udmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19lbXB0eV9saXN0KHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImxpc3RcIiwgZXhwb3J0cywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgbmV3X21vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlX2lkLmlkLCB7fSwgaW5kaWNhdG9ycywge1xyXG5cdFx0XHRcdFx0XHRcdHNlc3Npb246IHRocmVhZC5zZXNzaW9uXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZC5pZF0gPSBuZXdfbW9kdWxlO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdLm1vZHVsZXNbbW9kdWxlX2lkLmlkXSA9IG5ld19tb2R1bGU7XHJcblx0XHRcdFx0XHRcdG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPSBtb2R1bGVfaWQuaWQ7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5wZXJtaXNzaW9uKFwiY3JlYXRlXCIsIFwibW9kdWxlXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyB1c2VfbW9kdWxlLzFcclxuXHRcdFx0XCJ1c2VfbW9kdWxlLzFcIjogZnVuY3Rpb24odGhyZWFkLCBhdG9tLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dmFyIG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRcdFx0b3B0aW9ucy5jb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdFx0XHR2YXIgbW9kdWxlX2lkID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUobW9kdWxlX2lkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKG1vZHVsZV9pZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJ0ZXJtXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYobW9kdWxlX2lkLmluZGljYXRvciA9PT0gXCJsaWJyYXJ5LzFcIikge1xyXG5cdFx0XHRcdFx0XHR2YXIgbmFtZSA9IG1vZHVsZV9pZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHBsLm1vZHVsZXNbbmFtZV07XHJcblx0XHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV0ubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1tuYW1lXSA9IGdldF9tb2R1bGU7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdLm1vZHVsZXNbbmFtZV0gPSBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGdldF9tb2R1bGUuZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciB0ZXJtID0gbmV3IFRlcm0oXCJ1c2VfbW9kdWxlXCIsIFtuZXcgVGVybShcImxpYnJhcnlcIiwgW25ldyBUZXJtKGdldF9tb2R1bGUuZGVwZW5kZW5jaWVzW2ldKV0pXSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHBsLmRpcmVjdGl2ZVtcInVzZV9tb2R1bGUvMVwiXSh0aHJlYWQsIHRlcm0sIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjb250ZXh0X21vZHVsZTogbmFtZVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuZXhpc3RlbmNlKFwibW9kdWxlXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dmFyIG5hbWUgPSBtb2R1bGVfaWQuaWQ7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5jb25zdWx0KG5hbWUsIHtcclxuXHRcdFx0XHRcdFx0XHRjb250ZXh0X21vZHVsZTogb3B0aW9ucy5jb250ZXh0X21vZHVsZSxcclxuXHRcdFx0XHRcdFx0XHR0ZXh0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIG9wdGlvbnMuc3RyaW5nLCBvcHRpb25zKTtcclxuXHRcdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuZXJyb3IocGwuZXJyb3IuZXhpc3RlbmNlKFwibW9kdWxlXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBjaGFyX2NvbnZlcnNpb24vMlxyXG5cdFx0XHRcImNoYXJfY29udmVyc2lvbi8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgYXRvbSwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBpbmNoYXIgPSBhdG9tLmFyZ3NbMF0sIG91dGNoYXIgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShpbmNoYXIpIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUob3V0Y2hhcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2hhcmFjdGVyKGluY2hhcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJjaGFyYWN0ZXJcIiwgaW5jaGFyLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jaGFyYWN0ZXIob3V0Y2hhcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJjaGFyYWN0ZXJcIiwgb3V0Y2hhciwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoaW5jaGFyLmlkID09PSBvdXRjaGFyLmlkKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aHJlYWQuc2Vzc2lvbi5fX2NoYXJfY29udmVyc2lvbltpbmNoYXIuaWRdO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uX19jaGFyX2NvbnZlcnNpb25baW5jaGFyLmlkXSA9IG91dGNoYXIuaWQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRvcHRpb25zLnRva2VucyA9IG9wdGlvbnMudG9rZW5pemVyLmdldF90b2tlbnMob3B0aW9ucy5jdXJyZW50X3Rva2VuKTtcclxuXHRcdFx0XHRcdG9wdGlvbnMuY3VycmVudF90b2tlbiA9IDA7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBvcC8zXHJcblx0XHRcdFwib3AvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBhdG9tICkge1xyXG5cdFx0XHRcdHZhciBwcmlvcml0eSA9IGF0b20uYXJnc1swXSwgdHlwZSA9IGF0b20uYXJnc1sxXSwgb3BlcmF0b3JzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfYXRvbShvcGVyYXRvcnMpKVxyXG5cdFx0XHRcdFx0b3BlcmF0b3JzID0gbmV3IFRlcm0oXCIuXCIsIFtvcGVyYXRvcnMsIG5ldyBUZXJtKFwiW11cIildKTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJpb3JpdHkgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0eXBlICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggcHJpb3JpdHkgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIHR5cGUgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgdHlwZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19lbXB0eV9saXN0KCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wZXJhdG9ycztcclxuXHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHR2YXIgb3BlcmF0b3IgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcGVyYXRvciApICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggb3BlcmF0b3IgKSApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggcHJpb3JpdHkudmFsdWUgPCAwIHx8IHByaW9yaXR5LnZhbHVlID4gMTIwMCApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3ByaW9yaXR5XCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwiLFwiICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJtb2RpZnlcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcInt9XCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJbXVwiICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwifFwiICYmIHByaW9yaXR5LnZhbHVlICE9PSAwICYmIChwcmlvcml0eS52YWx1ZSA8IDEwMDEgfHwgdHlwZS5pZC5sZW5ndGggIT09IDMgKSApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIFtcImZ5XCIsIFwiZnhcIiwgXCJ5ZlwiLCBcInhmXCIsIFwieGZ4XCIsIFwieWZ4XCIsIFwieGZ5XCJdLmluZGV4T2YoIHR5cGUuaWQgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9zcGVjaWZpZXJcIiwgdHlwZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBmaXggPSB7IHByZWZpeDogbnVsbCwgaW5maXg6IG51bGwsIHBvc3RmaXg6IG51bGwgfTtcclxuXHRcdFx0XHRcdFx0XHRmb3IoIHZhciBwIGluIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBjbGFzc2VzID0gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcF1bb3BlcmF0b3IuaWRdO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGNsYXNzZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcImZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5wcmVmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcImZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJmeVwiICkgIT09IC0xICkgeyBmaXgucHJlZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJmeVwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZcIiApICE9PSAtMSApIHsgZml4LnBvc3RmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmXCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ5ZlwiICkgIT09IC0xICkgeyBmaXgucG9zdGZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieWZcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInhmeFwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZ5XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZ5XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ5ZnhcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ5ZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2NsYXNzO1xyXG5cdFx0XHRcdFx0XHRcdHN3aXRjaCggdHlwZS5pZCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJmeVwiOiBjYXNlIFwiZnhcIjogY3VycmVudF9jbGFzcyA9IFwicHJlZml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcInlmXCI6IGNhc2UgXCJ4ZlwiOiBjdXJyZW50X2NsYXNzID0gXCJwb3N0Zml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGVmYXVsdDogY3VycmVudF9jbGFzcyA9IFwiaW5maXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGZpeC5pbmZpeCAmJiBjdXJyZW50X2NsYXNzID09PSBcInBvc3RmaXhcIiB8fCBmaXgucG9zdGZpeCAmJiBjdXJyZW50X2NsYXNzID09PSBcImluZml4XCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBmaXhbY3VycmVudF9jbGFzc10gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJlbW92ZSggdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF0sIGZpeFtjdXJyZW50X2NsYXNzXS50eXBlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXS5sZW5ndGggPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggcHJpb3JpdHkudmFsdWUgPiAwICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXSApIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlLnRvU3RyaW5nKCldID0ge307XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCAhdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXSApIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXS5wdXNoKCB0eXBlLmlkICk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpIHx8IHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIikge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gaW5pdGlhbGl6YXRpb24vMVxyXG5cdFx0XHRcImluaXRpYWxpemF0aW9uLzFcIjogZnVuY3Rpb24odGhyZWFkLCBhdG9tLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dmFyIGdvYWwgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0b3B0aW9ucy5pbml0aWFsaXphdGlvbi5wdXNoKGdvYWwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRmxhZ3NcclxuXHRcdGZsYWc6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEJvdW5kZWQgbnVtYmVyc1xyXG5cdFx0XHRib3VuZGVkOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcInRydWVcIiApLCBuZXcgVGVybSggXCJmYWxzZVwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJ0cnVlXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTWF4aW11bSBpbnRlZ2VyXHJcblx0XHRcdG1heF9pbnRlZ2VyOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBOdW0oIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgTnVtKCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBNaW5pbXVtIGludGVnZXJcclxuXHRcdFx0bWluX2ludGVnZXI6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IE51bSggTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBOdW0oIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFJvdW5kaW5nIGZ1bmN0aW9uXHJcblx0XHRcdGludGVnZXJfcm91bmRpbmdfZnVuY3Rpb246IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwiZG93blwiICksIG5ldyBUZXJtKCBcInRvd2FyZF96ZXJvXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcInRvd2FyZF96ZXJvXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQ2hhcmFjdGVyIGNvbnZlcnNpb25cclxuXHRcdFx0Y2hhcl9jb252ZXJzaW9uOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcIm9uXCIgKSwgbmV3IFRlcm0oIFwib2ZmXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcIm9uXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiB0cnVlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBEZWJ1Z2dlclxyXG5cdFx0XHRkZWJ1Zzoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJvblwiICksIG5ldyBUZXJtKCBcIm9mZlwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJvZmZcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1heGltdW0gYXJpdHkgb2YgcHJlZGljYXRlc1xyXG5cdFx0XHRtYXhfYXJpdHk6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwidW5ib3VuZGVkXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcInVuYm91bmRlZFwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFVua3dub3cgcHJlZGljYXRlcyBiZWhhdmlvclxyXG5cdFx0XHR1bmtub3duOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcImVycm9yXCIgKSwgbmV3IFRlcm0oIFwiZmFpbFwiICksIG5ldyBUZXJtKCBcIndhcm5pbmdcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwiZXJyb3JcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIERvdWJsZSBxdW90ZXMgYmVoYXZpb3JcclxuXHRcdFx0ZG91YmxlX3F1b3Rlczoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJjaGFyc1wiICksIG5ldyBUZXJtKCBcImNvZGVzXCIgKSwgbmV3IFRlcm0oIFwiYXRvbVwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJjaGFyc1wiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gT2NjdXJzIGNoZWNrIGJlaGF2aW9yXHJcblx0XHRcdG9jY3Vyc19jaGVjazoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJmYWxzZVwiICksIG5ldyBUZXJtKCBcInRydWVcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwiZmFsc2VcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIERpYWxlY3RcclxuXHRcdFx0ZGlhbGVjdDoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJ0YXVcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwidGF1XCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVmVyc2lvblxyXG5cdFx0XHR2ZXJzaW9uX2RhdGE6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwidGF1XCIsIFtuZXcgTnVtKHZlcnNpb24ubWFqb3IsZmFsc2UpLCBuZXcgTnVtKHZlcnNpb24ubWlub3IsZmFsc2UpLCBuZXcgTnVtKHZlcnNpb24ucGF0Y2gsZmFsc2UpLCBuZXcgVGVybSh2ZXJzaW9uLnN0YXR1cyldICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJ0YXVcIiwgW25ldyBOdW0odmVyc2lvbi5tYWpvcixmYWxzZSksIG5ldyBOdW0odmVyc2lvbi5taW5vcixmYWxzZSksIG5ldyBOdW0odmVyc2lvbi5wYXRjaCxmYWxzZSksIG5ldyBUZXJtKHZlcnNpb24uc3RhdHVzKV0gKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTm9kZUpTXHJcblx0XHRcdG5vZGVqczoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJ0cnVlXCIgKSwgbmV3IFRlcm0oIFwiZmFsc2VcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIG5vZGVqc19mbGFnID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gQXJndW1lbnRzXHJcblx0XHRcdGFyZ3Y6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbm9kZWpzX2FyZ3VtZW50c10sXHJcblx0XHRcdFx0dmFsdWU6IG5vZGVqc19hcmd1bWVudHMsXHJcblx0XHRcdFx0Y2hhbmdlYmxlOiBmYWxzZVxyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVW5pZnlcclxuXHRcdHVuaWZ5OiBmdW5jdGlvbih0MSwgdDIsIG9jY3Vyc19jaGVjaykge1xyXG5cdFx0XHRvY2N1cnNfY2hlY2sgPSBvY2N1cnNfY2hlY2sgPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogb2NjdXJzX2NoZWNrO1xyXG5cdFx0XHR2YXIgbGVmdCA9IEFycmF5LmlzQXJyYXkodDEpID8gdDEgOiBbdDFdO1xyXG5cdFx0XHR2YXIgcmlnaHQgPSBBcnJheS5pc0FycmF5KHQyKSA/IHQyIDogW3QyXTtcclxuXHRcdFx0aWYobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aClcclxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0dmFyIHN1YnMgPSBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRcdHdoaWxlKGxlZnQubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdHZhciBzID0gbGVmdC5wb3AoKTtcclxuXHRcdFx0XHR2YXIgdCA9IHJpZ2h0LnBvcCgpO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocykpXHJcblx0XHRcdFx0XHRzID0gcy5hcHBseShzdWJzKTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHQpKVxyXG5cdFx0XHRcdFx0dCA9IHQuYXBwbHkoc3Vicyk7XHJcblx0XHRcdFx0Ly8gc2FtZSBvYmplY3RcclxuXHRcdFx0XHRpZihzID09IHQpXHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHQvLyBjb21wb3VuZCB0ZXJtc1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShzKSAmJiBwbC50eXBlLmlzX3Rlcm0odCkpIHtcclxuXHRcdFx0XHRcdGlmKHMuaW5kaWNhdG9yICE9PSB0LmluZGljYXRvcilcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSBzLmFyZ3MubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdFx0XHRcdGxlZnQucHVzaChzLmFyZ3NbaV0pO1xyXG5cdFx0XHRcdFx0XHRyaWdodC5wdXNoKHQuYXJnc1tpXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gbnVtYmVyc1xyXG5cdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX251bWJlcihzKSAmJiBwbC50eXBlLmlzX251bWJlcih0KSkge1xyXG5cdFx0XHRcdFx0aWYocy52YWx1ZSAhPT0gdC52YWx1ZSB8fCBzLmlzX2Zsb2F0ICE9PSB0LmlzX2Zsb2F0KVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHQvLyB2YXJpYWJsZSAtIHRlcm1cclxuXHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc192YXJpYWJsZShzKSkge1xyXG5cdFx0XHRcdFx0dCA9IHQuYXBwbHkoc3Vicyk7XHJcblx0XHRcdFx0XHQvLyB4ID0geFxyXG5cdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0KSAmJiBzLmlkID09PSB0LmlkKVxyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdC8vIG9jY3VycyBjaGVja1xyXG5cdFx0XHRcdFx0aWYob2NjdXJzX2NoZWNrID09PSB0cnVlICYmIGluZGV4T2YodC52YXJpYWJsZXMoKSwgcy5pZCkgIT09IC0xKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdC8vIGFub255bW91cyB2YXJpYWJsZVxyXG5cdFx0XHRcdFx0aWYocy5pZCAhPT0gXCJfXCIpXHJcblx0XHRcdFx0XHRcdHN1YnMuYWRkKHMuaWQsIHQpO1xyXG5cdFx0XHRcdC8vIHRlcm0gLSB2YXJpYWJsZVxyXG5cdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHQpKSB7XHJcblx0XHRcdFx0XHRsZWZ0LnB1c2godCk7XHJcblx0XHRcdFx0XHRyaWdodC5wdXNoKHMpO1xyXG5cdFx0XHRcdC8vIHVzZXItZGVmaW5lZCB0ZXJtc1xyXG5cdFx0XHRcdH0gZWxzZSBpZihzLnVuaWZ5ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHZhciB1c2VyX3N1YnMgPSBzLmFwcGx5KHN1YnMpLnVuaWZ5KHQuYXBwbHkoc3VicyksIG9jY3Vyc19jaGVjayk7XHJcblx0XHRcdFx0XHRpZih1c2VyX3N1YnMgPT0gbnVsbClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgaW4gdXNlcl9zdWJzLmxpbmtzKVxyXG5cdFx0XHRcdFx0XHRzdWJzLmFkZChpLCB1c2VyX3N1YnMubGlua3NbaV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHN1YnMuYXBwbHkoc3Vicyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIElzIHJlbmFtZVxyXG5cdFx0aXNfcmVuYW1lOiBmdW5jdGlvbihvYmoxLCBvYmoyLCBsaW5rcykge1xyXG5cdFx0XHRsaW5rcyA9IGxpbmtzIHx8IHt9O1xyXG5cdFx0XHRpZihvYmoxLmlzX3JlbmFtZSAmJiBvYmoyLmlzX3JlbmFtZSlcclxuXHRcdFx0XHRyZXR1cm4gb2JqMS5pc19yZW5hbWUob2JqMiwgbGlua3MpO1xyXG5cdFx0XHRlbHNlIGlmKG9iajEuZXF1YWxzICYmIG9iajIuZXF1YWxzKVxyXG5cdFx0XHRcdHJldHVybiBvYmoxLmVxdWFscyhvYmoyKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIENvbXBhcmVcclxuXHRcdGNvbXBhcmU6IGZ1bmN0aW9uKCBvYmoxLCBvYmoyICkge1xyXG5cdFx0XHR2YXIgdHlwZSA9IHBsLnR5cGUuY29tcGFyZSggb2JqMSwgb2JqMiApO1xyXG5cdFx0XHRyZXR1cm4gdHlwZSAhPT0gMCA/IHR5cGUgOiBvYmoxLmNvbXBhcmUoIG9iajIgKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEFyaXRobWV0aWMgY29tcGFyaXNvblxyXG5cdFx0YXJpdGhtZXRpY19jb21wYXJlOiBmdW5jdGlvbiggdGhyZWFkLCBvYmoxLCBvYmoyICkge1xyXG5cdFx0XHR2YXIgZXhwcjEgPSBvYmoxLmludGVycHJldCggdGhyZWFkICk7XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIGV4cHIxICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGV4cHIxO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBleHByMiA9IG9iajIuaW50ZXJwcmV0KCB0aHJlYWQgKTtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCBleHByMiApICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGV4cHIyO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZXhwcjEudmFsdWUgPCBleHByMi52YWx1ZSA/IC0xIDogKGV4cHIxLnZhbHVlID4gZXhwcjIudmFsdWUgPyAxIDogMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBPcGVyYXRlXHJcblx0XHRvcGVyYXRlOiBmdW5jdGlvbiggdGhyZWFkLCBvYmogKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX29wZXJhdG9yKCBvYmogKSApIHtcclxuXHRcdFx0XHR2YXIgb3AgPSBwbC50eXBlLmlzX29wZXJhdG9yKCBvYmogKTtcclxuXHRcdFx0XHR2YXIgYXJncyA9IFtdLCB2YWx1ZTtcclxuXHRcdFx0XHR2YXIgdHlwZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgb2JqLmFyZ3MubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IG9iai5hcmdzW2ldLmludGVycHJldCggdGhyZWFkICk7XHJcblx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wLnR5cGVfYXJncyAhPT0gbnVsbCAmJiB2YWx1ZS5pc19mbG9hdCAhPT0gb3AudHlwZV9hcmdzICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IudHlwZSggb3AudHlwZV9hcmdzID8gXCJmbG9hdFwiIDogXCJpbnRlZ2VyXCIsIHZhbHVlLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0YXJncy5wdXNoKCB2YWx1ZS52YWx1ZSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dHlwZSA9IHR5cGUgfHwgdmFsdWUuaXNfZmxvYXQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGFyZ3MucHVzaCggdGhyZWFkICk7XHJcblx0XHRcdFx0dmFsdWUgPSBwbC5hcml0aG1ldGljLmV2YWx1YXRpb25bb2JqLmluZGljYXRvcl0uZm4uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcclxuXHRcdFx0XHRpZihvYmouaW5kaWNhdG9yID09PSBcIl4vMlwiICYmICF0eXBlICYmIHZhbHVlICE9PSBwYXJzZUludCh2YWx1ZSwgMTApKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLnR5cGUoIFwiZmxvYXRcIiwgbmV3IE51bShhcmdzWzBdLGZhbHNlKSwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTtcclxuXHRcdFx0XHR0eXBlID0gb3AudHlwZV9yZXN1bHQgPT09IG51bGwgPyB0eXBlIDogb3AudHlwZV9yZXN1bHQ7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggdmFsdWUgKSApIHtcclxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHZhbHVlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgdmFsdWUgPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcImZsb2F0X292ZXJmbG93XCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCB0eXBlID09PSBmYWxzZSAmJiB0aHJlYWQuZ2V0X2ZsYWcoIFwiYm91bmRlZFwiICkuaWQgPT09IFwidHJ1ZVwiICYmICh2YWx1ZSA+IHRocmVhZC5nZXRfZmxhZyggXCJtYXhfaW50ZWdlclwiICkudmFsdWUgfHwgdmFsdWUgPCB0aHJlYWQuZ2V0X2ZsYWcoIFwibWluX2ludGVnZXJcIiApLnZhbHVlKSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcImludF9vdmVyZmxvd1wiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE51bSggdmFsdWUsIHR5cGUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLnR5cGUoIFwiZXZhbHVhYmxlXCIsIHN0cl9pbmRpY2F0b3Iob2JqLmluZGljYXRvciksIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEVycm9yc1xyXG5cdFx0ZXJyb3I6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIEV4aXN0ZW5jZSBlcnJvclxyXG5cdFx0XHRleGlzdGVuY2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmplY3QsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRpZiggdHlwZW9mIG9iamVjdCA9PT0gXCJzdHJpbmdcIiApXHJcblx0XHRcdFx0XHRvYmplY3QgPSBzdHJfaW5kaWNhdG9yKCBvYmplY3QgKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcImV4aXN0ZW5jZV9lcnJvclwiLCBbbmV3IFRlcm0oIHR5cGUgKSwgb2JqZWN0XSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFR5cGUgZXJyb3JcclxuXHRcdFx0dHlwZTogZnVuY3Rpb24oIGV4cGVjdGVkLCBmb3VuZCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwidHlwZV9lcnJvclwiLCBbbmV3IFRlcm0oIGV4cGVjdGVkICksIGZvdW5kXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIEluc3RhbnRhdGlvbiBlcnJvclxyXG5cdFx0XHRpbnN0YW50aWF0aW9uOiBmdW5jdGlvbiggaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwiaW5zdGFudGlhdGlvbl9lcnJvclwiICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVW5pbnN0YW50YXRpb24gZXJyb3JcclxuXHRcdFx0dW5pbnN0YW50aWF0aW9uOiBmdW5jdGlvbiggZm91bmQsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInVuaW5zdGFudGlhdGlvbl9lcnJvclwiLCBbbmV3IFRlcm0oIGZvdW5kICldICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRG9tYWluIGVycm9yXHJcblx0XHRcdGRvbWFpbjogZnVuY3Rpb24oIGV4cGVjdGVkLCBmb3VuZCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwiZG9tYWluX2Vycm9yXCIsIFtuZXcgVGVybSggZXhwZWN0ZWQgKSwgZm91bmRdKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBSZXByZXNlbnRhdGlvbiBlcnJvclxyXG5cdFx0XHRyZXByZXNlbnRhdGlvbjogZnVuY3Rpb24oIGZsYWcsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInJlcHJlc2VudGF0aW9uX2Vycm9yXCIsIFtuZXcgVGVybSggZmxhZyApXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFBlcm1pc3Npb24gZXJyb3JcclxuXHRcdFx0cGVybWlzc2lvbjogZnVuY3Rpb24oIG9wZXJhdGlvbiwgdHlwZSwgZm91bmQsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInBlcm1pc3Npb25fZXJyb3JcIiwgW25ldyBUZXJtKCBvcGVyYXRpb24gKSwgbmV3IFRlcm0oIHR5cGUgKSwgZm91bmRdICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRXZhbHVhdGlvbiBlcnJvclxyXG5cdFx0XHRldmFsdWF0aW9uOiBmdW5jdGlvbiggZXJyb3IsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcImV2YWx1YXRpb25fZXJyb3JcIiwgW25ldyBUZXJtKCBlcnJvciApXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFN5bnRheCBlcnJvclxyXG5cdFx0XHRzeW50YXg6IGZ1bmN0aW9uKCB0b2tlbiwgZXhwZWN0ZWQsIGxhc3QgKSB7XHJcblx0XHRcdFx0dG9rZW4gPSB0b2tlbiB8fCB7dmFsdWU6IFwiXCIsIGxpbmU6IDAsIGNvbHVtbjogMCwgbWF0Y2hlczogW1wiXCJdLCBzdGFydDogMH07XHJcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gbGFzdCAmJiB0b2tlbi5tYXRjaGVzLmxlbmd0aCA+IDAgPyB0b2tlbi5zdGFydCArIHRva2VuLm1hdGNoZXNbMF0ubGVuZ3RoIDogdG9rZW4uc3RhcnQ7XHJcblx0XHRcdFx0dmFyIGZvdW5kID0gbGFzdCA/IG5ldyBUZXJtKFwidG9rZW5fbm90X2ZvdW5kXCIpIDogbmV3IFRlcm0oXCJmb3VuZFwiLCBbbmV3IFRlcm0odG9rZW4udmFsdWUudG9TdHJpbmcoKSldKTtcclxuXHRcdFx0XHR2YXIgaW5mbyA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBUZXJtKCBcImxpbmVcIiwgW25ldyBOdW0odG9rZW4ubGluZSsxKV0gKSwgbmV3IFRlcm0oIFwiLlwiLCBbbmV3IFRlcm0oIFwiY29sdW1uXCIsIFtuZXcgTnVtKHBvc2l0aW9uKV0gKSwgbmV3IFRlcm0oIFwiLlwiLCBbZm91bmQsIG5ldyBUZXJtKCBcIltdXCIsIFtdICldICldICldICk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJzeW50YXhfZXJyb3JcIiwgW25ldyBUZXJtKCBleHBlY3RlZCApXSApLCBpbmZvXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU3ludGF4IGVycm9yIGJ5IHByZWRpY2F0ZVxyXG5cdFx0XHRzeW50YXhfYnlfcHJlZGljYXRlOiBmdW5jdGlvbiggZXhwZWN0ZWQsIGluZGljYXRvciApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInN5bnRheF9lcnJvclwiLCBbbmV3IFRlcm0oIGV4cGVjdGVkICkgXSApLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFdhcm5pbmdzXHJcblx0XHR3YXJuaW5nOiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTaW5nbGV0b24gdmFyaWFibGVzXHJcblx0XHRcdHNpbmdsZXRvbjogZnVuY3Rpb24oIHZhcmlhYmxlcywgcnVsZSwgbGluZSApIHtcclxuXHRcdFx0XHR2YXIgbGlzdCA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRmb3IoIHZhciBpID0gdmFyaWFibGVzLmxlbmd0aC0xOyBpID49IDA7IGktLSApXHJcblx0XHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IFZhcih2YXJpYWJsZXNbaV0pLCBsaXN0XSApO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJ3YXJuaW5nXCIsIFtuZXcgVGVybSggXCJzaW5nbGV0b25fdmFyaWFibGVzXCIsIFtsaXN0LCBzdHJfaW5kaWNhdG9yKHJ1bGUpXSksIG5ldyBUZXJtKFwiLlwiLFtuZXcgVGVybSggXCJsaW5lXCIsIFsgbmV3IE51bSggbGluZSwgZmFsc2UgKSBdKSwgbmV3IFRlcm0oXCJbXVwiKV0pXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRmFpbGVkIGdvYWxcclxuXHRcdFx0ZmFpbGVkX2dvYWw6IGZ1bmN0aW9uKCBnb2FsLCBsaW5lICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJ3YXJuaW5nXCIsIFtuZXcgVGVybSggXCJmYWlsZWRfZ29hbFwiLCBbZ29hbF0pLCBuZXcgVGVybShcIi5cIixbbmV3IFRlcm0oIFwibGluZVwiLCBbIG5ldyBOdW0oIGxpbmUsIGZhbHNlICkgXSksIG5ldyBUZXJtKFwiW11cIildKV0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEZvcm1hdCBvZiByZW5hbWVkIHZhcmlhYmxlc1xyXG5cdFx0Zm9ybWF0X3ZhcmlhYmxlOiBmdW5jdGlvbiggaWQsIHZhcmlhYmxlICkge1xyXG5cdFx0XHR2YXIgY2hhcmNvZGUgPSB2YXJpYWJsZSAmJiB2YXJpYWJsZS5sZW5ndGggPiAwID8gY29kZVBvaW50QXQodmFyaWFibGUsIDEpIDogMDtcclxuXHRcdFx0aWYodmFyaWFibGUgPT09IFwiX1wiIHx8IHZhcmlhYmxlICYmIHZhcmlhYmxlWzBdID09PSBcIl9cIiAmJiAoY2hhcmNvZGUgPT09IDk1IHx8IGNoYXJjb2RlID49IDY1ICYmIGNoYXJjb2RlIDw9IDkwKSlcclxuXHRcdFx0XHRyZXR1cm4gXCJfX1wiICsgaWQ7XHJcblx0XHRcdHJldHVybiBcIl9cIiArIGlkO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRm9ybWF0IG9mIGNvbXB1dGVkIGFuc3dlcnNcclxuXHRcdGZvcm1hdF9hbnN3ZXI6IGZ1bmN0aW9uKCBhbnN3ZXIsIHRocmVhZCwgb3B0aW9ucyApIHtcclxuXHRcdFx0aWYoIHRocmVhZCBpbnN0YW5jZW9mIFNlc3Npb24gKVxyXG5cdFx0XHRcdHRocmVhZCA9IHRocmVhZC50aHJlYWQ7XHJcblx0XHRcdHZhciBvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcclxuXHRcdFx0b3B0aW9ucy5zZXNzaW9uID0gdGhyZWFkID8gdGhyZWFkLnNlc3Npb24gOiB1bmRlZmluZWQ7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2Vycm9yKCBhbnN3ZXIgKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJ1bmNhdWdodCBleGNlcHRpb246IFwiICsgYW5zd2VyLmFyZ3NbMF0udG9TdHJpbmcob3B0aW9ucyk7XHJcblx0XHRcdH0gZWxzZSBpZiggYW5zd2VyID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJmYWxzZVwiO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGFuc3dlciA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJsaW1pdCBleGNlZWRlZFwiO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpID0gMDtcclxuXHRcdFx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc19zdWJzdGl0dXRpb24oIGFuc3dlciApICkge1xyXG5cdFx0XHRcdFx0dmFyIGRvbSA9IGFuc3dlci5kb21haW4oIHRydWUgKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGxpbmsgaW4gYW5zd2VyLmxpbmtzICl7XHJcblx0XHRcdFx0XHRcdGlmKCAhYW5zd2VyLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspICkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKGFuc3dlci5saW5rc1tsaW5rXSkgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHRcdFx0XHRcdFx0bGlua3NbYW5zd2VyLmxpbmtzW2xpbmtdLmlkXSA9IG5ldyBWYXIobGluayk7XHJcblx0XHRcdFx0XHRcdFx0YW5zd2VyID0gYW5zd2VyLmFwcGx5KCBuZXcgU3Vic3RpdHV0aW9uKGxpbmtzKSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRhbnN3ZXIgPSBhbnN3ZXIuZmlsdGVyKCBmdW5jdGlvbiggaWQsIHZhbHVlICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gIXBsLnR5cGUuaXNfdmFyaWFibGUoIHZhbHVlICkgfHxcclxuXHRcdFx0XHRcdFx0XHRwbC50eXBlLmlzX3ZhcmlhYmxlKCB2YWx1ZSApICYmIGFuc3dlci5oYXNfYXR0cmlidXRlcyggaWQgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4T2YoIGRvbSwgdmFsdWUuaWQgKSAhPT0gLTEgJiYgaWQgIT09IHZhbHVlLmlkO1xyXG5cdFx0XHRcdFx0fSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IoIHZhciBsaW5rIGluIGFuc3dlci5saW5rcyApIHtcclxuXHRcdFx0XHRcdGlmKCFhbnN3ZXIubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGFuc3dlci5saW5rc1tsaW5rXSApICYmIGxpbmsgPT09IGFuc3dlci5saW5rc1tsaW5rXS5pZCApIHtcclxuXHRcdFx0XHRcdFx0dmFyIGF0dHJzID0gYW5zd2VyLmF0dHJzW2xpbmtdO1xyXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBtb2R1bGUgaW4gYXR0cnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIWF0dHJzLmhhc093blByb3BlcnR5KG1vZHVsZSkpXHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRcdFx0aWYoIHN0ciAhPT0gXCJcIiApXHJcblx0XHRcdFx0XHRcdFx0XHRzdHIgKz0gXCIsIFwiO1xyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBcInB1dF9hdHRyKFwiICsgbGluayArIFwiLCBcIiArIG1vZHVsZSArIFwiLCBcIiArIGF0dHJzW21vZHVsZV0udG9TdHJpbmcob3B0aW9ucykgKyBcIilcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0aSsrO1xyXG5cdFx0XHRcdFx0XHRpZiggc3RyICE9PSBcIlwiIClcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gXCIsIFwiO1xyXG5cdFx0XHRcdFx0XHRzdHIgKz0gbGluay50b1N0cmluZyggb3B0aW9ucyApICsgXCIgPSBcIiArXHJcblx0XHRcdFx0XHRcdFx0YW5zd2VyLmxpbmtzW2xpbmtdLnRvU3RyaW5nKCBvcHRpb25zLCB7cHJpb3JpdHk6IFwiNzAwXCIsIGNsYXNzOiBcInhmeFwiLCBpbmRpY2F0b3I6IFwiPS8yXCJ9LCBcInJpZ2h0XCIgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIGkgPT09IDAgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJ0cnVlXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBzdHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBGbGF0dGVuIGRlZmF1bHQgZXJyb3JzXHJcblx0XHRmbGF0dGVuX2Vycm9yOiBmdW5jdGlvbiggZXJyb3IgKSB7XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc19lcnJvciggZXJyb3IgKSApIHJldHVybiBudWxsO1xyXG5cdFx0XHRlcnJvciA9IGVycm9yLmFyZ3NbMF07XHJcblx0XHRcdHZhciBvYmogPSB7fTtcclxuXHRcdFx0b2JqLnR5cGUgPSBlcnJvci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRvYmoudGhyb3duID0gb2JqLnR5cGUgPT09IFwic3ludGF4X2Vycm9yXCIgPyBudWxsIDogZXJyb3IuYXJnc1sxXS5pZDtcclxuXHRcdFx0b2JqLmV4cGVjdGVkID0gbnVsbDtcclxuXHRcdFx0b2JqLmZvdW5kID0gbnVsbDtcclxuXHRcdFx0b2JqLnJlcHJlc2VudGF0aW9uID0gbnVsbDtcclxuXHRcdFx0b2JqLmV4aXN0ZW5jZSA9IG51bGw7XHJcblx0XHRcdG9iai5leGlzdGVuY2VfdHlwZSA9IG51bGw7XHJcblx0XHRcdG9iai5saW5lID0gbnVsbDtcclxuXHRcdFx0b2JqLmNvbHVtbiA9IG51bGw7XHJcblx0XHRcdG9iai5wZXJtaXNzaW9uX29wZXJhdGlvbiA9IG51bGw7XHJcblx0XHRcdG9iai5wZXJtaXNzaW9uX3R5cGUgPSBudWxsO1xyXG5cdFx0XHRvYmouZXZhbHVhdGlvbl90eXBlID0gbnVsbDtcclxuXHRcdFx0aWYoIG9iai50eXBlID09PSBcInR5cGVfZXJyb3JcIiB8fCBvYmoudHlwZSA9PT0gXCJkb21haW5fZXJyb3JcIiApIHtcclxuXHRcdFx0XHRvYmouZXhwZWN0ZWQgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0b2JqLmZvdW5kID0gZXJyb3IuYXJnc1swXS5hcmdzWzFdLnRvU3RyaW5nKCk7XHJcblx0XHRcdH0gZWxzZSBpZiggb2JqLnR5cGUgPT09IFwic3ludGF4X2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0aWYoIGVycm9yLmFyZ3NbMV0uaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0b2JqLmV4cGVjdGVkID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0b2JqLmZvdW5kID0gZXJyb3IuYXJnc1sxXS5hcmdzWzFdLmFyZ3NbMV0uYXJnc1swXTtcclxuXHRcdFx0XHRcdG9iai5mb3VuZCA9IG9iai5mb3VuZC5pZCA9PT0gXCJ0b2tlbl9ub3RfZm91bmRcIiA/IG9iai5mb3VuZC5pZCA6IG9iai5mb3VuZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0b2JqLmxpbmUgPSBlcnJvci5hcmdzWzFdLmFyZ3NbMF0uYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHRcdG9iai5jb2x1bW4gPSBlcnJvci5hcmdzWzFdLmFyZ3NbMV0uYXJnc1swXS5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRvYmoudGhyb3duID0gZXJyb3IuYXJnc1sxXS5pZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiggb2JqLnR5cGUgPT09IFwicGVybWlzc2lvbl9lcnJvclwiICkge1xyXG5cdFx0XHRcdG9iai5mb3VuZCA9IGVycm9yLmFyZ3NbMF0uYXJnc1syXS50b1N0cmluZygpO1xyXG5cdFx0XHRcdG9iai5wZXJtaXNzaW9uX29wZXJhdGlvbiA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0XHRvYmoucGVybWlzc2lvbl90eXBlID0gZXJyb3IuYXJnc1swXS5hcmdzWzFdLmlkO1xyXG5cdFx0XHR9IGVsc2UgaWYoIG9iai50eXBlID09PSBcImV2YWx1YXRpb25fZXJyb3JcIiApIHtcclxuXHRcdFx0XHRvYmouZXZhbHVhdGlvbl90eXBlID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHR9IGVsc2UgaWYoIG9iai50eXBlID09PSBcInJlcHJlc2VudGF0aW9uX2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0b2JqLnJlcHJlc2VudGF0aW9uID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHR9IGVsc2UgaWYoIG9iai50eXBlID09PSBcImV4aXN0ZW5jZV9lcnJvclwiICkge1xyXG5cdFx0XHRcdG9iai5leGlzdGVuY2UgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMV0udG9TdHJpbmcoKTtcclxuXHRcdFx0XHRvYmouZXhpc3RlbmNlX3R5cGUgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIENyZWF0ZSBuZXcgc2Vzc2lvblxyXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiggbGltaXQgKSB7XHJcblx0XHRcdHJldHVybiBuZXcgcGwudHlwZS5TZXNzaW9uKCBsaW1pdCApO1xyXG5cdFx0fVxyXG5cdFx0XHJcblx0fTtcclxuXHJcblx0Ly8gQnVpbHQtaW4gcHJlZGljYXRlc1xyXG5cdHBsLmJ1aWx0aW4gPSBuZXcgTW9kdWxlKFwic3lzdGVtXCIsIHtcclxuXHJcblx0XHQvLyBURVJNIEFORCBHT0FMIEVYUEFOU0lPTlxyXG5cclxuXHRcdC8vIGdvYWxfZXhwYW5zaW9uLzJcclxuXHRcdFwiZ29hbF9leHBhbnNpb24vMlwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiLFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIildKSxuZXcgVGVybShcIixcIiwgW25ldyBWYXIoXCJYX1wiKSxuZXcgVmFyKFwiWV9cIildKV0pLCBuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSxuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWVwiKV0pXSldKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSldKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCI7XCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKV0pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFZhcihcIlhfXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSksIG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pLG5ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJZXCIpXSldKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcIi0+XCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKV0pLG5ldyBUZXJtKFwiLT5cIiwgW25ldyBWYXIoXCJYX1wiKSxuZXcgVmFyKFwiWV9cIildKV0pLCBuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSxuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJZX1wiKSxuZXcgVmFyKFwiWVwiKV0pXSldKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSldKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYXRjaFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllcIiksbmV3IFZhcihcIlpcIildKSxuZXcgVGVybShcImNhdGNoXCIsIFtuZXcgVmFyKFwiWF9cIiksbmV3IFZhcihcIllcIiksbmV3IFZhcihcIlpfXCIpXSldKSwgbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlpcIiksbmV3IFZhcihcIlpfXCIpXSksbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWl9cIiksbmV3IFZhcihcIlpcIildKV0pXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJYX1wiKSxuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJaXCIpLG5ldyBWYXIoXCJaX1wiKV0pXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiXFxcXCtcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJcXFxcK1wiLCBbbmV3IFZhcihcIlhfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIm5vbnZhclwiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJvbmNlXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwib25jZVwiLCBbbmV3IFZhcihcIlhfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIm5vbnZhclwiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWlwiKV0pLG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJaXCIpXSldKSwgbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcInNldG9mXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWlwiKV0pLG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJaXCIpXSldKSwgbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImJhZ29mXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWlwiKV0pLG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJaXCIpXSldKSwgbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWF9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwibm9udmFyXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKSxuZXcgVmFyKFwiQTNcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTNcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIiksbmV3IFZhcihcIkEzXCIpLG5ldyBWYXIoXCJBNFwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBM1wiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNFwiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpLG5ldyBWYXIoXCJBM1wiKSxuZXcgVmFyKFwiQTRcIiksbmV3IFZhcihcIkE1XCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEzXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE0XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE1XCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKSxuZXcgVmFyKFwiQTNcIiksbmV3IFZhcihcIkE0XCIpLG5ldyBWYXIoXCJBNVwiKSxuZXcgVmFyKFwiQTZcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTNcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTRcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTVcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTZcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIiksbmV3IFZhcihcIkEzXCIpLG5ldyBWYXIoXCJBNFwiKSxuZXcgVmFyKFwiQTVcIiksbmV3IFZhcihcIkE2XCIpLG5ldyBWYXIoXCJBN1wiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBM1wiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBN1wiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblxyXG5cclxuXHRcdC8vIFNZU1RFTSBQUkVESUNBVEVTICgkKVxyXG5cclxuXHRcdC8vICckcHVzaF9nbG9iYWxfc3RhY2snLzJcclxuXHRcdFwiJHB1c2hfZ2xvYmFsX3N0YWNrLzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgc3RhY2sgPSBhdG9tLmFyZ3NbMF0sIHZhbHVlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShzdGFjaykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wdXNoX2dsb2JhbF9zdGFjayhzdGFjay5pZCwgdmFsdWUpO1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyAnJGZsdXNoX2dsb2JhbF9zdGFjaycvM1xyXG5cdFx0XCIkZmx1c2hfZ2xvYmFsX3N0YWNrLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgc3RhY2sgPSBhdG9tLmFyZ3NbMF0sIGxpc3QgPSBhdG9tLmFyZ3NbMV0sIHRhaWwgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHN0YWNrKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRocmVhZC5mbHVzaF9nbG9iYWxfc3RhY2soc3RhY2suaWQsIHRhaWwpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFtsaXN0LCB2YWx1ZXNdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyAnJGZyZWVfdmFyaWFibGVfc2V0Jy8zXHJcblx0XHRcIiRmcmVlX3ZhcmlhYmxlX3NldC8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGdvYWxfaW4gPSBhdG9tLmFyZ3NbMF0sIGdvYWxfb3V0ID0gYXRvbS5hcmdzWzFdLCB2YXJzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgYnYgPSBbXTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSBnb2FsX2luO1xyXG5cdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiXi8yXCIpIHtcclxuXHRcdFx0XHRidiA9IGJ2LmNvbmNhdChwb2ludGVyLmFyZ3NbMF0udmFyaWFibGVzKCkpO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGd2ID0gcG9pbnRlci52YXJpYWJsZXMoKTtcclxuXHRcdFx0dmFyIGZ2ID0gYXJyYXlUb0xpc3QobWFwKGRpZmZlcmVuY2UoZ3YsIGJ2KSwgZnVuY3Rpb24odikge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVmFyKHYpO1xyXG5cdFx0XHR9KSk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtnb2FsX291dCwgcG9pbnRlcl0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3ZhcnMsIGZ2XSkgXHJcblx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdClcclxuXHRcdFx0XSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vICckbWVtYmVyJy8yXHJcblx0XHRcIiRtZW1iZXIvMlwiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRtZW1iZXJcIiwgW25ldyBwbC50eXBlLlZhcihcIlhcIiksbmV3IHBsLnR5cGUuVGVybShcIi5cIiwgW25ldyBwbC50eXBlLlZhcihcIlhcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pXSksIG51bGwpLFxyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkbWVtYmVyXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJYXCIpLG5ldyBwbC50eXBlLlRlcm0oXCIuXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJfXCIpLG5ldyBwbC50eXBlLlZhcihcIlhzXCIpXSldKSwgbmV3IHBsLnR5cGUuVGVybShcIiRtZW1iZXJcIiwgW25ldyBwbC50eXBlLlZhcihcIlhcIiksbmV3IHBsLnR5cGUuVmFyKFwiWHNcIildKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gJyRiaW5kX2JhZ29mX2tleXMvMicvMlxyXG5cdFx0XCIkYmluZF9iYWdvZl9rZXlzLzJcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkYmluZF9iYWdvZl9rZXlzXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSwgbnVsbCksXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRiaW5kX2JhZ29mX2tleXNcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIuXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiS2V5XCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSxuZXcgcGwudHlwZS5WYXIoXCJCYWdcIildKSxuZXcgcGwudHlwZS5WYXIoXCJWYXJzXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwidGVybV92YXJpYWJsZXNcIiwgW25ldyBwbC50eXBlLlZhcihcIktleVwiKSxuZXcgcGwudHlwZS5WYXIoXCJWYXJzXCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSxuZXcgcGwudHlwZS5UZXJtKFwiJGJpbmRfYmFnb2Zfa2V5c1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiQmFnXCIpLG5ldyBwbC50eXBlLlZhcihcIlZhcnNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyAnJGZpbmRhbGwnLzRcclxuXHRcdFwiJGZpbmRhbGwvNFwiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRmaW5kYWxsXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTBcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIiksbmV3IHBsLnR5cGUuVmFyKFwiSW5zdGFuY2VzXCIpLG5ldyBwbC50eXBlLlZhcihcIlRhaWxcIildKSwgbmV3IHBsLnR5cGUuVGVybShcIjtcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiY29weV90ZXJtXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUwXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKV0pXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJjYWxsXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiY29weV90ZXJtXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTFcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUyXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkcHVzaF9nbG9iYWxfc3RhY2tcIiwgW25ldyBwbC50eXBlLlZhcihcIlZhclwiKSxuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTJcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiZmFsc2VcIiwgW10pXSldKV0pXSksbmV3IHBsLnR5cGUuVGVybShcIiRmbHVzaF9nbG9iYWxfc3RhY2tcIiwgW25ldyBwbC50eXBlLlZhcihcIlZhclwiKSxuZXcgcGwudHlwZS5WYXIoXCJJbnN0YW5jZXNcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGFpbFwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vICckYmFnb2YnLzNcclxuXHRcdFwiJGJhZ29mLzNcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkYmFnb2ZcIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlclwiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRmcmVlX3ZhcmlhYmxlX3NldFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIl5cIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwwXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIiksbmV3IHBsLnR5cGUuVmFyKFwiRlZcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImZpbmRhbGxcIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJGVlwiKSxuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKV0pLG5ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJGJpbmRfYmFnb2Zfa2V5c1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJrZXlncm91cFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlHcm91cHNcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImtleXNvcnRcIiwgW25ldyBwbC50eXBlLlZhcihcIktleUdyb3Vwc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlTb3J0ZWRcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiJG1lbWJlclwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIkZWXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlclwiKV0pLG5ldyBwbC50eXBlLlZhcihcIktleVNvcnRlZFwiKV0pXSldKV0pXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gJyRzZXRvZicvM1xyXG5cdFx0XCIkc2V0b2YvM1wiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRzZXRvZlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2VyXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJGZyZWVfdmFyaWFibGVfc2V0XCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiXlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIildKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJGVlwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiZmluZGFsbFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIkZWXCIpLG5ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkYmluZF9iYWdvZl9rZXlzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImtleWdyb3VwXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlZhcihcIktleUdyb3Vwc1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwia2V5c29ydFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiS2V5R3JvdXBzXCIpLG5ldyBwbC50eXBlLlZhcihcIktleVNvcnRlZFwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJG1lbWJlclwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIkZWXCIpLG5ldyBwbC50eXBlLlZhcihcIlVuc29ydGVkXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiS2V5U29ydGVkXCIpXSksbmV3IHBsLnR5cGUuVGVybShcInNvcnRcIiwgW25ldyBwbC50eXBlLlZhcihcIlVuc29ydGVkXCIpLG5ldyBwbC50eXBlLlZhcihcIkFuc3dlclwiKV0pXSldKV0pXSldKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyAnJGlmLzMnXHJcblx0XHRcIiRpZi8zXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJGlmXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJJZlwiKSxuZXcgcGwudHlwZS5WYXIoXCJUaGVuXCIpLG5ldyBwbC50eXBlLlZhcihcIkVsc2VcIildKSwgbmV3IHBsLnR5cGUuVGVybShcIjtcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiY2FsbFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiSWZcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRwdXNoX2dsb2JhbF9zdGFja1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiU3RhY2tcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCJjYWxsXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUaGVuXCIpXSldKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJGZsdXNoX2dsb2JhbF9zdGFja1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiU3RhY2tcIiksbmV3IHBsLnR5cGUuVGVybShcIltdXCIsIFtdKSxuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pXSksbmV3IHBsLnR5cGUuVGVybShcImNhbGxcIiwgW25ldyBwbC50eXBlLlZhcihcIkVsc2VcIildKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHJcblx0XHQvLyBBVFRSSUJVVEVEIFZBUklBQkxFU1xyXG5cdFx0XHJcblx0XHQvL3B1dF9hdHRyLzNcclxuXHRcdFwicHV0X2F0dHIvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHZhcmlhYmxlID0gYXRvbS5hcmdzWzBdLCBtb2R1bGUgPSBhdG9tLmFyZ3NbMV0sIHZhbHVlID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUodmFyaWFibGUpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJ2YXJpYWJsZVwiLCB2YXJpYWJsZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20obW9kdWxlKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBtb2R1bGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3VicyA9IHBvaW50LnN1YnN0aXR1dGlvbi5zZXRfYXR0cmlidXRlKCB2YXJpYWJsZS5pZCwgbW9kdWxlLCB2YWx1ZSApO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UobnVsbCksIHN1YnMsIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZ2V0X2F0dHIvM1xyXG5cdFx0XCJnZXRfYXR0ci8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdmFyaWFibGUgPSBhdG9tLmFyZ3NbMF0sIG1vZHVsZSA9IGF0b20uYXJnc1sxXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSh2YXJpYWJsZSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcInZhcmlhYmxlXCIsIHZhcmlhYmxlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbShtb2R1bGUpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG1vZHVsZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBhdHRyID0gcG9pbnQuc3Vic3RpdHV0aW9uLmdldF9hdHRyaWJ1dGUoIHZhcmlhYmxlLmlkLCBtb2R1bGUgKTtcclxuXHRcdFx0XHRpZiggYXR0ciApIHtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKFwiPVwiLCBbdmFsdWUsIGF0dHJdKSApLFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0XHJcblx0XHQvLyBJTlBVVCBBTkQgT1VUUFVUXHJcblx0XHRcclxuXHRcdC8vIG9wLzNcclxuXHRcdFwib3AvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHByaW9yaXR5ID0gYXRvbS5hcmdzWzBdLCB0eXBlID0gYXRvbS5hcmdzWzFdLCBvcGVyYXRvcnMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfYXRvbShvcGVyYXRvcnMpKVxyXG5cdFx0XHRcdG9wZXJhdG9ycyA9IG5ldyBUZXJtKFwiLlwiLCBbb3BlcmF0b3JzLCBuZXcgVGVybShcIltdXCIpXSk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcmlvcml0eSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHR5cGUgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBwcmlvcml0eSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggdHlwZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHR5cGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wZXJhdG9ycztcclxuXHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdHZhciBvcGVyYXRvciA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggb3BlcmF0b3IgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggb3BlcmF0b3IgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBwcmlvcml0eS52YWx1ZSA8IDAgfHwgcHJpb3JpdHkudmFsdWUgPiAxMjAwICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9wcmlvcml0eVwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcIixcIiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm1vZGlmeVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwie31cIiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwiW11cIiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwifFwiICYmIHByaW9yaXR5LnZhbHVlICE9PSAwICYmIChwcmlvcml0eS52YWx1ZSA8IDEwMDEgfHwgdHlwZS5pZC5sZW5ndGggIT09IDMgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggW1wiZnlcIiwgXCJmeFwiLCBcInlmXCIsIFwieGZcIiwgXCJ4ZnhcIiwgXCJ5ZnhcIiwgXCJ4ZnlcIl0uaW5kZXhPZiggdHlwZS5pZCApID09PSAtMSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3Jfc3BlY2lmaWVyXCIsIHR5cGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dmFyIGZpeCA9IHsgcHJlZml4OiBudWxsLCBpbmZpeDogbnVsbCwgcG9zdGZpeDogbnVsbCB9O1xyXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBwIGluIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9ycy5oYXNPd25Qcm9wZXJ0eShwKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNsYXNzZXMgPSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twXVtvcGVyYXRvci5pZF07XHJcblx0XHRcdFx0XHRcdFx0aWYoIGNsYXNzZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJmeFwiICkgIT09IC0xICkgeyBmaXgucHJlZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcImZ5XCIgKSAhPT0gLTEgKSB7IGZpeC5wcmVmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcImZ5XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZcIiApICE9PSAtMSApIHsgZml4LnBvc3RmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInhmXCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieWZcIiApICE9PSAtMSApIHsgZml4LnBvc3RmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInlmXCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZ5XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZ5XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieWZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieWZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudF9jbGFzcztcclxuXHRcdFx0XHRcdFx0c3dpdGNoKCB0eXBlLmlkICkge1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJmeVwiOiBjYXNlIFwiZnhcIjogY3VycmVudF9jbGFzcyA9IFwicHJlZml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgXCJ5ZlwiOiBjYXNlIFwieGZcIjogY3VycmVudF9jbGFzcyA9IFwicG9zdGZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjdXJyZW50X2NsYXNzID0gXCJpbmZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihmaXguaW5maXggJiYgY3VycmVudF9jbGFzcyA9PT0gXCJwb3N0Zml4XCIgfHwgZml4LnBvc3RmaXggJiYgY3VycmVudF9jbGFzcyA9PT0gXCJpbmZpeFwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBmaXhbY3VycmVudF9jbGFzc10gKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZW1vdmUoIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdLCBmaXhbY3VycmVudF9jbGFzc10udHlwZSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZiggcHJpb3JpdHkudmFsdWUgPiAwICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoICF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV0gKSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZS50b1N0cmluZygpXSA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoICF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdICkgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXS5wdXNoKCB0eXBlLmlkICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpIHx8IHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIikge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGN1cnJlbnRfb3AvM1xyXG5cdFx0XCJjdXJyZW50X29wLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBwcmlvcml0eSA9IGF0b20uYXJnc1swXSwgc3BlY2lmaWVyID0gYXRvbS5hcmdzWzFdLCBvcGVyYXRvciA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHByaW9yaXR5ICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggcHJpb3JpdHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggcHJpb3JpdHkgKSAmJiAoIHByaW9yaXR5LnZhbHVlIDwgMCB8fCBwcmlvcml0eS52YWx1ZSA+IDEyMDAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9wcmlvcml0eVwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzcGVjaWZpZXIgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzcGVjaWZpZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBzcGVjaWZpZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2F0b20oIHNwZWNpZmllciApICYmIGluZGV4T2YoIFtcImZ5XCIsIFwiZnhcIiwgXCJ5ZlwiLCBcInhmXCIsIFwieGZ4XCIsIFwieWZ4XCIsIFwieGZ5XCJdLCBzcGVjaWZpZXIuaWQgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3Jfc3BlY2lmaWVyXCIsIHNwZWNpZmllciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcGVyYXRvciApICYmICFwbC50eXBlLmlzX2F0b20oIG9wZXJhdG9yICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IoIHZhciBwIGluIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzIClcclxuXHRcdFx0XHRcdGZvciggdmFyIG8gaW4gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcF0gKVxyXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3BdW29dLmxlbmd0aDsgaSsrIClcclxuXHRcdFx0XHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybSggXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybSggXCI9XCIsIFtuZXcgTnVtKCBwLCBmYWxzZSApLCBwcmlvcml0eV0gKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybSggXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twXVtvXVtpXSwgW10gKSwgc3BlY2lmaWVyXSApLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIG8sIFtdICksIG9wZXJhdG9yXSApXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XSApXHJcblx0XHRcdFx0XHRcdFx0XHRcdF0gKVxyXG5cdFx0XHRcdFx0XHRcdFx0KSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0KSApO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBwb2ludHMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcclxuXHJcblxyXG5cdFx0Ly8gTE9HSUMgQU5EIENPTlRST0wgU1RSVUNUVVJFU1xyXG5cdFxyXG5cdFx0Ly8gOy8yIChkaXNqdW5jdGlvbilcclxuXHRcdFwiOy8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGxlZnQgPSBhdG9tLmFyZ3NbMF0sIHJpZ2h0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgY29udGV4dF9sZWZ0ID0gbGVmdC5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgZnJlZV9sZWZ0ID0gbGVmdC5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBsZWZ0LmFyZ3NbMV0gOiBsZWZ0O1xyXG5cdFx0XHQvLyBpZiB0aGVuIGVsc2VcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGZyZWVfbGVmdCkgJiYgZnJlZV9sZWZ0LmluZGljYXRvciA9PT0gXCItPi8yXCIpIHtcclxuXHRcdFx0XHR2YXIgY29uZCA9IGxlZnQuaW5kaWNhdG9yID09PSBcIjovMlwiID8gbmV3IFRlcm0oXCI6XCIsIFtjb250ZXh0X2xlZnQsIG5ldyBUZXJtKFwiY2FsbFwiLCBbZnJlZV9sZWZ0LmFyZ3NbMF1dKV0pIDogZnJlZV9sZWZ0LmFyZ3NbMF07XHJcblx0XHRcdFx0dmFyIHRoZW4gPSBsZWZ0LmluZGljYXRvciA9PT0gXCI6LzJcIiA/IG5ldyBUZXJtKFwiOlwiLCBbY29udGV4dF9sZWZ0LCBmcmVlX2xlZnQuYXJnc1sxXV0pIDogZnJlZV9sZWZ0LmFyZ3NbMV07XHJcblx0XHRcdFx0dmFyIG90aGVyd2lzZSA9IHJpZ2h0O1xyXG5cdFx0XHRcdHZhciBnb2FsX2ZzdCA9IHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybSggXCIsXCIsIFtjb25kLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiIVwiKSwgdGhlbl0pXSApICk7XHJcblx0XHRcdFx0dmFyIGdvYWxfc25kID0gcG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKFwiIVwiKSwgb3RoZXJ3aXNlXSkpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShnb2FsX2ZzdCwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCksXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUoZ29hbF9zbmQsIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpXHJcblx0XHRcdFx0XSk7XHJcblx0XHRcdC8vIHNvZnQtY3V0XHJcblx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX3Rlcm0oZnJlZV9sZWZ0KSAmJiBmcmVlX2xlZnQuaW5kaWNhdG9yID09PSBcIiotPi8yXCIpIHtcclxuXHRcdFx0XHR2YXIgY29uZCA9IGxlZnQuaW5kaWNhdG9yID09PSBcIjovMlwiID8gbmV3IFRlcm0oXCI6XCIsIFtjb250ZXh0X2xlZnQsIGZyZWVfbGVmdC5hcmdzWzBdXSkgOiBmcmVlX2xlZnQuYXJnc1swXTtcclxuXHRcdFx0XHR2YXIgdGhlbiA9IGxlZnQuaW5kaWNhdG9yID09PSBcIjovMlwiID8gbmV3IFRlcm0oXCI6XCIsIFtjb250ZXh0X2xlZnQsIGZyZWVfbGVmdC5hcmdzWzFdXSkgOiBmcmVlX2xlZnQuYXJnc1sxXTtcclxuXHRcdFx0XHR2YXIgb3RoZXJ3aXNlID0gcmlnaHQ7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIiRpZlwiLCBbY29uZCwgdGhlbiwgb3RoZXJ3aXNlXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdC8vIG90aGVyd2lzZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UobGVmdCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpLFxyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShyaWdodCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpXHJcblx0XHRcdFx0XSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vICEvMCAoY3V0KVxyXG5cdFx0XCIhLzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBwYXJlbnRfY3V0LCBsYXN0X2N1dCwgc3RhdGVzID0gW107XHJcblx0XHRcdHBhcmVudF9jdXQgPSBwb2ludDtcclxuXHRcdFx0bGFzdF9jdXQgPSBudWxsO1xyXG5cdFx0XHR3aGlsZSggcGFyZW50X2N1dC5wYXJlbnQgIT09IG51bGwgJiYgcGFyZW50X2N1dC5wYXJlbnQuZ29hbC5zZWFyY2goIGF0b20gKSApIHtcclxuXHRcdFx0XHRsYXN0X2N1dCA9IHBhcmVudF9jdXQ7XHJcblx0XHRcdFx0cGFyZW50X2N1dCA9IHBhcmVudF9jdXQucGFyZW50O1xyXG5cdFx0XHRcdGlmKHBhcmVudF9jdXQuZ29hbCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIHNlbGVjdGVkID0gcGFyZW50X2N1dC5nb2FsLnNlbGVjdCgpO1xyXG5cdFx0XHRcdFx0aWYoc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuaW5kaWNhdG9yID09PSBcIjovMlwiKVxyXG5cdFx0XHRcdFx0XHRzZWxlY3RlZCA9IHNlbGVjdGVkLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRpZiggc2VsZWN0ZWQgJiYgc2VsZWN0ZWQuaWQgPT09IFwiY2FsbFwiICYmIHNlbGVjdGVkLnNlYXJjaChhdG9tKSApIHtcclxuXHRcdFx0XHRcdFx0cGFyZW50X2N1dCA9IGxhc3RfY3V0O1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIHNldHVwX2NhbGxfY2xlYW51cCA9IG51bGw7XHJcblx0XHRcdGZvciggdmFyIGkgPSB0aHJlYWQucG9pbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHR2YXIgc3RhdGUgPSB0aHJlYWQucG9pbnRzW2ldO1xyXG5cdFx0XHRcdHZhciBub2RlID0gc3RhdGUucGFyZW50O1xyXG5cdFx0XHRcdHdoaWxlKCBub2RlICE9PSBudWxsICYmIG5vZGUgIT09IHBhcmVudF9jdXQucGFyZW50ICkge1xyXG5cdFx0XHRcdFx0bm9kZSA9IG5vZGUucGFyZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggbm9kZSA9PT0gbnVsbCAmJiBub2RlICE9PSBwYXJlbnRfY3V0LnBhcmVudCApXHJcblx0XHRcdFx0XHRzdGF0ZXMucHVzaCggc3RhdGUgKTtcclxuXHRcdFx0XHRlbHNlIGlmKHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF9nb2FsKVxyXG5cdFx0XHRcdFx0c2V0dXBfY2FsbF9jbGVhbnVwID0gc3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX2dvYWxcclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJlYWQucG9pbnRzID0gc3RhdGVzLnJldmVyc2UoKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2Uoc2V0dXBfY2FsbF9jbGVhbnVwKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0pO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gXFwrIChuZWdhdGlvbilcclxuXHRcdFwiXFxcXCsvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdvYWwgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBnb2FsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY2FsbGFibGUoIGdvYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2FsbGFibGVcIiwgZ29hbCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFRSQU5TUEFSRU5UIFZFUlNJT04gT0YgVEhFIE5FR0FUSU9OXHJcblx0XHRcdFx0Lyp2YXIgbmVnX3RocmVhZDtcclxuXHRcdFx0XHRpZihwb2ludC5uZWdhdGlvbl90aHJlYWQpIHtcclxuXHRcdFx0XHRcdG5lZ190aHJlYWQgPSBwb2ludC5uZWdhdGlvbl90aHJlYWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG5lZ190aHJlYWQgPSBuZXcgVGhyZWFkKCB0aHJlYWQuc2Vzc2lvbiApO1xyXG5cdFx0XHRcdFx0bmVnX3RocmVhZC5hZGRfZ29hbCggZ29hbCApO1xyXG5cdFx0XHRcdFx0cG9pbnQubmVnYXRpb25fdGhyZWFkID0gbmVnX3RocmVhZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bmVnX3RocmVhZC5hbnN3ZXIoIGZ1bmN0aW9uKCBhbnN3ZXIgKSB7XHJcblx0XHRcdFx0XHRpZihhbnN3ZXIgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfZXJyb3IoIGFuc3dlciApKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggYW5zd2VyLmFyZ3NbMF0gKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihhbnN3ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtwb2ludF0gKTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmN1cnJlbnRfbGltaXQgPSAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLmFnYWluKCBhbnN3ZXIgIT09IG51bGwgKTtcclxuXHRcdFx0XHR9ICk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7Ki9cclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyAnXFwrJyhYKSA6LSBjYWxsKFgpLCAhLCBmYWlsLlxyXG5cdFx0XHRcdC8vICdcXCsnKF8pLlxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiLFwiLCBbIG5ldyBUZXJtKCBcImNhbGxcIiwgW2dvYWxdICksIG5ldyBUZXJtKCBcIiFcIiwgW10gKSBdICksIG5ldyBUZXJtKCBcImZhaWxcIiwgW10gKSBdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApLFxyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG51bGwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXHJcblx0XHRcdFx0XSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyAtPi8yIChpbXBsaWNhdGlvbilcclxuXHRcdFwiLT4vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNvbmQgPSBhdG9tLmFyZ3NbMF0sIHRoZW4gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBnb2FsID0gcG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsXCIsIFtjb25kXSksXHJcblx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIiFcIiksIHRoZW5dKVxyXG5cdFx0XHRdKSk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBnb2FsLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vICotPi8yIChzb2Z0LWN1dClcclxuXHRcdFwiKi0+LzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY29uZCA9IGF0b20uYXJnc1swXSwgdGhlbiA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIGdvYWwgPSBwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRuZXcgVGVybShcImNhbGxcIiwgW2NvbmRdKSwgdGhlbl0pKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShnb2FsLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KV0pO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gZmFpbC8wXHJcblx0XHRcImZhaWwvMFwiOiBmdW5jdGlvbiggXzEsIF8yLCBfMyApIHt9LFxyXG5cdFx0XHJcblx0XHQvLyBmYWxzZS8wXHJcblx0XHRcImZhbHNlLzBcIjogZnVuY3Rpb24oIF8xLCBfMiwgXzMgKSB7fSxcclxuXHRcdFxyXG5cdFx0Ly8gdHJ1ZS8wXHJcblx0XHRcInRydWUvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgXyApIHtcclxuXHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjYWxsLzEuLjhcclxuXHRcdFwiY2FsbC8xXCI6IGNhbGxOKDEpLFxyXG5cdFx0XCJjYWxsLzJcIjogY2FsbE4oMiksXHJcblx0XHRcImNhbGwvM1wiOiBjYWxsTigzKSxcclxuXHRcdFwiY2FsbC80XCI6IGNhbGxOKDQpLFxyXG5cdFx0XCJjYWxsLzVcIjogY2FsbE4oNSksXHJcblx0XHRcImNhbGwvNlwiOiBjYWxsTig2KSxcclxuXHRcdFwiY2FsbC83XCI6IGNhbGxOKDcpLFxyXG5cdFx0XCJjYWxsLzhcIjogY2FsbE4oOCksXHJcblx0XHRcclxuXHRcdC8vIG9uY2UvMVxyXG5cdFx0XCJvbmNlLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBnb2FsID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCJjYWxsXCIsIFtnb2FsXSApLCBuZXcgVGVybSggXCIhXCIsIFtdICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gZm9yYWxsLzJcclxuXHRcdFwiZm9yYWxsLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBnZW5lcmF0ZSA9IGF0b20uYXJnc1swXSwgdGVzdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiXFxcXCtcIiwgW25ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcImNhbGxcIiwgW2dlbmVyYXRlXSApLCBuZXcgVGVybSggXCJcXFxcK1wiLCBbbmV3IFRlcm0oIFwiY2FsbFwiLCBbdGVzdF0gKV0gKV0gKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyByZXBlYXQvMFxyXG5cdFx0XCJyZXBlYXQvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgXyApIHtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbnVsbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICksIHBvaW50XSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBFWENFUFRJT05TXHJcblx0XHRcclxuXHRcdC8vIHRocm93LzFcclxuXHRcdFwidGhyb3cvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGVycm9yID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGVycm9yKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKHRocmVhZC5sZXZlbC5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhyZWFkLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlID0gdGhyZWFkLnBvaW50c1tpXTtcclxuXHRcdFx0XHRcdGlmKHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF9jYXRjaCkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucG9pbnRzID0gW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJjYXRjaFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF9jYXRjaCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IFZhcihcIl9cIiksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidGhyb3dcIiwgW2Vycm9yXSlcclxuXHRcdFx0XHRcdFx0XHRcdF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ0aHJvd1wiLCBbZXJyb3JdKVxyXG5cdFx0XHRcdFx0XHRcdF0pLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHQpXTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihlcnJvcik7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNhdGNoLzNcclxuXHRcdFwiY2F0Y2gvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBnb2FsID0gYXRvbS5hcmdzWzBdLCBjYXRjaGVyID0gYXRvbS5hcmdzWzFdLCByZWNvdmVyID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgbnRocmVhZDtcclxuXHRcdFx0aWYoIXBvaW50LmNhdGNoKSB7XHJcblx0XHRcdFx0bnRocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0XHRcdG50aHJlYWQuZGVidWdnZXIgPSB0aHJlYWQuZGVidWdnZXI7XHJcblx0XHRcdFx0bnRocmVhZC5mb3JtYXRfc3VjY2VzcyA9IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5zdWJzdGl0dXRpb247IH07XHJcblx0XHRcdFx0bnRocmVhZC5mb3JtYXRfZXJyb3IgPSBmdW5jdGlvbihzdGF0ZSkgeyByZXR1cm4gc3RhdGUuZ29hbDsgfTtcclxuXHRcdFx0XHRudGhyZWFkLmFkZF9nb2FsKGdvYWwsIHRydWUsIHBvaW50KTtcclxuXHRcdFx0XHRwb2ludC5jYXRjaCA9IG50aHJlYWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bnRocmVhZCA9IHBvaW50LmNhdGNoO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSkge1xyXG5cdFx0XHRcdFx0dmFyIG9jY3Vyc19jaGVjayA9IHRocmVhZC5nZXRfZmxhZyhcIm9jY3Vyc19jaGVja1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCI7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcclxuXHRcdFx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeShhbnN3ZXIuYXJnc1swXSwgY2F0Y2hlciwgb2NjdXJzX2NoZWNrKTtcclxuXHRcdFx0XHRcdGlmKG1ndSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24gPSBwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkobWd1KTtcclxuXHRcdFx0XHRcdFx0c3RhdGUuZ29hbCA9IHBvaW50LmdvYWwucmVwbGFjZShyZWNvdmVyKS5hcHBseShtZ3UpO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5wYXJlbnQgPSBwb2ludDtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoYW5zd2VyLmFyZ3NbMF0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZihhbnN3ZXIgIT09IGZhbHNlICYmIGFuc3dlciAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlID0gYW5zd2VyID09PSBudWxsID8gW10gOiBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwuYXBwbHkoYW5zd2VyKS5yZXBsYWNlKG51bGwpLFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoYW5zd2VyKSxcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGUsIHBvaW50XSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGFuc3dlciA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3BvaW50XSk7XHJcblx0XHRcdFx0XHRpZih0aHJlYWQuaGFzX2xpbWl0KVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQuY3VycmVudF9saW1pdCA9IDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5hZ2FpbihhbnN3ZXIgIT09IG51bGwpO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRudGhyZWFkLmFuc3dlcihjYWxsYmFjayk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjYWxsX2NsZWFudXAvMlxyXG5cdFx0XCJjYWxsX2NsZWFudXAvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjYWxsID0gYXRvbS5hcmdzWzBdLCBjbGVhbnVwID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGNhbGwpIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoY2xlYW51cCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2FsbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNhbGwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbGVhbnVwKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xlYW51cCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgbnRocmVhZCwgY2FsbGJhY2s7XHJcblx0XHRcdFx0aWYocG9pbnQuaGFzT3duUHJvcGVydHkoXCJzZXR1cF9jYWxsX2NsZWFudXBfdGhyZWFkXCIpKSB7XHJcblx0XHRcdFx0XHRudGhyZWFkID0gcG9pbnQuc2V0dXBfY2FsbF9jbGVhbnVwX3RocmVhZDtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gcG9pbnQuc2V0dXBfY2FsbF9jbGVhbnVwX2NhbGxiYWNrO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKFwiY2FsbFwiLCBbY2FsbF0pO1xyXG5cdFx0XHRcdFx0bnRocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0XHRcdFx0bnRocmVhZC5hZGRfZ29hbChnb2FsLCB0cnVlLCBwb2ludCk7XHJcblx0XHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRcdFx0XHRpZihhbnN3ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF90aHJlYWQgPSBudGhyZWFkO1xyXG5cdFx0XHRcdFx0XHRcdHN0YXRlLnNldHVwX2NhbGxfY2xlYW51cF9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoYW5zd2VyID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjbGVhbnVwX2FuZF9mYWlsID0gbmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiY2FsbFwiLCBbY2xlYW51cF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJmYWlsXCIpXHJcblx0XHRcdFx0XHRcdFx0XSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKGNsZWFudXBfYW5kX2ZhaWwpLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19lcnJvcihhbnN3ZXIpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNsZWFudXBfYW5kX3Rocm93ID0gbmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiY2FsbFwiLCBbY2xlYW51cF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0YW5zd2VyXHJcblx0XHRcdFx0XHRcdFx0XSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKGNsZWFudXBfYW5kX3Rocm93KSxcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGVdKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRpZihudGhyZWFkLnBvaW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiY2FsbFwiLCBbY2xlYW51cF0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdCkuYXBwbHkoYW5zd2VyKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KGFuc3dlciksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzdGF0ZTEgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwuYXBwbHkoYW5zd2VyKS5yZXBsYWNlKG51bGwpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoYW5zd2VyKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUyID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUyLnNldHVwX2NhbGxfY2xlYW51cF90aHJlYWQgPSBudGhyZWFkO1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUyLnNldHVwX2NhbGxfY2xlYW51cF9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUyLnNldHVwX2NhbGxfY2xlYW51cF9nb2FsID0gY2xlYW51cC5hcHBseShhbnN3ZXIpO1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUyLnNldHVwX2NhbGxfY2xlYW51cF9jYXRjaCA9IGNsZWFudXA7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGUxLCBzdGF0ZTJdKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dGhyZWFkLmFnYWluKCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG50aHJlYWQuYW5zd2VyKGNhbGxiYWNrKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzZXR1cF9jYWxsX2NsZWFudXAvM1xyXG5cdFx0XCJzZXR1cF9jYWxsX2NsZWFudXAvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBzZXR1cCA9IGF0b20uYXJnc1swXSwgY2FsbCA9IGF0b20uYXJnc1sxXSwgY2xlYW51cCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShzZXR1cCkgfHwgcGwudHlwZS5pc192YXJpYWJsZShjYWxsKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKGNsZWFudXApKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKHNldHVwKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgc2V0dXAsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjYWxsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2FsbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsZWFudXApKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbGVhbnVwLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJvbmNlXCIsIFtzZXR1cF0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcImNhbGxfY2xlYW51cFwiLCBbY2FsbCwgY2xlYW51cF0pXHJcblx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVU5JRklDQVRJT05cclxuXHRcdFxyXG5cdFx0Ly8gPS8yICh1bmlmaWNhdGlvbilcclxuXHRcdFwiPS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb2NjdXJzX2NoZWNrID0gdGhyZWFkLmdldF9mbGFnKCBcIm9jY3Vyc19jaGVja1wiICkuaW5kaWNhdG9yID09PSBcInRydWUvMFwiO1xyXG5cdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcclxuXHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSwgb2NjdXJzX2NoZWNrICk7XHJcblx0XHRcdGlmKCBtZ3UgIT09IG51bGwgKSB7XHJcblx0XHRcdFx0c3RhdGUuZ29hbCA9IHBvaW50LmdvYWwuYXBwbHkoIG1ndSApLnJlcGxhY2UoIG51bGwgKTtcclxuXHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24gPSBwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoIG1ndSApO1xyXG5cdFx0XHRcdHN0YXRlLnBhcmVudCA9IHBvaW50O1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbc3RhdGVdICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHVuaWZ5X3dpdGhfb2NjdXJzX2NoZWNrLzJcclxuXHRcdFwidW5pZnlfd2l0aF9vY2N1cnNfY2hlY2svMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcblx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0sIHRydWUgKTtcclxuXHRcdFx0aWYoIG1ndSAhPT0gbnVsbCApIHtcclxuXHRcdFx0XHRzdGF0ZS5nb2FsID0gcG9pbnQuZ29hbC5hcHBseSggbWd1ICkucmVwbGFjZSggbnVsbCApO1xyXG5cdFx0XHRcdHN0YXRlLnN1YnN0aXR1dGlvbiA9IHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseSggbWd1ICk7XHJcblx0XHRcdFx0c3RhdGUucGFyZW50ID0gcG9pbnQ7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtzdGF0ZV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gXFw9LzJcclxuXHRcdFwiXFxcXD0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9jY3Vyc19jaGVjayA9IHRocmVhZC5nZXRfZmxhZyggXCJvY2N1cnNfY2hlY2tcIiApLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIjtcclxuXHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSwgb2NjdXJzX2NoZWNrICk7XHJcblx0XHRcdGlmKCBtZ3UgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHN1YnN1bWVzX3Rlcm0vMlxyXG5cdFx0LypcclxuXHRcdHN1YnN1bWVzX3Rlcm0oR2VuZXJhbCwgU3BlY2lmaWMpIDotXHJcblx0XHRcdFxcKyBcXCsgKFxyXG5cdFx0XHR0ZXJtX3ZhcmlhYmxlcyhTcGVjaWZpYywgVmFyczEpLFxyXG5cdFx0XHR1bmlmeV93aXRoX29jY3Vyc19jaGVjayhHZW5lcmFsLCBTcGVjaWZpYyksXHJcblx0XHRcdHRlcm1fdmFyaWFibGVzKFZhcnMxLCBWYXJzMiksXHJcblx0XHRcdFZhcnMxID09IFZhcnMyXHJcblx0XHQpLlxyXG5cdFx0Ki9cclxuXHRcdFwic3Vic3VtZXNfdGVybS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ2VuZXJhbCA9IGF0b20uYXJnc1swXSwgc3BlY2lmaWMgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciB2YXJzMSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0dmFyIHZhcnMyID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIlxcXFwrXCIsIFtcclxuXHRcdFx0XHRcdG5ldyBUZXJtKFwiXFxcXCtcIiwgW1xyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidGVybV92YXJpYWJsZXNcIiwgW3NwZWNpZmljLCB2YXJzMV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInVuaWZ5X3dpdGhfb2NjdXJzX2NoZWNrXCIsIFtnZW5lcmFsLCBzcGVjaWZpY10pLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ0ZXJtX3ZhcmlhYmxlc1wiLCBbdmFyczEsIHZhcnMyXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPT1cIiwgW3ZhcnMxLCB2YXJzMl0pXHJcblx0XHRcdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0pO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQUxMIFNPTFVUSU9OU1xyXG5cclxuXHRcdC8vIGZpbmRhbGwvM1xyXG5cdFx0XCJmaW5kYWxsLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBhdG9tLmFyZ3NbMF0sIGdvYWwgPSBhdG9tLmFyZ3NbMV0sIGluc3RhbmNlcyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIHRhaWwgPSBuZXcgVGVybShcIltdXCIsIFtdKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJmaW5kYWxsXCIsIFt0ZW1wbGF0ZSwgZ29hbCwgaW5zdGFuY2VzLCB0YWlsXSkpLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGZpbmRhbGwvNFxyXG5cdFx0XCJmaW5kYWxsLzRcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBhdG9tLmFyZ3NbMF0sIGdvYWwgPSBhdG9tLmFyZ3NbMV0sIGluc3RhbmNlcyA9IGF0b20uYXJnc1syXSwgdGFpbCA9IGF0b20uYXJnc1szXTtcclxuXHRcdFx0dmFyIHByb3Blcl9nb2FsID0gZ29hbDtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGdvYWwpICYmIGdvYWwuaW5kaWNhdG9yID09PSBcIjovMlwiKVxyXG5cdFx0XHRcdHByb3Blcl9nb2FsID0gZ29hbC5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3Blcl9nb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShwcm9wZXJfZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGdvYWwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShpbnN0YW5jZXMpICYmICFwbC50eXBlLmlzX2xpc3QoaW5zdGFuY2VzKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibGlzdFwiLCBpbnN0YW5jZXMsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZSh0YWlsKSAmJiAhcGwudHlwZS5pc19saXN0KHRhaWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIHRhaWwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIiRmaW5kYWxsXCIsIFt0ZW1wbGF0ZSwgZ29hbCwgaW5zdGFuY2VzLCB0YWlsXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGJhZ29mLzNcclxuXHRcdFwiYmFnb2YvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZW1wbGF0ZSA9IGF0b20uYXJnc1swXSwgZ29hbCA9IGF0b20uYXJnc1sxXSwgaW5zdGFuY2VzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGdvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGdvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBnb2FsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5zdGFuY2VzKSAmJiAhcGwudHlwZS5pc19saXN0KGluc3RhbmNlcykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGluc3RhbmNlcywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiJGJhZ29mXCIsIFt0ZW1wbGF0ZSwgZ29hbCwgaW5zdGFuY2VzXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc2V0b2YvM1xyXG5cdFx0XCJzZXRvZi8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlbXBsYXRlID0gYXRvbS5hcmdzWzBdLCBnb2FsID0gYXRvbS5hcmdzWzFdLCBpbnN0YW5jZXMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGdvYWwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShpbnN0YW5jZXMpICYmICFwbC50eXBlLmlzX2xpc3QoaW5zdGFuY2VzKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZShcImxpc3RcIiwgaW5zdGFuY2VzLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIkc2V0b2ZcIiwgW3RlbXBsYXRlLCBnb2FsLCBpbnN0YW5jZXNdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVEVSTSBDUkVBVElPTiBBTkQgREVDT01QT1NJVElPTlxyXG5cdFx0XHJcblx0XHQvLyBmdW5jdG9yLzNcclxuXHRcdFwiZnVuY3Rvci8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3VicztcclxuXHRcdFx0dmFyIHRlcm0gPSBhdG9tLmFyZ3NbMF0sIG5hbWUgPSBhdG9tLmFyZ3NbMV0sIGFyaXR5ID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggdGVybSApICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBuYW1lICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggYXJpdHkgKSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGFyaXR5ICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggYXJpdHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBhdG9tLmFyZ3NbMl0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbmFtZSApICYmICFwbC50eXBlLmlzX2F0b21pYyggbmFtZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggdGVybSApICYmICFwbC50eXBlLmlzX2F0b20oIG5hbWUgKSAmJiBwbC50eXBlLmlzX2ludGVnZXIoIGFyaXR5ICkgJiYgYXJpdHkudmFsdWUgPiAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHRlcm0gKSAmJiBwbC50eXBlLmlzX2ludGVnZXIoIGFyaXR5ICkgJiYgYXJpdHkudmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBhdG9tLmFyZ3NbMl0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0ZXJtICkgKSB7XHJcblx0XHRcdFx0aWYoIGF0b20uYXJnc1syXS52YWx1ZSA+PSAwICkge1xyXG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgYXJpdHkudmFsdWU7IGkrKyApXHJcblx0XHRcdFx0XHRcdGFyZ3MucHVzaCggdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpICk7XHJcblx0XHRcdFx0XHR2YXIgZnVuY3RvciA9IHBsLnR5cGUuaXNfbnVtYmVyKCBuYW1lICkgPyBuYW1lIDogbmV3IFRlcm0oIG5hbWUuaWQsIGFyZ3MgKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3Rlcm0sIGZ1bmN0b3JdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaWQgPSBwbC50eXBlLmlzX251bWJlciggdGVybSApID8gdGVybSA6IG5ldyBUZXJtKCB0ZXJtLmlkLCBbXSApO1xyXG5cdFx0XHRcdHZhciBsZW5ndGggPSBwbC50eXBlLmlzX251bWJlciggdGVybSApID8gbmV3IE51bSggMCwgZmFsc2UgKSA6IG5ldyBOdW0oIHRlcm0uYXJncy5sZW5ndGgsIGZhbHNlICk7XHJcblx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCI9XCIsIFtpZCwgbmFtZV0gKSwgbmV3IFRlcm0oIFwiPVwiLCBbbGVuZ3RoLCBhcml0eV0gKV0gKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXJnLzNcclxuXHRcdFwiYXJnLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBhdG9tLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBhdG9tLmFyZ3NbMF0udmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBhdG9tLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jb21wb3VuZCggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNvbXBvdW5kXCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBuID0gYXRvbS5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdGlmKCBuID4gMCAmJiBuIDw9IGF0b20uYXJnc1sxXS5hcmdzLmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oIFwiPVwiLCBbYXRvbS5hcmdzWzFdLmFyZ3Nbbi0xXSwgYXRvbS5hcmdzWzJdXSApO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA9Li4vMiAodW5pdilcclxuXHRcdFwiPS4uLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0O1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1sxXSApXHJcblx0XHRcdHx8IHBsLnR5cGUuaXNfbm9uX2VtcHR5X2xpc3QoIGF0b20uYXJnc1sxXSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1sxXS5hcmdzWzBdICkpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2Z1bGx5X2xpc3QoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICYmIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm9uX2VtcHR5X2xpc3RcIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGF0b20uYXJnc1swXSApICYmIGF0b20uYXJnc1swXS5hcmdzLmxlbmd0aCA+IDAgKSB7XHJcblx0XHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IGF0b20uYXJnc1swXS5hcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbYXRvbS5hcmdzWzBdLmFyZ3NbaV0sIGxpc3RdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IFRlcm0oIGF0b20uYXJnc1swXS5pZCApLCBsaXN0XSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbYXRvbS5hcmdzWzBdLCBuZXcgVGVybSggXCJbXVwiICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xpc3QsIGF0b20uYXJnc1sxXV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHZhciBhcmdzID0gW107XHJcblx0XHRcdFx0bGlzdCA9IGF0b20uYXJnc1sxXS5hcmdzWzFdO1xyXG5cdFx0XHRcdHdoaWxlKCBsaXN0LmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdGFyZ3MucHVzaCggbGlzdC5hcmdzWzBdICk7XHJcblx0XHRcdFx0XHRsaXN0ID0gbGlzdC5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMCAmJiBwbC50eXBlLmlzX2NvbXBvdW5kKCBhdG9tLmFyZ3NbMV0uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBhdG9tLmFyZ3NbMV0uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggYXJncy5sZW5ndGggPiAwICYmIChwbC50eXBlLmlzX2NvbXBvdW5kKCBhdG9tLmFyZ3NbMV0uYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfbnVtYmVyKCBhdG9tLmFyZ3NbMV0uYXJnc1swXSApKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20uYXJnc1sxXS5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKCBhcmdzLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbYXRvbS5hcmdzWzFdLmFyZ3NbMF0sIGF0b20uYXJnc1swXV0sIHBvaW50ICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIGF0b20uYXJnc1sxXS5hcmdzWzBdLmlkLCBhcmdzICksIGF0b20uYXJnc1swXV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjb3B5X3Rlcm0vMlxyXG5cdFx0XCJjb3B5X3Rlcm0vMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBvcmlnaW5hbF90ZXJtID0gYXRvbS5hcmdzWzBdLCByZW5hbWVkX3Rlcm0gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdHZhciBuZXdfdGVybSA9IG9yaWdpbmFsX3Rlcm0ucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFtyZW5hbWVkX3Rlcm0sIG5ld190ZXJtXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnQpXHJcblx0XHRcdFx0XVxyXG5cdFx0XHQpO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gdGVybV92YXJpYWJsZXMvMlxyXG5cdFx0XCJ0ZXJtX3ZhcmlhYmxlcy8yXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwidGVybV92YXJpYWJsZXNcIiwgW25ldyBwbC50eXBlLlZhcihcIlRlcm1cIiksbmV3IHBsLnR5cGUuVmFyKFwiVmFyc1wiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwidGVybV92YXJpYWJsZXNcIiwgW25ldyBwbC50eXBlLlZhcihcIlRlcm1cIiksbmV3IHBsLnR5cGUuVmFyKFwiVmFyc1wiKSxuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHRlcm1fdmFyaWFibGVzLzNcclxuXHRcdFwidGVybV92YXJpYWJsZXMvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZXJtID0gYXRvbS5hcmdzWzBdLCB2YXJzID0gYXRvbS5hcmdzWzFdLCB0YWlsID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfZnVsbHlfbGlzdCggdmFycyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIHZhcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgbGlzdCA9IGFycmF5VG9MaXN0KG1hcChudWIodGVybS52YXJpYWJsZXMoKSksIGZ1bmN0aW9uKHYpIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVmFyKHYpO1xyXG5cdFx0XHRcdH0pLCB0YWlsKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbdmFycywgbGlzdF0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIG51bWJlcnZhcnMvM1xyXG5cdFx0XCJudW1iZXJ2YXJzLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVybSA9IGF0b20uYXJnc1swXSwgc3RhcnQgPSBhdG9tLmFyZ3NbMV0sIGVuZCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShzdGFydCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfaW50ZWdlcihzdGFydCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgc3RhcnQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShlbmQpICYmICFwbC50eXBlLmlzX2ludGVnZXIoZW5kKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCBlbmQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHZhcmlhYmxlcyA9IG51Yih0ZXJtLnZhcmlhYmxlcygpKTtcclxuXHRcdFx0XHR2YXIgdmFsdWUgPSBzdGFydC52YWx1ZTtcclxuXHRcdFx0XHR2YXIgdW5pZl9ib2R5ID0gbmV3IFRlcm0oXCJ0cnVlXCIpO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHVuaWZfYm9keSA9IG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFZhcih2YXJpYWJsZXNbaV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiJFZBUlwiLCBbbmV3IE51bSh2YWx1ZSwgZmFsc2UpXSldKSxcclxuXHRcdFx0XHRcdFx0XHR1bmlmX2JvZHldKTtcclxuXHRcdFx0XHRcdHZhbHVlKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciB1bmlmX2VuZCA9IG5ldyBUZXJtKFwiPVwiLCBbZW5kLCBuZXcgTnVtKHZhbHVlLCBmYWxzZSldKTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGVuZCkgfHwgZW5kLnZhbHVlID09PSB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbdW5pZl9ib2R5LCB1bmlmX2VuZF0pKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQ0xBVVNFIFJFVFJJRVZBTCBBTkQgSU5GT1JNQVRJT05cclxuXHRcdFxyXG5cdFx0Ly8gY2xhdXNlLzJcclxuXHRcdFwiY2xhdXNlLzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgaGVhZCA9IGF0b20uYXJnc1swXSwgYm9keSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZCA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oaGVhZCkgJiYgaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKGhlYWQuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIGhlYWQuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGhlYWQgPSBoZWFkLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShib2R5KSAmJiAhcGwudHlwZS5pc19jYWxsYWJsZShib2R5KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgYm9keSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKGhlYWQuaW5kaWNhdG9yID09PSBcIiwvMlwiIHx8IHRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwiYWNjZXNzXCIsIFwicHJpdmF0ZV9wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSAmJiBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSkge1xyXG5cdFx0XHRcdGlmKGdldF9tb2R1bGUuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBydWxlID0gZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl1baV07XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0XHRcdHJ1bGUgPSBydWxlLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHRcdFx0XHRpZihydWxlLmJvZHkgPT09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0cnVsZS5ib2R5ID0gbmV3IFRlcm0oXCJ0cnVlXCIpO1xyXG5cdFx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtydWxlLmhlYWQsIGhlYWRdKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3J1bGUuYm9keSwgYm9keV0pXHJcblx0XHRcdFx0XHRcdF0pO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKGdvYWwpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcImFjY2Vzc1wiLCBcInByaXZhdGVfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY3VycmVudF9wcmVkaWNhdGUvMVxyXG5cdFx0XCJjdXJyZW50X3ByZWRpY2F0ZS8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGluZGljYXRvciA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZDtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGluZGljYXRvcikgJiYgaW5kaWNhdG9yLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20oaW5kaWNhdG9yLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBpbmRpY2F0b3IuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gaW5kaWNhdG9yLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aW5kaWNhdG9yID0gaW5kaWNhdG9yLmFyZ3NbMV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gXCJ1c2VyXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yKSAmJiAoIXBsLnR5cGUuaXNfY29tcG91bmQoaW5kaWNhdG9yKSB8fCBpbmRpY2F0b3IuaW5kaWNhdG9yICE9PSBcIi8vMlwiKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKCBcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgaW5kaWNhdG9yLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvciApICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvci5hcmdzWzBdKSAmJiAhcGwudHlwZS5pc19hdG9tKGluZGljYXRvci5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKCBcImF0b21cIiwgaW5kaWNhdG9yLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IpICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvci5hcmdzWzFdKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKGluZGljYXRvci5hcmdzWzFdKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCBpbmRpY2F0b3IuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvcikgJiYgcGwudHlwZS5pc19pbnRlZ2VyKGluZGljYXRvci5hcmdzWzFdKSAmJiBpbmRpY2F0b3IuYXJnc1sxXS52YWx1ZSA8IDApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuZG9tYWluKFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGluZGljYXRvci5hcmdzWzFdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBwcm9wIGluIGdldF9tb2R1bGUucnVsZXMpIHtcclxuXHRcdFx0XHRcdFx0aWYoIWdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdHZhciBwcmVkaWNhdGUgPSBzdHJfaW5kaWNhdG9yKHByb3ApO1xyXG5cdFx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKFwiPVwiLCBbcHJlZGljYXRlLCBpbmRpY2F0b3JdKTtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShnb2FsKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY3VycmVudF9tb2R1bGUvMVxyXG5cdFx0XCJjdXJyZW50X21vZHVsZS8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUobW9kdWxlX2lkKSAmJiAhcGwudHlwZS5pc19hdG9tKG1vZHVsZV9pZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImF0b21cIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUobW9kdWxlX2lkKSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBwcm9wIGluIHRocmVhZC5zZXNzaW9uLm1vZHVsZXMpIHtcclxuXHRcdFx0XHRcdFx0aWYoIXRocmVhZC5zZXNzaW9uLm1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFttb2R1bGVfaWQsIG5ldyBUZXJtKHByb3ApXSkpLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKHRocmVhZC5zZXNzaW9uLm1vZHVsZXMuaGFzT3duUHJvcGVydHkobW9kdWxlX2lkLmlkKSlcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwcmVkaWNhdGVfcHJvcGVydHkvMlxyXG5cdFx0XCJwcmVkaWNhdGVfcHJvcGVydHkvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBoZWFkID0gYXRvbS5hcmdzWzBdLCBwcm9wZXJ0eSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZDtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGhlYWQpICYmIGhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShoZWFkLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBoZWFkLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IGhlYWQuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRoZWFkID0gaGVhZC5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpICYmICFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpICYmICFwbC50eXBlLmlzX3ByZWRpY2F0ZV9wcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuZG9tYWluKFwicHJlZGljYXRlX3Byb3BlcnR5XCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gbW9kdWxlX2lkID8gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdIDogdGhyZWFkLnNlc3Npb24ubW9kdWxlcy51c2VyO1xyXG5cdFx0XHRcdHZhciBwb2ludHMgPSBbXTtcclxuXHRcdFx0XHQvLyBhbGwgcHJlZGljYXRlc1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdC8vIGJ1aWx0LWluIHByZWRpY2F0ZXMgKGJ1aWx0X2luICsgc3RhdGljICsgbmF0aXZlX2NvZGUgKyBtZXRhX3ByZWRpY2F0ZT8pXHJcblx0XHRcdFx0XHRpZighbW9kdWxlX2lkKSB7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgcHJvcCBpbiBwbC5idWlsdGluLnJ1bGVzKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLmJ1aWx0aW4ucnVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaW5kaWNhdG9yID0gc3RyX2luZGljYXRvcihwcm9wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpbmRpY2F0b3IuYXJnc1sxXS52YWx1ZTsgaSsrKVxyXG5cdFx0XHRcdFx0XHRcdFx0YXJncy5wdXNoKHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHVuaWZfaGVhZCA9IG5ldyBUZXJtKGluZGljYXRvci5hcmdzWzBdLmlkLCBhcmdzKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudF9wcm9wZXJ0aWVzID0gW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJzdGF0aWNcIiksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImJ1aWx0X2luXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJuYXRpdmVfY29kZVwiKVxyXG5cdFx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0XHRcdFx0aWYocGwuYnVpbHRpbi5tZXRhX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm1ldGFfcHJlZGljYXRlXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cGwuYnVpbHRpbi5tZXRhX3ByZWRpY2F0ZXNbcHJvcF1cclxuXHRcdFx0XHRcdFx0XHRcdF0pKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBhbGwgcHJlZGljYXRlcywgb25lIHByb3BlcnR5IC8gYWxsIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY3VycmVudF9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSB8fCBjdXJyZW50X3Byb3BlcnRpZXNbaV0uaW5kaWNhdG9yID09PSBwcm9wZXJ0eS5pbmRpY2F0b3IpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2gobmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtoZWFkLCB1bmlmX2hlYWRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcHJvcGVydHksIGN1cnJlbnRfcHJvcGVydGllc1tpXV0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIHVzZXItZGVmaW5lZCBwcmVkaWNhdGVzXHJcblx0XHRcdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIHByb3AgaW4gZ2V0X21vZHVsZS5ydWxlcykge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFnZXRfbW9kdWxlLnJ1bGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGluZGljYXRvciA9IHN0cl9pbmRpY2F0b3IocHJvcCk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaW5kaWNhdG9yLmFyZ3NbMV0udmFsdWU7IGkrKylcclxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MucHVzaCh0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCkpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB1bmlmX2hlYWQgPSBuZXcgVGVybShpbmRpY2F0b3IuYXJnc1swXS5pZCwgYXJncyk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfcHJvcGVydGllcyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKHByb3AsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcImR5bmFtaWNcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwic3RhdGljXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW3Byb3BdIGluc3RhbmNlb2YgRnVuY3Rpb24pXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm5hdGl2ZV9jb2RlXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0aHJlYWQuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZShwcm9wLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJtdWx0aWZpbGVcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGdldF9tb2R1bGUubWV0YV9wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KHByb3ApKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJtZXRhX3ByZWRpY2F0ZVwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdGdldF9tb2R1bGUubWV0YV9wcmVkaWNhdGVzW3Byb3BdXHJcblx0XHRcdFx0XHRcdFx0XHRdKSk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYWxsIHByZWRpY2F0ZXMsIG9uZSBwcm9wZXJ0eSAvIGFsbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGN1cnJlbnRfcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkgfHwgY3VycmVudF9wcm9wZXJ0aWVzW2ldLmluZGljYXRvciA9PT0gcHJvcGVydHkuaW5kaWNhdG9yKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50cy5wdXNoKG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbaGVhZCwgdW5pZl9oZWFkXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3Byb3BlcnR5LCBjdXJyZW50X3Byb3BlcnRpZXNbaV1dKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gb25lIHByZWRpY2F0ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgYnVpbHRpbiA9ICFtb2R1bGVfaWQgJiYgcGwudHlwZS5pc19idWlsdGluKGhlYWQpO1xyXG5cdFx0XHRcdFx0dmFyIHByZWRpY2F0ZSA9IGJ1aWx0aW4gPyBwbC5idWlsdGluLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA6IGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZSA9IGJ1aWx0aW4gPyBwbC5idWlsdGluIDogZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRcdGlmKHByZWRpY2F0ZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudF9wcm9wZXJ0aWVzO1xyXG5cdFx0XHRcdFx0XHRpZihidWlsdGluKSB7XHJcblx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzID0gW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJzdGF0aWNcIiksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImJ1aWx0X2luXCIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJuYXRpdmVfY29kZVwiKVxyXG5cdFx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzID0gW107XHJcblx0XHRcdFx0XHRcdFx0aWYodGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcImR5bmFtaWNcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwic3RhdGljXCIpKTtcclxuXHRcdFx0XHRcdFx0XHRpZihwcmVkaWNhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibmF0aXZlX2NvZGVcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRocmVhZC5pc19tdWx0aWZpbGVfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJtdWx0aWZpbGVcIikpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKGdldF9tb2R1bGUubWV0YV9wcmVkaWNhdGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSlcclxuXHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm1ldGFfcHJlZGljYXRlXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdGdldF9tb2R1bGUubWV0YV9wcmVkaWNhdGVzW2hlYWQuaW5kaWNhdG9yXVxyXG5cdFx0XHRcdFx0XHRcdF0pKTtcclxuXHRcdFx0XHRcdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGhlYWQuYXJncy5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdFx0XHRhcmdzLnB1c2godGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpKTtcclxuXHRcdFx0XHRcdFx0dmFyIHVuaWZfaGVhZCA9IG5ldyBUZXJtKGhlYWQuaWQsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0XHQvLyBvbmUgcHJlZGljYXRlLCBvbmUgcHJvcGVydHkgLyBhbGwgcHJvcGVydGllc1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY3VycmVudF9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkgfHwgY3VycmVudF9wcm9wZXJ0aWVzW2ldLmluZGljYXRvciA9PT0gcHJvcGVydHkuaW5kaWNhdG9yKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludHMucHVzaChuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbaGVhZCwgdW5pZl9oZWFkXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtwcm9wZXJ0eSwgY3VycmVudF9wcm9wZXJ0aWVzW2ldXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQocG9pbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBsaXN0aW5nLzBcclxuXHRcdFwibGlzdGluZy8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBhdG9tLmNvbnRleHRfbW9kdWxlID8gYXRvbS5jb250ZXh0X21vZHVsZSA6IFwidXNlclwiO1xyXG5cdFx0XHR2YXIgcnVsZXMgPSB7fTtcclxuXHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV0pKSB7XHJcblx0XHRcdFx0cnVsZXMgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXS5ydWxlcztcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdFx0Zm9yKHZhciBpbmRpY2F0b3IgaW4gcnVsZXMpIHtcclxuXHRcdFx0XHRpZighcnVsZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSkgY29udGludWU7XHJcblx0XHRcdFx0dmFyIHByZWRpY2F0ZSA9IHJ1bGVzW2luZGljYXRvcl07XHJcblx0XHRcdFx0c3RyICs9IFwiJSBcIiArIGluZGljYXRvciArIFwiXFxuXCI7XHJcblx0XHRcdFx0aWYocHJlZGljYXRlIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVkaWNhdGUubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHRcdHN0ciArPSBwcmVkaWNhdGVbaV0udG9TdHJpbmcoIHtzZXNzaW9uOiB0aHJlYWQuc2Vzc2lvbn0gKSArIFwiXFxuXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0ciArPSBcIi8qXFxuXCIgKyBwcmVkaWNhdGUudG9TdHJpbmcoKSArIFwiXFxuKi9cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3RyICs9IFwiXFxuXCI7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwid3JpdGVcIiwgW25ldyBUZXJtKHN0ciwgW10pXSkpLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBsaXN0aW5nLzFcclxuXHRcdFwibGlzdGluZy8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgaW5kaWNhdG9yID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYoaW5kaWNhdG9yLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gaW5kaWNhdG9yLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aW5kaWNhdG9yID0gaW5kaWNhdG9yLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19wcmVkaWNhdGVfaW5kaWNhdG9yKGluZGljYXRvcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwicHJlZGljYXRlX2luZGljYXRvclwiLCBpbmRpY2F0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgcnVsZXMgPSB7fTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXSkpIHtcclxuXHRcdFx0XHRcdHJ1bGVzID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV0ucnVsZXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdHZhciBzdHJfaW5kaWNhdG9yID0gaW5kaWNhdG9yLmFyZ3NbMF0uaWQgKyBcIi9cIiArIGluZGljYXRvci5hcmdzWzFdLnZhbHVlO1xyXG5cdFx0XHRcdGlmKHJ1bGVzLmhhc093blByb3BlcnR5KHN0cl9pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHR2YXIgcHJlZGljYXRlID0gcnVsZXNbc3RyX2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRpZihwcmVkaWNhdGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlZGljYXRlLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBwcmVkaWNhdGVbaV0udG9TdHJpbmcoIHtzZXNzaW9uOiB0aHJlYWQuc2Vzc2lvbn0gKSArIFwiXFxuXCI7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzdHIgKz0gXCIvKlxcblwiICsgcHJlZGljYXRlLnRvU3RyaW5nKCkgKyBcIlxcbiovXCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdHIgKz0gXCJcXG5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJ3cml0ZVwiLCBbbmV3IFRlcm0oc3RyLCBbXSldKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gTElTVCBPUEVSQVRJT05TXHJcblxyXG5cdFx0Ly8gc29ydC8yXHJcblx0XHRcInNvcnQvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF0sIGV4cGVjdGVkID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBleHBlY3RlZCApICYmICFwbC50eXBlLmlzX2Z1bGx5X2xpc3QoIGV4cGVjdGVkICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgZXhwZWN0ZWQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdGFyci5wdXNoKCBwb2ludGVyLmFyZ3NbMF0gKTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHNvcnRlZF9hcnIgPSBhcnIuc29ydCggcGwuY29tcGFyZSApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHNvcnRlZF9hcnIubGVuZ3RoLTE7IGkgPiAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGlmKCBzb3J0ZWRfYXJyW2ldLmVxdWFscyhzb3J0ZWRfYXJyW2ktMV0pIClcclxuXHRcdFx0XHRcdFx0XHRzb3J0ZWRfYXJyLnNwbGljZShpLDEpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIHNvcnRlZF9saXN0ID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHNvcnRlZF9hcnIubGVuZ3RoLTE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRzb3J0ZWRfbGlzdCA9IG5ldyBUZXJtKCBcIi5cIiwgW3NvcnRlZF9hcnJbaV0sIHNvcnRlZF9saXN0XSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbc29ydGVkX2xpc3QsIGV4cGVjdGVkXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8ga2V5c29ydC8yXHJcblx0XHRcImtleXNvcnQvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF0sIGV4cGVjdGVkID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBleHBlY3RlZCApICYmICFwbC50eXBlLmlzX2Z1bGx5X2xpc3QoIGV4cGVjdGVkICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgZXhwZWN0ZWQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdFx0dmFyIGVsZW07XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdGVsZW0gPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZWxlbSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc190ZXJtKCBlbGVtICkgfHwgZWxlbS5pbmRpY2F0b3IgIT09IFwiLS8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJwYWlyXCIsIGVsZW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxlbS5hcmdzWzBdLnBhaXIgPSBlbGVtLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRhcnIucHVzaCggZWxlbS5hcmdzWzBdICk7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGV4cGVjdGVkKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGV4cGVjdGVkO1xyXG5cdFx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaGVhZCA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShoZWFkKSAmJiAoIXBsLnR5cGUuaXNfdGVybShoZWFkKSB8fCBoZWFkLmluZGljYXRvciAhPT0gXCItLzJcIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJwYWlyXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSAmJiAhcGwudHlwZS5pc19lbXB0eV9saXN0KHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgZXhwZWN0ZWQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBzb3J0ZWRfYXJyID0gYXJyLnNvcnQoIHBsLmNvbXBhcmUgKTtcclxuXHRcdFx0XHRcdHZhciBzb3J0ZWRfbGlzdCA9IG5ldyBwbC50eXBlLlRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHNvcnRlZF9hcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdHNvcnRlZF9saXN0ID0gbmV3IHBsLnR5cGUuVGVybSggXCIuXCIsIFtuZXcgcGwudHlwZS5UZXJtKCBcIi1cIiwgW3NvcnRlZF9hcnJbaV0sIHNvcnRlZF9hcnJbaV0ucGFpcl0gKSwgc29ydGVkX2xpc3RdICk7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBzb3J0ZWRfYXJyW2ldLnBhaXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBwbC50eXBlLlN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBwbC50eXBlLlRlcm0oIFwiPVwiLCBbc29ydGVkX2xpc3QsIGV4cGVjdGVkXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8ga2V5Z3JvdXBcclxuXHRcdFwia2V5Z3JvdXAvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdLCBleHBlY3RlZCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShsaXN0KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShleHBlY3RlZCkgJiYgIXBsLnR5cGUuaXNfZnVsbHlfbGlzdChleHBlY3RlZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImxpc3RcIiwgZXhwZWN0ZWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGtleXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgdmFsdWVzID0gW107XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0XHJcblx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHR2YXIgZWxlbSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZWxlbSkpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0oZWxlbSkgfHwgZWxlbS5pbmRpY2F0b3IgIT09IFwiLS8yXCIpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJwYWlyXCIsIGVsZW0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBrZXkgPSBlbGVtLmFyZ3NbMF0sIHZhbHVlID0gZWxlbS5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gLTE7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZihwbC5jb21wYXJlKGtleSwga2V5c1tpXSkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRpbmRleCA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRpbmRleCA9IGtleXMubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRrZXlzLnB1c2goa2V5KTtcclxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goW10pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFsdWVzW2luZGV4XS5wdXNoKHZhbHVlKTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2VtcHR5X2xpc3QocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShleHBlY3RlZCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBleHBlY3RlZDtcclxuXHRcdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGhlYWQgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkgJiYgKCFwbC50eXBlLmlzX3Rlcm0oaGVhZCkgfHwgaGVhZC5pbmRpY2F0b3IgIT09IFwiLS8yXCIpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcInBhaXJcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSAmJiAhcGwudHlwZS5pc19lbXB0eV9saXN0KHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGV4cGVjdGVkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Z3JvdXAgPSBuZXcgVGVybShcIltdXCIsIFtdKTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IGtleXMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxyXG5cdFx0XHRcdFx0XHRncm91cCA9IG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCItXCIsIFtrZXlzW2ldLCBhcnJheVRvTGlzdCh2YWx1ZXNbaV0pXSksIGdyb3VwXSk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0XHRcdG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IHBsLnR5cGUuVGVybShcIj1cIiwgW2V4cGVjdGVkLCBncm91cF0pKSxcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0XSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBDTEFVU0UgQ1JFQVRJT04gQU5EIERFU1RSVUNUSU9OXHJcblx0XHRcclxuXHRcdC8vIGFzc2VydGEvMVxyXG5cdFx0XCJhc3NlcnRhLzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY2xhdXNlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShjbGF1c2UpICYmIGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBjbGF1c2UuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRjbGF1c2UgPSBjbGF1c2UuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xhdXNlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBoZWFkLCBib2R5LCBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdGlmKGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi0vMlwiKSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRib2R5ID0gYm9keV9jb252ZXJzaW9uKGNsYXVzZS5hcmdzWzFdKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZTtcclxuXHRcdFx0XHRcdGJvZHkgPSBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZihib2R5ICE9PSBudWxsICYmICFwbC50eXBlLmlzX2NhbGxhYmxlKGJvZHkpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBib2R5LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZigoIXBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSlcclxuXHRcdFx0XHR8fCB0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHQmJiBoZWFkLmluZGljYXRvciAhPT0gXCIsLzJcIlxyXG5cdFx0XHRcdCYmICF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0pKSB7XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUgPSBuZXcgTW9kdWxlKG1vZHVsZV9pZCwge30sIFwiYWxsXCIsIHtzZXNzaW9uOiB0aHJlYWQuc2Vzc2lvbn0pO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0gPSBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID09PSB1bmRlZmluZWQpXHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID0gW107XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW2hlYWQuaW5kaWNhdG9yXSA9IHRydWU7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9IFtuZXcgUnVsZShoZWFkLCBib2R5LCB0cnVlKV0uY29uY2F0KGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdKTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUudXBkYXRlX2luZGljZXNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yKTtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKHBvaW50KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXNzZXJ0ei8xXHJcblx0XHRcImFzc2VydHovMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjbGF1c2UgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGNsYXVzZSkgJiYgY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IGNsYXVzZS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGNsYXVzZSA9IGNsYXVzZS5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbGF1c2UsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGhlYWQsIGJvZHksIGdldF9tb2R1bGU7XHJcblx0XHRcdFx0aWYoY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LS8yXCIpIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2UuYXJnc1swXTtcclxuXHRcdFx0XHRcdGJvZHkgPSBib2R5X2NvbnZlcnNpb24oY2xhdXNlLmFyZ3NbMV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlO1xyXG5cdFx0XHRcdFx0Ym9keSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGJvZHkgIT09IG51bGwgJiYgIXBsLnR5cGUuaXNfY2FsbGFibGUoYm9keSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGJvZHksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCghcGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdKVxyXG5cdFx0XHRcdHx8IHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdCYmIGhlYWQuaW5kaWNhdG9yICE9PSBcIiwvMlwiXHJcblx0XHRcdFx0JiYgIXRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSkpIHtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlX2lkLCB7fSwgXCJhbGxcIiwge3Nlc3Npb246IHRocmVhZC5zZXNzaW9ufSk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSA9IGdldF9tb2R1bGU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPSBbXTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNbaGVhZC5pbmRpY2F0b3JdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdLnB1c2gobmV3IFJ1bGUoaGVhZCwgYm9keSwgdHJ1ZSkpO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IpO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyByZXRyYWN0LzFcclxuXHRcdFwicmV0cmFjdC8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNsYXVzZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsYXVzZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaGVhZCwgYm9keSwgbW9kdWxlX2F0b20sIG1vZHVsZV9pZDtcclxuXHRcdFx0XHRpZihjbGF1c2UuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0XHRtb2R1bGVfYXRvbSA9IGNsYXVzZS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0Y2xhdXNlID0gY2xhdXNlLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKG1vZHVsZV9hdG9tKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm1vZHVsZVwiLCBtb2R1bGVfYXRvbSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRtb2R1bGVfYXRvbSA9IG5ldyBUZXJtKFwidXNlclwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LS8yXCIpIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2UuYXJnc1swXTtcclxuXHRcdFx0XHRcdGJvZHkgPSBjbGF1c2UuYXJnc1sxXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZTtcclxuXHRcdFx0XHRcdGJvZHkgPSBuZXcgVGVybShcInRydWVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IG1vZHVsZV9hdG9tLmlkO1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX21vZHVsZShnZXRfbW9kdWxlKSlcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRpZighcG9pbnQucmV0cmFjdCkge1xyXG5cdFx0XHRcdFx0aWYodGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIG1vZHVsZV9pZClcclxuXHRcdFx0XHRcdCYmIGhlYWQuaW5kaWNhdG9yICE9PSBcIiwvMlwiXHJcblx0XHRcdFx0XHQmJiAhdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG9ydWxlID0gZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl1baV07XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgcnVsZSA9IG9ydWxlLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYocnVsZS5ib2R5ID09PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRydWxlLmJvZHkgPSBuZXcgVGVybShcInRydWVcIiwgW10pO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIG9jY3Vyc19jaGVjayA9IHRocmVhZC5nZXRfZmxhZyhcIm9jY3Vyc19jaGVja1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCI7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkobmV3IFRlcm0oXCIsXCIsIFtoZWFkLCBib2R5XSksIG5ldyBUZXJtKFwiLFwiLCBbcnVsZS5oZWFkLCBydWxlLmJvZHldKSwgb2NjdXJzX2NoZWNrKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKG1ndSAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIjpcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVfYXRvbSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJyZXRyYWN0XCIsIFtuZXcgVGVybShcIjotXCIsIFtoZWFkLCBib2R5XSldKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtoZWFkLCBydWxlLmhlYWRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtib2R5LCBydWxlLmJvZHldKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdKSksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZS5yZXRyYWN0ID0gb3J1bGU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKHN0YXRlKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXRyYWN0KHRocmVhZCwgcG9pbnQsIGhlYWQuaW5kaWNhdG9yLCBwb2ludC5yZXRyYWN0LCBnZXRfbW9kdWxlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHJldHJhY3RhbGwvMVxyXG5cdFx0XCJyZXRyYWN0YWxsLzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgaGVhZCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShoZWFkKSAmJiBoZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGhlYWQgPSBoZWFkLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCF0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgY29udGV4dF9tb2R1bGUpXHJcblx0XHRcdHx8IGhlYWQuaW5kaWNhdG9yID09PSBcIiwvMlwiXHJcblx0XHRcdHx8IHRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiOlwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwicmV0cmFjdFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIjotXCIsIFtoZWFkLCBuZXcgVmFyKFwiX1wiKV0pXSlcclxuXHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiZmFpbFwiLCBbXSlcclxuXHRcdFx0XHRcdF0pKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCksXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKG51bGwpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KVxyXG5cdFx0XHRcdF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGFib2xpc2gvMVxyXG5cdFx0XCJhYm9saXNoLzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgcHJlZGljYXRlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0ocHJlZGljYXRlKSAmJiBwcmVkaWNhdGUuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShwcmVkaWNhdGUuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIHByZWRpY2F0ZS5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBwcmVkaWNhdGUuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRwcmVkaWNhdGUgPSBwcmVkaWNhdGUuYXJnc1sxXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBcInVzZXJcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByZWRpY2F0ZSkgfHwgcGwudHlwZS5pc190ZXJtKHByZWRpY2F0ZSkgJiYgcHJlZGljYXRlLmluZGljYXRvciA9PT0gXCIvLzJcIlxyXG5cdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShwcmVkaWNhdGUuYXJnc1swXSkgfHwgcGwudHlwZS5pc192YXJpYWJsZShwcmVkaWNhdGUuYXJnc1sxXSkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0ocHJlZGljYXRlKSB8fCBwcmVkaWNhdGUuaW5kaWNhdG9yICE9PSBcIi8vMlwiKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIHByZWRpY2F0ZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2F0b20ocHJlZGljYXRlLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJhdG9tXCIsIHByZWRpY2F0ZS5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfaW50ZWdlcihwcmVkaWNhdGUuYXJnc1sxXSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImludGVnZXJcIiwgcHJlZGljYXRlLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZihwcmVkaWNhdGUuYXJnc1sxXS52YWx1ZSA8IDApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuZG9tYWluKFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIHByZWRpY2F0ZS5hcmdzWzFdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19udW1iZXIodGhyZWFkLmdldF9mbGFnKFwibWF4X2FyaXR5XCIpKSAmJiBwcmVkaWNhdGUuYXJnc1sxXS52YWx1ZSA+IHRocmVhZC5nZXRfZmxhZyhcIm1heF9hcml0eVwiKS52YWx1ZSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5yZXByZXNlbnRhdGlvbihcIm1heF9hcml0eVwiLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0XHR2YXIgaW5kaWNhdG9yID0gcHJlZGljYXRlLmFyZ3NbMF0uaWQgKyBcIi9cIiArIHByZWRpY2F0ZS5hcmdzWzFdLnZhbHVlO1xyXG5cdFx0XHRcdFx0aWYodGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaW5kaWNhdG9yLCBtb2R1bGVfaWQpXHJcblx0XHRcdFx0XHQmJiBpbmRpY2F0b3IgIT09IFwiLC8yXCJcclxuXHRcdFx0XHRcdCYmICF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBnZXRfbW9kdWxlLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2V0X21vZHVsZS5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdldF9tb2R1bGUubXVsdGlmaWxlX3ByZWRpY2F0ZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIGF0b20uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQVRPTSBQUk9DRVNTSU5HXHJcblx0XHRcclxuXHRcdC8vIGF0b21fbGVuZ3RoLzJcclxuXHRcdFwiYXRvbV9sZW5ndGgvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMV0gKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGF0b20uYXJnc1sxXSApICYmIGF0b20uYXJnc1sxXS52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBsZW5ndGggPSBuZXcgTnVtKCBzdHJpbmdMZW5ndGgoYXRvbS5hcmdzWzBdLmlkKSwgZmFsc2UgKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsZW5ndGgsIGF0b20uYXJnc1sxXV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21fY29uY2F0LzNcclxuXHRcdFwiYXRvbV9jb25jYXQvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0ciwgZ29hbCwgc3RhcnQgPSBhdG9tLmFyZ3NbMF0sIGVuZCA9IGF0b20uYXJnc1sxXSwgd2hvbGUgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB3aG9sZSApICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdGFydCApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGVuZCApKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RhcnQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdGFydCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHN0YXJ0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGVuZCApICYmICFwbC50eXBlLmlzX2F0b20oIGVuZCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGVuZCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCB3aG9sZSApICYmICFwbC50eXBlLmlzX2F0b20oIHdob2xlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgd2hvbGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgdjEgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdGFydCApO1xyXG5cdFx0XHRcdHZhciB2MiA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIGVuZCApO1xyXG5cdFx0XHRcdC8vdmFyIHYzID0gcGwudHlwZS5pc192YXJpYWJsZSggd2hvbGUgKTtcclxuXHRcdFx0XHRpZiggIXYxICYmICF2MiApIHtcclxuXHRcdFx0XHRcdGdvYWwgPSBuZXcgVGVybSggXCI9XCIsIFt3aG9sZSwgbmV3IFRlcm0oIHN0YXJ0LmlkICsgZW5kLmlkICldICk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHYxICYmICF2MiApIHtcclxuXHRcdFx0XHRcdHN0ciA9IHdob2xlLmlkLnN1YnN0ciggMCwgd2hvbGUuaWQubGVuZ3RoIC0gZW5kLmlkLmxlbmd0aCApO1xyXG5cdFx0XHRcdFx0aWYoIHN0ciArIGVuZC5pZCA9PT0gd2hvbGUuaWQgKSB7XHJcblx0XHRcdFx0XHRcdGdvYWwgPSBuZXcgVGVybSggXCI9XCIsIFtzdGFydCwgbmV3IFRlcm0oIHN0ciApXSApO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoIHYyICYmICF2MSApIHtcclxuXHRcdFx0XHRcdHN0ciA9IHdob2xlLmlkLnN1YnN0ciggc3RhcnQuaWQubGVuZ3RoICk7XHJcblx0XHRcdFx0XHRpZiggc3RhcnQuaWQgKyBzdHIgPT09IHdob2xlLmlkICkge1xyXG5cdFx0XHRcdFx0XHRnb2FsID0gbmV3IFRlcm0oIFwiPVwiLCBbZW5kLCBuZXcgVGVybSggc3RyICldICk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8PSB3aG9sZS5pZC5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0dmFyIGF0b20xID0gbmV3IFRlcm0oIHdob2xlLmlkLnN1YnN0ciggMCwgaSApICk7XHJcblx0XHRcdFx0XHRcdHZhciBhdG9tMiA9IG5ldyBUZXJtKCB3aG9sZS5pZC5zdWJzdHIoIGkgKSApO1xyXG5cdFx0XHRcdFx0XHRnb2FsID0gbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiPVwiLCBbYXRvbTEsIHN0YXJ0XSApLCBuZXcgVGVybSggXCI9XCIsIFthdG9tMiwgZW5kXSApXSApO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaCggbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBzdWJfYXRvbS81XHJcblx0XHRcInN1Yl9hdG9tLzVcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBpLCBhdG9tMSA9IGF0b20uYXJnc1swXSwgYmVmb3JlID0gYXRvbS5hcmdzWzFdLCBsZW5ndGggPSBhdG9tLmFyZ3NbMl0sIGFmdGVyID0gYXRvbS5hcmdzWzNdLCBzdWJhdG9tID0gYXRvbS5hcmdzWzRdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20xLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGJlZm9yZSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGJlZm9yZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGJlZm9yZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsZW5ndGggKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBsZW5ndGggKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBsZW5ndGgsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYWZ0ZXIgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBhZnRlciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGFmdGVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBiZWZvcmUgKSAmJiBiZWZvcmUudmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBiZWZvcmUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGxlbmd0aCApICYmIGxlbmd0aC52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGxlbmd0aCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggYWZ0ZXIgKSAmJiBhZnRlci52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGFmdGVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN1YmF0b20gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdWJhdG9tICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgc3ViYXRvbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBicyA9IFtdLCBscyA9IFtdLCBhcyA9IFtdO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBiZWZvcmUgKSApIHtcclxuXHRcdFx0XHRcdGZvciggaSA9IDA7IGkgPD0gYXRvbTEuaWQubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdGJzLnB1c2goIGkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YnMucHVzaCggYmVmb3JlLnZhbHVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsZW5ndGggKSApIHtcclxuXHRcdFx0XHRcdGZvciggaSA9IDA7IGkgPD0gYXRvbTEuaWQubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdGxzLnB1c2goIGkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bHMucHVzaCggbGVuZ3RoLnZhbHVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhZnRlciApICkge1xyXG5cdFx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8PSBhdG9tMS5pZC5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0YXMucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhcy5wdXNoKCBhZnRlci52YWx1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0Zm9yKCB2YXIgX2kgaW4gYnMgKSB7XHJcblx0XHRcdFx0XHRpZighYnMuaGFzT3duUHJvcGVydHkoX2kpKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGkgPSBic1tfaV07XHJcblx0XHRcdFx0XHRmb3IoIHZhciBfaiBpbiBscyApIHtcclxuXHRcdFx0XHRcdFx0aWYoIWxzLmhhc093blByb3BlcnR5KF9qKSkgY29udGludWU7XHJcblx0XHRcdFx0XHRcdHZhciBqID0gbHNbX2pdO1xyXG5cdFx0XHRcdFx0XHR2YXIgayA9IGF0b20xLmlkLmxlbmd0aCAtIGkgLSBqO1xyXG5cdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggYXMsIGsgKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCBpK2orayA9PT0gYXRvbTEuaWQubGVuZ3RoICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN0ciA9IGF0b20xLmlkLnN1YnN0ciggaSwgaiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGF0b20xLmlkID09PSBhdG9tMS5pZC5zdWJzdHIoIDAsIGkgKSArIHN0ciArIGF0b20xLmlkLnN1YnN0ciggaStqLCBrICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwbDEgPSBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggc3RyICksIHN1YmF0b21dICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwbDIgPSBuZXcgVGVybSggXCI9XCIsIFtiZWZvcmUsIG5ldyBOdW0oIGkgKV0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHBsMyA9IG5ldyBUZXJtKCBcIj1cIiwgW2xlbmd0aCwgbmV3IE51bSggaiApXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGw0ID0gbmV3IFRlcm0oIFwiPVwiLCBbYWZ0ZXIsIG5ldyBOdW0oIGsgKV0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybSggXCIsXCIsIFsgbmV3IFRlcm0oIFwiLFwiLCBbIG5ldyBUZXJtKCBcIixcIiwgW3BsMiwgcGwzXSApLCBwbDRdICksIHBsMV0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goIG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21fY2hhcnMvMlxyXG5cdFx0XCJhdG9tX2NoYXJzLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBhdG9tMSA9IGF0b20uYXJnc1swXSwgbGlzdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICYmICFwbC50eXBlLmlzX2F0b20oIGF0b20xICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbTEsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgKSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShsaXN0KSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX2NoYXJhY3Rlcihwb2ludGVyLmFyZ3NbMF0pICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2hhcmFjdGVyXCIsIHBvaW50ZXIuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGxpc3QxID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0dmFyIHVuaWxlbiA9IHN0cmluZ0xlbmd0aChhdG9tMS5pZCk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gdW5pbGVuLTE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0MSA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBUZXJtKCBhdG9tMS5pZC5jaGFyQXQoIGkgKSApLCBsaXN0MV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xpc3QsIGxpc3QxXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFxyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0dmFyIHYgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApO1xyXG5cdFx0XHRcdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXIoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSAmJiB2ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2hhcmFjdGVyXCIsIHBvaW50ZXIuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gcG9pbnRlci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICYmIHYgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHN0ciApLCBhdG9tMV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9tX2NvZGVzLzJcclxuXHRcdFwiYXRvbV9jb2Rlcy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgYXRvbTEgPSBhdG9tLmFyZ3NbMF0sIGxpc3QgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGF0b20xLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUobGlzdCkpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc19jaGFyYWN0ZXJfY29kZShwb2ludGVyLmFyZ3NbMF0pICYmICFwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCBwb2ludGVyLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBsaXN0MSA9IG5ldyBUZXJtKCBcIltdXCIgKTtcclxuXHRcdFx0XHRcdHZhciB1bmlsZW4gPSBzdHJpbmdMZW5ndGgoYXRvbTEuaWQpO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHVuaWxlbi0xOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0bGlzdDEgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgTnVtKCBjb2RlUG9pbnRBdChhdG9tMS5pZCxpKSwgZmFsc2UgKSwgbGlzdDFdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsaXN0LCBsaXN0MV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHRcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdHZhciB2ID0gcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKTtcclxuXHRcdFx0XHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyX2NvZGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSAmJiB2ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IGZyb21Db2RlUG9pbnQoIHBvaW50ZXIuYXJnc1swXS52YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICYmIHYgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHN0ciApLCBhdG9tMV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjaGFyX2NvZGUvMlxyXG5cdFx0XCJjaGFyX2NvZGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNoYXIgPSBhdG9tLmFyZ3NbMF0sIGNvZGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjaGFyICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjaGFyICkgJiYgIXBsLnR5cGUuaXNfY2hhcmFjdGVyKCBjaGFyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNoYXJhY3RlclwiLCBjaGFyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgY29kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfY2hhcmFjdGVyX2NvZGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICkge1xyXG5cdFx0XHRcdFx0dmFyIGNvZGUxID0gbmV3IE51bSggY29kZVBvaW50QXQoY2hhci5pZCwwICksIGZhbHNlICk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtjb2RlMSwgY29kZV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBjaGFyMSA9IG5ldyBUZXJtKCBmcm9tQ29kZVBvaW50KCBjb2RlLnZhbHVlICkgKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2NoYXIxLCBjaGFyXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIG51bWJlcl9jaGFycy8yXHJcblx0XHRcIm51bWJlcl9jaGFycy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyLCBudW0gPSBhdG9tLmFyZ3NbMF0sIGxpc3QgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApICYmICFwbC50eXBlLmlzX251bWJlciggbnVtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcIm51bWJlclwiLCBudW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICYmICFwbC50eXBlLmlzX2xpc3QoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGlzdmFyID0gcGwudHlwZS5pc192YXJpYWJsZSggbnVtICk7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHRcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdHZhciB0b3RhbCA9IHRydWU7XHJcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0b3RhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNoYXJhY3RlclwiLCBwb2ludGVyLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IHBvaW50ZXIuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dG90YWwgPSB0b3RhbCAmJiBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKTtcclxuXHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggIXRvdGFsICYmIGlzdmFyICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCB0b3RhbCApIHtcclxuXHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSAmJiBpc3ZhciApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGV4cHIgPSB0aHJlYWQucGFyc2UoIHN0ciApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBudW0yID0gZXhwci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCBudW0yICkgfHwgZXhwci50b2tlbnNbZXhwci50b2tlbnMubGVuZ3RoLTFdLnNwYWNlICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5zeW50YXhfYnlfcHJlZGljYXRlKCBcInBhcnNlYWJsZV9udW1iZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtudW0sIG51bTJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoICFpc3ZhciApIHtcclxuXHRcdFx0XHRcdHN0ciA9IG51bS50b1N0cmluZygpO1xyXG5cdFx0XHRcdFx0dmFyIGxpc3QyID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0bGlzdDIgPSBuZXcgVGVybSggXCIuXCIsIFsgbmV3IFRlcm0oIHN0ci5jaGFyQXQoIGkgKSApLCBsaXN0MiBdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsaXN0LCBsaXN0Ml0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBudW1iZXJfY29kZXMvMlxyXG5cdFx0XCJudW1iZXJfY29kZXMvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0ciwgbnVtID0gYXRvbS5hcmdzWzBdLCBsaXN0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbnVtICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKSAmJiAhcGwudHlwZS5pc19udW1iZXIoIG51bSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJudW1iZXJcIiwgbnVtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSAmJiAhcGwudHlwZS5pc19saXN0KCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpc3ZhciA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApO1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1x0XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHR2YXIgdG90YWwgPSB0cnVlO1xyXG5cdFx0XHRcdFx0c3RyID0gXCJcIjtcclxuXHRcdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2NoYXJhY3Rlcl9jb2RlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0b3RhbCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBmcm9tQ29kZVBvaW50KCBwb2ludGVyLmFyZ3NbMF0udmFsdWUgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dG90YWwgPSB0b3RhbCAmJiBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKTtcclxuXHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggIXRvdGFsICYmIGlzdmFyICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCB0b3RhbCApIHtcclxuXHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSAmJiBpc3ZhciApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGV4cHIgPSB0aHJlYWQucGFyc2UoIHN0ciApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBudW0yID0gZXhwci52YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfbnVtYmVyKCBudW0yICkgfHwgZXhwci50b2tlbnNbZXhwci50b2tlbnMubGVuZ3RoLTFdLnNwYWNlICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5zeW50YXhfYnlfcHJlZGljYXRlKCBcInBhcnNlYWJsZV9udW1iZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtudW0sIG51bTJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoICFpc3ZhciApIHtcclxuXHRcdFx0XHRcdHN0ciA9IG51bS50b1N0cmluZygpO1xyXG5cdFx0XHRcdFx0dmFyIGxpc3QyID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0bGlzdDIgPSBuZXcgVGVybSggXCIuXCIsIFsgbmV3IE51bSggY29kZVBvaW50QXQoc3RyLGkpLCBmYWxzZSApLCBsaXN0MiBdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtsaXN0LCBsaXN0Ml0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyB1cGNhc2VfYXRvbS8yXHJcblx0XHRcInVwY2FzZV9hdG9tLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvcmlnaW5hbCA9IGF0b20uYXJnc1swXSwgdXBjYXNlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggb3JpZ2luYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBvcmlnaW5hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9yaWdpbmFsLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHVwY2FzZSApICYmICFwbC50eXBlLmlzX2F0b20oIHVwY2FzZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHVwY2FzZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3VwY2FzZSwgbmV3IFRlcm0oIG9yaWdpbmFsLmlkLnRvVXBwZXJDYXNlKCksIFtdICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBkb3duY2FzZV9hdG9tLzJcclxuXHRcdFwiZG93bmNhc2VfYXRvbS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb3JpZ2luYWwgPSBhdG9tLmFyZ3NbMF0sIGRvd25jYXNlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggb3JpZ2luYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBvcmlnaW5hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG9yaWdpbmFsLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGRvd25jYXNlICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggZG93bmNhc2UgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBkb3duY2FzZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2Rvd25jYXNlLCBuZXcgVGVybSggb3JpZ2luYWwuaWQudG9Mb3dlckNhc2UoKSwgW10gKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21pY19jb25jYXQvM1xyXG5cdFx0XCJhdG9taWNfY29uY2F0LzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBhdG9taWMxID0gYXRvbS5hcmdzWzBdLCBhdG9taWMyID0gYXRvbS5hcmdzWzFdLCBjb25jYXQgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9taWMxICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggYXRvbWljMiApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b21pYyggYXRvbWljMSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgYXRvbWljMSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b21pYyggYXRvbWljMiApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgYXRvbWljMiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb25jYXQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBjb25jYXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBjb25jYXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaWQgPSBcIlwiO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b20oIGF0b21pYzEgKSApIHtcclxuXHRcdFx0XHRcdGlkICs9IGF0b21pYzEuaWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlkICs9IFwiXCIgKyBhdG9taWMxLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc19hdG9tKCBhdG9taWMyICkgKSB7XHJcblx0XHRcdFx0XHRpZCArPSBhdG9taWMyLmlkO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZCArPSBcIlwiICsgYXRvbWljMi52YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGF0b20gPSBuZXcgVGVybShpZCwgW10pO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2F0b20sIGNvbmNhdF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gYXRvbWljX2xpc3RfY29uY2F0LzJcclxuXHRcdFwiYXRvbWljX2xpc3RfY29uY2F0LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdLCBjb25jYXQgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcImF0b21pY19saXN0X2NvbmNhdFwiLCBbbGlzdCwgbmV3IFRlcm0oIFwiXCIsIFtdICksIGNvbmNhdF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9taWNfbGlzdF9jb25jYXQvM1xyXG5cdFx0XCJhdG9taWNfbGlzdF9jb25jYXQvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF0sIHNlcGFyYXRvciA9IGF0b20uYXJnc1sxXSwgY29uY2F0ID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc2VwYXJhdG9yICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGNvbmNhdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgJiYgIXBsLnR5cGUuaXNfbGlzdCggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBzZXBhcmF0b3IgKSAmJiAhcGwudHlwZS5pc19udW1iZXIoIHNlcGFyYXRvciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9taWNcIiwgc2VwYXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvbmNhdCApICYmICFwbC50eXBlLmlzX2F0b20oIGNvbmNhdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGNvbmNhdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpZCA9IFwiXCI7XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0oIHBvaW50ZXIgKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggcG9pbnRlci5hcmdzWzBdICkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBwb2ludGVyLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIGlkICE9PSBcIlwiIClcclxuXHRcdFx0XHRcdFx0aWQgKz0gc2VwYXJhdG9yLmlkO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbSggcG9pbnRlci5hcmdzWzBdICkgKVxyXG5cdFx0XHRcdFx0XHRpZCArPSBwb2ludGVyLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGlkICs9IFwiXCIgKyBwb2ludGVyLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZCA9IG5ldyBUZXJtKCBpZCwgW10gKTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc190ZXJtKCBwb2ludGVyICkgfHwgcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtpZCwgY29uY2F0XSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFRFUk0gQ09NUEFSSVNPTlxyXG5cdFx0XHJcblx0XHRcIkA9PC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSA8PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcIj09LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApID09PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcIlxcXFw9PS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSAhPT0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCJAPC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiQD4vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgPiAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcIkA+PS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSA+PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcImNvbXBhcmUvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9yZGVyID0gYXRvbS5hcmdzWzBdLCBsZWZ0ID0gYXRvbS5hcmdzWzFdLCByaWdodCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcmRlciApICYmICFwbC50eXBlLmlzX2F0b20oIG9yZGVyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3JkZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2F0b20oIG9yZGVyICkgJiYgW1wiPFwiLCBcIj5cIiwgXCI9XCJdLmluZGV4T2YoIG9yZGVyLmlkICkgPT09IC0xICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm9yZGVyXCIsIG9yZGVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGNvbXBhcmUgPSBwbC5jb21wYXJlKCBsZWZ0LCByaWdodCApO1xyXG5cdFx0XHRcdGNvbXBhcmUgPSBjb21wYXJlID09PSAwID8gXCI9XCIgOiAoY29tcGFyZSA9PT0gLTEgPyBcIjxcIiA6IFwiPlwiKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtvcmRlciwgbmV3IFRlcm0oIGNvbXBhcmUsIFtdICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBFVkFMVUFUSU9OXHJcblx0XHRcclxuXHRcdC8vIGlzLzJcclxuXHRcdFwiaXMvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9wID0gYXRvbS5hcmdzWzFdLmludGVycHJldCggdGhyZWFkICk7XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIG9wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBvcCApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2F0b20uYXJnc1swXSwgb3BdLCBhdG9tLmluZGljYXRvciApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYmV0d2Vlbi8zXHJcblx0XHRcImJldHdlZW4vM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxvd2VyID0gYXRvbS5hcmdzWzBdLCB1cHBlciA9IGF0b20uYXJnc1sxXSwgYmV0ID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbG93ZXIgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB1cHBlciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGxvd2VyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgbG93ZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCB1cHBlciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIHVwcGVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGJldCApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGJldCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGJldCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBiZXQgKSApIHtcclxuXHRcdFx0XHRcdGlmKCBsb3dlci52YWx1ZSA8PSB1cHBlci52YWx1ZSApIHtcclxuXHRcdFx0XHRcdFx0dmFyIHN0YXRlcyA9IFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbYmV0LCBsb3dlcl0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaCggbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcImJldHdlZW5cIiwgW25ldyBOdW0oIGxvd2VyLnZhbHVlKzEsIGZhbHNlICksIHVwcGVyLCBiZXRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApICk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoIGxvd2VyLnZhbHVlIDw9IGJldC52YWx1ZSAmJiB1cHBlci52YWx1ZSA+PSBiZXQudmFsdWUgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHN1Y2MvMlxyXG5cdFx0XCJzdWNjLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBuID0gYXRvbS5hcmdzWzBdLCBtID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbiApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIG0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbiApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIG4gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBuLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG0gKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBuICkgJiYgbi52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIG4sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbSApICYmIG0udmFsdWUgPCAwICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm5vdF9sZXNzX3RoYW5femVyb1wiLCBtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG0gKSB8fCBtLnZhbHVlID4gMCApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBuICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW24sIG5ldyBOdW0oIG0udmFsdWUtMSwgZmFsc2UgKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFttLCBuZXcgTnVtKCBuLnZhbHVlKzEsIGZhbHNlICldICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPTo9LzJcclxuXHRcdFwiPTo9LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgPT09IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID1cXD0vMlxyXG5cdFx0XCI9XFxcXD0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCAhPT0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPC8yXHJcblx0XHRcIjwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID08LzJcclxuXHRcdFwiPTwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCA8PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA+LzJcclxuXHRcdFwiPi8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wID4gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPj0vMlxyXG5cdFx0XCI+PS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wID49IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIFRZUEUgVEVTVFxyXG5cdFx0XHJcblx0XHQvLyB2YXIvMVxyXG5cdFx0XCJ2YXIvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9tLzFcclxuXHRcdFwiYXRvbS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19hdG9tKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbWljLzFcclxuXHRcdFwiYXRvbWljLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b21pYyggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNvbXBvdW5kLzFcclxuXHRcdFwiY29tcG91bmQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfY29tcG91bmQoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBpbnRlZ2VyLzFcclxuXHRcdFwiaW50ZWdlci8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gZmxvYXQvMVxyXG5cdFx0XCJmbG9hdC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19mbG9hdCggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIG51bWJlci8xXHJcblx0XHRcIm51bWJlci8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19udW1iZXIoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBub252YXIvMVxyXG5cdFx0XCJub252YXIvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gZ3JvdW5kLzFcclxuXHRcdFwiZ3JvdW5kLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBhdG9tLnZhcmlhYmxlcygpLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYWN5Y2xpY190ZXJtLzFcclxuXHRcdFwiYWN5Y2xpY190ZXJtLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB0ZXN0ID0gcG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KCBwb2ludC5zdWJzdGl0dXRpb24gKTtcclxuXHRcdFx0dmFyIHZhcmlhYmxlcyA9IGF0b20uYXJnc1swXS52YXJpYWJsZXMoKTtcclxuXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKysgKVxyXG5cdFx0XHRcdGlmKCBwb2ludC5zdWJzdGl0dXRpb24ubGlua3NbdmFyaWFibGVzW2ldXSAhPT0gdW5kZWZpbmVkICYmICFwb2ludC5zdWJzdGl0dXRpb24ubGlua3NbdmFyaWFibGVzW2ldXS5lcXVhbHMoIHRlc3QubGlua3NbdmFyaWFibGVzW2ldXSApIClcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjYWxsYWJsZS8xXHJcblx0XHRcImNhbGxhYmxlLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjYWxsYWJsZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGNhbGxhYmxlKSkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGlzX2xpc3QvMVxyXG5cdFx0XCJpc19saXN0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBsaXN0ID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKCBsaXN0ICkgJiYgbGlzdC5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKVxyXG5cdFx0XHRcdGxpc3QgPSBsaXN0LmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGxpc3QgKSAmJiBsaXN0LmluZGljYXRvciA9PT0gXCJbXS8wXCIgKVxyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIFNUUkVBTSBTRUxFQ1RJT04gQU5EIENPTlRST0xcclxuXHJcblx0XHQvLyBjdXJyZW50X2lucHV0LzFcclxuXHRcdFwiY3VycmVudF9pbnB1dC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShzdHJlYW0pXHJcblx0XHRcdCYmICghcGwudHlwZS5pc19zdHJlYW0oc3RyZWFtKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmFsaWFzKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgICYmICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uaWQpKVxyXG5cdFx0XHQmJiAoIXBsLnR5cGUuaXNfYXRvbShzdHJlYW0pIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uaWQpKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IpICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19hdG9tKHN0cmVhbSkpXHJcblx0XHRcdFx0XHRzdHJlYW0gPSB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uaWQpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbc3RyZWFtLCB0aHJlYWQuZ2V0X2N1cnJlbnRfaW5wdXQoKV0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50KVxyXG5cdFx0XHRcdF0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjdXJyZW50X291dHB1dC8xXHJcblx0XHRcImN1cnJlbnRfb3V0cHV0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHN0cmVhbSlcclxuXHRcdFx0JiYgKCFwbC50eXBlLmlzX3N0cmVhbShzdHJlYW0pIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uYWxpYXMpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgJiYgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5pZCkpXHJcblx0XHRcdCYmICghcGwudHlwZS5pc19hdG9tKHN0cmVhbSkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5pZCkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvcikgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2F0b20oc3RyZWFtKSlcclxuXHRcdFx0XHRcdHN0cmVhbSA9IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW3N0cmVhbSwgdGhyZWFkLmdldF9jdXJyZW50X291dHB1dCgpXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnQpXHJcblx0XHRcdFx0XSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNldF9pbnB1dC8xXHJcblx0XHRcInNldF9pbnB1dC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgaW5wdXQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBzdHJlYW0gPSBwbC50eXBlLmlzX3N0cmVhbSggaW5wdXQgKSA/IGlucHV0IDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIGlucHV0LmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbnB1dCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggaW5wdXQgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBpbnB1dCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBpbnB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKGlucHV0LmFsaWFzKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCYmICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhpbnB1dC5pZCkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIGlucHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtLm91dHB1dCA9PT0gdHJ1ZSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgaW5wdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuc2V0X2N1cnJlbnRfaW5wdXQoIHN0cmVhbSApO1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNldF9vdXRwdXQvMVxyXG5cdFx0XCJzZXRfb3V0cHV0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvdXRwdXQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBzdHJlYW0gPSBwbC50eXBlLmlzX3N0cmVhbSggb3V0cHV0ICkgPyBvdXRwdXQgOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggb3V0cHV0LmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvdXRwdXQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIG91dHB1dCApICYmICFwbC50eXBlLmlzX2F0b20oIG91dHB1dCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBvdXRwdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhvdXRwdXQuYWxpYXMpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JiYgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKG91dHB1dC5pZCkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIG91dHB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbS5pbnB1dCA9PT0gdHJ1ZSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIG91dHB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5zZXRfY3VycmVudF9vdXRwdXQoIHN0cmVhbSApO1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIG9wZW4vM1xyXG5cdFx0XCJvcGVuLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBkZXN0ID0gYXRvbS5hcmdzWzBdLCBtb2RlID0gYXRvbS5hcmdzWzFdLCBzdHJlYW0gPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIm9wZW5cIiwgW2Rlc3QsIG1vZGUsIHN0cmVhbSwgbmV3IFRlcm0oXCJbXVwiLCBbXSldKSksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIG9wZW4vNFxyXG5cdFx0XCJvcGVuLzRcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBkZXN0ID0gYXRvbS5hcmdzWzBdLCBtb2RlID0gYXRvbS5hcmdzWzFdLCBzdHJlYW0gPSBhdG9tLmFyZ3NbMl0sIG9wdGlvbnMgPSBhdG9tLmFyZ3NbM107XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBkZXN0ICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggbW9kZSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbW9kZSApICYmICFwbC50eXBlLmlzX2F0b20oIG1vZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBtb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci51bmluc3RhbnRpYXRpb24oIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGRlc3QgKSAmJiAhcGwudHlwZS5pc19zdHJlYW1hYmxlKCBkZXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic291cmNlX3NpbmtcIiwgZGVzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2lvX21vZGUoIG1vZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJpb19tb2RlXCIsIG1vZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgb2JqX29wdGlvbnMgPSB7fTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wdGlvbnM7XHJcblx0XHRcdFx0dmFyIHByb3BlcnR5O1xyXG5cdFx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRwcm9wZXJ0eSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW1fb3B0aW9uKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3B0aW9uXCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG9ial9vcHRpb25zW3Byb3BlcnR5LmlkXSA9IHByb3BlcnR5LmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBhbGlhcyA9IG9ial9vcHRpb25zW1wiYWxpYXNcIl07XHJcblx0XHRcdFx0XHRpZiggYWxpYXMgJiYgdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoYWxpYXMpICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3BlblwiLCBcInNvdXJjZV9zaW5rXCIsIG5ldyBUZXJtKFwiYWxpYXNcIiwgW25ldyBUZXJtKGFsaWFzLCBbXSldKSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggIW9ial9vcHRpb25zW1widHlwZVwiXSApXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW1widHlwZVwiXSA9IFwidGV4dFwiO1xyXG5cdFx0XHRcdFx0dmFyIGZpbGU7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc19hdG9tKCBkZXN0ICkgKVxyXG5cdFx0XHRcdFx0XHRmaWxlID0gdGhyZWFkLmZpbGVfc3lzdGVtX29wZW4oIGRlc3QuaWQsIG9ial9vcHRpb25zW1widHlwZVwiXSwgbW9kZS5pZCApO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRmaWxlID0gZGVzdC5zdHJlYW0oIG9ial9vcHRpb25zW1widHlwZVwiXSwgbW9kZS5pZCApO1xyXG5cdFx0XHRcdFx0aWYoIGZpbGUgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3BlblwiLCBcInNvdXJjZV9zaW5rXCIsIGRlc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBmaWxlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzb3VyY2Vfc2lua1wiLCBkZXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBuZXdzdHJlYW0gPSBuZXcgU3RyZWFtKFxyXG5cdFx0XHRcdFx0XHRmaWxlLCBtb2RlLmlkLFxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1tcImFsaWFzXCJdLFxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1tcInR5cGVcIl0sXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW1wicmVwb3NpdGlvblwiXSA9PT0gXCJ0cnVlXCIsXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW1wiZW9mX2FjdGlvblwiXSApO1xyXG5cdFx0XHRcdFx0aWYoIGFsaWFzIClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uc3RyZWFtc1thbGlhc10gPSBuZXdzdHJlYW07XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnN0cmVhbXNbbmV3c3RyZWFtLmlkXSA9IG5ld3N0cmVhbTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3N0cmVhbSwgbmV3c3RyZWFtXSApICksXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGNsb3NlLzFcclxuXHRcdFwiY2xvc2UvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiY2xvc2VcIiwgW3N0cmVhbSwgbmV3IFRlcm0oXCJbXVwiLCBbXSldKSksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGNsb3NlLzJcclxuXHRcdFwiY2xvc2UvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgb3B0aW9ucyA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gR2V0IG9wdGlvbnNcclxuXHRcdFx0XHR2YXIgb2JqX29wdGlvbnMgPSB7fTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wdGlvbnM7XHJcblx0XHRcdFx0dmFyIHByb3BlcnR5O1xyXG5cdFx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRwcm9wZXJ0eSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jbG9zZV9vcHRpb24oIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcImNsb3NlX29wdGlvblwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRvYmpfb3B0aW9uc1twcm9wZXJ0eS5pZF0gPSBwcm9wZXJ0eS5hcmdzWzBdLmlkID09PSBcInRydWVcIjtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApIClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoc3RyZWFtMiA9PT0gdGhyZWFkLnNlc3Npb24uc3RhbmRhcmRfaW5wdXQgfHwgc3RyZWFtMiA9PT0gdGhyZWFkLnNlc3Npb24uc3RhbmRhcmRfb3V0cHV0IHx8IHN0cmVhbTIgPT09IHRocmVhZC5zZXNzaW9uLnN0YW5kYXJkX2Vycm9yKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIgPT09IHRocmVhZC5zZXNzaW9uLmN1cnJlbnRfaW5wdXQgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLmN1cnJlbnRfaW5wdXQgPSB0aHJlYWQuc2Vzc2lvbi5zdGFuZGFyZF9pbnB1dDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMiA9PT0gdGhyZWFkLnNlc3Npb24uY3VycmVudF9vdXRwdXQgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLmN1cnJlbnRfb3V0cHV0ID0gdGhyZWFkLnNlc3Npb24uc3RhbmRhcmRfb3V0cHV0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbTIuYWxpYXMgIT09IG51bGwgJiYgc3RyZWFtMi5hbGlhcyAhPT0gdW5kZWZpbmVkIClcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRocmVhZC5zZXNzaW9uLnN0cmVhbXNbc3RyZWFtMi5hbGlhc107XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGRlbGV0ZSB0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zW3N0cmVhbTIuaWRdO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbTIub3V0cHV0IClcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5zdHJlYW0uZmx1c2goKTtcclxuXHRcdFx0XHRcdHZhciBjbG9zZWQgPSBzdHJlYW0yLnN0cmVhbS5jbG9zZSgpO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5zdHJlYW0gPSBudWxsO1xyXG5cdFx0XHRcdFx0aWYoIG9ial9vcHRpb25zLmZvcmNlID09PSB0cnVlIHx8IGNsb3NlZCA9PT0gdHJ1ZSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGZsdXNoX291dHB1dC8wXHJcblx0XHRcImZsdXNoX291dHB1dC8wXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJmbHVzaF9vdXRwdXRcIiwgW10pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJmbHVzaF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gZmx1c2hfb3V0cHV0LzFcclxuXHRcdFwiZmx1c2hfb3V0cHV0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIuaW5wdXQgPT09IHRydWUgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdHJlYW0yLnN0cmVhbS5mbHVzaCgpO1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHN0cmVhbV9wcm9wZXJ0eS8yXHJcblx0XHRcInN0cmVhbV9wcm9wZXJ0eS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBwcm9wZXJ0eSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICghcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcm9wZXJ0eSApICYmICFwbC50eXBlLmlzX3N0cmVhbV9wcm9wZXJ0eSggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fcHJvcGVydHlcIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtcyA9IFtdO1xyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgcHJvcHZhciA9IHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpO1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKVxyXG5cdFx0XHRcdFx0c3RyZWFtcy5wdXNoKCBzdHJlYW0yICk7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0Zm9yKCB2YXIga2V5IGluIHRocmVhZC5zZXNzaW9uLnN0cmVhbXMgKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW1zLnB1c2goIHRocmVhZC5zZXNzaW9uLnN0cmVhbXNba2V5XSApO1xyXG5cdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgc3RyZWFtcy5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gW107XHJcblx0XHRcdFx0XHQvLyBmaWxlX25hbWUvMVxyXG5cdFx0XHRcdFx0aWYoIChwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJmaWxlX25hbWUvMVwiKSAmJiBzdHJlYW1zW2ldLmZpbGVuYW1lIClcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJmaWxlX25hbWVcIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0uZmlsZV9uYW1lLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIG1vZGUvMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwibW9kZS8xXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwibW9kZVwiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS5tb2RlLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIGlucHV0LzAgb3Igb3V0cHV0LzBcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcImlucHV0LzBcIiB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwib3V0cHV0LzBcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggc3RyZWFtc1tpXS5pbnB1dCA/IFwiaW5wdXRcIiA6IFwib3V0cHV0XCIsIFtdICkgKTtcclxuXHRcdFx0XHRcdC8vIGFsaWFzLzFcclxuXHRcdFx0XHRcdGlmKCAocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwiYWxpYXMvMVwiKSAmJiBzdHJlYW1zW2ldLmFsaWFzIClcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJhbGlhc1wiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS5hbGlhcywgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyBwb3NpdGlvbi8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJwb3NpdGlvbi8xXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwicG9zaXRpb25cIiwgW1xyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwicG9zaXRpb25cIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE51bShzdHJlYW1zW2ldLmNoYXJfY291bnQsIGZhbHNlKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBOdW0oc3RyZWFtc1tpXS5saW5lX2NvdW50LCBmYWxzZSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgTnVtKHN0cmVhbXNbaV0ubGluZV9wb3NpdGlvbiwgZmFsc2UpXHJcblx0XHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdFx0XSApICk7XHJcblx0XHRcdFx0XHQvLyBlbmRfb2Zfc3RyZWFtLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcImVuZF9vZl9zdHJlYW0vMVwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcImVuZF9vZl9zdHJlYW1cIiwgW25ldyBUZXJtKFxyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbXNbaV0ucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiIHx8IHN0cmVhbXNbaV0uc3RyZWFtLmVvZiAmJiBzdHJlYW1zW2ldLnN0cmVhbS5lb2Yoc3RyZWFtc1tpXS5wb3NpdGlvbikgPyBcImF0XCIgOlxyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbXNbaV0ucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgPyBcInBhc3RcIiA6XHJcblx0XHRcdFx0XHRcdFx0XCJub3RcIiwgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyBlb2ZfYWN0aW9uLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcImVvZl9hY3Rpb24vMVwiKVx0XHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwiZW9mX2FjdGlvblwiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS5lb2ZfYWN0aW9uLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIHJlcG9zaXRpb24vMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwicmVwb3NpdGlvbi8xXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwicmVwb3NpdGlvblwiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS5yZXBvc2l0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gdHlwZS8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJ0eXBlLzFcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJ0eXBlXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLnR5cGUsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaisrICkge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaCggbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3BsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApID8gc3RyZWFtIDogc3RyZWFtMiwgc3RyZWFtc1tpXV0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtwcm9wZXJ0eSwgcHJvcGVydGllc1tqXV0pXSkgKSxcclxuXHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0KSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc3RyZWFtX3Bvc2l0aW9uX2RhdGFcclxuXHRcdFwic3RyZWFtX3Bvc2l0aW9uX2RhdGEvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBmaWVsZCA9IGF0b20uYXJnc1swXSwgcG9zaXRpb24gPSBhdG9tLmFyZ3NbMV0sIHZhbHVlID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHBvc2l0aW9uKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc190ZXJtKHBvc2l0aW9uKSB8fCBwb3NpdGlvbi5pbmRpY2F0b3IgIT09IFwicG9zaXRpb24vM1wiKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmRvbWFpbihcInN0cmVhbV9wb3NpdGlvblwiLCBwb3NpdGlvbiwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGZpZWxkKSAmJiAhcGwudHlwZS5pc19hdG9tKGZpZWxkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiYXRvbVwiLCBmaWVsZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHZhbHVlKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKHZhbHVlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCB2YWx1ZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgZmllbGRzID0gW1wiY2hhcl9jb3VudFwiLCBcImxpbmVfY291bnRcIiwgXCJsaW5lX3Bvc2l0aW9uXCJdO1xyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgZGF0YV9wb3MgPSB7Y2hhcl9jb3VudDogMCwgbGluZV9jb3VudDogMSwgbGluZV9wb3NpdGlvbjogMn07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShmaWVsZCkpIHtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtuZXcgVGVybShmaWVsZHNbaV0pLCBmaWVsZF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFt2YWx1ZSwgcG9zaXRpb24uYXJnc1tkYXRhX3Bvc1tmaWVsZHNbaV1dXV0pXHJcblx0XHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdFx0KSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZihkYXRhX3Bvcy5oYXNPd25Qcm9wZXJ0eShmaWVsZC5pZCkpIHtcclxuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbdmFsdWUsIHBvc2l0aW9uLmFyZ3NbZGF0YV9wb3NbZmllbGQuaWRdXV0pXHJcblx0XHRcdFx0XHQpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gYXRfZW5kX29mX3N0cmVhbS8wXHJcblx0XHRcImF0X2VuZF9vZl9zdHJlYW0vMFwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiYXRfZW5kX29mX3N0cmVhbVwiLCBbXSksIG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcInN0cmVhbV9wcm9wZXJ0eVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFRlcm0oXCJlbmRfb2Zfc3RyZWFtXCIsIFtuZXcgVmFyKFwiRVwiKV0pXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIiFcIiwgW10pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiRVwiKSxuZXcgVGVybShcImF0XCIsIFtdKV0pLG5ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIkVcIiksbmV3IFRlcm0oXCJwYXN0XCIsIFtdKV0pXSldKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIGF0X2VuZF9vZl9zdHJlYW0vMVxyXG5cdFx0XCJhdF9lbmRfb2Zfc3RyZWFtLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBlID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwic3RyZWFtX3Byb3BlcnR5XCIsIFtzdHJlYW0yLG5ldyBUZXJtKFwiZW5kX29mX3N0cmVhbVwiLCBbZV0pXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCIhXCIsIFtdKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiPVwiLCBbZSxuZXcgVGVybShcImF0XCIsIFtdKV0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2UsbmV3IFRlcm0oXCJwYXN0XCIsIFtdKV0pXSldKV0pXHJcblx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNldF9zdHJlYW1fcG9zaXRpb24vMlxyXG5cdFx0XCJzZXRfc3RyZWFtX3Bvc2l0aW9uLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHBvc2l0aW9uID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvc2l0aW9uICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbV9wb3NpdGlvbiggcG9zaXRpb24gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fcG9zaXRpb25cIiwgcG9zaXRpb24sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnJlcG9zaXRpb24gPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJyZXBvc2l0aW9uXCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBwb3NpdGlvbi5pbmRpY2F0b3IgPT09IFwicG9zaXRpb24vM1wiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IHBvc2l0aW9uLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQgPSBwb3NpdGlvbi5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50ID0gcG9zaXRpb24uYXJnc1sxXS52YWx1ZTtcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IHBvc2l0aW9uLmFyZ3NbMl0udmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBwb3NpdGlvbi5pZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyAgQ0hBUkFDVEVSIElOUFVUIE9VVFBVVFxyXG5cdFx0XHJcblx0XHQvLyBnZXRfY2hhci8xXHJcblx0XHRcImdldF9jaGFyLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdldF9jaGFyXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcImdldF9jaGFyXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIGdldF9jaGFyLzJcclxuXHRcdFwiZ2V0X2NoYXIvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY2hhciA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY2hhciApICYmICFwbC50eXBlLmlzX2luX2NoYXJhY3RlciggY2hhciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbl9jaGFyYWN0ZXJcIiwgY2hhciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9jaGFyO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fY2hhciA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2NoYXIgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRpZihzdHJlYW1fY2hhciA9PT0gXCJcXG5cIikge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IDA7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKHN0cmVhbV9jaGFyLFtdKSwgY2hhcl0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGdldF9jb2RlLzFcclxuXHRcdFwiZ2V0X2NvZGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ2V0X2NvZGVcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwiZ2V0X2NvZGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gZ2V0X2NvZGUvMlxyXG5cdFx0XCJnZXRfY29kZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjb2RlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGNvZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19pbl9jaGFyYWN0ZXJfY29kZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiaW5fY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fY29kZTtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IC0xO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSAtMTtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9jb2RlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3RlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fY29kZSA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSAtMTtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IGNvZGVQb2ludEF0KCBzdHJlYW1fY29kZSwgMCApO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0aWYoc3RyZWFtX2NvZGUgPT09IDEwKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gMDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IE51bShzdHJlYW1fY29kZSwgZmFsc2UpLCBjb2RlXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcGVla19jaGFyLzFcclxuXHRcdFwicGVla19jaGFyLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInBlZWtfY2hhclwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwZWVrX2NoYXJcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcGVla19jaGFyLzJcclxuXHRcdFwicGVla19jaGFyLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNoYXIgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNoYXIgKSAmJiAhcGwudHlwZS5pc19pbl9jaGFyYWN0ZXIoIGNoYXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW5fY2hhcmFjdGVyXCIsIGNoYXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fY2hhcjtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2NoYXIgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9jaGFyID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKHN0cmVhbV9jaGFyLFtdKSwgY2hhcl0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHBlZWtfY29kZS8xXHJcblx0XHRcInBlZWtfY29kZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwZWVrX2NvZGVcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicGVla19jb2RlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHBlZWtfY29kZS8yXHJcblx0XHRcInBlZWtfY29kZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjb2RlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGNvZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19pbl9jaGFyYWN0ZXJfY29kZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiaW5fY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fY29kZTtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IC0xO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2NvZGUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9jb2RlID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IC0xO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSBjb2RlUG9pbnRBdCggc3RyZWFtX2NvZGUsIDAgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBOdW0oc3RyZWFtX2NvZGUsIGZhbHNlKSwgY29kZV0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHB1dF9jaGFyLzFcclxuXHRcdFwicHV0X2NoYXIvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicHV0X2NoYXJcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInB1dF9jaGFyXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHB1dF9jaGFyLzJcclxuXHRcdFwicHV0X2NoYXIvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY2hhciA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjaGFyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyKCBjaGFyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNoYXJhY3RlclwiLCBjaGFyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLmlucHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnN0cmVhbS5wdXQoIGNoYXIuaWQsIHN0cmVhbTIucG9zaXRpb24gKSApIHtcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBzdHJlYW0yLnBvc2l0aW9uID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0aWYoY2hhci5pZCA9PT0gXCJcXG5cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQrKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwdXRfY29kZS8xXHJcblx0XHRcInB1dF9jb2RlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInB1dF9jb2RlXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwdXRfY29kZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwdXRfY29kZS8yXHJcblx0XHRcInB1dF9jb2RlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNvZGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBjb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyX2NvZGUoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIuaW5wdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIuc3RyZWFtLnB1dCggZnJvbUNvZGVQb2ludCggY29kZS52YWx1ZSApLCBzdHJlYW0yLnBvc2l0aW9uICkgKSB7XHJcblx0XHRcdFx0XHRpZih0eXBlb2Ygc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIilcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdGlmKGNvZGUudmFsdWUgPT09IDEwKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIG5sLzBcclxuXHRcdFwibmwvMFwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwibmxcIiksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInB1dF9jaGFyXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVGVybShcIlxcblwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIG5sLzFcclxuXHRcdFwibmwvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oXCJwdXRfY2hhclwiLCBbc3RyZWFtLCBuZXcgVGVybShcIlxcblwiLCBbXSldKSApLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIEJZVEUgSU5QVVQvT1VUUFVUXHJcblxyXG5cdFx0Ly8gZ2V0X2J5dGUvMVxyXG5cdFx0XCJnZXRfYnl0ZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnZXRfYnl0ZVwiLCBbbmV3IFZhcihcIkJcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJnZXRfYnl0ZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkJcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBnZXRfYnl0ZS8yXHJcblx0XHRcImdldF9ieXRlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGJ5dGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGJ5dGUgKSAmJiAhcGwudHlwZS5pc19pbl9ieXRlKCBieXRlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImluX2J5dGVcIiwgYnl0ZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcInRleHRcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJ0ZXh0X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2J5dGU7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSAtMTtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IHN0cmVhbTIuc3RyZWFtLmdldF9ieXRlKCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2J5dGUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiYnl0ZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fYnl0ZSA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSAtMTtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24rKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBOdW0oc3RyZWFtX2J5dGUsZmFsc2UpLCBieXRlXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHBlZWtfYnl0ZS8xXHJcblx0XHRcInBlZWtfYnl0ZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwZWVrX2J5dGVcIiwgW25ldyBWYXIoXCJCXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicGVla19ieXRlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQlwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHBlZWtfYnl0ZS8yXHJcblx0XHRcInBlZWtfYnl0ZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBieXRlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBieXRlICkgJiYgIXBsLnR5cGUuaXNfaW5fYnl0ZSggYnl0ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbl9ieXRlXCIsIGJ5dGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJ0ZXh0XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwidGV4dF9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9ieXRlO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gLTE7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSBzdHJlYW0yLnN0cmVhbS5nZXRfYnl0ZSggc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9ieXRlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImJ5dGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2J5dGUgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gLTE7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgTnVtKHN0cmVhbV9ieXRlLGZhbHNlKSwgYnl0ZV0gKSApLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHB1dF9ieXRlLzFcclxuXHRcdFwicHV0X2J5dGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicHV0X2J5dGVcIiwgW25ldyBWYXIoXCJCXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInB1dF9ieXRlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQlwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHB1dF9ieXRlLzJcclxuXHRcdFwicHV0X2J5dGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgYnl0ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBieXRlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYnl0ZSggYnl0ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJieXRlXCIsIGJ5dGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIuaW5wdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwidGV4dFwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJ0ZXh0X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5zdHJlYW0ucHV0X2J5dGUoIGJ5dGUudmFsdWUsIHN0cmVhbTIucG9zaXRpb24gKSApIHtcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBzdHJlYW0yLnBvc2l0aW9uID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gVEVSTSBJTlBVVC9PVVRQVVRcclxuXHJcblx0XHQvLyByZWFkLzFcclxuXHRcdFwicmVhZC8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJyZWFkXCIsIFtuZXcgVmFyKFwiVFwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInJlYWRfdGVybVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIiksbmV3IFRlcm0oXCJbXVwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHJlYWQvMlxyXG5cdFx0XCJyZWFkLzJcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInJlYWRcIiwgW25ldyBWYXIoXCJTXCIpLCBuZXcgVmFyKFwiVFwiKV0pLCBuZXcgVGVybShcInJlYWRfdGVybVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIiksbmV3IFRlcm0oXCJbXVwiKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyByZWFkX3Rlcm0vMlxyXG5cdFx0XCJyZWFkX3Rlcm0vMlwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicmVhZF90ZXJtXCIsIFtuZXcgVmFyKFwiVFwiKSxuZXcgVmFyKFwiT1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInJlYWRfdGVybVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIiksbmV3IFZhcihcIk9cIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyByZWFkX3Rlcm0vM1xyXG5cdFx0XCJyZWFkX3Rlcm0vM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgdGVybSA9IGF0b20uYXJnc1sxXSwgb3B0aW9ucyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5vdXRwdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJiaW5hcnlfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVvZl9jb2RlXCIgKSB7XHJcblx0XHRcdFx0ZXhwciA9IHtcclxuXHRcdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcImVuZF9vZl9maWxlXCIsIFtdKSxcclxuXHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1MsXHJcblx0XHRcdFx0XHRsZW46IC0xXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBHZXQgb3B0aW9uc1xyXG5cdFx0XHRcdHZhciBvYmpfb3B0aW9ucyA9IHt9O1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gb3B0aW9ucztcclxuXHRcdFx0XHR2YXIgcHJvcGVydHk7XHJcblx0XHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdHByb3BlcnR5ID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3JlYWRfb3B0aW9uKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJyZWFkX29wdGlvblwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRvYmpfb3B0aW9uc1twcm9wZXJ0eS5pZF0gPSBwcm9wZXJ0eS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgY2hhciwgdG9rZW5pemVyLCBleHByO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSBcIlwiO1xyXG5cdFx0XHRcdFx0dmFyIHRva2VucyA9IFtdO1xyXG5cdFx0XHRcdFx0dmFyIGxhc3RfdG9rZW4gPSBudWxsO1xyXG5cdFx0XHRcdFx0dmFyIGxleGljYWxfZXJyb3IgPSBmYWxzZTtcclxuXHRcdFx0XHRcdC8vIEdldCB0ZXJtXHJcblx0XHRcdFx0XHR3aGlsZSggbGFzdF90b2tlbiA9PT0gbnVsbCB8fCBsZXhpY2FsX2Vycm9yIHx8IGxhc3RfdG9rZW4ubmFtZSAhPT0gXCJhdG9tXCIgfHwgbGFzdF90b2tlbi52YWx1ZSAhPT0gXCIuXCIgfHwgdG9rZW5zLmxlbmd0aCA+IDAgJiYgZXhwci50eXBlID09PSBFUlJPUiApIHtcclxuXHRcdFx0XHRcdFx0Y2hhciA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHR3aGlsZShjaGFyICE9PSBudWxsICYmIGNoYXIgIT09IFwiLlwiICYmIGNoYXIgIT09IFwiZW5kX29mX3N0cmVhbVwiICYmIGNoYXIgIT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdFx0dGV4dCArPSBjaGFyO1xyXG5cdFx0XHRcdFx0XHRcdGNoYXIgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiggY2hhciA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3RlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIGNoYXIgPT09IFwiZW5kX29mX3N0cmVhbVwiIHx8IGNoYXIgPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYodG9rZW5zID09PSBudWxsIHx8IHRva2Vucy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwciA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiZW5kX29mX2ZpbGVcIiwgW10pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRsZW46IC0xXHJcblx0XHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKGV4cHIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3Iuc3ludGF4KCBsYXN0X3Rva2VuLCBcInVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVcIiwgZmFsc2UgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnN5bnRheCggbGFzdF90b2tlbiwgXCJ0b2tlbiBub3QgZm91bmRcIiwgdHJ1ZSApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoY2hhciA9PT0gXCIuXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdFx0dGV4dCArPSBjaGFyO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIoIHRocmVhZCApO1xyXG5cdFx0XHRcdFx0XHR0b2tlbml6ZXIubmV3X3RleHQoIHRleHQgKTtcclxuXHRcdFx0XHRcdFx0dG9rZW5zID0gdG9rZW5pemVyLmdldF90b2tlbnMoKTtcclxuXHRcdFx0XHRcdFx0bnVtX3Rva2VuID0gdG9rZW5zICE9PSBudWxsICYmIHRva2Vucy5sZW5ndGggPiAxID8gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMl0gOiBudWxsO1xyXG5cdFx0XHRcdFx0XHRsYXN0X3Rva2VuID0gdG9rZW5zICE9PSBudWxsICYmIHRva2Vucy5sZW5ndGggPiAwID8gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0gOiBudWxsO1xyXG5cdFx0XHRcdFx0XHRpZih0b2tlbnMgPT09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdGxleGljYWxfZXJyb3IgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggJiYgIWxleGljYWxfZXJyb3I7IGkrKylcclxuXHRcdFx0XHRcdFx0XHRsZXhpY2FsX2Vycm9yID0gdG9rZW5zW2ldLm5hbWUgPT09IFwibGV4aWNhbFwiO1xyXG5cdFx0XHRcdFx0XHRpZihsZXhpY2FsX2Vycm9yKVxyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCAwLCB0aHJlYWQuX19nZXRfbWF4X3ByaW9yaXR5KCksIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0aWYobnVtX3Rva2VuICYmIG51bV90b2tlbi5uYW1lID09PSBcIm51bWJlclwiICYmICFudW1fdG9rZW4uZmxvYXQgJiYgIW51bV90b2tlbi5ibGFuayAmJiBsYXN0X3Rva2VuLnZhbHVlID09PSBcIi5cIikge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBuZXh0X2NoYXIgPSBzdHJlYW0yLnN0cmVhbS5nZXQoMSwgc3RyZWFtMi5wb3NpdGlvbik7XHJcblx0XHRcdFx0XHRcdFx0aWYobmV4dF9jaGFyID49ICcwJyAmJiBuZXh0X2NoYXIgPD0gJzknKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0ICs9IG5leHRfY2hhcjtcclxuXHRcdFx0XHRcdFx0XHRcdGxhc3RfdG9rZW4gPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihsYXN0X3Rva2VuKSB7XHJcblx0XHRcdFx0XHRcdGlmKGxhc3RfdG9rZW4ubGluZV9wb3NpdGlvbiA9PT0gbGFzdF90b2tlbi5sZW4pXHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uICs9IGxhc3RfdG9rZW4ubGluZV9wb3NpdGlvbjtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IGxhc3RfdG9rZW4ubGluZV9wb3NpdGlvbjtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50ICs9IGxhc3RfdG9rZW4ubGluZV9jb3VudDtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50ICs9IGxhc3RfdG9rZW4ubGVuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gU3VjY2VlZCBhbmFseXppbmcgdGVybVxyXG5cdFx0XHRcdFx0aWYoIGV4cHIudHlwZSA9PT0gU1VDQ0VTUyAmJiAoZXhwci5sZW4gPT09IC0xIHx8IGV4cHIubGVuID09PSB0b2tlbnMubGVuZ3RoLTEgJiYgbGFzdF90b2tlbi52YWx1ZSA9PT0gXCIuXCIgKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHRleHByID0gZXhwci52YWx1ZS5yZW5hbWUoIHRocmVhZCApO1xyXG5cdFx0XHRcdFx0XHR2YXIgZXEgPSBuZXcgVGVybSggXCI9XCIsIFt0ZXJtLCBleHByXSApO1xyXG5cdFx0XHRcdFx0XHQvLyBWYXJpYWJsZXNcclxuXHRcdFx0XHRcdFx0aWYoIG9ial9vcHRpb25zLnZhcmlhYmxlcyApIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFycyA9IGFycmF5VG9MaXN0KCBtYXAoIG51YiggZXhwci52YXJpYWJsZXMoKSApLCBmdW5jdGlvbih2KSB7IHJldHVybiBuZXcgVmFyKHYpOyB9ICkgKTtcclxuXHRcdFx0XHRcdFx0XHRlcSA9IG5ldyBUZXJtKCBcIixcIiwgW2VxLCBuZXcgVGVybSggXCI9XCIsIFtvYmpfb3B0aW9ucy52YXJpYWJsZXMsIHZhcnNdICldIClcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyBWYXJpYWJsZSBuYW1lc1xyXG5cdFx0XHRcdFx0XHRpZiggb2JqX29wdGlvbnMudmFyaWFibGVfbmFtZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhcnMgPSBudWIoZXhwci52YXJpYWJsZXMoKSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHBsdmFycyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdiA9IHZhcnNbaV07XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IoIHZhciBwcm9wIGluIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXNbIHByb3AgXSA9PT0gdiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBsdmFycy5wdXNoKG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBwcm9wLCBbXSksIG5ldyBWYXIodildICkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBsdmFycyA9IGFycmF5VG9MaXN0KHBsdmFycyk7XHJcblx0XHRcdFx0XHRcdFx0ZXEgPSBuZXcgVGVybSggXCIsXCIsIFtlcSwgbmV3IFRlcm0oIFwiPVwiLCBbb2JqX29wdGlvbnMudmFyaWFibGVfbmFtZXMsIHBsdmFyc10gKV0gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyBTaW5nbGV0b25zXHJcblx0XHRcdFx0XHRcdGlmKCBvYmpfb3B0aW9ucy5zaW5nbGV0b25zICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2YXJzID0gbnViKG5ldyBSdWxlKGV4cHIsIG51bGwpLnNpbmdsZXRvbl92YXJpYWJsZXModHJ1ZSkpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBwbHZhcnMgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHYgPSB2YXJzW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKCB2YXIgcHJvcCBpbiB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzWyBwcm9wIF0gPT09IHYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwbHZhcnMucHVzaChuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggcHJvcCwgW10pLCBuZXcgVmFyKHYpXSApKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwbHZhcnMgPSBhcnJheVRvTGlzdChwbHZhcnMpO1xyXG5cdFx0XHRcdFx0XHRcdGVxID0gbmV3IFRlcm0oIFwiLFwiLCBbZXEsIG5ldyBUZXJtKCBcIj1cIiwgW29ial9vcHRpb25zLnNpbmdsZXRvbnMsIHBsdmFyc10gKV0gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBlcSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHQvLyBGYWlsZWQgYW5hbHl6aW5nIHRlcm1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGlmKCBleHByLnR5cGUgPT09IFNVQ0NFU1MgKVxyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3Iuc3ludGF4KCB0b2tlbnNbZXhwci5sZW5dLCBcInVuZXhwZWN0ZWQgdG9rZW5cIiwgZmFsc2UgKSApO1xyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBleHByLnZhbHVlICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHdyaXRlLzFcclxuXHRcdFwid3JpdGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwid3JpdGVcIiwgW25ldyBWYXIoXCJUXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcIndyaXRlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKV0pXSkpXHJcblx0XHRdLFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZS8yXHJcblx0XHRcIndyaXRlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHRlcm0gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKFwid3JpdGVfdGVybVwiLCBbc3RyZWFtLCB0ZXJtLFxyXG5cdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcInF1b3RlZFwiLCBbbmV3IFRlcm0oXCJmYWxzZVwiLCBbXSldKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcImlnbm9yZV9vcHNcIiwgW25ldyBUZXJtKFwiZmFsc2VcIildKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwibnVtYmVydmFyc1wiLCBbbmV3IFRlcm0oXCJ0cnVlXCIpXSksIG5ldyBUZXJtKFwiW11cIixbXSldKV0pXSldKSApLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGVxLzFcclxuXHRcdFwid3JpdGVxLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcIndyaXRlcVwiLCBbbmV3IFZhcihcIlRcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwid3JpdGVxXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKV0pXSkpXHJcblx0XHRdLFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZXEvMlxyXG5cdFx0XCJ3cml0ZXEvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgdGVybSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oXCJ3cml0ZV90ZXJtXCIsIFtzdHJlYW0sIHRlcm0sXHJcblx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwicXVvdGVkXCIsIFtuZXcgVGVybShcInRydWVcIiwgW10pXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJpZ25vcmVfb3BzXCIsIFtuZXcgVGVybShcImZhbHNlXCIpXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcIm51bWJlcnZhcnNcIiwgW25ldyBUZXJtKFwidHJ1ZVwiKV0pLCBuZXcgVGVybShcIltdXCIsW10pXSldKV0pXSkgKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlX2Nhbm9uaWNhbC8xXHJcblx0XHRcIndyaXRlX2Nhbm9uaWNhbC8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJ3cml0ZV9jYW5vbmljYWxcIiwgW25ldyBWYXIoXCJUXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcIndyaXRlX2Nhbm9uaWNhbFwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIildKV0pKVxyXG5cdFx0XSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGVfY2Fub25pY2FsLzJcclxuXHRcdFwid3JpdGVfY2Fub25pY2FsLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHRlcm0gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKFwid3JpdGVfdGVybVwiLCBbc3RyZWFtLCB0ZXJtLFxyXG5cdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcInF1b3RlZFwiLCBbbmV3IFRlcm0oXCJ0cnVlXCIsIFtdKV0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwiaWdub3JlX29wc1wiLCBbbmV3IFRlcm0oXCJ0cnVlXCIpXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcIm51bWJlcnZhcnNcIiwgW25ldyBUZXJtKFwiZmFsc2VcIildKSwgbmV3IFRlcm0oXCJbXVwiLFtdKV0pXSldKV0pICksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHdyaXRlX3Rlcm0vMlxyXG5cdFx0XCJ3cml0ZV90ZXJtLzJcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcIndyaXRlX3Rlcm1cIiwgW25ldyBWYXIoXCJUXCIpLG5ldyBWYXIoXCJPXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcIndyaXRlX3Rlcm1cIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpLG5ldyBWYXIoXCJPXCIpXSldKSlcclxuXHRcdF0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlX3Rlcm0vM1xyXG5cdFx0XCJ3cml0ZV90ZXJtLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHRlcm0gPSBhdG9tLmFyZ3NbMV0sIG9wdGlvbnMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIuaW5wdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEdldCBvcHRpb25zXHJcblx0XHRcdFx0dmFyIG9ial9vcHRpb25zID0ge307XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcHRpb25zO1xyXG5cdFx0XHRcdHZhciBwcm9wZXJ0eTtcclxuXHRcdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfd3JpdGVfb3B0aW9uKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJ3cml0ZV9vcHRpb25cIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYocHJvcGVydHkuaW5kaWNhdG9yID09PSBcInZhcmlhYmxlX25hbWVzLzFcIilcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbcHJvcGVydHkuaWRdID0gcHJvcGVydHkuYXJnc1swXTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbcHJvcGVydHkuaWRdID0gcHJvcGVydHkuYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCI7XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG9ial9vcHRpb25zLnNlc3Npb24gPSB0aHJlYWQuc2Vzc2lvbjtcclxuXHRcdFx0XHRcdHZhciB0ZXh0ID0gdGVybS50b1N0cmluZyggb2JqX29wdGlvbnMgKTtcclxuXHRcdFx0XHRcdHN0cmVhbTIuc3RyZWFtLnB1dCggdGV4dCwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHR5cGVvZiBzdHJlYW0yLnBvc2l0aW9uID09PSBcIm51bWJlclwiIClcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiArPSB0ZXh0Lmxlbmd0aDtcclxuXHRcdFx0XHRcdHZhciBubCA9ICh0ZXh0Lm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCArPSBubDtcclxuXHRcdFx0XHRcdGlmKG5sID4gMClcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gdGV4dC5sZW5ndGggLSB0ZXh0Lmxhc3RJbmRleE9mKFwiXFxuXCIpIC0gMTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uICs9IHRleHQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50ICs9IHRleHQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBJTVBMRU1FTlRBVElPTiBERUZJTkVEIEhPT0tTXHJcblx0XHRcclxuXHRcdC8vIGhhbHQvMFxyXG5cdFx0XCJoYWx0LzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIF8gKSB7XHJcblx0XHRcdGlmKCB0aHJlYWQuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiIClcclxuXHRcdFx0XHRwcm9jZXNzLmV4aXQoKTtcclxuXHRcdFx0dGhyZWFkLnBvaW50cyA9IFtdO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gaGFsdC8xXHJcblx0XHRcImhhbHQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGludCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGludCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGludCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGludCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCB0aHJlYWQuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiIClcclxuXHRcdFx0XHRcdHByb2Nlc3MuZXhpdChpbnQudmFsdWUpO1xyXG5cdFx0XHRcdHRocmVhZC5wb2ludHMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY3VycmVudF9wcm9sb2dfZmxhZy8yXHJcblx0XHRcImN1cnJlbnRfcHJvbG9nX2ZsYWcvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGZsYWcgPSBhdG9tLmFyZ3NbMF0sIHZhbHVlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGZsYWcgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBmbGFnICkgJiYgIXBsLnR5cGUuaXNfZmxhZyggZmxhZyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInByb2xvZ19mbGFnXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0Zm9yKCB2YXIgbmFtZSBpbiBwbC5mbGFnICkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLmZsYWcuaGFzT3duUHJvcGVydHkobmFtZSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggbmFtZSApLCBmbGFnXSApLCBuZXcgVGVybSggXCI9XCIsIFt0aHJlYWQuZ2V0X2ZsYWcobmFtZSksIHZhbHVlXSApXSApO1xyXG5cdFx0XHRcdFx0c3RhdGVzLnB1c2goIG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggc3RhdGVzICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHNldF9wcm9sb2dfZmxhZy8yXHJcblx0XHRcInNldF9wcm9sb2dfZmxhZy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZmxhZyA9IGF0b20uYXJnc1swXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBmbGFnICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggdmFsdWUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ZsYWcoIGZsYWcgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJwcm9sb2dfZmxhZ1wiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbW9kaWZpYWJsZV9mbGFnKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm1vZGlmeVwiLCBcImZsYWdcIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhbHVlX2ZsYWcoIGZsYWcsIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwiZmxhZ192YWx1ZVwiLCBuZXcgVGVybSggXCIrXCIsIFtmbGFnLCB2YWx1ZV0gKSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5zZXNzaW9uLmZsYWdbZmxhZy5pZF0gPSB2YWx1ZTtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIExPQUQgUFJPTE9HIFNPVVJDRSBGSUxFU1xyXG5cclxuXHRcdC8vIGNvbnN1bHQvMVxyXG5cdFx0XCJjb25zdWx0LzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgc3JjID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYoc3JjLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gc3JjLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0c3JjID0gc3JjLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShzcmMpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19hdG9tKHNyYykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBzcmMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aHJlYWQuY29uc3VsdChzcmMuaWQsIHtcclxuXHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlOiBjb250ZXh0X21vZHVsZSxcclxuXHRcdFx0XHRcdHRleHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0aHRtbDogZmFsc2UsXHJcblx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuYWdhaW4oKTtcclxuXHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRlcnJvcjogZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihlcnIpO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuYWdhaW4oKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBUSU1FIEFORCBEQVRFU1xyXG5cclxuXHRcdC8vIGdldF90aW1lLzFcclxuXHRcdFwiZ2V0X3RpbWUvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHRpbWUgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHRpbWUpICYmICFwbC50eXBlLmlzX251bWJlcih0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJudW1iZXJcIiwgdGltZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBjdXJyZW50ID0gbmV3IE51bShEYXRlLm5vdygpLCB0cnVlKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbdGltZSwgY3VycmVudF0gKSApLCBcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyB0aW1lX3Byb3BlcnR5XHJcblx0XHRcInRpbWVfcHJvcGVydHkvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0aW1lID0gYXRvbS5hcmdzWzBdLCBwcm9wZXJ0eSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZSh0aW1lKSAmJiAhcGwudHlwZS5pc19udW1iZXIodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcIm51bWJlclwiLCB0aW1lLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpICYmICFwbC50eXBlLmlzX3RpbWVfcHJvcGVydHkocHJvcGVydHkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmRvbWFpbihcInRpbWVfcHJvcGVydHlcIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHByb3BzO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpKSB7XHJcblx0XHRcdFx0XHRwcm9wcyA9IFtcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJzXCIsIFwibWludXRlc1wiLCBcInNlY29uZHNcIiwgXCJtaWxsaXNlY29uZHNcIiwgXCJ3ZWVrZGF5XCJdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRwcm9wcyA9IFtwcm9wZXJ0eS5pZF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBkYXRlID0gbmV3IERhdGUodGltZS52YWx1ZSk7XHJcblx0XHRcdFx0dmFyIHZhbHVlO1xyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHN3aXRjaChwcm9wc1tpXSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwieWVhclwiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJ5ZWFyXCIsIFtuZXcgTnVtKGRhdGUuZ2V0RnVsbFllYXIoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJtb250aFwiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJtb250aFwiLCBbbmV3IE51bShkYXRlLmdldE1vbnRoKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiZGF5XCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcImRheVwiLCBbbmV3IE51bShkYXRlLmdldERhdGUoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJob3Vyc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJob3Vyc1wiLCBbbmV3IE51bShkYXRlLmdldEhvdXJzKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwibWludXRlc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJtaW51dGVzXCIsIFtuZXcgTnVtKGRhdGUuZ2V0TWludXRlcygpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcInNlY29uZHNcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwic2Vjb25kc1wiLCBbbmV3IE51bShkYXRlLmdldFNlY29uZHMoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJtaWxsaXNlY29uZHNcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwibWlsbGlzZWNvbmRzXCIsIFtuZXcgTnVtKGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwid2Vla2RheVwiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJ3ZWVrZGF5XCIsIFtuZXcgTnVtKGRhdGUuZ2V0RGF5KCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3Byb3BlcnR5LCB2YWx1ZV0gKSApLCBcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gdGltZV95ZWFyLzJcclxuXHRcdFwidGltZV95ZWFyLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB0aW1lID0gYXRvbS5hcmdzWzBdLCB5ZWFyID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19udW1iZXIodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibnVtYmVyXCIsIHRpbWUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHllYXIpICYmICFwbC50eXBlLmlzX2ludGVnZXIoeWVhcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCB5ZWFyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gbmV3IE51bShuZXcgRGF0ZSh0aW1lLnZhbHVlKS5nZXRGdWxsWWVhcigpLCBmYWxzZSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW3llYXIsIHZhbHVlXSApICksIFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHRpbWVfbW9udGgvMlxyXG5cdFx0XCJ0aW1lX21vbnRoLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB0aW1lID0gYXRvbS5hcmdzWzBdLCBtb250aCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZSh0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfbnVtYmVyKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcIm51bWJlclwiLCB0aW1lLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShtb250aCkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlcihtb250aCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBtb250aCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IG5ldyBOdW0obmV3IERhdGUodGltZS52YWx1ZSkuZ2V0TW9udGgoKSwgZmFsc2UpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFttb250aCwgdmFsdWVdICkgKSwgXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBHUkFNTUFSU1xyXG5cclxuXHRcdC8vIHBocmFzZS8zXHJcblx0XHRcInBocmFzZS8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ3Jib2R5ID0gYXRvbS5hcmdzWzBdLCBzMCA9IGF0b20uYXJnc1sxXSwgcyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKGdyYm9keS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGdyYm9keS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGdyYm9keSA9IGdyYm9keS5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBncmJvZHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jYWxsYWJsZSggZ3Jib2R5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImNhbGxhYmxlXCIsIGdyYm9keSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBnb2FsID0gYm9keV90b19kY2coIGdyYm9keS5jbG9uZSgpLCBzMCwgdGhyZWFkICk7XHJcblx0XHRcdFx0Z29hbC52YWx1ZSA9IG5ldyBUZXJtKFwiOlwiLCBbbmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLCBuZXcgVGVybShcImNhbGxcIiwgW2dvYWwudmFsdWVdKV0pO1xyXG5cdFx0XHRcdGlmKGdvYWwgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIixcIiwgW2dvYWwudmFsdWUsIG5ldyBUZXJtKFwiPVwiLCBbZ29hbC52YXJpYWJsZSwgc10pXSApICksIFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwaHJhc2UvMlxyXG5cdFx0XCJwaHJhc2UvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdyYm9keSA9IGF0b20uYXJnc1swXSwgczAgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwicGhyYXNlXCIsIFtncmJvZHksIHMwLCBuZXcgVGVybShcIltdXCIsIFtdKV0gKSApLCBcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBUQVUgUFJPTE9HIElORk9STUFUSU9OXHJcblxyXG5cdFx0Ly8gdmVyc2lvbi8wXHJcblx0XHRcInZlcnNpb24vMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG1zZyA9IFwiV2VsY29tZSB0byBUYXUgUHJvbG9nIHZlcnNpb24gXCIgKyB2ZXJzaW9uLm1ham9yICsgXCIuXCIgKyB2ZXJzaW9uLm1pbm9yICsgXCIuXCIgKyB2ZXJzaW9uLnBhdGNoICsgXCJcXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiVGF1IFByb2xvZyBjb21lcyB3aXRoIEFCU09MVVRFTFkgTk8gV0FSUkFOVFkuIFRoaXMgaXMgZnJlZSBzb2Z0d2FyZS5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiUGxlYXNlIHJ1biA/LSBsaWNlbnNlLiBmb3IgbGVnYWwgZGV0YWlscy5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiRm9yIG9ubGluZSBoZWxwIGFuZCBiYWNrZ3JvdW5kLCB2aXNpdCBodHRwOi90YXUtcHJvbG9nLm9yZ1wiO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIndyaXRlXCIsIFtuZXcgVGVybSggbXNnLCBbXSApXSApICksIFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBsaWNlbnNlLzBcclxuXHRcdFwibGljZW5zZS8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbXNnID0gXCJUYXUgUHJvbG9nLiBBIFByb2xvZyBpbnRlcnByZXRlciBpbiBKYXZhU2NyaXB0LlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJDb3B5cmlnaHQgKEMpIDIwMTcgLSAyMDIyIEpvc8OpIEFudG9uaW8gUmlhemEgVmFsdmVyZGVcXG5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCIxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIjIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxcblxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFxcXCJBUyBJU1xcXCIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxcblxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBCU0QgMy1DbGF1c2UgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gSWYgbm90LCBzZWUgaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcIjtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJ3cml0ZVwiLCBbbmV3IFRlcm0oIG1zZywgW10gKV0gKSApLCBcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH1cclxuXHJcblx0fSwgXCJhbGxcIiwge1xyXG5cdFx0bWV0YV9wcmVkaWNhdGVzOiB7XHJcblx0XHRcdC8vICckZmluZGFsbCcoPywgMCwgLSwgPylcclxuXHRcdFx0XCIkZmluZGFsbC80XCI6IG5ldyBUZXJtKFwiJGZpbmRhbGxcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IE51bSgwLCBmYWxzZSksIG5ldyBUZXJtKFwiLVwiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vICckYmFnb2YnKD8sIF4sIC0pXHJcblx0XHRcdFwiJGJhZ29mLzNcIjogbmV3IFRlcm0oXCIkYmFnb2ZcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCJeXCIpLCBuZXcgVGVybShcIi1cIildKSxcclxuXHRcdFx0Ly8gJyRzZXRvZicoPywgXiwgLSlcclxuXHRcdFx0XCIkc2V0b2YvM1wiOiBuZXcgVGVybShcIiRzZXRvZlwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIl5cIiksIG5ldyBUZXJtKFwiLVwiKV0pLFxyXG5cdFx0XHQvLyAnJGlmJygwLCAwLCAwKVxyXG5cdFx0XHRcIiRpZi8zXCI6IG5ldyBUZXJtKFwiJGlmXCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vICgwOzApXHJcblx0XHRcdFwiOy8yXCI6IG5ldyBUZXJtKFwiO1wiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vICgwLT4wKVxyXG5cdFx0XHRcIi0+LzJcIjogbmV3IFRlcm0oXCItPlwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vICgwLT4wKVxyXG5cdFx0XHRcIiotPi8yXCI6IG5ldyBUZXJtKFwiKi0+XCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gKFxcKzApXHJcblx0XHRcdFwiXFxcXCsvMVwiOiBuZXcgVGVybShcIlxcXFwrXCIsIFtuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBhYm9saXNoKDopXHJcblx0XHRcdFwiYWJvbGlzaC8xXCI6IG5ldyBUZXJtKFwiYWJvbGlzaFwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIGFzc2VydGEoOilcclxuXHRcdFx0XCJhc3NlcnRhLzFcIjogbmV3IFRlcm0oXCJhc3NlcnRhXCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gYXNzZXJ0eig6KVxyXG5cdFx0XHRcImFzc2VydHovMVwiOiBuZXcgVGVybShcImFzc2VydHpcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBiYWdvZig/LCBeLCAtKVxyXG5cdFx0XHRcImJhZ29mLzNcIjogbmV3IFRlcm0oXCJiYWdvZlwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIl5cIiksIG5ldyBUZXJtKFwiLVwiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDApXHJcblx0XHRcdFwiY2FsbC8xXCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gY2FsbCgxLCA/KVxyXG5cdFx0XHRcImNhbGwvMlwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oMSwgZmFsc2UpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCgyLCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvM1wiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oMiwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDMsID8sID8sID8pXHJcblx0XHRcdFwiY2FsbC80XCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSgzLCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCg0LCA/LCA/LCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvNVwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oNCwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCg1LCA/LCA/LCA/LCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvNlwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oNSwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDYsID8sID8sID8sID8sID8sID8pXHJcblx0XHRcdFwiY2FsbC83XCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSg2LCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbCg3LCA/LCA/LCA/LCA/LCA/LCA/LCA/KVxyXG5cdFx0XHRcImNhbGwvOFwiOiBuZXcgVGVybShcImNhbGxcIiwgW25ldyBOdW0oNiwgZmFsc2UpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY2FsbF9jbGVhbnVwKDAsIDApXHJcblx0XHRcdFwiY2FsbF9jbGVhbnVwLzJcIjogbmV3IFRlcm0oXCJjYWxsX2NsZWFudXBcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBjYXRjaCgwLCA/LCAwKVxyXG5cdFx0XHRcImNhdGNoLzNcIjogbmV3IFRlcm0oXCJjYXRjaFwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gY29uc3VsdCg6KVxyXG5cdFx0XHRcImNvbnN1bHQvMVwiOiBuZXcgVGVybShcImNvbnN1bHRcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBjbGF1c2UoOiwgPylcclxuXHRcdFx0XCJjbGF1c2UvMlwiOiBuZXcgVGVybShcImNsYXVzZVwiLCBbbmV3IFRlcm0oXCI6XCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gY3VycmVudF9wcmVkaWNhdGUoPywgOilcclxuXHRcdFx0XCJjdXJyZW50X3ByZWRpY2F0ZS8yXCI6IG5ldyBUZXJtKFwiY3VycmVudF9wcmVkaWNhdGVcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIGZpbmRhbGwoPywgMCwgLSlcclxuXHRcdFx0XCJmaW5kYWxsLzNcIjogbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBOdW0oMCwgZmFsc2UpLCBuZXcgVGVybShcIi1cIildKSxcclxuXHRcdFx0Ly8gZmluZGFsbCg/LCAwLCAtLCA/KVxyXG5cdFx0XHRcImZpbmRhbGwvNFwiOiBuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IE51bSgwLCBmYWxzZSksIG5ldyBUZXJtKFwiLVwiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGZvcmFsbCgwLCAwKVxyXG5cdFx0XHRcImZvcmFsbC8yXCI6IG5ldyBUZXJtKFwiZm9yYWxsXCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gbGlzdGluZyg6KVxyXG5cdFx0XHRcImxpc3RpbmcvMVwiOiBuZXcgVGVybShcImxpc3RpbmdcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBvbmNlKDApXHJcblx0XHRcdFwib25jZS8xXCI6IG5ldyBUZXJtKFwib25jZVwiLCBbbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gcGhyYXNlKDosID8pXHJcblx0XHRcdFwicGhyYXNlLzJcIjogbmV3IFRlcm0oXCJwaHJhc2VcIiwgW25ldyBUZXJtKFwiOlwiKSxuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gcGhyYXNlKDosID8sID8pXHJcblx0XHRcdFwicGhyYXNlLzNcIjogbmV3IFRlcm0oXCJwaHJhc2VcIiwgW25ldyBUZXJtKFwiOlwiKSxuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyByZXRyYWN0KDopXHJcblx0XHRcdFwicmV0cmFjdC8xXCI6IG5ldyBUZXJtKFwicmV0cmFjdFwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIHJldHJhY3RhbGwoOilcclxuXHRcdFx0XCJyZXRyYWN0YWxsLzFcIjogbmV3IFRlcm0oXCJyZXRyYWN0YWxsXCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gc2V0dXBfY2FsbF9jbGVhbnVwKDAsIDAsIDApXHJcblx0XHRcdFwic2V0dXBfY2FsbF9jbGVhbnVwLzNcIjogbmV3IFRlcm0oXCJzZXR1cF9jYWxsX2NsZWFudXBcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gc2V0b2YoPywgXiwgLSlcclxuXHRcdFx0XCJzZXRvZi8zXCI6IG5ldyBUZXJtKFwic2V0b2ZcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCJeXCIpLCBuZXcgVGVybShcIi1cIildKVxyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRpZiggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgKSB7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IHBsO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aW5kb3cucGwgPSBwbDtcclxuXHR9XHJcblx0XHJcbn0pKCk7XHJcbiIsInZhciBwbDtcclxuKGZ1bmN0aW9uKHBsKSB7XHJcblxyXG5cdC8vIEV4dGVuZCBUYXUgUHJvbG9nIHByb3RvdHlwZXNcclxuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24ocGwpIHtcclxuXHJcblx0XHQvLyBDb25zdWx0IGEgcHJvZ3JhbSBmcm9tIGEgc3RyaW5nXHJcblx0XHRwbC50eXBlLlNlc3Npb24ucHJvdG90eXBlLnByb21pc2VDb25zdWx0ID0gZnVuY3Rpb24ocHJvZ3JhbSwgb3B0aW9ucykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHJvbWlzZUNvbnN1bHQocHJvZ3JhbSwgb3B0aW9ucyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdHBsLnR5cGUuVGhyZWFkLnByb3RvdHlwZS5wcm9taXNlQ29uc3VsdCA9IGZ1bmN0aW9uKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHRcdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdFx0XHR2YXIgb3B0cyA9IHt9O1xyXG5cdFx0XHRcdG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRcdFx0b3B0cy5jb250ZXh0X21vZHVsZSA9IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdFx0b3B0cy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xyXG5cdFx0XHRcdG9wdHMuaHRtbCA9IG9wdGlvbnMuaHRtbDtcclxuXHRcdFx0XHRvcHRzLnVybCA9IG9wdGlvbnMudXJsO1xyXG5cdFx0XHRcdG9wdHMuZmlsZSA9IG9wdGlvbnMuZmlsZTtcclxuXHRcdFx0XHRvcHRzLnNjcmlwdCA9IG9wdGlvbnMuc2NyaXB0O1xyXG5cdFx0XHRcdG9wdHMuc3VjY2VzcyA9IHJlc29sdmU7XHJcblx0XHRcdFx0b3B0cy5lcnJvciA9IHJlamVjdDtcclxuXHRcdFx0XHR0aHJlYWQuY29uc3VsdChwcm9ncmFtLCBvcHRzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFF1ZXJ5IGdvYWwgZnJvbSBhIHN0cmluZyAod2l0aG91dCA/LSlcclxuXHRcdHBsLnR5cGUuU2Vzc2lvbi5wcm90b3R5cGUucHJvbWlzZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRocmVhZC5wcm9taXNlUXVlcnkoc3RyaW5nKTtcclxuXHRcdH07XHJcblxyXG5cdFx0cGwudHlwZS5UaHJlYWQucHJvdG90eXBlLnByb21pc2VRdWVyeSA9IGZ1bmN0aW9uKHN0cmluZykge1xyXG5cdFx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0XHRcdHRocmVhZC5xdWVyeShzdHJpbmcsIHtcclxuXHRcdFx0XHRcdHN1Y2Nlc3M6IHJlc29sdmUsXHJcblx0XHRcdFx0XHRlcnJvcjogcmVqZWN0XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBGaW5kIG5leHQgY29tcHV0ZWQgYW5zd2VyXHJcblx0XHRwbC50eXBlLlNlc3Npb24ucHJvdG90eXBlLnByb21pc2VBbnN3ZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGhyZWFkLnByb21pc2VBbnN3ZXIoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0cGwudHlwZS5UaHJlYWQucHJvdG90eXBlLnByb21pc2VBbnN3ZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcclxuXHRcdFx0XHR0aHJlYWQuYW5zd2VyKHtcclxuXHRcdFx0XHRcdHN1Y2Nlc3M6IHJlc29sdmUsXHJcblx0XHRcdFx0XHRmYWlsOiByZXNvbHZlLFxyXG5cdFx0XHRcdFx0ZXJyb3I6IHJlamVjdCxcclxuXHRcdFx0XHRcdGxpbWl0OiByZWplY3RcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEZpbmQgYWxsIGNvbXB1dGVkIGFuc3dlcnMgKGFzeW5jaHJvbm91cyBnZW5lcmF0b3IgZnVuY3Rpb24pXHJcblx0XHRwbC50eXBlLlNlc3Npb24ucHJvdG90eXBlLnByb21pc2VBbnN3ZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRocmVhZC5wcm9taXNlQW5zd2VycygpO1xyXG5cdFx0fTtcclxuXHRcdHBsLnR5cGUuVGhyZWFkLnByb3RvdHlwZS5wcm9taXNlQW5zd2VycyA9IGFzeW5jIGZ1bmN0aW9uKigpIHtcclxuXHRcdFx0d2hpbGUodHJ1ZSkge1xyXG5cdFx0XHRcdHZhciBhbnN3ZXIgPSBhd2FpdCB0aGlzLnByb21pc2VBbnN3ZXIoKTtcclxuXHRcdFx0XHRpZihhbnN3ZXIgIT09IGZhbHNlKVxyXG5cdFx0XHRcdFx0eWllbGQgYW5zd2VyO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0fVxyXG5cclxuXHRpZih0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwKSB7XHJcblx0XHRcdHBsID0gcDtcclxuXHRcdFx0ZXh0ZW5kKHBsKTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGV4dGVuZChwbCk7XHJcblx0fVxyXG5cclxufSkocGwpOyIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImJpZ1wiLFxuICAgIFwic21hbGxcIixcbiAgICBcImhlbHBmdWxcIixcbiAgICBcInJlZFwiLFxuICAgIFwiYmxhY2tcIixcbiAgICBcImdyZWF0XCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJpc1wiLFxuICAgIFwiYXJlXCIsXG4gICAgXCJiZVwiXG5dIiwiZXhwb3J0IGRlZmF1bHRbXG4gICAgXCJ0aGVcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcInNvbWVcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImRvXCIsXG4gICAgXCJkb2VzXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJhXCIsXG4gICAgXCJhblwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZXhpc3RcIixcbiAgICBcImV4aXN0c1wiLFxuICAgIFwicnVuXCIsXG4gICAgXCJncm93XCIsXG4gICAgXCJkaWVcIixcbiAgICBcImxpdmVcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImVhdFwiLFxuICAgIFwiZHJpbmtcIixcbiAgICBcIndhdGNoXCIsXG4gICAgXCJtYWtlXCIsXG4gICAgXCJoaXRcIixcbiAgICBcImNsaWNrXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJkb2Vzbid0XCIsXG4gICAgXCJkb2VzIG5vdFwiLFxuICAgICdub3QnLFxuICAgIFwiZG9uJ3RcIixcbiAgICAnZG8gbm90J1xuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImFuZFwiLFxuICAgIFwib3JcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImNhdFwiLFxuICAgIFwibWF0XCIsXG4gICAgXCJ0YWJsZVwiLFxuICAgIFwiZG9nXCIsXG4gICAgXCJub2RlanNcIixcbiAgICBcImNvbG9yXCIsXG4gICAgXCJidXR0b25cIixcbiAgICBcImRpdlwiLFxuICAgIFwicHJlc2lkZW50XCIsXG4gICAgXCJ0cnVtcFwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwidG9cIixcbiAgICBcIndpdGhcIixcbiAgICBcImZyb21cIixcbiAgICBcIm9mXCIsXG4gICAgXCJvdmVyXCIsXG4gICAgXCJvblwiLFxuICAgIFwiYXRcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcInRoYXRcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImlmXCIsXG4gICAgXCJ3aGVuXCIsXG4gICAgXCJiZWNhdXNlXCIsXG4gICAgXCJ3aGlsZVwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwidGhlblwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZXZlcnlcIixcbiAgICBcImFsbFwiLFxuICAgIFwiZWFjaFwiXG5dIiwiaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgY2xhdXNlT2YsIGdldFJhbmRvbUlkLCBJZCB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IFBocmFzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9QaHJhc2VcIjtcbmltcG9ydCBQcmVwb3NpdGlvbiBmcm9tIFwiLi4vdG9rZW5zL1ByZXBvc2l0aW9uXCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi9Ob3VuUGhyYXNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBsZW1lbnQgaW1wbGVtZW50cyBQaHJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgcHJlcG9zaXRpb246IFByZXBvc2l0aW9uLCByZWFkb25seSBub3VuUGhyYXNlOiBOb3VuUGhyYXNlKSB7XG5cbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzKTogQ2xhdXNlIHsgLy8gcHJlcG9zaXRpb24oYXJncy5zdWJqZWN0LCBZKSArIG5vdW5waHJhc2UudG9Qcm9sb2coc3ViamVjdD1ZKVxuXG4gICAgICAgIGNvbnN0IHN1YmpJZCA9IGFyZ3M/LnJvbGVzPy5zdWJqZWN0ID8/ICgoKTogSWQgPT4geyB0aHJvdyBuZXcgRXJyb3IoJ3VuZGVmaW5lZCBzdWJqZWN0IGlkJykgfSkoKVxuICAgICAgICBjb25zdCBuZXdJZCA9IGdldFJhbmRvbUlkKClcblxuICAgICAgICByZXR1cm4gY2xhdXNlT2YodGhpcy5wcmVwb3NpdGlvbi5zdHJpbmcsIHN1YmpJZCwgbmV3SWQpXG4gICAgICAgICAgICAuYW5kKHRoaXMubm91blBocmFzZS50b0NsYXVzZSh7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IG5ld0lkIH0gfSkpXG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IFN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1N1Ym9yZGluYXRlQ2xhdXNlXCI7XG5pbXBvcnQgQ29wdWxhIGZyb20gXCIuLi90b2tlbnMvQ29wdWxhXCI7XG5pbXBvcnQgUmVsYXRpdmVQcm9ub3VuIGZyb20gXCIuLi90b2tlbnMvUmVsYXRpdmVQcm9ub3VuXCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi9Ob3VuUGhyYXNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlIGltcGxlbWVudHMgU3Vib3JkaW5hdGVDbGF1c2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgcmVscHJvbjogUmVsYXRpdmVQcm9ub3VuLCByZWFkb25seSBwcmVkaWNhdGU6IE5vdW5QaHJhc2UsIHJlYWRvbmx5IGNvcHVsYTogQ29wdWxhKSB7XG5cbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZGljYXRlLnRvQ2xhdXNlKHsgLi4uYXJncywgcm9sZXM6IHsgc3ViamVjdDogYXJncz8ucm9sZXM/LnN1YmplY3QgfSB9KVxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbn0iLCJpbXBvcnQgUGhyYXNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1BocmFzZVwiO1xuaW1wb3J0IEFkamVjdGl2ZSBmcm9tIFwiLi4vdG9rZW5zL0FkamVjdGl2ZVwiO1xuaW1wb3J0IEFydGljbGUgZnJvbSBcIi4uL3Rva2Vucy9BcnRpY2xlXCI7XG5pbXBvcnQgTm91biBmcm9tIFwiLi4vdG9rZW5zL05vdW5cIjtcbmltcG9ydCBRdWFudGlmaWVyIGZyb20gXCIuLi90b2tlbnMvUXVhbnRpZmllclwiO1xuaW1wb3J0IENvbXBsZW1lbnQgZnJvbSBcIi4vQ29tcGxlbWVudFwiO1xuaW1wb3J0IFN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1N1Ym9yZGluYXRlQ2xhdXNlXCI7XG5pbXBvcnQgeyBUb1Byb2xvZ0FyZ3MgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlLCBnZXRSYW5kb21JZCwgY2xhdXNlT2YsIGVtcHR5Q2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdW5QaHJhc2UgaW1wbGVtZW50cyBQaHJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgYWRqZWN0aXZlczogQWRqZWN0aXZlW10sXG4gICAgICAgIHJlYWRvbmx5IGNvbXBsZW1lbnRzOiBDb21wbGVtZW50W10sXG4gICAgICAgIHJlYWRvbmx5IG5vdW4/OiBOb3VuLFxuICAgICAgICByZWFkb25seSBxdWFudGlmaWVyPzogUXVhbnRpZmllcixcbiAgICAgICAgcmVhZG9ubHkgYXJ0aWNsZT86IEFydGljbGUsXG4gICAgICAgIHJlYWRvbmx5IHN1Ym9yZENsYXVzZT86IFN1Ym9yZGluYXRlQ2xhdXNlKSB7XG5cbiAgICB9XG5cbiAgICBpc1VuaVF1YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFudGlmaWVyPy5pc1VuaXZlcnNhbCgpID8/IGZhbHNlXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoKVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5hZGplY3RpdmVzXG4gICAgICAgICAgICAubWFwKGEgPT4gYS5zdHJpbmcpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubm91biA/IFt0aGlzLm5vdW4uc3RyaW5nXSA6IFtdKVxuICAgICAgICAgICAgLm1hcChwID0+IGNsYXVzZU9mKHAsIHN1YmplY3RJZCkpXG4gICAgICAgICAgICAucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMiksIGVtcHR5Q2xhdXNlKCkpXG4gICAgICAgICAgICAuYW5kKHRoaXMuY29tcGxlbWVudHMubWFwKGMgPT4gYy50b0NsYXVzZShuZXdBcmdzKSkucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMiksIGVtcHR5Q2xhdXNlKCkpKVxuICAgICAgICAgICAgLmFuZCh0aGlzLnN1Ym9yZENsYXVzZT8udG9DbGF1c2UobmV3QXJncykgPz8gZW1wdHlDbGF1c2UoKSlcblxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbn0iLCJpbXBvcnQgQ29tcG91bmRTZW50ZW5jZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db21wb3VuZFNlbnRlbmNlXCI7XG5pbXBvcnQgeyBUb1Byb2xvZ0FyZ3MgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlLCBnZXRSYW5kb21JZCB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IFNpbXBsZVNlbnRlbmNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1NpbXBsZVNlbnRlbmNlXCI7XG5pbXBvcnQgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGZyb20gXCIuLi90b2tlbnMvU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uXCI7XG5cbi8qKlxuICogQSBzZW50ZW5jZSB0aGF0IHJlbGF0ZXMgdHdvIHNpbXBsZSBzZW50ZW5jZXMgaHlwb3RhY3RpY2FsbHksIGluIGEgXG4gKiBjb25kaXRpb24tb3V0Y29tZSByZWxhdGlvbnNoaXAuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbXBsZXhTZW50ZW5jZSBpbXBsZW1lbnRzIENvbXBvdW5kU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY29uZGl0aW9uOiBTaW1wbGVTZW50ZW5jZSxcbiAgICAgICAgcmVhZG9ubHkgb3V0Y29tZTogU2ltcGxlU2VudGVuY2UsXG4gICAgICAgIHJlYWRvbmx5IHN1YmNvbmo6IFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbikge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvUHJvbG9nQXJncyk6IENsYXVzZSB7XG4gICAgICAgIGNvbnN0IHN1YmplY3RJZCA9IGFyZ3M/LnJvbGVzPy5zdWJqZWN0ID8/IGdldFJhbmRvbUlkKClcbiAgICAgICAgY29uc3QgbmV3QXJncyA9IHsgLi4uYXJncywgcm9sZXM6IHsgc3ViamVjdDogc3ViamVjdElkIH0gfVxuXG4gICAgICAgIC8vVE9ETzogdGhpcyBpcyBXUk9ORywgc3ViamVjdCBvZiBjb25kaXRpb24gbWF5IE5PVCBhbHdheXMgYmUgdGhlIHN1YmplY3Qgb2YgdGhlIG91dGNvbWVcbiAgICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5jb25kaXRpb24udG9DbGF1c2UobmV3QXJncylcbiAgICAgICAgY29uc3Qgb3V0Y29tZSA9IHRoaXMub3V0Y29tZS50b0NsYXVzZShuZXdBcmdzKVxuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24uaW1wbGllcyhvdXRjb21lKVxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBCaW5hcnlRdWVzdGlvbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9CaW5hcnlRdWVzdGlvblwiO1xuaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBOb3VuUGhyYXNlIGZyb20gXCIuLi9waHJhc2VzL05vdW5QaHJhc2VcIjtcbmltcG9ydCBDb3B1bGEgZnJvbSBcIi4uL3Rva2Vucy9Db3B1bGFcIjtcbmltcG9ydCBDb3B1bGFTZW50ZW5jZSBmcm9tIFwiLi9Db3B1bGFTZW50ZW5jZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3B1bGFRdWVzdGlvbiBpbXBsZW1lbnRzIEJpbmFyeVF1ZXN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHN1YmplY3Q6IE5vdW5QaHJhc2UsIHJlYWRvbmx5IHByZWRpY2F0ZTogTm91blBocmFzZSwgcmVhZG9ubHkgY29wdWxhOiBDb3B1bGEpIHtcblxuICAgIH1cblxuICAgIHRvQ2xhdXNlKGFyZ3M/OiBUb1Byb2xvZ0FyZ3MpOiBDbGF1c2Uge1xuXG4gICAgICAgIGNvbnN0IHN1YmplY3RJZCA9IGFyZ3M/LnJvbGVzPy5zdWJqZWN0ID8/IGdldFJhbmRvbUlkKHsgYXNWYXI6IHRoaXMuc3ViamVjdC5pc1VuaVF1YW50KCkgfSlcbiAgICAgICAgY29uc3QgbmV3QXJncyA9IHsgLi4uYXJncywgcm9sZXM6IHsgc3ViamVjdDogc3ViamVjdElkIH0gfVxuXG4gICAgICAgIC8vVE9ETzogaW4gY2FzZSBvZiBhIHVuaXZlcnNhbGx5IHF1YW50aWZpZWQgcXVlc3Rpb24gZWc6IFwiYXJlIGFsbCBjYXRzIHNtYXJ0P1wiIHRoZSBwcm9sb2dcbiAgICAgICAgLy8gcHJvZHVjZWQgc2hvdWxkIE5PVCBiZSBhbiBpbXBsaWNhdGlvbiwgYnV0IHJhdGhlciBhIGNoZWNrIHRoYXQgYWxsIGNhdHMgYXJlIHNtYXJ0LlxuXG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhU2VudGVuY2UodGhpcy5zdWJqZWN0LCB0aGlzLmNvcHVsYSwgdGhpcy5wcmVkaWNhdGUpLnRvQ2xhdXNlKG5ld0FyZ3MpXG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgVG9Qcm9sb2dBcmdzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBTaW1wbGVTZW50ZW5jZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TaW1wbGVTZW50ZW5jZVwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IENvcHVsYSBmcm9tIFwiLi4vdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IE5lZ2F0aW9uIGZyb20gXCIuLi90b2tlbnMvTmVnYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29wdWxhU2VudGVuY2UgaW1wbGVtZW50cyBTaW1wbGVTZW50ZW5jZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzdWJqZWN0OiBOb3VuUGhyYXNlLCByZWFkb25seSBjb3B1bGE6IENvcHVsYSwgcmVhZG9ubHkgcHJlZGljYXRlOiBOb3VuUGhyYXNlLCByZWFkb25seSBuZWdhdGlvbj86IE5lZ2F0aW9uKSB7XG5cbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzKTogQ2xhdXNlIHtcblxuICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyBnZXRSYW5kb21JZCh7IGFzVmFyOiB0aGlzLnN1YmplY3QuaXNVbmlRdWFudCgpIH0pXG4gICAgICAgIGNvbnN0IG5ld0FyZ3MgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IHN1YmplY3RJZCB9IH1cblxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0LnRvQ2xhdXNlKG5ld0FyZ3MpXG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMucHJlZGljYXRlLnRvQ2xhdXNlKG5ld0FyZ3MpLmNvcHkoeyBuZWdhdGU6ICEhdGhpcy5uZWdhdGlvbiB9KVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN1YmplY3QuaXNVbmlRdWFudCgpID9cbiAgICAgICAgICAgIHN1YmplY3QuaW1wbGllcyhwcmVkaWNhdGUpIDpcbiAgICAgICAgICAgIHN1YmplY3QuYW5kKHByZWRpY2F0ZSwgeyBhc1JoZW1lOiB0cnVlIH0pXG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBUb1Byb2xvZ0FyZ3MgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlLCBjbGF1c2VPZiwgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBWZXJiU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvVmVyYlNlbnRlbmNlXCI7XG5pbXBvcnQgQ29tcGxlbWVudCBmcm9tIFwiLi4vcGhyYXNlcy9Db21wbGVtZW50XCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi4vcGhyYXNlcy9Ob3VuUGhyYXNlXCI7XG5pbXBvcnQgSVZlcmIgZnJvbSBcIi4uL3Rva2Vucy9JVmVyYlwiO1xuaW1wb3J0IE5lZ2F0aW9uIGZyb20gXCIuLi90b2tlbnMvTmVnYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50cmFuc2l0aXZlU2VudGVuY2UgaW1wbGVtZW50cyBWZXJiU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSxcbiAgICAgICAgcmVhZG9ubHkgaXZlcmI6IElWZXJiLFxuICAgICAgICByZWFkb25seSBjb21wbGVtZW50czogQ29tcGxlbWVudFtdLFxuICAgICAgICByZWFkb25seSBuZWdhdGlvbj86IE5lZ2F0aW9uKSB7XG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzKTogQ2xhdXNlIHtcblxuICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyBnZXRSYW5kb21JZCh7IGFzVmFyOiB0aGlzLnN1YmplY3QuaXNVbmlRdWFudCgpIH0pXG4gICAgICAgIGNvbnN0IG5ld0FyZ3MgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IHN1YmplY3RJZCB9IH1cblxuICAgICAgICBjb25zdCB0aGVtZSA9IHRoaXMuc3ViamVjdC50b0NsYXVzZShuZXdBcmdzKVxuICAgICAgICBjb25zdCByaGVtZSA9IGNsYXVzZU9mKHRoaXMuaXZlcmIuc3RyaW5nLCBzdWJqZWN0SWQpXG4gICAgICAgICAgICAuYW5kKHRoaXMuY29tcGxlbWVudHMubWFwKGMgPT4gYy50b0NsYXVzZShuZXdBcmdzKSkucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMikpKVxuXG4gICAgICAgIHJldHVybiB0aGVtZS5hbmQocmhlbWUsIHsgYXNSaGVtZTogdHJ1ZSB9KVxuICAgIH1cblxufVxuXG4iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgeyBUb1Byb2xvZ0FyZ3MgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgVmVyYlNlbnRlbmNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1ZlcmJTZW50ZW5jZVwiO1xuaW1wb3J0IENvbXBsZW1lbnQgZnJvbSBcIi4uL3BocmFzZXMvQ29tcGxlbWVudFwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IE1WZXJiIGZyb20gXCIuLi90b2tlbnMvTVZlcmJcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vdG9rZW5zL05lZ2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vbm90cmFuc2l0aXZlU2VudGVuY2UgaW1wbGVtZW50cyBWZXJiU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSxcbiAgICAgICAgICAgICAgICByZWFkb25seSBtdmVyYjogTVZlcmIsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgb2JqZWN0OiBOb3VuUGhyYXNlLFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5IGNvbXBsZW1lbnRzOiBDb21wbGVtZW50W10sXG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgbmVnYXRpb24/OiBOZWdhdGlvbikge1xuXG4gICAgfVxuICAgIFxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBcbiAgICB0b0NsYXVzZShhcmdzPzogVG9Qcm9sb2dBcmdzIHwgdW5kZWZpbmVkKTogQ2xhdXNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFRva2VuIGltcGxlbWVudHMgVG9rZW57XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzdHJpbmc6c3RyaW5nKXtcblxuICAgIH0gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkamVjdGl2ZSBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IGRlZmluaXRlX2FydGljbGVzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL2RlZmluaXRlX2FydGljbGVzXCI7XG5pbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFydGljbGUgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuXG4gICAgaXNEZWZpbml0ZSgpe1xuICAgICAgICByZXR1cm4gZGVmaW5pdGVfYXJ0aWNsZXMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKXtcbiAgICAgICAgcmV0dXJuIGBBcnRpY2xlKCR7dGhpcy5zdHJpbmd9LCBpc0RlZmluaXRlPSR7dGhpcy5pc0RlZmluaXRlKCl9KWBcbiAgICB9XG5cbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29wdWxhIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVsbFN0b3AgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVmVyYiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElWZXJiIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTVZlcmIgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZWdhdGlvbiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdW4gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVwb3NpdGlvbiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgICAgXG59IiwiaW1wb3J0IGV4aXN0ZW50aWFsX3F1YW50aWZpZXJzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL2V4aXN0ZW50aWFsX3F1YW50aWZpZXJzXCI7XG5pbXBvcnQgdW5pdmVyc2FsX3F1YW50aWZpZXJzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL3VuaXZlcnNhbF9xdWFudGlmaWVyc1wiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXIgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxuICAgIGlzVW5pdmVyc2FsKCl7XG4gICAgICAgIHJldHVybiB1bml2ZXJzYWxfcXVhbnRpZmllcnMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuXG4gICAgaXNFeGlzdGVudGlhbCgpe1xuICAgICAgICByZXR1cm4gZXhpc3RlbnRpYWxfcXVhbnRpZmllcnMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxhdGl2ZVByb25vdW4gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaGVuIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICAgXG59IiwiaW1wb3J0IENvbnN0aXR1ZW50IGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiXG5pbXBvcnQgeyBDbGF1c2UsIElkLCBNYXAgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIlxuaW1wb3J0IFByb2xvZ0JyYWluIGZyb20gXCIuL1Byb2xvZ0JyYWluXCJcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIEJyYWlue1xuICAgIHF1ZXJ5KHF1ZXJ5OkNsYXVzZSk6IFByb21pc2U8TWFwW10gfCBib29sZWFuPlxuICAgIGFzc2VydChjb2RlOkNsYXVzZSk6UHJvbWlzZTx2b2lkPlxuICAgIGV4ZWN1dGUobmF0bGFuZzpzdHJpbmcpOlByb21pc2U8TWFwW10gfCBib29sZWFuPlxuICAgIC8vIGNsb25lKCk6QnJhaW5cbiAgICAvLyBhZGRMaXN0ZW5lcihlbGVtZW50Om51bWJlciwgZXZlbnQ6c3RyaW5nLCBjYWxsYmFjazooZXZlbnQ6RXZlbnQpPT52b2lkKTp2b2lkXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcmFpbigpOlByb21pc2U8QnJhaW4+eyAvLyBhc3luYyBkdWUgdG8gcG9zc2libGUgaW5pdCBwaGFzZSAoaW4gdGhlIGZ1dHVyZSlcbiAgICByZXR1cm4gbmV3IFByb2xvZ0JyYWluKClcbn0iLCJpbXBvcnQgeyBDbGF1c2UsIElkLCBNYXAsIHRvVmFyIH0gZnJvbSBcIi4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBnZXRQYXJzZXIgfSBmcm9tIFwiLi4vcGFyc2VyL1BhcnNlclwiO1xuaW1wb3J0IFByb2xvZywgeyBnZXRQcm9sb2cgfSBmcm9tIFwiLi4vcHJvbG9nL1Byb2xvZ1wiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuL0JyYWluXCI7XG5pbXBvcnQgeyBnZXRTYW5kYm94IH0gZnJvbSBcIi4vU2FuZGJveFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9sb2dCcmFpbiBpbXBsZW1lbnRzIEJyYWluIHtcblxuICAgIHJlYWRvbmx5IGtiOiBQcm9sb2dcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmtiID0gZ2V0UHJvbG9nKClcbiAgICB9XG5cbiAgICBhc3luYyBleGVjdXRlKG5hdGxhbmc6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbiB8IE1hcFtdPiB7XG4gICAgICAgIGNvbnN0IGFzdCA9IGdldFBhcnNlcihuYXRsYW5nKS5wYXJzZSgpXG5cbiAgICAgICAgaWYgKGFzdC5pc1NpZGVFZmZlY3R5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFzc2VydChhc3QudG9DbGF1c2UoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5xdWVyeShhc3QudG9DbGF1c2UoKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHF1ZXJ5KHF1ZXJ5OiBDbGF1c2UpOiBQcm9taXNlPGJvb2xlYW4gfCBNYXBbXT4ge1xuXG4gICAgICAgIGNvbnN0IG1hcFRvVmFyID0gcXVlcnkuZW50aXRpZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoeyBbZV06IHRvVmFyKGUpIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICAvLyBjb25zdCByZXZlcnNlTWFwVG9WYXIgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobWFwVG9WYXIpLm1hcChlID0+IFtlWzFdLCBlWzBdXSkpXG5cbiAgICAgICAgY29uc3QgcSA9IHF1ZXJ5XG4gICAgICAgICAgICAuY29weSh7IG1hcDogbWFwVG9WYXIgfSlcbiAgICAgICAgICAgIC50b1Byb2xvZygpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBgJHthfSwgJHtifWApICsgJy4nIC8vIFRPRE86IGRlYWwgd2l0aCBkb3QgYXQgYSBsb3dlciBsZXZlbCA/XG5cbiAgICAgICAgY29uc3QgcXVlcnlSZXMgPSBhd2FpdCB0aGlzLmtiLnF1ZXJ5KHEpIGFzIE1hcFtdXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcXVlcnlSZXMgLy9UT0RPOiByZXZlcnNlIG1hcCB0byBvcmlnaW5hbCBjb25zdGFudHMgdXNlZCBmb3IgcXVlcnkgPz9cblxuICAgIH1cblxuXG4gICAgYXN5bmMgYXNzZXJ0KGNsYXVzZTogQ2xhdXNlKTogUHJvbWlzZTx2b2lkPiB7XG5cbiAgICAgICAgY29uc3QgYW5hcGhvcmFNYXAgPSBhd2FpdCBnZXRTYW5kYm94KGNsYXVzZSkubWFwVG8odGhpcylcblxuICAgICAgICBjb25zdCB0b0JlQXNzZXJ0ZWQgPSBjbGF1c2VcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBhbmFwaG9yYU1hcCB9KVxuICAgICAgICAgICAgLnRvUHJvbG9nKClcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdG9CZUFzc2VydGVkKSB7IC8vIFRPRE86IGJ1ZyBmaW5kaW5nIG9uZSBlbnRpdHkgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMua2IuYXNzZXJ0KGMpXG4gICAgICAgIH1cblxuICAgIH1cblxufSIsImltcG9ydCB7IENsYXVzZSwgTWFwLCB0b1ZhciB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuL0JyYWluXCI7XG5cbi8qKlxuICogRW50aXRpZXMgaW4gYSBuZXcgc2VudGVuY2UgcG90ZW50aWFsbHkgcG9pbnQgdG8gZXhpc3RpbmcgZW50aXRpZXNcbiAqIGluIHRoZSB1bml2ZXJzZSAoaWU6IHtAbGluayBCcmFpbn0pLiB7QGxpbmsgU2FuZGJveH0gcmVzb2x2ZXMgdGhlIGFuYXBob3JhLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNhbmRib3gge1xuICAgIG1hcFRvKHVuaXZlcnNlOiBCcmFpbik6IFByb21pc2U8TWFwPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2FuZGJveChjbGF1c2U6IENsYXVzZSk6IFNhbmRib3gge1xuICAgIHJldHVybiBuZXcgQmFzZVNhbmRib3goY2xhdXNlKVxufVxuXG5jbGFzcyBCYXNlU2FuZGJveCBpbXBsZW1lbnRzIFNhbmRib3gge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY2xhdXNlOiBDbGF1c2UpIHtcblxuICAgIH1cblxuICAgIGFzeW5jIG1hcFRvKHVuaXZlcnNlOiBCcmFpbik6IFByb21pc2U8TWFwPiB7XG5cbiAgICAgICAgY29uc3QgdGhlbWVFbnRzID0gdGhpcy5jbGF1c2UudGhlbWUuZW50aXRpZXNcblxuICAgICAgICAvLyBnZXQgZGVzY3JpcHRpb25zIG9mIGVudGl0aWVzIGluIHRoZW1lIG9taXR0aW5nIHJlbGF0aW9ucyB3aXRoIGVudGl0aWVzIGluIHJoZW1lXG4gICAgICAgIGNvbnN0IHRoZW1lRGVzY3MgPSB0aGlzLmNsYXVzZS50aGVtZS5mbGF0TGlzdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gIWUuaXNJbXBseSlcblxuICAgICAgICAvLyBnZXQgZGVzY3JpcHRpb25zIG9mIGVudGl0aWVzIGluIHJoZW1lIG9taXR0aW5nIHJlbGF0aW9ucyB3aXRoIGVudGl0aWVzIGluIHRoZW1lXG4gICAgICAgIGNvbnN0IHJoZW1lRGVzY3MgPSB0aGlzLmNsYXVzZS5yaGVtZS5mbGF0TGlzdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGMgPT4gdGhlbWVFbnRzLmV2ZXJ5KGUgPT4gIWMuZW50aXRpZXMuaW5jbHVkZXMoZSkpKVxuICAgICAgICAgICAgLmZpbHRlcihlID0+ICFlLmlzSW1wbHkpXG5cbiAgICAgICAgY29uc3QgbWFwVG9WYXIgPSB0aGlzLmNsYXVzZS5lbnRpdGllc1xuICAgICAgICAgICAgLm1hcChlID0+ICh7IFtlXTogdG9WYXIoZSkgfSkpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiAoeyAuLi5hLCAuLi5iIH0pKVxuXG4gICAgICAgIGNvbnN0IHJldmVyc2VNYXBUb1ZhciA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhtYXBUb1ZhcikubWFwKGUgPT4gW2VbMV0sIGVbMF1dKSlcblxuICAgICAgICBjb25zdCBiaWdEZXNjQ2xhdXNlID0gdGhlbWVEZXNjc1xuICAgICAgICAgICAgLmNvbmNhdChyaGVtZURlc2NzKVxuICAgICAgICAgICAgLnJlZHVjZSgoYzEsIGMyKSA9PiBjMS5hbmQoYzIpKVxuICAgICAgICAgICAgLmNvcHkoeyBtYXA6IG1hcFRvVmFyIH0pXG5cbiAgICAgICAgY29uc3QgY2FuZGlkYXRlcyA9IGF3YWl0IHVuaXZlcnNlLnF1ZXJ5KGJpZ0Rlc2NDbGF1c2UpIGFzIE1hcFtdXG4gICAgICAgIGNvbnN0IGNob3NlbiA9IGNhbmRpZGF0ZXNbMF0gPz8ge30gLy9UT0RPOiBiZXR0ZXIgY3JpdGVyaW9uICEhIVxuXG4gICAgICAgIGNvbnN0IGFuYXBob3JhID0gT2JqZWN0XG4gICAgICAgICAgICAua2V5cyhjaG9zZW4pXG4gICAgICAgICAgICAubWFwKGsgPT4gKHsgW3JldmVyc2VNYXBUb1ZhcltrXV06IGNob3NlbltrXSA/PyByZXZlcnNlTWFwVG9WYXJba10gfSkpXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiAoeyAuLi5hLCAuLi5iIH0pLCB7fSlcblxuICAgICAgICByZXR1cm4gYW5hcGhvcmFcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBDbGF1c2UsIEFuZE9wdHMsIENvcHlPcHRzLCBlbXB0eUNsYXVzZSwgSWQgfSBmcm9tIFwiLi9DbGF1c2VcIjtcbmltcG9ydCBJbXBseSBmcm9tIFwiLi9JbXBseVwiO1xuaW1wb3J0IEFuZENsYXVzZSBmcm9tIFwiLi9MaXN0Q2xhdXNlXCI7XG5cblxuZXhwb3J0IGNsYXNzIEJhc2ljQ2xhdXNlIGltcGxlbWVudHMgQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHByZWRpY2F0ZTogc3RyaW5nLCByZWFkb25seSBhcmdzOiBJZFtdLCByZWFkb25seSBuZWdhdGVkID0gZmFsc2UsIHJlYWRvbmx5IGlzSW1wbHkgPSBmYWxzZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmRDbGF1c2UodGhpcy5mbGF0TGlzdCgpLmNvbmNhdChvdGhlci5mbGF0TGlzdCgpKSlcbiAgICB9XG5cbiAgICBjb3B5KG9wdHM/OiBDb3B5T3B0cyk6IEJhc2ljQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNpY0NsYXVzZSh0aGlzLnByZWRpY2F0ZSwgdGhpcy5hcmdzLm1hcChhID0+IG9wdHM/Lm1hcCA/IG9wdHM/Lm1hcFthXSA/PyBhIDogYSksIG9wdHM/Lm5lZ2F0ZSA/ICF0aGlzLm5lZ2F0ZWQgOiB0aGlzLm5lZ2F0ZWQpXG4gICAgfVxuXG4gICAgZmxhdExpc3QoKTogQ2xhdXNlW10ge1xuICAgICAgICByZXR1cm4gW3RoaXMuY29weSgpXVxuICAgIH1cblxuICAgIHRvUHJvbG9nKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgY29uc3QgY29yZSA9IGAke3RoaXMucHJlZGljYXRlfSgke3RoaXMuYXJncy5yZWR1Y2UoKGEsIGIpID0+IGAke2F9LCAke2J9YCl9KWBcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZCA/IFtgbG9naWNOb3QoJHtjb3JlfSlgXSA6IFtjb3JlXVxuICAgIH1cblxuICAgIGdldCBlbnRpdGllcygpOiBJZFtdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmFyZ3MuY29uY2F0KFtdKSkpXG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoKVxuICAgIH1cblxuICAgIGdldCByaGVtZSgpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gZW1wdHlDbGF1c2UoKVxuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLmNvcHkoKSwgY29uY2x1c2lvbi5jb3B5KCkpXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmFzaWNDbGF1c2UgfSBmcm9tIFwiLi9CYXNpY0NsYXVzZVwiXG5pbXBvcnQgQW5kQ2xhdXNlIGZyb20gXCIuL0xpc3RDbGF1c2VcIlxuXG5leHBvcnQgdHlwZSBJZCA9IG51bWJlciB8IHN0cmluZ1xuXG4vKipcbiAqIEEgJ2xhbmd1YWdlLWFnbm9zdGljJyBmaXJzdCBvcmRlciBsb2dpYyByZXByZXNlbnRhdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDbGF1c2Uge1xuICAgIGFuZChvdGhlcjogQ2xhdXNlLCBvcHRzPzogQW5kT3B0cyk6IENsYXVzZVxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlXG4gICAgY29weShvcHRzPzogQ29weU9wdHMpOiBDbGF1c2VcbiAgICBmbGF0TGlzdCgpOiBDbGF1c2VbXVxuICAgIHRvUHJvbG9nKCk6IHN0cmluZ1tdXG4gICAgcmVhZG9ubHkgbmVnYXRlZDogYm9vbGVhblxuICAgIHJlYWRvbmx5IGlzSW1wbHk6IGJvb2xlYW5cbiAgICBnZXQgZW50aXRpZXMoKTogSWRbXVxuICAgIGdldCB0aGVtZSgpOiBDbGF1c2VcbiAgICBnZXQgcmhlbWUoKTogQ2xhdXNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGF1c2VPZihwcmVkaWNhdGU6IHN0cmluZywgLi4uYXJnczogSWRbXSkge1xuICAgIHJldHVybiBuZXcgQmFzaWNDbGF1c2UocHJlZGljYXRlLCBhcmdzKVxufVxuXG5leHBvcnQgY29uc3QgZW1wdHlDbGF1c2UgPSAoKTogQ2xhdXNlID0+IG5ldyBBbmRDbGF1c2UoW10pXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29weU9wdHMge1xuICAgIG5lZ2F0ZT86IGJvb2xlYW5cbiAgICBtYXA/OiBNYXBcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbmRPcHRzIHtcbiAgICBhc1JoZW1lPzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldFJhbmRvbUlkT3B0cyB7XG4gICAgYXNWYXI6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbUlkKG9wdHM/OiBHZXRSYW5kb21JZE9wdHMpOiBJZCB7IC8vIFRPRE86IGhpZ2hlciBjb25zdCBmb3IgcHJvZHVjdGlvbiB0byBhdm9pZCBjb2xsaXNpb25zXG4gICAgcmV0dXJuIGAke29wdHM/LmFzVmFyID8gJ0lkJyA6ICdpZCd9JHtwYXJzZUludCgxMDAwICogTWF0aC5yYW5kb20oKSArICcnKX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1ZhcihpZDogSWQpOiBJZCB7XG4gICAgcmV0dXJuICghTnVtYmVyLmlzTmFOKE51bWJlcihpZCkpID8gYGlkJHtpZH1gIDogaWQgKyAnJykudG9VcHBlckNhc2UoKVxufVxuXG4vKipcbiAqIE1hcHBpbmcgYW55IGdpdmVuIGlkIGluIHRoZSBzYW5kYm94IHRvIGFuIGlkIGluIHRoZSBcbiAqIGxhcmdlciB1bml2ZXJzZS5cbiAqL1xuZXhwb3J0IHR5cGUgTWFwID0geyBbYTogSWRdOiBJZCB9IiwiaW1wb3J0IHsgQ2xhdXNlLCBBbmRPcHRzLCBDb3B5T3B0cywgSWQgfSBmcm9tIFwiLi9DbGF1c2VcIjtcbmltcG9ydCBBbmRDbGF1c2UgZnJvbSBcIi4vTGlzdENsYXVzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbXBseSBpbXBsZW1lbnRzIENsYXVzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBjb25kaXRpb246IENsYXVzZSwgcmVhZG9ubHkgY29uY2x1c2lvbjogQ2xhdXNlLCByZWFkb25seSBuZWdhdGVkID0gZmFsc2UsIHJlYWRvbmx5IGlzSW1wbHkgPSB0cnVlKSB7XG5cbiAgICB9XG5cbiAgICBhbmQob3RoZXI6IENsYXVzZSwgb3B0cz86IEFuZE9wdHMpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gbmV3IEFuZENsYXVzZShbdGhpcy5jb3B5KCksIG90aGVyLmNvcHkoKV0pXG4gICAgfVxuXG4gICAgY29weShvcHRzPzogQ29weU9wdHMpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gbmV3IEltcGx5KHRoaXMuY29uZGl0aW9uLmNvcHkob3B0cyksIHRoaXMuY29uY2x1c2lvbi5jb3B5KG9wdHMpLCBvcHRzPy5uZWdhdGUgPyAhdGhpcy5uZWdhdGVkIDogdGhpcy5uZWdhdGVkKVxuICAgIH1cblxuICAgIGZsYXRMaXN0KCk6IENsYXVzZVtdIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLmNvcHkoKV1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgaG9ybiBjbGF1c2VzLCBvbmUgZm9yIGVhY2ggY29uY2x1c2lvbi4gXG4gICAgICogU2luY2UgcHJvbG9nIG9ubHkgc3VwcG9ydHMgdGhhdCBraW5kIG9mIGltcGxpY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIHRvUHJvbG9nKCk6IHN0cmluZ1tdIHtcblxuICAgICAgICBjb25zdCBjb25kaXRpb25TdHJpbmcgPSB0aGlzLmNvbmRpdGlvblxuICAgICAgICAgICAgLnRvUHJvbG9nKClcbiAgICAgICAgICAgIC5yZWR1Y2UoKGMxLCBjMikgPT4gYCR7YzF9LCAke2MyfWApXG5cbiAgICAgICAgY29uc3QgY29uY2x1c2lvbnMgPSB0aGlzLmNvbmNsdXNpb24uZmxhdExpc3QoKVxuXG4gICAgICAgIHJldHVybiBjb25jbHVzaW9ucy5tYXAoYyA9PiBgJHtjLnRvUHJvbG9nKClbMF19IDotICR7Y29uZGl0aW9uU3RyaW5nfWApIC8vVE9ETzogWzBdIGlzIHRvIGJlIGRlYWx0IHdpdGggYmV0dGVyXG5cbiAgICB9XG5cbiAgICBnZXQgZW50aXRpZXMoKTogSWRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvbi5lbnRpdGllcy5jb25jYXQodGhpcy5jb25jbHVzaW9uLmVudGl0aWVzKVxuICAgIH1cblxuICAgIGdldCB0aGVtZSgpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb24udGhlbWVcbiAgICB9XG5cbiAgICBnZXQgcmhlbWUoKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29weSgpIC8vIGR1bm5vIHdoYXQgSSdtIGRvaW4nXG4gICAgfVxuXG4gICAgaW1wbGllcyhjb25jbHVzaW9uOiBDbGF1c2UpOiBDbGF1c2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCEnKVxuICAgIH1cblxufSIsImltcG9ydCB7IENsYXVzZSwgQW5kT3B0cywgQ29weU9wdHMsIElkIH0gZnJvbSBcIi4vQ2xhdXNlXCI7XG5pbXBvcnQgSW1wbHkgZnJvbSBcIi4vSW1wbHlcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQW5kQ2xhdXNlIGltcGxlbWVudHMgQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGNsYXVzZXM6IENsYXVzZVtdLCByZWFkb25seSBuZWdhdGVkID0gZmFsc2UsIHJlYWRvbmx5IGlzSW1wbHkgPSBmYWxzZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcblxuICAgICAgICByZXR1cm4gb3B0cz8uYXNSaGVtZSA/XG4gICAgICAgICAgICBuZXcgQW5kQ2xhdXNlKFt0aGlzLmNvcHkoKSwgb3RoZXIuY29weSgpXSkgOlxuICAgICAgICAgICAgbmV3IEFuZENsYXVzZShbLi4udGhpcy5mbGF0TGlzdCgpLCAuLi5vdGhlci5mbGF0TGlzdCgpXSlcblxuICAgIH1cblxuICAgIGNvcHkob3B0cz86IENvcHlPcHRzKTogQW5kQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmRDbGF1c2UodGhpcy5jbGF1c2VzLm1hcChjID0+IGMuY29weSh7IC4uLm9wdHMsIG5lZ2F0ZTogZmFsc2UgfSkpLCBvcHRzPy5uZWdhdGUgPyAhdGhpcy5uZWdhdGVkIDogdGhpcy5uZWdhdGVkKVxuICAgIH1cblxuICAgIGZsYXRMaXN0KCk6IENsYXVzZVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRlZCA/IFt0aGlzLmNvcHkoKV0gOiB0aGlzLmNsYXVzZXMuZmxhdE1hcChjID0+IGMuZmxhdExpc3QoKSlcbiAgICB9XG5cbiAgICBnZXQgZW50aXRpZXMoKTogSWRbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQodGhpcy5jbGF1c2VzLmZsYXRNYXAoYyA9PiBjLmVudGl0aWVzKSkpXG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsYXVzZXNbMF1cbiAgICB9XG5cbiAgICBnZXQgcmhlbWUoKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhdXNlc1sxXVxuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLmNvcHkoKSwgY29uY2x1c2lvbi5jb3B5KCkpXG4gICAgfVxuXG4gICAgdG9Qcm9sb2coKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IHByb2xvZ0NsYXVzZXMgPSB0aGlzLmNsYXVzZXMuZmxhdE1hcChjID0+IGMudG9Qcm9sb2coKSlcblxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkID9cbiAgICAgICAgICAgIFtgbG9naWNOb3QoJHtwcm9sb2dDbGF1c2VzLnJlZHVjZSgoYSwgYikgPT4gYCR7YX0sICR7Yn1gKX0pYF0gOlxuICAgICAgICAgICAgcHJvbG9nQ2xhdXNlc1xuXG4gICAgfVxuXG59IiwiaW1wb3J0IHBsLCB7IGZvcm1hdF9hbnN3ZXIgfSBmcm9tICd0YXUtcHJvbG9nJ1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSAnLi9hc3QvcGhyYXNlcy9Ob3VuUGhyYXNlJztcbmltcG9ydCBDb3B1bGFRdWVzdGlvbiBmcm9tICcuL2FzdC9zZW50ZW5jZXMvQ29wdWxhUXVlc3Rpb24nO1xuaW1wb3J0IEFydGljbGUgZnJvbSAnLi9hc3QvdG9rZW5zL0FydGljbGUnO1xuaW1wb3J0IENvcHVsYSBmcm9tICcuL2FzdC90b2tlbnMvQ29wdWxhJztcbmltcG9ydCBOb3VuIGZyb20gJy4vYXN0L3Rva2Vucy9Ob3VuJztcbmltcG9ydCB7IGdldEJyYWluIH0gZnJvbSAnLi9icmFpbi9CcmFpbic7XG5pbXBvcnQgeyBnZXRTYW5kYm94IH0gZnJvbSAnLi9icmFpbi9TYW5kYm94JztcbmltcG9ydCB7IEJhc2ljQ2xhdXNlIH0gZnJvbSAnLi9jbGF1c2VzL0Jhc2ljQ2xhdXNlJztcbmltcG9ydCB7IGNsYXVzZU9mIH0gZnJvbSAnLi9jbGF1c2VzL0NsYXVzZSc7XG5pbXBvcnQgeyBnZXRMZXhlciB9IGZyb20gJy4vbGV4ZXIvTGV4ZXInO1xuaW1wb3J0IHsgZ2V0UGFyc2VyIH0gZnJvbSAnLi9wYXJzZXIvUGFyc2VyJztcbmltcG9ydCBQcm9sb2csIHsgZ2V0UHJvbG9nIH0gZnJvbSAnLi9wcm9sb2cvUHJvbG9nJztcbmltcG9ydCBUYXVQcm9sb2cgZnJvbSAnLi9wcm9sb2cvVGF1UHJvbG9nJztcbmltcG9ydCBjb21waWxlTG9naWNUZXN0IGZyb20gJy4vdGVzdHMvY29tcGlsZS1sb2dpYy10ZXN0JztcbmltcG9ydCBwbGF5Z3JvdW5kIGZyb20gJy4vdGVzdHMvcGxheWdyb3VuZCc7XG5pbXBvcnQgcHJvbG9nUGxheSBmcm9tICcuL3Rlc3RzL3Byb2xvZy1wbGF5Z3JvdW5kJztcblxuXG4vLyBQUk9MT0cgVEVTVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnN0IHBybyA9IGdldFByb2xvZygpO1xuLy8gKHdpbmRvdyBhcyBhbnkpLnBybyA9IHBybztcbi8vIChhc3luYyAoKSA9PiB7XG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnY2FwcmEoc2NlbW8pJylcbi8vICAgICBhd2FpdCBwcm8uYXNzZXJ0KCdtYW1tYWwocGVsb3NvKScpXG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnbWFtbWFsKGZpZG8pJylcbi8vICAgICBhd2FpdCBwcm8uYXNzZXJ0KCdtYW1tYWwoWCkgOi0gY2FwcmEoWCknKVxuLy8gICAgIGNvbnNvbGUubG9nKGF3YWl0IHByby5xdWVyeSgnbWFtbWFsKFgpLicpKVxuLy8gICAgIGF3YWl0IHByby5yZXRyYWN0KCdjYXByYShzY2VtbyknKVxuLy8gICAgIGNvbnNvbGUubG9nKGF3YWl0IHByby5xdWVyeSgnbWFtbWFsKFgpLicpKVxuLy8gfSkoKTtcbi8vIC8vICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnNvbGUubG9nKCh0b2tlbk9mKCdhJykgYXMgQXJ0aWNsZSkuaXNEZWZpbml0ZSgpKVxuLy8gY29uc29sZS5sb2codG9rZW5PZignYScpICBpbnN0YW5jZW9mIEFydGljbGUpXG4vLyBjb25zb2xlLmxvZyh0b2tlbk9mKCdhJykgIGluc3RhbmNlb2YgUXVhbnRpZmllcilcbi8vIGNvbnNvbGUubG9nKHRva2VuT2YoJ2V2ZXJ5JykgIGluc3RhbmNlb2YgUXVhbnRpZmllcilcbi8vIGNvbnNvbGUubG9nKHRva2VuT2YoJ2EnKS50b1N0cmluZygpKVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29uc3QgbGV4ZXIgPSBnZXRMZXhlcigndGhlIGNhdCBpcyBhIGNhdC4nKVxuLy8gY29uc29sZS5sb2cobGV4ZXIpXG4vLyBjb25zb2xlLmxvZygnaXMgaXQgYSBub3VuPycsIGxleGVyLmFzc2VydChOb3VuLCB7ZXJyb3JPdXQ6ZmFsc2V9KSApXG4vLyBjb25zb2xlLmxvZyhsZXhlci5wZWVrKVxuLy8gY29uc29sZS5sb2coJ2lzIGl0IGEgY29wdWxhPycsIGxleGVyLmFzc2VydChDb3B1bGEsIHtlcnJvck91dDpmYWxzZX0pIClcbi8vIGNvbnNvbGUubG9nKGxleGVyLnBlZWspXG4vLyBjb25zb2xlLmxvZygnaXMgaXQgYW4gYXJ0aWNsZT8nLCBsZXhlci5hc3NlcnQoQXJ0aWNsZSwge2Vycm9yT3V0OmZhbHNlfSkgKVxuLy8gY29uc29sZS5sb2cobGV4ZXIucGVlaylcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBjYXQgaXMgYmlnJykucGFyc2UoKSlcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGJpZyBjYXQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGJpZyBjYXQgb24gdGhlIHRhYmxlIGlzIGVhdGluZyB0dW5hJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBiaWcgY2F0IG9uIHRoZSBtYXQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcignZXZlcnkgZG9nIGlzIHN0dXBpZCcpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgY2F0IHRoYXQgaXMgc21hcnQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcignbm9kZWpzIGlzIG5vdCBoZWxwZnVsJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ2lmIHRoZSBkb2cgaXMgc3R1cGlkIHRoZW4gdGhlIGNhdCBpcyBoYXBweScpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgY2F0IGlzIGhhcHB5IGlmIHRoZSBkb2cgaXMgc3R1cGlkJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZygod2luZG93IGFzIGFueSkuYXN0ID0gZ2V0UGFyc2VyKCd0aGUgY29sb3Igb2YgdGhlIGJ1dHRvbiBpcyByZWQnKS5wYXJzZSgpKVxuLy8gY29uc29sZS5sb2coKHdpbmRvdyBhcyBhbnkpLmFzdCA9IGdldFBhcnNlcigndGhlIGNvbG9yIG9mIHRoZSBidXR0b24gb24gdGhlIGJsYWNrIGRpdiBpcyByZWQnKS5wYXJzZSgpKVxuXG4vLyBDT01QSUxFUiBURVNUU1xuLy8gZnVuY3Rpb24gdGVzdChzdHJpbmc6IHN0cmluZykge1xuLy8gICAgIGNvbnNvbGUubG9nKHN0cmluZylcbi8vICAgICBjb25zdCBjbGF1c2UgPSBnZXRQYXJzZXIoc3RyaW5nKS5wYXJzZSgpLnRvQ2xhdXNlKCkuY29weSh7IG1hcDogeyAnaWQxJzogMTAwMCwgJ2lkMic6IDIwMDAgfSB9KVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsYXVzZS5mbGF0TGlzdCgpLm1hcChjID0+IGMudG9TdHJpbmcoKSkpXG4vLyAgICAgY29uc29sZS5sb2coY2xhdXNlLnRvUHJvbG9nKCkpXG4vLyAgICAgLy8gY29uc29sZS5sb2coY2xhdXNlKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKCdlbnRpdGllcycsIGNsYXVzZS5lbnRpdGllcylcbi8vICAgICAvLyBjb25zb2xlLmxvZygndGhlbWUnLCBjbGF1c2UudGhlbWUpXG4vLyAgICAgLy8gY29uc29sZS5sb2coJ3JoZW1lJywgY2xhdXNlLnJoZW1lKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsYXVzZS5hYm91dCgnaWQwJykpXG4vLyB9XG5cbi8vIHRlc3QoJ3RoZSBjYXQgaXMgb24gdGhlIG1hdCcpXG4vLyAvLyB0ZXN0KCd0aGUgY2F0IHRoYXQgaXMgcmVkIGlzIG9uIHRoZSBtYXQnKVxuLy8gLy8gdGVzdCgndGhlIGJpZyBjYXQgdGhhdCBpcyBvbiB0aGUgbWF0IGlzIGJsYWNrJylcbi8vIHRlc3QoJ2V2ZXJ5IGNhdCBpcyByZWQnKVxuLy8gdGVzdCgnZXZlcnkgcmVkIGNhdCBpcyBvbiB0aGUgbWF0Jylcbi8vIC8vIHRlc3QoJ3RoZSBjYXQgZXhpc3RzIG9uIHRoZSBtYXQnKVxuLy8gdGVzdCgnaWYgdGhlIGNhdCBpcyBvbiB0aGUgbWF0IHRoZW4gdGhlIGNhdCBpcyByZWQnKVxuLy8gLy8gdGVzdCgndGhlIGNhdCBpcyBub3QgcmVkJylcbi8vIHRlc3QoJ2V2ZXJ5IGNhdCBpcyBub3QgcmVkJylcbi8vIHRlc3QoJ3RydW1wIGlzIG5vdCBhIGdyZWF0IHByZXNpZGVudCcpOyAvLyBwcm9iYWJseSBuZWVkIGFuIGFuZCBwcmVkaWNhdGVcblxuLy8gRU5EIENPTVBJTEVSIFRFU1RTXG5cblxuLy8gKGFzeW5jICgpID0+IHtcbi8vICAgICBjb25zdCBicmFpbiA9IGF3YWl0IGdldEJyYWluKCk7XG4vLyAgICAgY29uc3QgYyA9IGNsYXVzZU9mKCdjYXByYScsICd1bm8nKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsIDIpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsIDMpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCd3aGl0ZScsIDMpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXQnLCA0KSlcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignd2hpdGUnLCA0KSlcblxuLy8gICAgIGF3YWl0IGJyYWluLmFzc2VydChjKTtcbi8vICAgICBjb25zb2xlLmxvZyhhd2FpdCBicmFpbi5xdWVyeShjbGF1c2VPZignd2hpdGUnLCAnWCcpLmNvbmNhdChjbGF1c2VPZignY2F0JywgJ1gnKSkpKVxuLy8gfSkoKVxuXG4vLyAoYXN5bmMgKCkgPT4ge1xuXG4vLyAgICAgY29uc3Qgc3RhdGUgPSB7XG4vLyAgICAgICAgIHRpbWVyIDogc2V0VGltZW91dCgoKT0+e30sMCksXG4vLyAgICAgICAgIGJyYWluIDogYXdhaXQgZ2V0QnJhaW4oKSxcbi8vICAgICAgICAgZGVib3VuY2luZ1RpbWUgOiAwXG4vLyAgICAgfVxuXG4vLyAgICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuLy8gICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk/LmFwcGVuZENoaWxkKHApXG5cbi8vICAgICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbi8vICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnNTB2aCdcbi8vICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9ICc1MHZ3J1xuXG4vLyAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQodGV4dGFyZWEpXG5cbi8vICAgICBjb25zdCBvbklucHV0ID0gYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dGFyZWEudmFsdWVcbi8vICAgICAgICAgY29uc3QgYXN0ID0gZ2V0UGFyc2VyKHRleHQpLnBhcnNlKClcbi8vICAgICAgICAgY29uc3QgY2xhdXNlID0gYXN0LnRvUHJvbG9nKClcblxuLy8gICAgICAgICBpZiAoIWNsYXVzZSl7XG4vLyAgICAgICAgICAgICByZXR1cm4gXG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0U2FuZGJveChjbGF1c2UpLm1hcFRvKHN0YXRlLmJyYWluKVxuXG5cbi8vICAgICAgICAgcC5pbm5lckhUTUwgPSBgJHsoYXN0IGFzIGFueSkuY29uc3RydWN0b3IubmFtZX06ICR7Y2xhdXNlLnRvU3RyaW5nKCl9YFxuXG4vLyAgICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBDb3B1bGFRdWVzdGlvbil7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCBzdGF0ZS5icmFpbi5xdWVyeShjbGF1c2UpKVxuLy8gICAgICAgICB9ZWxzZXtcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhc3NlcnRlZDonLCBjbGF1c2UudG9TdHJpbmcoKSlcbi8vICAgICAgICAgfVxuXG4vLyAgICAgfVxuXG4vLyAgICAgdGV4dGFyZWEub25pbnB1dCA9IGUgPT4ge1xuLy8gICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZXIpXG4vLyAgICAgICAgIHN0YXRlLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuLy8gICAgICAgICAgICAgb25JbnB1dCgpXG4vLyAgICAgICAgIH0sIHN0YXRlLmRlYm91bmNpbmdUaW1lKVxuLy8gICAgIH1cblxuLy8gfSkoKTtcblxuXG5cbi8vIChhc3luYyAoKSA9PiB7XG5cbi8vICAgICBjb25zdCBwcm9sb2cgPSBhd2FpdCBnZXRCcmFpbigpO1xuLy8gICAgICh3aW5kb3cgYXMgYW55KS5wcm9sb2cgPSBwcm9sb2dcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCdjYXQnLCAnYScpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2NhdCcsICdiJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignY2F0JywgJ2MnKSlcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCd3aGl0ZScsICdhJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZG9nJywgJ2QnKSlcblxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdhJywgJ3JhYmJpdCcpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdhJywgJ21vdXNlJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZWF0JywgJ2EnLCAnYmlyZGllJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZWF0JywgJ2QnLCAnYm9uZScpKVxuXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZigndGFibGUnLCAndGIxJykpXG5cbi8vICAgICAvLyBjb25zdCByZXMgPSBhd2FpdCBwcm9sb2cucXVlcnkoY2xhdXNlT2YoJ2NhdCcsICdYJykuY29uY2F0KGNsYXVzZU9mKCdlYXQnLCAnWCcsICdZJykuY29uY2F0KGNsYXVzZU9mKCdkb2cnLCAnWicpKSkpXG4vLyAgICAgLy8gY29uc3QgY2xhdXNlID0gY2xhdXNlT2YoJ2NhdCcsICdpZDAnKS5jb25jYXQoY2xhdXNlT2YoJ2RvZycsICdpZDEnKSkuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsICdpZDU1JykpIFxuLy8gICAgIC8vIGNvbnN0IGNsYXVzZSA9IGdldFBhcnNlcigndGhlIGNhdCB0aGF0IGlzIGJsYWNrIGlzIHNtYXJ0JykucGFyc2UoKS50b1Byb2xvZygpXG4vLyAgICAgY29uc3QgY2xhdXNlID0gZ2V0UGFyc2VyKCd0aGUgY2F0IHRoYXQgaXMgd2hpdGUgaXMgb24gdGhlIHRhYmxlJykucGFyc2UoKS50b1Byb2xvZygpXG4vLyAgICAgY29uc29sZS5sb2coY2xhdXNlLnRvU3RyaW5nKCkpXG5cbi8vICAgICBjb25zdCByZXMgPSBhd2FpdCBnZXRTYW5kYm94KGNsYXVzZSkubWFwVG8ocHJvbG9nKVxuLy8gICAgIGNvbnNvbGUubG9nKHJlcylcbi8vICAgICBjb25zb2xlLmxvZyhjbGF1c2UucmhlbWUuY29weSh7IG1hcDogcmVzIH0pLnRvU3RyaW5nKCkpXG5cbi8vIH0pKCk7XG5cblxuLy8gcHJvbG9nUGxheSgpXG4vLyBjb21waWxlTG9naWNUZXN0KClcbnBsYXlncm91bmQoKSIsImltcG9ydCBUb2tlbiBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBMZXhlciwgeyBBc3NlcnRBcmdzLCBDb25zdHJ1Y3RvciB9IGZyb20gXCIuL0xleGVyXCI7XG5pbXBvcnQgdG9rZW5PZiBmcm9tIFwiLi90b2tlbk9mXCI7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRWFnZXJMZXhlciBpbXBsZW1lbnRzIExleGVyIHtcblxuICAgIHByb3RlY3RlZCByZWFkb25seSB0b2tlbnM6IFRva2VuW11cbiAgICBwcm90ZWN0ZWQgX3BvczogbnVtYmVyXG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzb3VyY2VDb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgLy9UT0RPOiByZWNvbnN0cnVjdCBcImRvIG5vdFwiIGFuZCBcImRvZXMgbm90XCIgdG9rZW5zXG4gICAgICAgIC8vVE9ETzogbm91bnMgdnMgYWRqZWN0aXZlc1xuICAgICAgICB0aGlzLnRva2VucyA9IHNvdXJjZUNvZGUudHJpbSgpLnNwbGl0KC9cXHMrfFxcLi8pLm1hcChlID0+ICFlID8gJy4nIDogZSkubWFwKHRva2VuT2YpXG4gICAgICAgIGNvbnNvbGUuZGVidWcoJ3Rva2VucycsIHRoaXMudG9rZW5zKVxuICAgICAgICB0aGlzLl9wb3MgPSAwXG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9zKytcbiAgICB9XG5cbiAgICBnZXQgcG9zKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb3NcbiAgICB9XG5cbiAgICBiYWNrVG8ocG9zOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcG9zID0gcG9zXG4gICAgfVxuXG4gICAgZ2V0IHBlZWsoKTogVG9rZW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5fcG9zXVxuICAgIH1cblxuICAgIGNyb2FrKGVycm9yTXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTXNnfSBhdCAke3RoaXMuX3Bvc31gKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCB0b2tlbiBpZmYgb2YgZ2l2ZW4gdHlwZSBhbmQgbW92ZSB0byBuZXh0OyBcbiAgICAgKiBlbHNlIHJldHVybiB1bmRlZmluZWQgYW5kIGRvbid0IG1vdmUuXG4gICAgICogQHBhcmFtIGFyZ3MgXG4gICAgICogQHJldHVybnMgXG4gICAgICovXG4gICAgYXNzZXJ0PFQ+KGNsYXp6OiBDb25zdHJ1Y3RvcjxUPiwgYXJnczogQXNzZXJ0QXJncyk6IFQgfCB1bmRlZmluZWQge1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnBlZWtcblxuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIGNsYXp6KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgICAgfSBlbHNlIGlmIChhcmdzLmVycm9yT3V0ID8/IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JvYWsoYXJncy5lcnJvck1zZyA/PyAnJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuXG4gICAgfVxuXG59IiwiaW1wb3J0IFRva2VuIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Ub2tlblwiXG5pbXBvcnQgRWFnZXJMZXhlciBmcm9tIFwiLi9FYWdlckxleGVyXCJcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIExleGVye1xuICAgIG5leHQoKTp2b2lkXG4gICAgYmFja1RvKHBvczpudW1iZXIpOnZvaWRcbiAgICBnZXQgcGVlaygpOlRva2VuXG4gICAgZ2V0IHBvcygpOm51bWJlclxuICAgIGNyb2FrKGVycm9yTXNnOnN0cmluZyk6dm9pZCAgIFxuICAgIGFzc2VydCA8VD4oY2xheno6Q29uc3RydWN0b3I8VD4sIGFyZ3M6QXNzZXJ0QXJncyk6IFR8dW5kZWZpbmVkIFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2VydEFyZ3N7XG4gICAgZXJyb3JNc2c/OnN0cmluZ1xuICAgIGVycm9yT3V0Pzpib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZXhlcihzb3VyY2VDb2RlOnN0cmluZyk6TGV4ZXJ7XG4gICAgcmV0dXJuIG5ldyBFYWdlckxleGVyKHNvdXJjZUNvZGUpXG59XG5cbmV4cG9ydCB0eXBlIENvbnN0cnVjdG9yPFQ+ID0gbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVFxuIiwiaW1wb3J0IGFkamVjdGl2ZXMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9hZGplY3RpdmVzJ1xuaW1wb3J0IGluZGVmaW5pdGVfYXJ0aWNsZXMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9pbmRlZmluaXRlX2FydGljbGVzJ1xuaW1wb3J0IGRlZmluaXRlX2FydGljbGVzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvZGVmaW5pdGVfYXJ0aWNsZXMnXG5pbXBvcnQgY29wdWxhcyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2NvcHVsYXMnXG5pbXBvcnQgaHZlcmJzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvaHZlcmJzJ1xuaW1wb3J0IGl2ZXJicyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2l2ZXJicydcbmltcG9ydCBtdmVyYnMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9tdmVyYnMnXG5pbXBvcnQgbmVnYXRpb25zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbmVnYXRpb25zJ1xuaW1wb3J0IG5vbnN1YmNvbmogZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9ub25zdWJjb25qJ1xuaW1wb3J0IG5vdW5zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbm91bnMnXG5pbXBvcnQgcHJlcG9zaXRpb25zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvcHJlcG9zaXRpb25zJ1xuaW1wb3J0IGV4aXN0cXVhbnQgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9leGlzdGVudGlhbF9xdWFudGlmaWVycydcbmltcG9ydCB1bmlxdWFudCBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL3VuaXZlcnNhbF9xdWFudGlmaWVycydcbmltcG9ydCByZWxwcm9ucyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL3JlbHByb25zJ1xuaW1wb3J0IHN1YmNvbmogZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9zdWJjb25qJ1xuaW1wb3J0IHRoZW4gZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy90aGVuJ1xuaW1wb3J0IEFydGljbGUgZnJvbSAnLi4vYXN0L3Rva2Vucy9BcnRpY2xlJ1xuaW1wb3J0IENvcHVsYSBmcm9tICcuLi9hc3QvdG9rZW5zL0NvcHVsYSdcbmltcG9ydCBIVmVyYiBmcm9tICcuLi9hc3QvdG9rZW5zL0hWZXJiJ1xuaW1wb3J0IElWZXJiIGZyb20gJy4uL2FzdC90b2tlbnMvSVZlcmInXG5pbXBvcnQgTVZlcmIgZnJvbSAnLi4vYXN0L3Rva2Vucy9NVmVyYidcbmltcG9ydCBOZWdhdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL05lZ2F0aW9uJ1xuaW1wb3J0IE5vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL05vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbidcbmltcG9ydCBQcmVwb3NpdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL1ByZXBvc2l0aW9uJ1xuaW1wb3J0IFF1YW50aWZpZXIgZnJvbSAnLi4vYXN0L3Rva2Vucy9RdWFudGlmaWVyJ1xuaW1wb3J0IFRoZW4gZnJvbSAnLi4vYXN0L3Rva2Vucy9UaGVuJ1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tICcuLi9hc3QvdG9rZW5zL1JlbGF0aXZlUHJvbm91bidcbmltcG9ydCBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZnJvbSAnLi4vYXN0L3Rva2Vucy9TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24nXG5pbXBvcnQgTm91biBmcm9tICcuLi9hc3QvdG9rZW5zL05vdW4nXG5pbXBvcnQgQWRqZWN0aXZlIGZyb20gJy4uL2FzdC90b2tlbnMvQWRqZWN0aXZlJ1xuaW1wb3J0IFRva2VuIGZyb20gJy4uL2FzdC9pbnRlcmZhY2VzL1Rva2VuJ1xuaW1wb3J0IEZ1bGxTdG9wIGZyb20gJy4uL2FzdC90b2tlbnMvRnVsbFN0b3AnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRva2VuT2Yoc3RyaW5nOnN0cmluZyk6VG9rZW57XG4gICAgXG4gICAgaWYgKGluZGVmaW5pdGVfYXJ0aWNsZXMuY29uY2F0KGRlZmluaXRlX2FydGljbGVzKS5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnRpY2xlKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoY29wdWxhcy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGEoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChodmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgSFZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChpdmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgSVZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChtdmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgTVZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChuZWdhdGlvbnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgTmVnYXRpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChub25zdWJjb25qLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IE5vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKHByZXBvc2l0aW9ucy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwb3NpdGlvbihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKGV4aXN0cXVhbnQuY29uY2F0KHVuaXF1YW50KS5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWFudGlmaWVyKHN0cmluZylcbiAgICB9ZWxzZSBpZiAodGhlbi5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGVuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAocmVscHJvbnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRpdmVQcm9ub3VuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoc3ViY29uai5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChub3Vucy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3VuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoYWRqZWN0aXZlcy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGplY3RpdmUoc3RyaW5nKVxuICAgIH1lbHNlIGlmICgnLicgPT09IHN0cmluZyl7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFN0b3AoJy4nKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQWRqZWN0aXZlKHN0cmluZylcbn0iLCJpbXBvcnQgQXN0IGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Bc3RcIjtcbmltcG9ydCBCaW5hcnlRdWVzdGlvbiBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQmluYXJ5UXVlc3Rpb25cIjtcbmltcG9ydCBDb21wb3VuZFNlbnRlbmNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Db21wb3VuZFNlbnRlbmNlXCI7XG5pbXBvcnQgRGVjbGFyYXRpb24gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL0RlY2xhcmF0aW9uXCI7XG5pbXBvcnQgUXVlc3Rpb24gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1F1ZXN0aW9uXCI7XG5pbXBvcnQgU2ltcGxlU2VudGVuY2UgZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1NpbXBsZVNlbnRlbmNlXCI7XG5pbXBvcnQgVmVyYlNlbnRlbmNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9WZXJiU2VudGVuY2VcIjtcbmltcG9ydCBDb21wbGVtZW50IGZyb20gXCIuLi9hc3QvcGhyYXNlcy9Db21wbGVtZW50XCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi4vYXN0L3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IFN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IENvbXBsZXhTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db21wbGV4U2VudGVuY2VcIjtcbmltcG9ydCBDb25qdW5jdGl2ZVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL0Nvbmp1bmN0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBDb3B1bGFRdWVzdGlvbiBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db3B1bGFRdWVzdGlvblwiO1xuaW1wb3J0IENvcHVsYVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL0NvcHVsYVNlbnRlbmNlXCI7XG5pbXBvcnQgSW50cmFuc2l0aXZlU2VudGVuY2UgZnJvbSBcIi4uL2FzdC9zZW50ZW5jZXMvSW50cmFuc2l0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBNb25vdHJhbnNpdGl2ZVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL01vbm90cmFuc2l0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBBZGplY3RpdmUgZnJvbSBcIi4uL2FzdC90b2tlbnMvQWRqZWN0aXZlXCI7XG5pbXBvcnQgQXJ0aWNsZSBmcm9tIFwiLi4vYXN0L3Rva2Vucy9BcnRpY2xlXCI7XG5pbXBvcnQgQ29wdWxhIGZyb20gXCIuLi9hc3QvdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IElWZXJiIGZyb20gXCIuLi9hc3QvdG9rZW5zL0lWZXJiXCI7XG5pbXBvcnQgTVZlcmIgZnJvbSBcIi4uL2FzdC90b2tlbnMvTVZlcmJcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vYXN0L3Rva2Vucy9OZWdhdGlvblwiO1xuaW1wb3J0IE5vdW4gZnJvbSBcIi4uL2FzdC90b2tlbnMvTm91blwiO1xuaW1wb3J0IFByZXBvc2l0aW9uIGZyb20gXCIuLi9hc3QvdG9rZW5zL1ByZXBvc2l0aW9uXCI7XG5pbXBvcnQgUXVhbnRpZmllciBmcm9tIFwiLi4vYXN0L3Rva2Vucy9RdWFudGlmaWVyXCI7XG5pbXBvcnQgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGZyb20gXCIuLi9hc3QvdG9rZW5zL1N1Ym9yZGluYXRpbmdDb25qdW5jdGlvblwiO1xuaW1wb3J0IFRoZW4gZnJvbSBcIi4uL2FzdC90b2tlbnMvVGhlblwiO1xuaW1wb3J0IExleGVyLCB7IGdldExleGVyIH0gZnJvbSBcIi4uL2xleGVyL0xleGVyXCI7XG5pbXBvcnQgUGFyc2VyIGZyb20gXCIuL1BhcnNlclwiO1xuaW1wb3J0IENvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9hc3QvcGhyYXNlcy9Db3B1bGFTdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tIFwiLi4vYXN0L3Rva2Vucy9SZWxhdGl2ZVByb25vdW5cIjtcbmltcG9ydCBDb25zdGl0dWVudCBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQmFzaWNQYXJzZXIgaW1wbGVtZW50cyBQYXJzZXIge1xuXG4gICAgcHJvdGVjdGVkIGx4OiBMZXhlclxuXG4gICAgY29uc3RydWN0b3Ioc291cmNlQ29kZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMubHggPSBnZXRMZXhlcihzb3VyY2VDb2RlKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB0cnk8VCBleHRlbmRzIEFzdD4obWV0aG9kOiAoKSA9PiBUKSB7XG5cbiAgICAgICAgY29uc3QgbWVtZW50byA9IHRoaXMubHgucG9zXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QoKVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygoZXJyb3IgYXMgRXJyb3IpLm1lc3NhZ2UpXG4gICAgICAgICAgICB0aGlzLmx4LmJhY2tUbyhtZW1lbnRvKVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZXJyb3JPdXQoZXJyb3JNc2c6IHN0cmluZyk6IENvbnN0aXR1ZW50IHtcbiAgICAgICAgdGhpcy5seC5jcm9hayhlcnJvck1zZylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKVxuICAgIH1cblxuICAgIHBhcnNlKCk6IENvbnN0aXR1ZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VRdWVzdGlvbikgXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlRGVjbGFyYXRpb24pXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlTm91blBocmFzZSkgLy8gZm9yIHF1aWNrIHRvcGljIHJlZmVyZW5jZVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2UoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlRGVjbGFyYXRpb24gPSAoKTogRGVjbGFyYXRpb24gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvbXBvdW5kKVxuICAgICAgICAgICAgPz8gdGhpcy50cnkodGhpcy5wYXJzZVNpbXBsZSkgXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZURlY2xhcmF0aW9uKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVF1ZXN0aW9uID0gKCk6IFF1ZXN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VCaW5hcnlRdWVzdGlvbilcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlUXVlc3Rpb24oKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlU2ltcGxlID0gKCk6IFNpbXBsZVNlbnRlbmNlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VDb3B1bGFTZW50ZW5jZSlcbiAgICAgICAgICAgID8/IHRoaXMudHJ5KHRoaXMucGFyc2VWZXJiU2VudGVuY2UpXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZVNpbXBsZSgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb21wb3VuZCA9ICgpOiBDb21wb3VuZFNlbnRlbmNlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VDb21wbGV4KVxuICAgICAgICAgICAgPz8gdGhpcy50cnkodGhpcy5wYXJzZUNvbmp1bmN0aXZlKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VDb21wb3VuZCgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VWZXJiU2VudGVuY2UgPSAoKTogVmVyYlNlbnRlbmNlID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VJbnRyYW5zaXRpdmVTZW50ZW5jZSlcbiAgICAgICAgICAgID8/IHRoaXMudHJ5KHRoaXMucGFyc2VNb25vdHJhbnNpdGl2ZVNlbnRlbmNlKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VWZXJiU2VudGVuY2UoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29wdWxhU2VudGVuY2UgPSAoKTogQ29wdWxhU2VudGVuY2UgPT4ge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICBjb25zdCBjb3B1bGEgPSB0aGlzLmx4LmFzc2VydChDb3B1bGEsIHsgZXJyb3JNc2c6ICdwYXJzZUNvcHVsYVNlbnRlbmNlKCksIGV4cGVjdGVkIGNvcHVsYScgfSlcbiAgICAgICAgY29uc3QgbmVnYXRpb24gPSB0aGlzLmx4LmFzc2VydChOZWdhdGlvbiwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICByZXR1cm4gbmV3IENvcHVsYVNlbnRlbmNlKHN1YmplY3QsIGNvcHVsYSBhcyBDb3B1bGEsIHByZWRpY2F0ZSwgbmVnYXRpb24pXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29tcGxleCA9ICgpOiBDb21wbGV4U2VudGVuY2UgPT4ge1xuXG4gICAgICAgIGNvbnN0IHN1YmNvbmogPSB0aGlzLmx4LmFzc2VydChTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG5cbiAgICAgICAgaWYgKHN1YmNvbmopIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMucGFyc2VTaW1wbGUoKVxuICAgICAgICAgICAgdGhpcy5seC5hc3NlcnQoVGhlbiwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgICAgIGNvbnN0IG91dGNvbWUgPSB0aGlzLnBhcnNlU2ltcGxlKClcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleFNlbnRlbmNlKGNvbmRpdGlvbiwgb3V0Y29tZSwgc3ViY29uailcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG91dGNvbWUgPSB0aGlzLnBhcnNlU2ltcGxlKClcbiAgICAgICAgICAgIGNvbnN0IHN1YmNvbmogPSB0aGlzLmx4LmFzc2VydChTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24sIHsgZXJyb3JPdXQ6IHRydWUsIGVycm9yTXNnOiAnZXhwZWN0ZWQgc3Vib3JkaW5hdGluZyBjb25qdW5jdGlvbicgfSlcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMucGFyc2VTaW1wbGUoKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb21wbGV4U2VudGVuY2UoY29uZGl0aW9uLCBvdXRjb21lLCBzdWJjb25qIGFzIFN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbilcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlSW50cmFuc2l0aXZlU2VudGVuY2UgPSAoKTogSW50cmFuc2l0aXZlU2VudGVuY2UgPT4ge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICBjb25zdCBuZWdhdGlvbiA9IHRoaXMubHguYXNzZXJ0KE5lZ2F0aW9uLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICBjb25zdCBpdmVyYiA9IHRoaXMubHguYXNzZXJ0KElWZXJiLCB7IGVycm9yTXNnOiAncGFyc2VJbnRyYW5zaXRpdmVTZW50ZW5jZSgpLCBleHBlY3RlZCBpLXZlcmInIH0pXG4gICAgICAgIGNvbnN0IGNvbXBsZW1lbnRzID0gdGhpcy5wYXJzZUNvbXBsZW1lbnRzKClcbiAgICAgICAgcmV0dXJuIG5ldyBJbnRyYW5zaXRpdmVTZW50ZW5jZShzdWJqZWN0LCBpdmVyYiBhcyBJVmVyYiwgY29tcGxlbWVudHMsIG5lZ2F0aW9uKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZU1vbm90cmFuc2l0aXZlU2VudGVuY2UgPSAoKTogTW9ub3RyYW5zaXRpdmVTZW50ZW5jZSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIGNvbnN0IG5lZ2F0aW9uID0gdGhpcy5seC5hc3NlcnQoTmVnYXRpb24sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIGNvbnN0IG12ZXJiID0gdGhpcy5seC5hc3NlcnQoTVZlcmIsIHsgZXJyb3JNc2c6ICdwYXJzZU1vbm90cmFuc2l0aXZlU2VudGVuY2UoKSwgZXhwZWN0ZWQgaS12ZXJiJyB9KVxuICAgICAgICBjb25zdCBjczEgPSB0aGlzLnBhcnNlQ29tcGxlbWVudHMoKVxuICAgICAgICBjb25zdCBvYmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIGNvbnN0IGNzMiA9IHRoaXMucGFyc2VDb21wbGVtZW50cygpXG4gICAgICAgIHJldHVybiBuZXcgTW9ub3RyYW5zaXRpdmVTZW50ZW5jZShzdWJqZWN0LCBtdmVyYiBhcyBNVmVyYiwgb2JqZWN0LCBjczEuY29uY2F0KGNzMiksIG5lZ2F0aW9uKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUJpbmFyeVF1ZXN0aW9uID0gKCk6IEJpbmFyeVF1ZXN0aW9uID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VDb3B1bGFRdWVzdGlvbilcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlQmluYXJ5UXVlc3Rpb24oKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29wdWxhUXVlc3Rpb24gPSAoKTogQ29wdWxhUXVlc3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjb3B1bGEgPSB0aGlzLmx4LmFzc2VydChDb3B1bGEsIHsgZXJyb3JNc2c6ICdwYXJzZUNvcHVsYVF1ZXN0aW9uKCksIGV4cGVjdGVkIGNvcHVsYScgfSlcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICByZXR1cm4gbmV3IENvcHVsYVF1ZXN0aW9uKHN1YmplY3QsIHByZWRpY2F0ZSwgY29wdWxhIGFzIENvcHVsYSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VOb3VuUGhyYXNlID0gKCk6IE5vdW5QaHJhc2UgPT4ge1xuICAgICAgICBjb25zdCBxdWFudGlmaWVyID0gdGhpcy5seC5hc3NlcnQoUXVhbnRpZmllciwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgY29uc3QgYXJ0aWNsZSA9IHRoaXMubHguYXNzZXJ0KEFydGljbGUsIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG5cbiAgICAgICAgbGV0IGFkamVjdGl2ZXMgPSBbXVxuICAgICAgICBsZXQgYWRqXG5cbiAgICAgICAgd2hpbGUgKGFkaiA9IHRoaXMubHguYXNzZXJ0KEFkamVjdGl2ZSwgeyBlcnJvck91dDogZmFsc2UgfSkpIHtcbiAgICAgICAgICAgIGFkamVjdGl2ZXMucHVzaChhZGopXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBub3VuID0gdGhpcy5seC5hc3NlcnQoTm91biwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgY29uc3Qgc3Vib3JkaW5hdGVDbGF1c2UgPSB0aGlzLnRyeSh0aGlzLnBhcnNlU3Vib3JkaW5hdGVDbGF1c2UpXG4gICAgICAgIGNvbnN0IGNvbXBsZW1lbnRzID0gdGhpcy5wYXJzZUNvbXBsZW1lbnRzKCkgXG5cbiAgICAgICAgcmV0dXJuIG5ldyBOb3VuUGhyYXNlKGFkamVjdGl2ZXMsIGNvbXBsZW1lbnRzLCBub3VuLCBxdWFudGlmaWVyLCBhcnRpY2xlLCBzdWJvcmRpbmF0ZUNsYXVzZSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb21wbGVtZW50cyA9ICgpOiBDb21wbGVtZW50W10gPT4ge1xuXG4gICAgICAgIGNvbnN0IGNvbXBsZW1lbnRzID0gW11cbiAgICAgICAgbGV0IGNvbXBcblxuICAgICAgICB3aGlsZSAoY29tcCA9IHRoaXMudHJ5KHRoaXMucGFyc2VDb21wbGVtZW50KSkge1xuICAgICAgICAgICAgY29tcGxlbWVudHMucHVzaChjb21wKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBsZW1lbnRzXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29tcGxlbWVudCA9ICgpOiBDb21wbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgcHJlcG9zaXRpb24gPSB0aGlzLmx4LmFzc2VydChQcmVwb3NpdGlvbiwgeyBlcnJvck1zZzogJ3BhcnNlQ29tcGxlbWVudCgpIGV4cGVjdGVkIHByZXBvc2l0aW9uJyB9KVxuICAgICAgICBjb25zdCBub3VuUGhyYXNlID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZW1lbnQocHJlcG9zaXRpb24gYXMgUHJlcG9zaXRpb24sIG5vdW5QaHJhc2UpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlU3Vib3JkaW5hdGVDbGF1c2UgPSAoKTogU3Vib3JkaW5hdGVDbGF1c2UgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlKSBcbiAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VTdWJvcmRpbmF0ZUNsYXVzZSgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSA9ICgpOkNvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlID0+e1xuICAgICAgICBjb25zdCByZWxwcm9uID0gdGhpcy5seC5hc3NlcnQoUmVsYXRpdmVQcm9ub3VuLCB7ZXJyb3JNc2c6J3BhcnNlQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UoKSBleHBlY3RlZCByZWxhdGl2ZSBwcm9ub3VuJ30pXG4gICAgICAgIGNvbnN0IGNvcHVsYSA9IHRoaXMubHguYXNzZXJ0KENvcHVsYSwge2Vycm9yTXNnOidwYXJzZUNvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlKCkgZXhwZWN0ZWQgY29wdWxhJ30pXG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIHJldHVybiBuZXcgQ29wdWxhU3Vib3JkaW5hdGVDbGF1c2UocmVscHJvbiBhcyBSZWxhdGl2ZVByb25vdW4sIHN1YmplY3QsIGNvcHVsYSBhcyBDb3B1bGEpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29uanVuY3RpdmUgPSAoKTogQ29uanVuY3RpdmVTZW50ZW5jZSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTk9UIElNUExFTUVOVEVEISBUT0RPIScpXG4gICAgfVxuXG59IiwiaW1wb3J0IENvbnN0aXR1ZW50IGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IEJhc2ljUGFyc2VyIGZyb20gXCIuL0Jhc2ljUGFyc2VyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBQYXJzZXJ7XG4gICAgcGFyc2UoKTpDb25zdGl0dWVudCAgIFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyc2VyKHNvdXJjZUNvZGU6c3RyaW5nKTpQYXJzZXJ7XG4gICAgcmV0dXJuIG5ldyBCYXNpY1BhcnNlcihzb3VyY2VDb2RlKVxufSIsImltcG9ydCB7IElkLCBNYXAgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIlxuaW1wb3J0IFRhdVByb2xvZyBmcm9tIFwiLi9UYXVQcm9sb2dcIlxuXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgUHJvbG9nIHtcbiAgICBhc3NlcnQoY2xhdXNlOiBzdHJpbmcsIG9wdHM/OiBBc3NlcnRPcHRzKTogUHJvbWlzZTx2b2lkPlxuICAgIHJldHJhY3QoY2xhdXNlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+XG4gICAgcXVlcnkoY29kZTogc3RyaW5nKTogUHJvbWlzZTwgTWFwW10gfCBib29sZWFuPlxuICAgIHByZWRpY2F0ZXMob3B0cz86IFByZWlkY2F0ZXNPcHRzKTogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NlcnRPcHRzIHtcbiAgICAvKiogaWYgdHJ1ZSBjYWxscyBhc3NlcnR6ICovXG4gICAgejogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWlkY2F0ZXNPcHRzIHtcbiAgICBhcml0eTogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9sb2coKTogUHJvbG9nIHtcbiAgICByZXR1cm4gbmV3IFRhdVByb2xvZygpXG59IiwiaW1wb3J0IFByb2xvZywgeyBBc3NlcnRPcHRzLCBQcmVpZGNhdGVzT3B0cyB9IGZyb20gXCIuL1Byb2xvZ1wiO1xuaW1wb3J0IHBsIGZyb20gJ3RhdS1wcm9sb2cnXG5pbXBvcnQgeyBNYXAgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIjtcbnJlcXVpcmUoXCJ0YXUtcHJvbG9nL21vZHVsZXMvcHJvbWlzZXMuanNcIikocGwpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhdVByb2xvZyBpbXBsZW1lbnRzIFByb2xvZyB7XG5cbiAgICBwcm90ZWN0ZWQgc2Vzc2lvbjogcGwudHlwZS5TZXNzaW9uXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gcGwuY3JlYXRlKClcbiAgICB9XG5cbiAgICBhc3luYyBhc3NlcnQoY2xhdXNlOiBzdHJpbmcsIG9wdHM/OiBBc3NlcnRPcHRzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlUXVlcnkoYGFzc2VydCR7b3B0cz8ueiA/ICd6JyA6ICdhJ30oICggJHtjbGF1c2V9ICkgKS5gKVxuICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VBbnN3ZXIoKVxuICAgIH1cblxuICAgIGFzeW5jIHJldHJhY3QoY2xhdXNlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgYXdhaXQgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VRdWVyeShgcmV0cmFjdCgke2NsYXVzZX0pLmApXG4gICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZUFuc3dlcigpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGFzeW5jIHBlcmZvcm1RdWVyeShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPE1hcFtdIHwgYm9vbGVhbj4ge1xuXG4gICAgICAgIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlUXVlcnkoY29kZSlcbiAgICAgICAgbGV0IGFuc3dlcnM6IE1hcFtdID0gW11cblxuICAgICAgICBmb3IgYXdhaXQgKGxldCBhbnMgb2YgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VBbnN3ZXJzKCkpIHtcblxuICAgICAgICAgICAgY29uc3QgZm1hbnMgPSBwbC5mb3JtYXRfYW5zd2VyKGFucylcblxuICAgICAgICAgICAgaWYgKFsndHJ1ZScsICdmYWxzZSddLmluY2x1ZGVzKGZtYW5zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbWFucyA9PT0gJ3RydWUnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gYW5zLmxpbmtzXG5cbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gT2JqZWN0LmtleXMobGlua3MpXG4gICAgICAgICAgICAgICAgLm1hcChrID0+ICh7IFtrXTogbGlua3Nba10udmFsdWUgPz8gbGlua3Nba10uaWQgfSkpXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICAgICAgYW5zd2Vycy5wdXNoKGVudHJ5KVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5xdWVyeUhhc1Zhcihjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFuc3dlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBhc3luYyBxdWVyeShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPE1hcFtdIHwgYm9vbGVhbj4ge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJmb3JtUXVlcnkoY29kZSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHRoaXMucGFyc2VFcnJvcihlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VFcnJvcihlOiBhbnkpIHtcblxuICAgICAgICBjb25zdCBlcnJvciA9IChlIGFzIGFueSkuYXJnc1swXS5hcmdzWzBdLmlkXG5cbiAgICAgICAgaWYgKGVycm9yID09ICdleGlzdGVuY2VfZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zdCBtaXNzaW5nUHJlZGljYXRlID0gKGUgYXMgYW55KS5hcmdzWzBdLmFyZ3NbMF0uYXJnc1sxXS5hcmdzWzBdLmlkXG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciwgbWlzc2luZ1ByZWRpY2F0ZSB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcXVlcnlIYXNWYXIoY29kZTogc3RyaW5nKSB7IC8vIGNoZWNrIGlmIHF1ZXJ5IGhhcyBhIHZhci4gYnJlYWtzIGRvd24gaWYgcHJlZGljYXRlIG5hbWUgY29udGFpbnMgY2FwaXRhbCBsZXR0ZXIhXG4gICAgICAgIHJldHVybiBjb2RlLnNwbGl0KCcnKS5maW5kKGMgPT4gYy5tYXRjaCgvXFx3Ky8pICYmIGMudG9VcHBlckNhc2UoKSA9PT0gYylcbiAgICB9XG5cbiAgICBwcmVkaWNhdGVzKG9wdHM/OiBQcmVpZGNhdGVzT3B0cyk6IHN0cmluZ1tdIHtcblxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXNzaW9uLnJ1bGVzKVxuICAgICAgICAgICAgLm1hcChyID0+IHIuc3BsaXQoJy8nKSlcbiAgICAgICAgICAgIC5maWx0ZXIodCA9PiBvcHRzPy5hcml0eSAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQodFsxXSkgPT09IG9wdHM/LmFyaXR5IDogdHJ1ZSlcbiAgICAgICAgICAgIC5tYXAodCA9PiB0WzBdKVxuXG4gICAgfVxuXG5cbn0iLCJpbXBvcnQgeyBnZXRCcmFpbiB9IGZyb20gXCIuLi9icmFpbi9CcmFpblwiXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHBsYXlncm91bmQoKXtcbiAgICBcbiAgICBjb25zdCBicmFpbiA9IGF3YWl0IGdldEJyYWluKClcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG4gICAgYnV0dG9uLmlubmVyVGV4dCA9ICdydW4nXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQoYnV0dG9uKVxuXG4gICAgY29uc3QgcGFyYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJylcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpPy5hcHBlbmRDaGlsZChwYXJhZylcblxuICAgIGNvbnN0IHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKVxuICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9ICc1MHZoJ1xuICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gJzUwdncnXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQodGV4dGFyZWEpXG5cbiAgICBidXR0b24ub25jbGljayA9IGFzeW5jIGUgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCBicmFpbi5leGVjdXRlKHRleHRhcmVhLnZhbHVlKSlcbiAgICB9XG5cbn0iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvKiAoaWdub3JlZCkgKi8iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2FwcC9zcmMvaW5kZXgudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=