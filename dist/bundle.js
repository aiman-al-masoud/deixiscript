/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/readline-sync/lib/readline-sync.js":
/*!*********************************************************!*\
  !*** ./node_modules/readline-sync/lib/readline-sync.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __dirname = "/";
/*
 * readlineSync
 * https://github.com/anseki/readline-sync
 *
 * Copyright (c) 2018 anseki
 * Licensed under the MIT license.
 */



var
  IS_WIN = process.platform === 'win32',

  ALGORITHM_CIPHER = 'aes-256-cbc',
  ALGORITHM_HASH = 'sha256',
  DEFAULT_ERR_MSG = 'The current environment doesn\'t support interactive reading from TTY.',

  fs = __webpack_require__(/*! fs */ "?b05a"),
  TTY = process.binding('tty_wrap').TTY,
  childProc = __webpack_require__(/*! child_process */ "?a95c"),
  pathUtil = __webpack_require__(/*! path */ "?1b04"),

  defaultOptions = {
    /* eslint-disable key-spacing */
    prompt:             '> ',
    hideEchoBack:       false,
    mask:               '*',
    limit:              [],
    limitMessage:       'Input another, please.$<( [)limit(])>',
    defaultInput:       '',
    trueValue:          [],
    falseValue:         [],
    caseSensitive:      false,
    keepWhitespace:     false,
    encoding:           'utf8',
    bufferSize:         1024,
    print:              void 0,
    history:            true,
    cd:                 false,
    phContent:          void 0,
    preCheck:           void 0
    /* eslint-enable key-spacing */
  },

  fdR = 'none', fdW, ttyR, isRawMode = false,
  extHostPath, extHostArgs, tempdir, salt = 0,
  lastInput = '', inputHistory = [], rawInput,
  _DBG_useExt = false, _DBG_checkOptions = false, _DBG_checkMethod = false;

function getHostArgs(options) {
  // Send any text to crazy Windows shell safely.
  function encodeArg(arg) {
    return arg.replace(/[^\w\u0080-\uFFFF]/g, function(chr) {
      return '#' + chr.charCodeAt(0) + ';';
    });
  }

  return extHostArgs.concat((function(conf) {
    var args = [];
    Object.keys(conf).forEach(function(optionName) {
      if (conf[optionName] === 'boolean') {
        if (options[optionName]) { args.push('--' + optionName); }
      } else if (conf[optionName] === 'string') {
        if (options[optionName]) {
          args.push('--' + optionName, encodeArg(options[optionName]));
        }
      }
    });
    return args;
  })({
    /* eslint-disable key-spacing */
    display:        'string',
    displayOnly:    'boolean',
    keyIn:          'boolean',
    hideEchoBack:   'boolean',
    mask:           'string',
    limit:          'string',
    caseSensitive:  'boolean'
    /* eslint-enable key-spacing */
  }));
}

// piping via files (for Node.js v0.10-)
function _execFileSync(options, execOptions) {

  function getTempfile(name) {
    var filepath, suffix = '', fd;
    tempdir = tempdir || (__webpack_require__(/*! os */ "?a1b8").tmpdir)();

    while (true) {
      filepath = pathUtil.join(tempdir, name + suffix);
      try {
        fd = fs.openSync(filepath, 'wx');
      } catch (e) {
        if (e.code === 'EEXIST') {
          suffix++;
          continue;
        } else {
          throw e;
        }
      }
      fs.closeSync(fd);
      break;
    }
    return filepath;
  }

  var hostArgs, shellPath, shellArgs, res = {}, exitCode, extMessage,
    pathStdout = getTempfile('readline-sync.stdout'),
    pathStderr = getTempfile('readline-sync.stderr'),
    pathExit = getTempfile('readline-sync.exit'),
    pathDone = getTempfile('readline-sync.done'),
    crypto = __webpack_require__(/*! crypto */ "?4ec4"), shasum, decipher, password;

  shasum = crypto.createHash(ALGORITHM_HASH);
  shasum.update('' + process.pid + (salt++) + Math.random());
  password = shasum.digest('hex');
  decipher = crypto.createDecipher(ALGORITHM_CIPHER, password);

  hostArgs = getHostArgs(options);
  if (IS_WIN) {
    shellPath = process.env.ComSpec || 'cmd.exe';
    process.env.Q = '"'; // The quote (") that isn't escaped.
    // `()` for ignore space by echo
    shellArgs = ['/V:ON', '/S', '/C',
      '(%Q%' + shellPath + '%Q% /V:ON /S /C %Q%' + /* ESLint bug? */ // eslint-disable-line no-path-concat
        '%Q%' + extHostPath + '%Q%' +
          hostArgs.map(function(arg) { return ' %Q%' + arg + '%Q%'; }).join('') +
        ' & (echo !ERRORLEVEL!)>%Q%' + pathExit + '%Q%%Q%) 2>%Q%' + pathStderr + '%Q%' +
      ' |%Q%' + process.execPath + '%Q% %Q%' + __dirname + '\\encrypt.js%Q%' +
        ' %Q%' + ALGORITHM_CIPHER + '%Q% %Q%' + password + '%Q%' +
        ' >%Q%' + pathStdout + '%Q%' +
      ' & (echo 1)>%Q%' + pathDone + '%Q%'];
  } else {
    shellPath = '/bin/sh';
    shellArgs = ['-c',
      // Use `()`, not `{}` for `-c` (text param)
      '("' + extHostPath + '"' + /* ESLint bug? */ // eslint-disable-line no-path-concat
          hostArgs.map(function(arg) { return " '" + arg.replace(/'/g, "'\\''") + "'"; }).join('') +
        '; echo $?>"' + pathExit + '") 2>"' + pathStderr + '"' +
      ' |"' + process.execPath + '" "' + __dirname + '/encrypt.js"' +
        ' "' + ALGORITHM_CIPHER + '" "' + password + '"' +
        ' >"' + pathStdout + '"' +
      '; echo 1 >"' + pathDone + '"'];
  }
  if (_DBG_checkMethod) { _DBG_checkMethod('_execFileSync', hostArgs); }
  try {
    childProc.spawn(shellPath, shellArgs, execOptions);
  } catch (e) {
    res.error = new Error(e.message);
    res.error.method = '_execFileSync - spawn';
    res.error.program = shellPath;
    res.error.args = shellArgs;
  }

  while (fs.readFileSync(pathDone, {encoding: options.encoding}).trim() !== '1') {} // eslint-disable-line no-empty
  if ((exitCode =
      fs.readFileSync(pathExit, {encoding: options.encoding}).trim()) === '0') {
    res.input =
      decipher.update(fs.readFileSync(pathStdout, {encoding: 'binary'}),
        'hex', options.encoding) +
      decipher.final(options.encoding);
  } else {
    extMessage = fs.readFileSync(pathStderr, {encoding: options.encoding}).trim();
    res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
    res.error.method = '_execFileSync';
    res.error.program = shellPath;
    res.error.args = shellArgs;
    res.error.extMessage = extMessage;
    res.error.exitCode = +exitCode;
  }

  fs.unlinkSync(pathStdout);
  fs.unlinkSync(pathStderr);
  fs.unlinkSync(pathExit);
  fs.unlinkSync(pathDone);

  return res;
}

function readlineExt(options) {
  var hostArgs, res = {}, extMessage,
    execOptions = {env: process.env, encoding: options.encoding};

  if (!extHostPath) {
    if (IS_WIN) {
      if (process.env.PSModulePath) { // Windows PowerShell
        extHostPath = 'powershell.exe';
        extHostArgs = ['-ExecutionPolicy', 'Bypass', '-File', __dirname + '\\read.ps1']; // eslint-disable-line no-path-concat
      } else {                        // Windows Script Host
        extHostPath = 'cscript.exe';
        extHostArgs = ['//nologo', __dirname + '\\read.cs.js']; // eslint-disable-line no-path-concat
      }
    } else {
      extHostPath = '/bin/sh';
      extHostArgs = [__dirname + '/read.sh']; // eslint-disable-line no-path-concat
    }
  }
  if (IS_WIN && !process.env.PSModulePath) { // Windows Script Host
    // ScriptPW (Win XP and Server2003) needs TTY stream as STDIN.
    // In this case, If STDIN isn't TTY, an error is thrown.
    execOptions.stdio = [process.stdin];
  }

  if (childProc.execFileSync) {
    hostArgs = getHostArgs(options);
    if (_DBG_checkMethod) { _DBG_checkMethod('execFileSync', hostArgs); }
    try {
      res.input = childProc.execFileSync(extHostPath, hostArgs, execOptions);
    } catch (e) { // non-zero exit code
      extMessage = e.stderr ? (e.stderr + '').trim() : '';
      res.error = new Error(DEFAULT_ERR_MSG + (extMessage ? '\n' + extMessage : ''));
      res.error.method = 'execFileSync';
      res.error.program = extHostPath;
      res.error.args = hostArgs;
      res.error.extMessage = extMessage;
      res.error.exitCode = e.status;
      res.error.code = e.code;
      res.error.signal = e.signal;
    }
  } else {
    res = _execFileSync(options, execOptions);
  }
  if (!res.error) {
    res.input = res.input.replace(/^\s*'|'\s*$/g, '');
    options.display = '';
  }

  return res;
}

/*
  display:            string
  displayOnly:        boolean
  keyIn:              boolean
  hideEchoBack:       boolean
  mask:               string
  limit:              string (pattern)
  caseSensitive:      boolean
  keepWhitespace:     boolean
  encoding, bufferSize, print
*/
function _readlineSync(options) {
  var input = '', displaySave = options.display,
    silent = !options.display &&
      options.keyIn && options.hideEchoBack && !options.mask;

  function tryExt() {
    var res = readlineExt(options);
    if (res.error) { throw res.error; }
    return res.input;
  }

  if (_DBG_checkOptions) { _DBG_checkOptions(options); }

  (function() { // open TTY
    var fsB, constants, verNum;

    function getFsB() {
      if (!fsB) {
        fsB = process.binding('fs'); // For raw device path
        constants = process.binding('constants');
      }
      return fsB;
    }

    if (typeof fdR !== 'string') { return; }
    fdR = null;

    if (IS_WIN) {
      // iojs-v2.3.2+ input stream can't read first line. (#18)
      // ** Don't get process.stdin before check! **
      // Fixed v5.1.0
      // Fixed v4.2.4
      // It regressed again in v5.6.0, it is fixed in v6.2.0.
      verNum = (function(ver) { // getVerNum
        var nums = ver.replace(/^\D+/, '').split('.');
        var verNum = 0;
        if ((nums[0] = +nums[0])) { verNum += nums[0] * 10000; }
        if ((nums[1] = +nums[1])) { verNum += nums[1] * 100; }
        if ((nums[2] = +nums[2])) { verNum += nums[2]; }
        return verNum;
      })(process.version);
      if (!(verNum >= 20302 && verNum < 40204 || verNum >= 50000 && verNum < 50100 || verNum >= 50600 && verNum < 60200) &&
          process.stdin.isTTY) {
        process.stdin.pause();
        fdR = process.stdin.fd;
        ttyR = process.stdin._handle;
      } else {
        try {
          // The stream by fs.openSync('\\\\.\\CON', 'r') can't switch to raw mode.
          // 'CONIN$' might fail on XP, 2000, 7 (x86).
          fdR = getFsB().open('CONIN$', constants.O_RDWR, parseInt('0666', 8));
          ttyR = new TTY(fdR, true);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('\\\\.\\CON', 'w');
        } catch (e) { /* ignore */ }
        if (typeof fdW !== 'number') { // Retry
          try {
            fdW = getFsB().open('CONOUT$', constants.O_RDWR, parseInt('0666', 8));
          } catch (e) { /* ignore */ }
        }
      }

    } else {
      if (process.stdin.isTTY) {
        process.stdin.pause();
        try {
          fdR = fs.openSync('/dev/tty', 'r'); // device file, not process.stdin
          ttyR = process.stdin._handle;
        } catch (e) { /* ignore */ }
      } else {
        // Node.js v0.12 read() fails.
        try {
          fdR = fs.openSync('/dev/tty', 'r');
          ttyR = new TTY(fdR, false);
        } catch (e) { /* ignore */ }
      }

      if (process.stdout.isTTY) {
        fdW = process.stdout.fd;
      } else {
        try {
          fdW = fs.openSync('/dev/tty', 'w');
        } catch (e) { /* ignore */ }
      }
    }
  })();

  (function() { // try read
    var atEol, limit,
      isCooked = !options.hideEchoBack && !options.keyIn,
      buffer, reqSize, readSize, chunk, line;
    rawInput = '';

    // Node.js v0.10- returns an error if same mode is set.
    function setRawMode(mode) {
      if (mode === isRawMode) { return true; }
      if (ttyR.setRawMode(mode) !== 0) { return false; }
      isRawMode = mode;
      return true;
    }

    if (_DBG_useExt || !ttyR ||
        typeof fdW !== 'number' && (options.display || !isCooked)) {
      input = tryExt();
      return;
    }

    if (options.display) {
      fs.writeSync(fdW, options.display);
      options.display = '';
    }
    if (options.displayOnly) { return; }

    if (!setRawMode(!isCooked)) {
      input = tryExt();
      return;
    }

    reqSize = options.keyIn ? 1 : options.bufferSize;
    // Check `allocUnsafe` to make sure of the new API.
    buffer = Buffer.allocUnsafe && Buffer.alloc ? Buffer.alloc(reqSize) : new Buffer(reqSize);

    if (options.keyIn && options.limit) {
      limit = new RegExp('[^' + options.limit + ']',
        'g' + (options.caseSensitive ? '' : 'i'));
    }

    while (true) {
      readSize = 0;
      try {
        readSize = fs.readSync(fdR, buffer, 0, reqSize);
      } catch (e) {
        if (e.code !== 'EOF') {
          setRawMode(false);
          input += tryExt();
          return;
        }
      }
      if (readSize > 0) {
        chunk = buffer.toString(options.encoding, 0, readSize);
        rawInput += chunk;
      } else {
        chunk = '\n';
        rawInput += String.fromCharCode(0);
      }

      if (chunk && typeof (line = (chunk.match(/^(.*?)[\r\n]/) || [])[1]) === 'string') {
        chunk = line;
        atEol = true;
      }

      // other ctrl-chars
      // eslint-disable-next-line no-control-regex
      if (chunk) { chunk = chunk.replace(/[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]/g, ''); }
      if (chunk && limit) { chunk = chunk.replace(limit, ''); }

      if (chunk) {
        if (!isCooked) {
          if (!options.hideEchoBack) {
            fs.writeSync(fdW, chunk);
          } else if (options.mask) {
            fs.writeSync(fdW, (new Array(chunk.length + 1)).join(options.mask));
          }
        }
        input += chunk;
      }

      if (!options.keyIn && atEol ||
        options.keyIn && input.length >= reqSize) { break; }
    }

    if (!isCooked && !silent) { fs.writeSync(fdW, '\n'); }
    setRawMode(false);
  })();

  if (options.print && !silent) {
    options.print(displaySave + (options.displayOnly ? '' :
        (options.hideEchoBack ? (new Array(input.length + 1)).join(options.mask)
          : input) + '\n'), // must at least write '\n'
      options.encoding);
  }

  return options.displayOnly ? '' :
    (lastInput = options.keepWhitespace || options.keyIn ? input : input.trim());
}

function flattenArray(array, validator) {
  var flatArray = [];
  function _flattenArray(array) {
    if (array == null) {
      return;
    } else if (Array.isArray(array)) {
      array.forEach(_flattenArray);
    } else if (!validator || validator(array)) {
      flatArray.push(array);
    }
  }
  _flattenArray(array);
  return flatArray;
}

function escapePattern(pattern) {
  return pattern.replace(/[\x00-\x7f]/g, // eslint-disable-line no-control-regex
    function(s) { return '\\x' + ('00' + s.charCodeAt().toString(16)).substr(-2); });
}

// margeOptions(options1, options2 ... )
// margeOptions(true, options1, options2 ... )
//    arg1=true : Start from defaultOptions and pick elements of that.
function margeOptions() {
  var optionsList = Array.prototype.slice.call(arguments),
    optionNames, fromDefault;

  if (optionsList.length && typeof optionsList[0] === 'boolean') {
    fromDefault = optionsList.shift();
    if (fromDefault) {
      optionNames = Object.keys(defaultOptions);
      optionsList.unshift(defaultOptions);
    }
  }

  return optionsList.reduce(function(options, optionsPart) {
    if (optionsPart == null) { return options; }

    // ======== DEPRECATED ========
    if (optionsPart.hasOwnProperty('noEchoBack') &&
        !optionsPart.hasOwnProperty('hideEchoBack')) {
      optionsPart.hideEchoBack = optionsPart.noEchoBack;
      delete optionsPart.noEchoBack;
    }
    if (optionsPart.hasOwnProperty('noTrim') &&
        !optionsPart.hasOwnProperty('keepWhitespace')) {
      optionsPart.keepWhitespace = optionsPart.noTrim;
      delete optionsPart.noTrim;
    }
    // ======== /DEPRECATED ========

    if (!fromDefault) { optionNames = Object.keys(optionsPart); }
    optionNames.forEach(function(optionName) {
      var value;
      if (!optionsPart.hasOwnProperty(optionName)) { return; }
      value = optionsPart[optionName];
      switch (optionName) {
                           // _readlineSync <- *    * -> defaultOptions
        // ================ string
        case 'mask':                        // *    *
        case 'limitMessage':                //      *
        case 'defaultInput':                //      *
        case 'encoding':                    // *    *
          value = value != null ? value + '' : '';
          if (value && optionName !== 'limitMessage') { value = value.replace(/[\r\n]/g, ''); }
          options[optionName] = value;
          break;
        // ================ number(int)
        case 'bufferSize':                  // *    *
          if (!isNaN(value = parseInt(value, 10)) && typeof value === 'number') {
            options[optionName] = value; // limited updating (number is needed)
          }
          break;
        // ================ boolean
        case 'displayOnly':                 // *
        case 'keyIn':                       // *
        case 'hideEchoBack':                // *    *
        case 'caseSensitive':               // *    *
        case 'keepWhitespace':              // *    *
        case 'history':                     //      *
        case 'cd':                          //      *
          options[optionName] = !!value;
          break;
        // ================ array
        case 'limit':                       // *    *     to string for readlineExt
        case 'trueValue':                   //      *
        case 'falseValue':                  //      *
          options[optionName] = flattenArray(value, function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number' ||
              type === 'function' || value instanceof RegExp;
          }).map(function(value) {
            return typeof value === 'string' ? value.replace(/[\r\n]/g, '') : value;
          });
          break;
        // ================ function
        case 'print':                       // *    *
        case 'phContent':                   //      *
        case 'preCheck':                    //      *
          options[optionName] = typeof value === 'function' ? value : void 0;
          break;
        // ================ other
        case 'prompt':                      //      *
        case 'display':                     // *
          options[optionName] = value != null ? value : '';
          break;
        // no default
      }
    });
    return options;
  }, {});
}

function isMatched(res, comps, caseSensitive) {
  return comps.some(function(comp) {
    var type = typeof comp;
    return type === 'string' ?
        (caseSensitive ? res === comp : res.toLowerCase() === comp.toLowerCase()) :
      type === 'number' ? parseFloat(res) === comp :
      type === 'function' ? comp(res) :
      comp instanceof RegExp ? comp.test(res) : false;
  });
}

function replaceHomePath(path, expand) {
  var homePath = pathUtil.normalize(
    IS_WIN ? (process.env.HOMEDRIVE || '') + (process.env.HOMEPATH || '') :
    process.env.HOME || '').replace(/[\/\\]+$/, '');
  path = pathUtil.normalize(path);
  return expand ? path.replace(/^~(?=\/|\\|$)/, homePath) :
    path.replace(new RegExp('^' + escapePattern(homePath) +
      '(?=\\/|\\\\|$)', IS_WIN ? 'i' : ''), '~');
}

function replacePlaceholder(text, generator) {
  var PTN_INNER = '(?:\\(([\\s\\S]*?)\\))?(\\w+|.-.)(?:\\(([\\s\\S]*?)\\))?',
    rePlaceholder = new RegExp('(\\$)?(\\$<' + PTN_INNER + '>)', 'g'),
    rePlaceholderCompat = new RegExp('(\\$)?(\\$\\{' + PTN_INNER + '\\})', 'g');

  function getPlaceholderText(s, escape, placeholder, pre, param, post) {
    var text;
    return escape || typeof (text = generator(param)) !== 'string' ? placeholder :
      text ? (pre || '') + text + (post || '') : '';
  }

  return text.replace(rePlaceholder, getPlaceholderText)
    .replace(rePlaceholderCompat, getPlaceholderText);
}

function array2charlist(array, caseSensitive, collectSymbols) {
  var values, group = [], groupClass = -1, charCode = 0, symbols = '', suppressed;
  function addGroup(groups, group) {
    if (group.length > 3) { // ellipsis
      groups.push(group[0] + '...' + group[group.length - 1]);
      suppressed = true;
    } else if (group.length) {
      groups = groups.concat(group);
    }
    return groups;
  }

  values = array.reduce(
      function(chars, value) { return chars.concat((value + '').split('')); }, [])
    .reduce(function(groups, curChar) {
      var curGroupClass, curCharCode;
      if (!caseSensitive) { curChar = curChar.toLowerCase(); }
      curGroupClass = /^\d$/.test(curChar) ? 1 :
        /^[A-Z]$/.test(curChar) ? 2 : /^[a-z]$/.test(curChar) ? 3 : 0;
      if (collectSymbols && curGroupClass === 0) {
        symbols += curChar;
      } else {
        curCharCode = curChar.charCodeAt(0);
        if (curGroupClass && curGroupClass === groupClass &&
            curCharCode === charCode + 1) {
          group.push(curChar);
        } else {
          groups = addGroup(groups, group);
          group = [curChar];
          groupClass = curGroupClass;
        }
        charCode = curCharCode;
      }
      return groups;
    }, []);
  values = addGroup(values, group); // last group
  if (symbols) { values.push(symbols); suppressed = true; }
  return {values: values, suppressed: suppressed};
}

function joinChunks(chunks, suppressed) {
  return chunks.join(chunks.length > 2 ? ', ' : suppressed ? ' / ' : '/');
}

function getPhContent(param, options) {
  var text, values, resCharlist = {}, arg;
  if (options.phContent) {
    text = options.phContent(param, options);
  }
  if (typeof text !== 'string') {
    switch (param) {
      case 'hideEchoBack':
      case 'mask':
      case 'defaultInput':
      case 'caseSensitive':
      case 'keepWhitespace':
      case 'encoding':
      case 'bufferSize':
      case 'history':
      case 'cd':
        text = !options.hasOwnProperty(param) ? '' :
          typeof options[param] === 'boolean' ? (options[param] ? 'on' : 'off') :
          options[param] + '';
        break;
      // case 'prompt':
      // case 'query':
      // case 'display':
      //   text = options.hasOwnProperty('displaySrc') ? options.displaySrc + '' : '';
      //   break;
      case 'limit':
      case 'trueValue':
      case 'falseValue':
        values = options[options.hasOwnProperty(param + 'Src') ? param + 'Src' : param];
        if (options.keyIn) { // suppress
          resCharlist = array2charlist(values, options.caseSensitive);
          values = resCharlist.values;
        } else {
          values = values.filter(function(value) {
            var type = typeof value;
            return type === 'string' || type === 'number';
          });
        }
        text = joinChunks(values, resCharlist.suppressed);
        break;
      case 'limitCount':
      case 'limitCountNotZero':
        text = options[options.hasOwnProperty('limitSrc') ?
          'limitSrc' : 'limit'].length;
        text = text || param !== 'limitCountNotZero' ? text + '' : '';
        break;
      case 'lastInput':
        text = lastInput;
        break;
      case 'cwd':
      case 'CWD':
      case 'cwdHome':
        text = process.cwd();
        if (param === 'CWD') {
          text = pathUtil.basename(text);
        } else if (param === 'cwdHome') {
          text = replaceHomePath(text);
        }
        break;
      case 'date':
      case 'time':
      case 'localeDate':
      case 'localeTime':
        text = (new Date())['to' +
          param.replace(/^./, function(str) { return str.toUpperCase(); }) +
          'String']();
        break;
      default: // with arg
        if (typeof (arg = (param.match(/^history_m(\d+)$/) || [])[1]) === 'string') {
          text = inputHistory[inputHistory.length - arg] || '';
        }
    }
  }
  return text;
}

function getPhCharlist(param) {
  var matches = /^(.)-(.)$/.exec(param), text = '', from, to, code, step;
  if (!matches) { return null; }
  from = matches[1].charCodeAt(0);
  to = matches[2].charCodeAt(0);
  step = from < to ? 1 : -1;
  for (code = from; code !== to + step; code += step) { text += String.fromCharCode(code); }
  return text;
}

// cmd "arg" " a r g " "" 'a"r"g' "a""rg" "arg
function parseCl(cl) {
  var reToken = new RegExp(/(\s*)(?:("|')(.*?)(?:\2|$)|(\S+))/g), matches,
    taken = '', args = [], part;
  cl = cl.trim();
  while ((matches = reToken.exec(cl))) {
    part = matches[3] || matches[4] || '';
    if (matches[1]) {
      args.push(taken);
      taken = '';
    }
    taken += part;
  }
  if (taken) { args.push(taken); }
  return args;
}

function toBool(res, options) {
  return (
    (options.trueValue.length &&
      isMatched(res, options.trueValue, options.caseSensitive)) ? true :
    (options.falseValue.length &&
      isMatched(res, options.falseValue, options.caseSensitive)) ? false : res);
}

function getValidLine(options) {
  var res, forceNext, limitMessage,
    matches, histInput, args, resCheck;

  function _getPhContent(param) { return getPhContent(param, options); }
  function addDisplay(text) { options.display += (/[^\r\n]$/.test(options.display) ? '\n' : '') + text; }

  options.limitSrc = options.limit;
  options.displaySrc = options.display;
  options.limit = ''; // for readlineExt
  options.display = replacePlaceholder(options.display + '', _getPhContent);

  while (true) {
    res = _readlineSync(options);
    forceNext = false;
    limitMessage = '';

    if (options.defaultInput && !res) { res = options.defaultInput; }

    if (options.history) {
      if ((matches = /^\s*\!(?:\!|-1)(:p)?\s*$/.exec(res))) { // `!!` `!-1` +`:p`
        histInput = inputHistory[0] || '';
        if (matches[1]) { // only display
          forceNext = true;
        } else { // replace input
          res = histInput;
        }
        // Show it even if it is empty (NL only).
        addDisplay(histInput + '\n');
        if (!forceNext) { // Loop may break
          options.displayOnly = true;
          _readlineSync(options);
          options.displayOnly = false;
        }
      } else if (res && res !== inputHistory[inputHistory.length - 1]) {
        inputHistory = [res];
      }
    }

    if (!forceNext && options.cd && res) {
      args = parseCl(res);
      switch (args[0].toLowerCase()) {
        case 'cd':
          if (args[1]) {
            try {
              process.chdir(replaceHomePath(args[1], true));
            } catch (e) {
              addDisplay(e + '');
            }
          }
          forceNext = true;
          break;
        case 'pwd':
          addDisplay(process.cwd());
          forceNext = true;
          break;
        // no default
      }
    }

    if (!forceNext && options.preCheck) {
      resCheck = options.preCheck(res, options);
      res = resCheck.res;
      if (resCheck.forceNext) { forceNext = true; } // Don't switch to false.
    }

    if (!forceNext) {
      if (!options.limitSrc.length ||
        isMatched(res, options.limitSrc, options.caseSensitive)) { break; }
      if (options.limitMessage) {
        limitMessage = replacePlaceholder(options.limitMessage, _getPhContent);
      }
    }

    addDisplay((limitMessage ? limitMessage + '\n' : '') +
      replacePlaceholder(options.displaySrc + '', _getPhContent));
  }
  return toBool(res, options);
}

// for dev
exports._DBG_set_useExt = function(val) { _DBG_useExt = val; };
exports._DBG_set_checkOptions = function(val) { _DBG_checkOptions = val; };
exports._DBG_set_checkMethod = function(val) { _DBG_checkMethod = val; };
exports._DBG_clearHistory = function() { lastInput = ''; inputHistory = []; };

// ------------------------------------

exports.setDefaultOptions = function(options) {
  defaultOptions = margeOptions(true, options);
  return margeOptions(true); // copy
};

exports.question = function(query, options) {
  /* eslint-disable key-spacing */
  return getValidLine(margeOptions(margeOptions(true, options), {
    display:            query
  }));
  /* eslint-enable key-spacing */
};

exports.prompt = function(options) {
  var readOptions = margeOptions(true, options);
  readOptions.display = readOptions.prompt;
  return getValidLine(readOptions);
};

exports.keyIn = function(query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions(margeOptions(true, options), {
    display:            query,
    keyIn:              true,
    keepWhitespace:     true
  });
  /* eslint-enable key-spacing */

  // char list
  readOptions.limitSrc = readOptions.limit.filter(function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number';
  })
  .map(function(text) { return replacePlaceholder(text + '', getPhCharlist); });
  // pattern
  readOptions.limit = escapePattern(readOptions.limitSrc.join(''));

  ['trueValue', 'falseValue'].forEach(function(optionName) {
    readOptions[optionName] = readOptions[optionName].reduce(function(comps, comp) {
      var type = typeof comp;
      if (type === 'string' || type === 'number') {
        comps = comps.concat((comp + '').split(''));
      } else { comps.push(comp); }
      return comps;
    }, []);
  });

  readOptions.display = replacePlaceholder(readOptions.display + '',
    function(param) { return getPhContent(param, readOptions); });

  return toBool(_readlineSync(readOptions), readOptions);
};

// ------------------------------------

exports.questionEMail = function(query, options) {
  if (query == null) { query = 'Input e-mail address: '; }
  /* eslint-disable key-spacing */
  return exports.question(query, margeOptions({
    // -------- default
    hideEchoBack:       false,
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address
    limit:              /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
    limitMessage:       'Input valid e-mail address, please.',
    trueValue:          null,
    falseValue:         null
  }, options, {
    // -------- forced
    keepWhitespace:     false,
    cd:                 false
  }));
  /* eslint-enable key-spacing */
};

exports.questionNewPassword = function(query, options) {
  /* eslint-disable key-spacing */
  var resCharlist, min, max,
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       true,
      mask:               '*',
      limitMessage:       'It can include: $<charlist>\n' +
                            'And the length must be: $<length>',
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      true
    }, options, {
      // -------- forced
      history:            false,
      cd:                 false,
      // limit (by charlist etc.),
      phContent: function(param) {
        return param === 'charlist' ? resCharlist.text :
          param === 'length' ? min + '...' + max : null;
      }
    }),
    // added:     charlist, min, max, confirmMessage, unmatchMessage
    charlist, confirmMessage, unmatchMessage,
    limit, limitMessage, res1, res2;
  /* eslint-enable key-spacing */
  options = options || {};

  charlist = replacePlaceholder(
    options.charlist ? options.charlist + '' : '$<!-~>', getPhCharlist);
  if (isNaN(min = parseInt(options.min, 10)) || typeof min !== 'number') { min = 12; }
  if (isNaN(max = parseInt(options.max, 10)) || typeof max !== 'number') { max = 24; }
  limit = new RegExp('^[' + escapePattern(charlist) +
    ']{' + min + ',' + max + '}$');
  resCharlist = array2charlist([charlist], readOptions.caseSensitive, true);
  resCharlist.text = joinChunks(resCharlist.values, resCharlist.suppressed);

  confirmMessage = options.confirmMessage != null ? options.confirmMessage :
    'Reinput a same one to confirm it: ';
  unmatchMessage = options.unmatchMessage != null ? options.unmatchMessage :
    'It differs from first one.' +
      ' Hit only the Enter key if you want to retry from first one.';

  if (query == null) { query = 'Input new password: '; }

  limitMessage = readOptions.limitMessage;
  while (!res2) {
    readOptions.limit = limit;
    readOptions.limitMessage = limitMessage;
    res1 = exports.question(query, readOptions);

    readOptions.limit = [res1, ''];
    readOptions.limitMessage = unmatchMessage;
    res2 = exports.question(confirmMessage, readOptions);
  }

  return res1;
};

function _questionNum(query, options, parser) {
  var validValue;
  function getValidValue(value) {
    validValue = parser(value);
    return !isNaN(validValue) && typeof validValue === 'number';
  }
  /* eslint-disable key-spacing */
  exports.question(query, margeOptions({
    // -------- default
    limitMessage:       'Input valid number, please.'
  }, options, {
    // -------- forced
    limit:              getValidValue,
    cd:                 false
    // trueValue, falseValue, caseSensitive, keepWhitespace don't work.
  }));
  /* eslint-enable key-spacing */
  return validValue;
}
exports.questionInt = function(query, options) {
  return _questionNum(query, options, function(value) { return parseInt(value, 10); });
};
exports.questionFloat = function(query, options) {
  return _questionNum(query, options, parseFloat);
};

exports.questionPath = function(query, options) {
  /* eslint-disable key-spacing */
  var validPath, error = '',
    readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       '$<error(\n)>Input valid path, please.' +
                            '$<( Min:)min>$<( Max:)max>',
      history:            true,
      cd:                 true
    }, options, {
      // -------- forced
      keepWhitespace:     false,
      limit: function(value) {
        var exists, stat, res;
        value = replaceHomePath(value, true);
        error = ''; // for validate
        // mkdir -p
        function mkdirParents(dirPath) {
          dirPath.split(/\/|\\/).reduce(function(parents, dir) {
            var path = pathUtil.resolve((parents += dir + pathUtil.sep));
            if (!fs.existsSync(path)) {
              fs.mkdirSync(path);
            } else if (!fs.statSync(path).isDirectory()) {
              throw new Error('Non directory already exists: ' + path);
            }
            return parents;
          }, '');
        }

        try {
          exists = fs.existsSync(value);
          validPath = exists ? fs.realpathSync(value) : pathUtil.resolve(value);
          // options.exists default: true, not-bool: no-check
          if (!options.hasOwnProperty('exists') && !exists ||
              typeof options.exists === 'boolean' && options.exists !== exists) {
            error = (exists ? 'Already exists' : 'No such file or directory') +
              ': ' + validPath;
            return false;
          }
          if (!exists && options.create) {
            if (options.isDirectory) {
              mkdirParents(validPath);
            } else {
              mkdirParents(pathUtil.dirname(validPath));
              fs.closeSync(fs.openSync(validPath, 'w')); // touch
            }
            validPath = fs.realpathSync(validPath);
          }
          if (exists && (options.min || options.max ||
              options.isFile || options.isDirectory)) {
            stat = fs.statSync(validPath);
            // type check first (directory has zero size)
            if (options.isFile && !stat.isFile()) {
              error = 'Not file: ' + validPath;
              return false;
            } else if (options.isDirectory && !stat.isDirectory()) {
              error = 'Not directory: ' + validPath;
              return false;
            } else if (options.min && stat.size < +options.min ||
                options.max && stat.size > +options.max) {
              error = 'Size ' + stat.size + ' is out of range: ' + validPath;
              return false;
            }
          }
          if (typeof options.validate === 'function' &&
              (res = options.validate(validPath)) !== true) {
            if (typeof res === 'string') { error = res; }
            return false;
          }
        } catch (e) {
          error = e + '';
          return false;
        }
        return true;
      },
      // trueValue, falseValue, caseSensitive don't work.
      phContent: function(param) {
        return param === 'error' ? error :
          param !== 'min' && param !== 'max' ? null :
          options.hasOwnProperty(param) ? options[param] + '' : '';
      }
    });
    // added:     exists, create, min, max, isFile, isDirectory, validate
  /* eslint-enable key-spacing */
  options = options || {};

  if (query == null) { query = 'Input path (you can "cd" and "pwd"): '; }

  exports.question(query, readOptions);
  return validPath;
};

// props: preCheck, args, hRes, limit
function getClHandler(commandHandler, options) {
  var clHandler = {}, hIndex = {};
  if (typeof commandHandler === 'object') {
    Object.keys(commandHandler).forEach(function(cmd) {
      if (typeof commandHandler[cmd] === 'function') {
        hIndex[options.caseSensitive ? cmd : cmd.toLowerCase()] = commandHandler[cmd];
      }
    });
    clHandler.preCheck = function(res) {
      var cmdKey;
      clHandler.args = parseCl(res);
      cmdKey = clHandler.args[0] || '';
      if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
      clHandler.hRes =
        cmdKey !== '_' && hIndex.hasOwnProperty(cmdKey) ?
          hIndex[cmdKey].apply(res, clHandler.args.slice(1)) :
        hIndex.hasOwnProperty('_') ? hIndex._.apply(res, clHandler.args) : null;
      return {res: res, forceNext: false};
    };
    if (!hIndex.hasOwnProperty('_')) {
      clHandler.limit = function() { // It's called after preCheck.
        var cmdKey = clHandler.args[0] || '';
        if (!options.caseSensitive) { cmdKey = cmdKey.toLowerCase(); }
        return hIndex.hasOwnProperty(cmdKey);
      };
    }
  } else {
    clHandler.preCheck = function(res) {
      clHandler.args = parseCl(res);
      clHandler.hRes = typeof commandHandler === 'function' ?
        commandHandler.apply(res, clHandler.args) : true; // true for break loop
      return {res: res, forceNext: false};
    };
  }
  return clHandler;
}

exports.promptCL = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  exports.prompt(readOptions);
  return clHandler.args;
};

exports.promptLoop = function(inputHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
    // -------- default
    hideEchoBack:       false,
    trueValue:          null,
    falseValue:         null,
    caseSensitive:      false,
    history:            true
  }, options);
  /* eslint-enable key-spacing */
  while (true) { if (inputHandler(exports.prompt(readOptions))) { break; } }
  return;
};

exports.promptCLLoop = function(commandHandler, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false,
      limitMessage:       'Requested command is not available.',
      caseSensitive:      false,
      history:            true
    }, options),
      // -------- forced
      // trueValue, falseValue, keepWhitespace don't work.
      // preCheck, limit (by clHandler)
    clHandler = getClHandler(commandHandler, readOptions);
  /* eslint-enable key-spacing */
  readOptions.limit = clHandler.limit;
  readOptions.preCheck = clHandler.preCheck;
  while (true) {
    exports.prompt(readOptions);
    if (clHandler.hRes) { break; }
  }
  return;
};

exports.promptSimShell = function(options) {
  /* eslint-disable key-spacing */
  return exports.prompt(margeOptions({
    // -------- default
    hideEchoBack:       false,
    history:            true
  }, options, {
    // -------- forced
    prompt:             (function() {
      return IS_WIN ?
        '$<cwd>>' :
        // 'user@host:cwd$ '
        (process.env.USER || '') +
        (process.env.HOSTNAME ?
          '@' + process.env.HOSTNAME.replace(/\..*$/, '') : '') +
        ':$<cwdHome>$ ';
    })()
  }));
  /* eslint-enable key-spacing */
};

function _keyInYN(query, options, limit) {
  var res;
  if (query == null) { query = 'Are you sure? '; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s*:?\s*$/, '') + ' [y/n]: ';
  }
  /* eslint-disable key-spacing */
  res = exports.keyIn(query, margeOptions(options, {
    // -------- forced
    hideEchoBack:       false,
    limit:              limit,
    trueValue:          'y',
    falseValue:         'n',
    caseSensitive:      false
    // mask doesn't work.
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return typeof res === 'boolean' ? res : '';
}
exports.keyInYN = function(query, options) { return _keyInYN(query, options); };
exports.keyInYNStrict = function(query, options) { return _keyInYN(query, options, 'yn'); };

exports.keyInPause = function(query, options) {
  if (query == null) { query = 'Continue...'; }
  if ((!options || options.guide !== false) && (query += '')) {
    query = query.replace(/\s+$/, '') + ' (Hit any key)';
  }
  /* eslint-disable key-spacing */
  exports.keyIn(query, margeOptions({
    // -------- default
    limit:              null
  }, options, {
    // -------- forced
    hideEchoBack:       true,
    mask:               ''
  }));
  // added:     guide
  /* eslint-enable key-spacing */
  return;
};

exports.keyInSelect = function(items, query, options) {
  /* eslint-disable key-spacing */
  var readOptions = margeOptions({
      // -------- default
      hideEchoBack:       false
    }, options, {
      // -------- forced
      trueValue:          null,
      falseValue:         null,
      caseSensitive:      false,
      // limit (by items),
      phContent: function(param) {
        return param === 'itemsCount' ? items.length + '' :
          param === 'firstItem' ? (items[0] + '').trim() :
          param === 'lastItem' ? (items[items.length - 1] + '').trim() : null;
      }
    }),
    // added:     guide, cancel
    keylist = '', key2i = {}, charCode = 49 /* '1' */, display = '\n';
  /* eslint-enable key-spacing */
  if (!Array.isArray(items) || !items.length || items.length > 35) {
    throw '`items` must be Array (max length: 35).';
  }

  items.forEach(function(item, i) {
    var key = String.fromCharCode(charCode);
    keylist += key;
    key2i[key] = i;
    display += '[' + key + '] ' + (item + '').trim() + '\n';
    charCode = charCode === 57 /* '9' */ ? 97 /* 'a' */ : charCode + 1;
  });
  if (!options || options.cancel !== false) {
    keylist += '0';
    key2i['0'] = -1;
    display += '[0] ' +
      (options && options.cancel != null && typeof options.cancel !== 'boolean' ?
        (options.cancel + '').trim() : 'CANCEL') + '\n';
  }
  readOptions.limit = keylist;
  display += '\n';

  if (query == null) { query = 'Choose one from list: '; }
  if ((query += '')) {
    if (!options || options.guide !== false) {
      query = query.replace(/\s*:?\s*$/, '') + ' [$<limit>]: ';
    }
    display += query;
  }

  return key2i[exports.keyIn(display, readOptions).toLowerCase()];
};

exports.getRawInput = function() { return rawInput; };

// ======== DEPRECATED ========
function _setOption(optionName, args) {
  var options;
  if (args.length) { options = {}; options[optionName] = args[0]; }
  return exports.setDefaultOptions(options)[optionName];
}
exports.setPrint = function() { return _setOption('print', arguments); };
exports.setPrompt = function() { return _setOption('prompt', arguments); };
exports.setEncoding = function() { return _setOption('encoding', arguments); };
exports.setMask = function() { return _setOption('mask', arguments); };
exports.setBufferSize = function() { return _setOption('bufferSize', arguments); };


/***/ }),

/***/ "./node_modules/tau-prolog/modules/core.js":
/*!*************************************************!*\
  !*** ./node_modules/tau-prolog/modules/core.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function() {
	
	// VERSION
	var version = { major: 0, minor: 3, patch: 4, status: "beta" };



	// IO FILE SYSTEM
	
	// Virtual file
	function TauFile(name, type, parent, text) {
		text = text === undefined ? "" : text;
		this.name = name;
		this.type = type;
		this.parent = parent;
		this.text = text;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauFile.prototype.get = function(length, position) {
		if(position === this.text.length) {
			return "end_of_stream";
		} else if(position > this.text.length) {
			return "end_of_stream";
		} else {
			return this.text.substring(position, position+length);
		}
	};

	TauFile.prototype.eof = function(position) {
		return position === this.text.length;
	};

	TauFile.prototype.put = function(text, position) {
		if(position === "end_of_stream") {
			this.text += text;
			return true;
		} else if(position === "past_end_of_stream") {
			return null;
		} else {
			this.text = this.text.substring(0, position) + text + this.text.substring(position+text.length);
			return true;
		}
	};

	TauFile.prototype.get_byte = function(position) {
		if(position === "end_of_stream")
			return -1;
		var index = Math.floor(position/2);
		if(this.text.length <= index)
			return -1;
		var code = codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0)
			return code & 0xff;
		else
			return code / 256 >>> 0;
	};

	TauFile.prototype.put_byte = function(byte, position) {
		var index = position === "end_of_stream" ? this.text.length : Math.floor(position/2);
		if(this.text.length < index)
			return null;
		var code = this.text.length === index ? -1 : codePointAt(this.text[Math.floor(position/2)], 0);
		if(position % 2 === 0) {
			code = code / 256 >>> 0;
			code = ((code & 0xff) << 8) | (byte & 0xff);
		} else {
			code = code & 0xff;
			code = ((byte & 0xff) << 8) | (code & 0xff);
		}
		if(this.text.length === index)
			this.text += fromCodePoint(code);
		else 
			this.text = this.text.substring(0, index) + fromCodePoint(code) + this.text.substring(index+1);
		return true;
	};

	TauFile.prototype.flush = function() {
		return true;
	};

	TauFile.prototype.close = function() {
		this.modified = Date.now() / 1000;
		return true;
	};

	TauFile.prototype.size = function() {
		return this.text.length;
	};

	// Virtual directory
	function TauDirectory(name, parent) {
		this.name = name;
		this.parent = parent;
		this.files = {};
		this.length = 0;
		this.created = Date.now() / 1000;
		this.modified = this.created;
	}

	TauDirectory.prototype.lookup = function(file) {
		if(this.files.hasOwnProperty(file))
			return this.files[file];
		return null;
	};

	TauDirectory.prototype.push = function(name, file) {
		if(!this.files.hasOwnProperty(name))
			this.length++;
		this.files[name] = file;
		this.modified = Date.now() / 1000;
	};

	TauDirectory.prototype.remove = function(name) {
		if(this.files.hasOwnProperty(name)) {
			this.length--;
			delete this.files[name];
			this.modified = Date.now() / 1000;
		}
	};

	TauDirectory.prototype.empty = function() {
		return this.length === 0;
	};

	TauDirectory.prototype.size = function() {
		return 4096;
	};

	// Virtual file system for browser
	tau_file_system = {
		// Current files
		files: new TauDirectory("/", "/", null),
		// Open file
		open: function(path, type, mode) {
			var dirs = path.replace(/\/$/, "").split("/");
			var dir = tau_file_system.files;
			var name = dirs[dirs.length-1];
			for(var i = 1; i < dirs.length-1; i++) {
				dir = dir.lookup(dirs[i]);
				if(!pl.type.is_directory(dir))
					return null;
			}
			var file = dir.lookup(name);
			if(file === null) {
				if(mode === "read")
					return null;
				file = new TauFile(name, type, dir);
				dir.push(name, file);
			} else if(!pl.type.is_file(file)) {
				return null;
			}
			if(mode === "write")
				file.text = "";
			return file;
		},
		// Get item
		get: function(path) {
			var dirs = path.replace(/\/$/, "").split("/");
			var file = tau_file_system.files;
			for(var i = 1; i < dirs.length; i++)
				if(pl.type.is_directory(file))
					file = file.lookup(dirs[i]);
				else
					return null;
			return file;
		}
	};

	// User input for browser
	tau_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			while( tau_user_input.buffer.length < length ) {
				text = window.prompt();
				if( text.length === 0 )
					return "end_of_stream";
				if( text ) {
					tau_user_input.buffer += text;
				}
			}
			text = tau_user_input.buffer.substr( 0, length );
			tau_user_input.buffer = tau_user_input.buffer.substr( length );
			return text;
		},
		eof: function(_) {
			return false;
		}
	};

	// User output for browser
	tau_user_output = {
		put: function( text, _ ) {
			console.log( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// User error for browser
	tau_user_error = {
		put: function( text, _ ) {
			(console.error || console.log)( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};

	// Virtual file system for Node.js
	nodejs_file_system = {
		// Open file
		open: function( path, type, mode ) {
			var fd, fs = __webpack_require__(/*! fs */ "?4a0f");
			if( mode === "read" && !fs.existsSync( path ) )
				return null;
			try {
				fd = fs.openSync( path, mode[0] );
			} catch(ex) {
				return false;
			}
			return {
				get: function( length, position ) {
					var buffer = new Buffer( length );
					fs.readSync( fd, buffer, 0, length, position );
					var end_of_file = true;
					var text = buffer.toString();
					for(var i = 0; i < length && end_of_file; i++)
						end_of_file = text[i] === "\u0000";
					return end_of_file ? "end_of_stream" : buffer.toString();
				},
				eof: function(position) {
					var stats = fs.statSync(path)
					return position === stats["size"];
				},
				put: function( text, position ) {
					var buffer = Buffer.from( text );
					if( position === "end_of_stream" )
						fs.writeSync( fd, buffer );
					else if( position === "past_end_of_stream" )
						return null;
					else
						fs.writeSync( fd, buffer, 0, buffer.length, position );
					return true;
				},
				get_byte: function( position ) {
					try {
						var buffer = Buffer.alloc(1);
						var bytesRead = fs.readSync(fd, buffer, 0, 1, position);
						//var _text = buffer.toString("utf8", 0, bytesRead);
						var end_of_file = bytesRead < 1;
						return end_of_file ? "end_of_stream" : buffer.readUInt8(0);
					} catch(ex) {
						return "end_of_stream";
					}
				},
				put_byte: function(byte, position) {
					var buffer = Buffer.from([byte]);
					if(position === "end_of_stream")
						fs.writeSync(fd, buffer);
					else if(position === "past_end_of_stream")
						return null;
					else
						fs.writeSync(fd, buffer, 0, buffer.length, position);
					return true;
				},
				flush: function() {
					return true;
				},
				close: function() {
					fs.closeSync( fd );
					return true;
				}
			};
		}
	};

	// User input for Node.js
	nodejs_user_input = {
		buffer: "",
		get: function( length, _ ) {
			var text;
			var readlineSync = __webpack_require__(/*! readline-sync */ "./node_modules/readline-sync/lib/readline-sync.js");
			while( nodejs_user_input.buffer.length < length )
				nodejs_user_input.buffer += readlineSync.question("", {keepWhitespace: true}) + "\n";
			text = nodejs_user_input.buffer.substr( 0, length );
			nodejs_user_input.buffer = nodejs_user_input.buffer.substr( length );
			return text;
		},
		eof: function(length) {
			return false;
		}
	};

	// User output for Node.js
	nodejs_user_output = {
		put: function( text, _ ) {
			process.stdout.write( text );
			return true;
		},
		flush: function() {
			return true;
		}
	};

	// User error for Node.js
	nodejs_user_error = {
		put: function( text, _ ) {
			process.stderr.write( text );
			return true;
		},
		flush: function() {
			return true;
		} 
	};
	
	
	
	// COMPATITBILITY
	
	var indexOf;
	if(!Array.prototype.indexOf) {
		indexOf = function(array, elem) {
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(elem === array[i]) return i;
			}
			return -1;
		};
	} else {
		indexOf = function(array, elem) {
			return array.indexOf(elem);
		};
	}

	var reduce = function(array, fn) {
		if(array.length === 0) return undefined;
		var elem = array[0];
		var len = array.length;
		for(var i = 1; i < len; i++) {
			elem = fn(elem, array[i]);
		}
		return elem;
	};

	var map;
	if(!Array.prototype.map) {
		map = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				a.push( fn(array[i]) );
			}
			return a;
		};
	} else {
		map = function(array, fn) {
			return array.map(fn);
		};
	}
	
	var filter;
	if(!Array.prototype.filter) {
		filter = function(array, fn) {
			var a = [];
			var len = array.length;
			for(var i = 0; i < len; i++) {
				if(fn(array[i]))
					a.push( array[i] );
			}
			return a;
		};
	} else {
		filter = function(array, fn) {
			return array.filter(fn);
		};
	}
	
	var codePointAt;
	if(!String.prototype.codePointAt) {
		codePointAt = function(str, i) {
			return str.charCodeAt(i);
		};
	} else {
		codePointAt = function(str, i) {
			return str.codePointAt(i);
		};
	}
	
	var fromCodePoint;
	if(!String.fromCodePoint) {
		fromCodePoint = function() {
			return String.fromCharCode.apply(null, arguments);
		};
	} else {
		fromCodePoint = function() {
			return String.fromCodePoint.apply(null, arguments);
		};
	}

	var stringLength;
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	if(Array.from)
		stringLength = function(str) {
			return Array.from(str).length;
		};
	else
		stringLength = function(str) {
			return str.replace(regexAstralSymbols, '_').length;
		};

	
	
	// PARSER

	var ERROR = 0;
	var SUCCESS = 1;

	var regex_escape = /(\\a)|(\\b)|(\\d)|(\\e)|(\\f)|(\\n)|(\\r)|(\\s)|(\\t)|(\\v)|\\x([0-9a-fA-F]+)\\|\\([0-7]+)\\|(\\\\)|(\\')|('')|(\\")|(\\`)|(\\.)|(.)/g;
	var escape_map = {"\\a": 7, "\\b": 8, "\\d": 127, "\\e": 27, "\\f": 12, "\\n": 10, "\\r": 13, "\\s": 32, "\\t": 9, "\\v": 11};
	function escape(str) {
		var stack = [];
		var _error = false;
		str.replace(regex_escape, function(match, a, b, d, e, f, n, r, s, t, v, hex, octal, back, single, dsingle, double, backquote, error, char) {
			switch(true) {
				case hex !== undefined:
					stack.push( parseInt(hex, 16) );
					return "";
				case octal !== undefined:
					stack.push( parseInt(octal, 8) );
					return "";
				case back !== undefined:
				case single !== undefined:
				case dsingle !== undefined:
				case double !== undefined:
				case backquote !== undefined:
					stack.push( codePointAt(match.substr(1),0) );
					return "";
				case char !== undefined:
					stack.push( codePointAt(char,0) );
					return "";
				case error !== undefined:
					_error = true;
				default:
					stack.push(escape_map[match]);
					return "";
			}
		});
		if(_error)
			return null;
		return stack;
	}

	// Escape atoms
	function escapeAtom(str, quote) {
		var atom = '';
		if( str === "\\" ) return null;
		if( str.length < 2 ) return str;
		try {
			str = str.replace(/((?:\\\\)+)|\\([0-7]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 8));
			});
			str = str.replace(/((?:\\\\)+)|\\x([0-9a-fA-F]+)\\/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
			str = str.replace(/((?:\\\\)+)|\\u([0-9a-fA-F]{4})/g, function(match, g1, g2) {
				return g1 || fromCodePoint(parseInt(g2, 16));
			});
		} catch(error) {
			return null;
		}
		for( var i = 0; i < str.length; i++) {
			var a = str.charAt(i);
			var b = str.charAt(i+1);
			if( a === quote && b === quote ) {
				i++;
				atom += quote;
			} else if( a === '\\' ) {
				if( ['a','b','f','n','r','t','v',"'",'"','\\','\a','\b','\f','\n','\r','\t','\v'].indexOf(b) !== -1 ) {
					i += 1;
					switch( b ) {
						case 'a': atom += '\a'; break;
						case 'b': atom += '\b'; break;
						case 'f': atom += '\f'; break;
						case 'n': atom += '\n'; break;
						case 'r': atom += '\r'; break;
						case 't': atom += '\t'; break;
						case 'v': atom += '\v'; break;
						case "'": atom += "'"; break;
						case '"': atom += '"'; break;
						case '\\': atom += '\\'; break;
					}
				} else {
					return null;
				}
			} else {
				atom += a;
			}
		}
		return atom;
	}
	
	// Redo escape
	function redoEscape(str) {
		var atom = '';
		for( var i = 0; i < str.length; i++) {
			switch( str.charAt(i) ) {
				case "'": atom += "\\'"; break;
				case '\\': atom += '\\\\'; break;
				//case '\a': atom += '\\a'; break;
				case '\b': atom += '\\b'; break;
				case '\f': atom += '\\f'; break;
				case '\n': atom += '\\n'; break;
				case '\r': atom += '\\r'; break;
				case '\t': atom += '\\t'; break;
				case '\v': atom += '\\v'; break;
				default: atom += str.charAt(i); break;
			}
		}
		return atom;
	}

	// String to num
	function convertNum(num) {
		var n = num.substr(2);
		switch(num.substr(0,2).toLowerCase()) {
			case "0x":
				return parseInt(n, 16);
			case "0b":
				return parseInt(n, 2);
			case "0o":
				return parseInt(n, 8);
			case "0'":
				return escape(n)[0];
			default:
				return parseFloat(num);
		}
	}

	// Is graphic token
	function is_graphic_token(string) {
		return /^[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+/.test(string);
	}

	// Regular expressions for tokens
	var rules = {
		whitespace: /^\s*(?:(?:%.*)|(?:\/\*(?:\n|\r|.)*?(?:\*\/|$))|(?:\s+))\s*/,
		variable: /^(?:[A-Z_][a-zA-Z0-9_]*)/,
		atom: /^(\!|,|;|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+|'(?:(?:'')|(?:\\\\)|(?:\\')|[^'])*')/,
		number: /^(?:0o[0-7]+|0x[0-9a-fA-F]+|0b[01]+|0'(?:''|\\[abdefnrstv\\'"`]|\\x?\d+\\|[^\\])|\d+(?:\.\d+(?:[eE][+-]?\d+)?)?)/,
		string: /^(?:"([^"]|""|\\")*"|`([^`]|``|\\`)*`)/,
		l_brace: /^(?:\[)/,
		r_brace: /^(?:\])/,
		l_bracket: /^(?:\{)/,
		r_bracket: /^(?:\})/,
		bar: /^(?:\|)/,
		l_paren: /^(?:\()/,
		r_paren: /^(?:\))/
	};

	// Replace chars of char_conversion session
	function replace( thread, text ) {
		if( thread.get_flag( "char_conversion" ).id === "on" ) {
			return text.replace(/./g, function(char) {
				return thread.get_char_conversion( char );
			});
		}
		return text;
	}

	// Tokenize strings
	function Tokenizer(thread) {
		this.thread = thread;
		this.text = ""; // Current text to be analized
		this.tokens = []; // Consumed tokens
	}

	Tokenizer.prototype.set_last_tokens = function(tokens) {
		return this.tokens = tokens;
	};

	Tokenizer.prototype.new_text = function(text) {
		this.text = text;
		this.tokens = [];
	};

	Tokenizer.prototype.get_tokens = function(init) {
		var text;
		var len = 0; // Total length respect to text
		var line = 0;
		var start = 0;
		var tokens = [];
		var last_is_blank;

		if(init) {
			var token = this.tokens[init-1];
			len = token.len;
			text = replace( this.thread, this.text.substr(token.len) );
			line = token.line;
			start = token.start;
		}
		else
			text = this.text;


		// If there is nothing to be analized, return null
		if(/^\s*$/.test(text))
			return null;

		while(text !== "") {
			var matches = [];
			last_is_blank = false;

			if(/^\n/.exec(text) !== null) {
				line++;
				start = 0;
				len++;
				text = text.replace(/\n/, "");
				last_is_blank = true;
				continue;
			}

			for(var rule in rules) {
				if(rules.hasOwnProperty(rule)) {
					var matchs = rules[rule].exec( text );
					if(matchs) {
						matches.push({
							value: matchs[0],
							name: rule,
							matches: matchs
						});
					}
				}
			}

			// Lexical error
			if(!matches.length)
				return this.set_last_tokens( [{ value: text, matches: [], name: "lexical", line: line, start: start }] );

			var token = reduce( matches, function(a, b) {
				return a.value.length >= b.value.length ? a : b;
			} );

			token.start = start;
			token.line = line;

			text = text.replace(token.value, "");
			start += token.value.length;
			len += token.value.length;

			var nl = (token.value.match(/\n/g) || []).length;
			line += nl;
			if(nl > 0) 
				start = token.value.length - token.value.lastIndexOf("\n") - 1;
			token.line_count = line;
			token.line_position = start;

			switch(token.name) {
				case "atom":
					token.raw = token.value;
					if(token.value.charAt(0) === "'") {
						token.value = escapeAtom( token.value.substring(1, token.value.length - 1), "'" );
						if( token.value === null ) {
							token.name = "lexical";
							token.value = token.raw;
							token.error = "unknown_escape_sequence";
						}
					}
					break;
				case "number":
					var substr = token.value.substring(0,2);
					token.raw = token.value;
					token.float = substr !== "0x" && substr !== "0'" && token.value.match(/[.eE]/) !== null;
					token.value = convertNum( token.value );
					token.blank = last_is_blank;
					if(!token.float && pl.flag.bounded.value.indicator === "true/0" && token.value > pl.flag.max_integer.value.value) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "int_overflow";
					}
					break;
				case "string":
					var del = token.value.charAt(0);
					token.raw = token.value;
					token.value = escapeAtom( token.value.substring(1, token.value.length - 1), del );
					if( token.value === null ) {
						token.name = "lexical";
						token.value = token.raw;
						token.error = "unknown_escape_sequence"
					}
					break;
				case "whitespace":
					var last = tokens[tokens.length-1];
					if(last) last.space = true;
					last_is_blank = true;
					continue;
				case "r_bracket":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_bracket" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "{}";
						token.raw = "{}";
						token.space = false;
					}
					break;
				case "r_brace":
					if( tokens.length > 0 && tokens[tokens.length-1].name === "l_brace" ) {
						token = tokens.pop();
						token.name = "atom";
						token.value = "[]";
						token.raw = "[]";
						token.space = false;
					}
					break;
			}
			token.len = len;
			tokens.push( token );
			last_is_blank = false;
		}

		var t = this.set_last_tokens( tokens );
		return t.length === 0 ? null : t;
	};

	// Parse an expression
	function parseExpr(thread, tokens, start, priority, toplevel) {
		if(!tokens[start]) return {type: ERROR, value: pl.error.syntax(tokens[start-1], "expression expected", true)};
		var error;

		if(priority === "0") {
			var token = tokens[start];
			switch(token.name) {
				case "number":
					return {type: SUCCESS, len: start+1, value: new pl.type.Num(token.value, token.float)};
				case "variable":
					return {type: SUCCESS, len: start+1, value: new pl.type.Var(token.value)};
				case "string":
					var str;
					switch( thread.get_flag( "double_quotes" ).id ) {
						case "atom":;
							str = new Term( token.value, [] );
							break;
						case "codes":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Num( codePointAt(token.value,i), false ), str] );
							break;
						case "chars":
							str = new Term( "[]", [] );
							for(var i = token.value.length-1; i >= 0; i-- )
								str = new Term( ".", [new pl.type.Term( token.value.charAt(i), [] ), str] );
							break;
					}
					return {type: SUCCESS, len: start+1, value: str};
				case "l_paren":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_paren") {
						expr.len++;
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], ") or operator expected", !tokens[expr.len])}
				case "l_bracket":
					var expr = parseExpr(thread, tokens, start+1, thread.__get_max_priority(), true);
					if(expr.type !== SUCCESS) return expr;
					if(tokens[expr.len] && tokens[expr.len].name === "r_bracket") {
						expr.len++;
						expr.value = new Term( "{}", [expr.value] );
						return expr;
					}
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[expr.len] ? tokens[expr.len] : tokens[expr.len-1], "} or operator expected", !tokens[expr.len])}
			}
			// Compound term
			var result = parseTerm(thread, tokens, start, toplevel);
			if(result.type === SUCCESS || result.derived)
				return result;
			// List
			result = parseList(thread, tokens, start);
			if(result.type === SUCCESS || result.derived)
				return result;
			// Unexpected
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], token.error || "unexpected token")};
		}

		var max_priority = thread.__get_max_priority();
		var next_priority = thread.__get_next_priority(priority);
		var aux_start = start;
		
		// Prefix operators
		if(tokens[start].name === "atom" && tokens[start+1] && (tokens[start].space || tokens[start+1].name !== "l_paren")) {
			var token = tokens[start++];
			var classes = thread.__lookup_operator_classes(priority, token.value);
			
			// Associative prefix operator
			if(classes && classes.indexOf("fy") > -1) {
				var expr = parseExpr(thread, tokens, start, priority, toplevel);
				if(expr.type !== ERROR) {
					if( token.value === "-" && !token.space && pl.type.is_number( expr.value ) ) {
						return {
							value: new pl.type.Num(-expr.value.value, expr.value.is_float),
							len: expr.len,
							type: SUCCESS
						};
					} else {
						return {
							value: new pl.type.Term(token.value, [expr.value]),
							len: expr.len,
							type: SUCCESS
						};
					}
				} else {
					error = expr;
				}
			// Non-associative prefix operator
			} else if(classes && classes.indexOf("fx") > -1) {
				var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
				if(expr.type !== ERROR) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: expr.len,
						type: SUCCESS
					};
				} else {
					error = expr;
				}
			}
		}

		start = aux_start;
		var expr = parseExpr(thread, tokens, start, next_priority, toplevel);
		if(expr.type === SUCCESS) {
			start = expr.len;
			var token = tokens[start];
			if(tokens[start] && (
				tokens[start].name === "atom" && thread.__lookup_operator_classes(priority, token.value) ||
				tokens[start].name === "bar" && thread.__lookup_operator_classes(priority, "|")
			) ) {
				var next_priority_lt = next_priority;
				var next_priority_eq = priority;
				var classes = thread.__lookup_operator_classes(priority, token.value);

				if(classes.indexOf("xf") > -1) {
					return {
						value: new pl.type.Term(token.value, [expr.value]),
						len: ++expr.len,
						type: SUCCESS
					};
				} else if(classes.indexOf("xfx") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_lt, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(classes.indexOf("xfy") > -1) {
					var expr2 = parseExpr(thread, tokens, start + 1, next_priority_eq, toplevel);
					if(expr2.type === SUCCESS) {
						return {
							value: new pl.type.Term(token.value, [expr.value, expr2.value]),
							len: expr2.len,
							type: SUCCESS
						};
					} else {
						expr2.derived = true;
						return expr2;
					}
				} else if(expr.type !== ERROR) {
					while(true) {
						start = expr.len;
						var token = tokens[start];
						if(token && token.name === "atom" && thread.__lookup_operator_classes(priority, token.value)) {
							var classes = thread.__lookup_operator_classes(priority, token.value);
							if( classes.indexOf("yf") > -1 ) {
								expr = {
									value: new pl.type.Term(token.value, [expr.value]),
									len: ++start,
									type: SUCCESS
								};
							} else if( classes.indexOf("yfx") > -1 ) {
								var expr2 = parseExpr(thread, tokens, ++start, next_priority_lt, toplevel);
								if(expr2.type === ERROR) {
									expr2.derived = true;
									return expr2;
								}
								start = expr2.len;
								expr = {
									value: new pl.type.Term(token.value, [expr.value, expr2.value]),
									len: start,
									type: SUCCESS
								};
							} else { break; }
						} else { break; }
					}
				}
			} else {
				error = {type: ERROR, value: pl.error.syntax(tokens[expr.len-1], "operator expected")};
			}
			return expr;
		}
		return expr;
	}

	// Parse a compound term
	function parseTerm(thread, tokens, start, toplevel) {
		if(!tokens[start] || (tokens[start].name === "atom" && tokens[start].raw === "." && !toplevel && (tokens[start].space || !tokens[start+1] || tokens[start+1].name !== "l_paren")))
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "unfounded token")};
		var atom = tokens[start];
		var exprs = [];
		if(tokens[start].name === "atom" && tokens[start].raw !== ",") {
			start++;
			if(tokens[start-1].space) return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
			if(tokens[start] && tokens[start].name === "l_paren") {
				if(tokens[start+1] && tokens[start+1].name === "r_paren") 
					return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1], "argument expected")};
				var expr = parseExpr(thread, tokens, ++start, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], "argument expected", !tokens[start])};
				}
				exprs.push(expr.value);
				start = expr.len;
				while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
					expr = parseExpr(thread, tokens, start+1, "999", true);
					if(expr.type === ERROR) {
						if( expr.derived )
							return expr;
						else
							return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
					}
					exprs.push(expr.value);
					start = expr.len;
				}
				if(tokens[start] && tokens[start].name === "r_paren") start++;
				else return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ", or ) expected", !tokens[start])};
			}
			return {type: SUCCESS, len: start, value: new pl.type.Term(atom.value, exprs)};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "term expected")};
	}

	// Parse a list
	function parseList(thread, tokens, start) {
		if(!tokens[start]) 
			return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start-1], "[ expected")};
		if(tokens[start] && tokens[start].name === "l_brace") {
			var expr = parseExpr(thread, tokens, ++start, "999", true);
			var exprs = [expr.value];
			var cons = undefined;

			if(expr.type === ERROR) {
				if(tokens[start] && tokens[start].name === "r_brace") {
					return {type: SUCCESS, len: start+1, value: new pl.type.Term("[]", [])};
				}
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start], "] expected")};
			}
			
			start = expr.len;

			while(tokens[start] && tokens[start].name === "atom" && tokens[start].value === ",") {
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				exprs.push(expr.value);
				start = expr.len;
			}
			var bar = false
			if(tokens[start] && tokens[start].name === "bar") {
				bar = true;
				expr = parseExpr(thread, tokens, start+1, "999", true);
				if(expr.type === ERROR) {
					if( expr.derived )
						return expr;
					else
						return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start+1] ? tokens[start+1] : tokens[start], "argument expected", !tokens[start+1])};
				}
				cons = expr.value;
				start = expr.len;
			}
			if(tokens[start] && tokens[start].name === "r_brace")
				return {type: SUCCESS, len: start+1, value: arrayToList(exprs, cons) };
			else
				return {type: ERROR, derived: true, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], bar ? "] expected" : ", or | or ] expected", !tokens[start])};
		}
		return {type: ERROR, derived: false, value: pl.error.syntax(tokens[start], "list expected")};
	}

	// Parse a rule
	function parseRule(thread, tokens, start) {
		var line = tokens[start].line;
		var expr = parseExpr(thread, tokens, start, thread.__get_max_priority(), false);
		var rule = null;
		var obj;
		if(expr.type !== ERROR) {
			start = expr.len;
			if(tokens[start] && tokens[start].name === "atom" && tokens[start].raw === ".") {
				start++;
				if( pl.type.is_term(expr.value) ) {
					if(expr.value.indicator === ":-/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					} else if(expr.value.indicator === "-->/2") {
						rule = new pl.type.Rule(expr.value.args[0], body_conversion(expr.value.args[1]));
						rule = rule_to_dcg(rule, thread);
						rule.body = body_conversion(rule.body);
						if(!pl.type.is_rule(rule))
							return {
								value: rule,
								len: start,
								type: ERROR
							};
						obj = {
							value: rule,
							len: start,
							type: pl.type.is_rule( rule ) ? SUCCESS : ERROR
						};
					} else {
						rule = new pl.type.Rule(expr.value, null);
						obj = {
							value: rule,
							len: start,
							type: SUCCESS
						};
					}
					if( rule ) {
						var singleton = rule.singleton_variables();
						if( singleton.length > 0 )
							thread.throw_warning( pl.warning.singleton( singleton, rule.head.indicator, line ) );
					}
					return obj;
				} else {
					return { type: ERROR, value: pl.error.syntax(tokens[start], "callable expected") };
				}
			} else {
				return { type: ERROR, value: pl.error.syntax(tokens[start] ? tokens[start] : tokens[start-1], ". or operator expected") };
			}
		}
		return expr;
	}

	// Parse a program
	function parseProgram(thread, string, options) {
		var opts = {};
		options = options ? options : {};
		opts.success = options.success ? options.success : function(){};
		opts.error = options.error ? options.error : function(){};
		opts.from = options.from ? options.from : "$tau-js";
		opts.reconsult = options.reconsult !== undefined ? options.reconsult : true;
		opts.reconsulted = options.reconsulted === undefined ? {} : options.reconsulted;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.initialization = options.initialization === undefined ? [] : options.initialization;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.tokens = options.tokens === undefined ? null : options.tokens;
		opts.string = string;
		opts.term_expansion = false;
		var reconsulted = opts.reconsulted;
		var tokenizer = opts.tokenizer;
		var tokens = opts.tokens;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			tokenizer.new_text(string);
			opts.tokenizer = tokenizer;
			tokens = tokenizer.get_tokens(0);
			opts.tokens = tokens;
		}
		var n = opts.current_token;
		while(tokens !== null && tokens[n]) {
			var expr = parseRule(thread, tokens, n);
			opts.current_token = expr.len;
			if(expr.type === ERROR) {
				if(opts.error !== undefined)
				opts.error(new Term("throw", [expr.value]));
				return;
			} else {
				// Term expansion
				var context_module = opts.context_module;
				var term_expansion = thread.session.modules[context_module].rules["term_expansion/2"];
				if(term_expansion && term_expansion.length > 0) {
					opts.term_expansion = true;
					var n_thread = new Thread(thread.session);
					var term = expr.value.body ? new Term(":-", [expr.value.head, expr.value.body]) : expr.value.head;
					thread.session.renamed_variables = {};
					term = term.rename(thread.session);
					n_thread.query(context_module + ":term_expansion(" + term.toString({quoted: true}) + ", X).");
					n_thread.answer((function(thread, opts, reconsulted, expr) {
						return function(answer) {
							if(answer && !pl.type.is_error(answer) && pl.type.is_term(answer.links['X'])) {
								var term = answer.links['X'];
								var rule = term.indicator === ":-/2" ? new Rule(term.args[0], term.args[1]) : new Rule(term, null);
								parseProgramExpansion(thread, opts, reconsulted, {value: rule, len: expr.len, type: expr.type});
							} else {
								parseProgramExpansion(thread, opts, reconsulted, expr);
							}
						}
					})(thread, opts, reconsulted, expr));
					return;
				} else {
					opts.term_expansion = false;
					var async = parseProgramExpansion(thread, opts, reconsulted, expr);
					if(async)
						return;
					n = expr.len;
				}
			}
		}
		// run goals from initialization/1 directive
		var callback = opts.success;
		var nthread = new Thread(thread.session);
		for(var i = opts.initialization.length-1; i > 0; i--) {
			var next_callback = (function(init, callback) {
				return function(answer) {
					if(answer === null) {
						nthread.answer();
					} else if(pl.type.is_error(answer)) {
						opts.error(answer);
					} else {
						nthread.add_goal(init);
						nthread.answer(callback);
					}
				};
			})(opts.initialization[i], callback);
			callback = next_callback;
		}
		if(opts.initialization.length > 0) {
			nthread.add_goal(opts.initialization[0]);
			nthread.answer(callback);
		} else {
			callback();
		}
	}

	function parseGoalExpansion(thread, options, expr) {
		var n_thread = new Thread( thread.session );
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var varhead = thread.next_free_variable();
		var goal = varhead + " = " + expr.value.head + ", goal_expansion(" + expr.value.body.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				expr.value.head = answer.links[varhead];
				expr.value.body = body_conversion(answer.links[varterm]);
				parseGoalExpansion(thread, options, expr);
			} else {
				thread.add_rule(expr.value, options);
				parseProgram(thread, options.string, options);
			}
		});
	}

	function parseQueryExpansion(thread, term, options) {
		var n_thread = new Thread(thread.session);
		n_thread.__goal_expansion = true;
		var varterm = thread.next_free_variable();
		var goal = "goal_expansion(" + term.toString({
			quoted: true
		}) + ", " + varterm.toString({
			quoted: true
		}) + ").";
		n_thread.query(goal);
		var variables = n_thread.head_point().substitution.domain();
		n_thread.answer(function(answer) {
			if(answer && !pl.type.is_error(answer) && answer.links[varterm]) {
				for(var i = 0; i < variables.length; i++) {
					if(variables[i] !== varterm.id && answer.links[variables[i]]) {
						var subs = new Substitution();
						subs.links[answer.links[variables[i]]] = variables[i];
						answer.links[varterm] = answer.links[varterm].apply( subs );
					}
				}
				parseQueryExpansion(thread, body_conversion(answer.links[varterm]), options);
			} else {
				thread.add_goal(term);
				options.success(term);
				parseQuery(thread, options.string, options);
			}
		});
	}

	function parseProgramExpansion(thread, options, reconsulted, expr) {
		var async = options.term_expansion === true;
		if(expr.value.body === null && expr.value.head.indicator === "?-/1") {
			async = true;
			var n_thread = new Thread(thread.session);
			n_thread.add_goal(expr.value.head.args[0]);
			n_thread.answer(function(answer) {
				if(pl.type.is_error(answer)) {
					thread.throw_warning(answer.args[0]);
				} else if(answer === false || answer === null) {
					thread.throw_warning(pl.warning.failed_goal(expr.value.head.args[0], expr.len));
				}
				parseProgram(thread, options.string, options);
			});
		} else if(expr.value.body === null && expr.value.head.indicator === ":-/1") {
			var result = thread.run_directive(expr.value.head.args[0], options);
			async = async || (result === true);
			if(async)
				parseProgram(thread, options.string, options);
		} else {
			var context_module = options.context_module;
			var indicator = expr.value.head.indicator;
			if(expr.value.head.indicator === ":/2") {
				context_module = expr.value.head.args[0].id;
				indicator = expr.value.head.args[1].indicator;
			}
			if(!reconsulted.hasOwnProperty(context_module))
				reconsulted[context_module] = {};
			if(options.reconsult !== false && reconsulted[context_module][indicator] !== true && !thread.is_multifile_predicate(indicator)) {
				var get_module = thread.session.modules[context_module];
				if(context_module !== "system" && get_module && get_module.rules[indicator]) {
					get_module.rules[indicator] = filter(get_module.rules[indicator], function(rule) {
						return rule.dynamic;
					});
					get_module.update_indices_predicate(indicator);
				}
				reconsulted[context_module][indicator] = true;
			}
			var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
			if(expr.value.body !== null && goal_expansion && goal_expansion.length > 0) {
				async = true;
				thread.session.renamed_variables = {};
				var origin = {
					head: function() { return expr.value.head; },
					term: function() { return expr.value.body; },
					set: function(h, p){
						expr.value.head = h;
						expr.value.body = p;
					}
				};
				parseGoalExpansion(thread, options, expr, body_conversion(expr.value.body), origin.set, origin);
			} else {
				thread.add_rule(expr.value, options);
				if(async)
					parseProgram(thread, options.string, options);
			}
		}
		return async;
	}
	
	// Parse a query
	function parseQuery(thread, string, options) {
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		opts.tokenizer = options.tokenizer === undefined ? null : options.tokenizer;
		opts.current_token = options.current_token === undefined ? 0 : options.current_token;
		opts.string = string;
		var tokenizer = opts.tokenizer;
		var n = opts.current_token;
		if(tokenizer === null) {
			tokenizer = new Tokenizer(thread);
			opts.tokenizer = tokenizer;
			tokenizer.new_text(string);
		}
		do {
			var tokens = tokenizer.get_tokens(n);
			if(tokens === null)
				break;
			var expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
			if(expr.type !== ERROR) {
				var expr_position = expr.len;
				n = expr.len + 1;
				opts.current_token = n;
				if(tokens[expr_position] && tokens[expr_position].name === "atom" && tokens[expr_position].raw === ".") {
					expr.value = body_conversion(expr.value);
					// Goal expansion
					var goal_expansion = thread.session.modules.user.rules["goal_expansion/2"];
					if(!thread.__goal_expansion && goal_expansion && goal_expansion.length > 0) {
						parseQueryExpansion(thread, expr.value, opts);
						return;
					} else {
						thread.add_goal(expr.value);
						opts.success(expr.value);
					}
				} else {
					var token = tokens[expr_position];
					opts.error(
						new Term("throw", [
							pl.error.syntax(
								token ? token : tokens[expr_position-1],
								token && token.error ? token.error : ". or operator expected",
								!token
							)
						])
					);
					return;
				}
			} else {
				opts.error(new Term("throw", [expr.value]));
				return;
			}
		} while(true);
	}


	
	// UTILS

	// Rule to DCG
	function rule_to_dcg(rule, thread) {
		thread.session.renamed_variables = {};
		rule = rule.rename(thread);
		var begin = thread.next_free_variable();
		var dcg = body_to_dcg( rule.body, begin, thread );
		if( dcg.error )
			return dcg.value;
		rule.body = dcg.value;
		// push-back lists
		if(rule.head.indicator === ",/2") {
			var terminals = rule.head.args[1];
			rule.head = rule.head.args[0];
			var last = thread.next_free_variable();
			var pointer = terminals;
			if(!pl.type.is_list(pointer)) {
				return pl.error.type("list", pointer, "DCG/0");
			}
			if(pointer.indicator === "[]/0") {
				terminals = dcg.variable;
			} else {
				while(pointer.indicator === "./2" && pl.type.is_list(pointer) && pointer.args[1].indicator !== "[]/0") {
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer))
					return pl.error.instantiation("DCG/0");
				else if(!pl.type.is_list(pointer))
					return pl.error.type("list", terminals, "DCG/0");
				pointer.args[1] = dcg.variable;
			}
			rule.body = new Term(",", [rule.body, new Term("=", [last, terminals])]);
			rule.head = new Term(rule.head.id, rule.head.args.concat([begin, last]));
		} else {
			// replace first assignment
			var first_assign = rule.body;
			if(pl.type.is_term(first_assign) && first_assign.indicator === ",/2")
				first_assign = first_assign.args[0];
			if(pl.type.is_term(first_assign) && first_assign.indicator === "=/2" &&
			   pl.type.is_variable(first_assign.args[0]) && first_assign.args[0] === begin) {
				begin = first_assign.args[1];
				rule.body = rule.body.replace(null);
			}
			// add first and last variables to the head
			if(rule.head.indicator === ":/2")
				rule.head = new Term(":", [
					new Term(rule.head.args[0].id, []),
					new Term(rule.head.args[1].id, rule.head.args[1].args.concat([begin, dcg.variable]))
				]);
			else
				rule.head = new Term(rule.head.id, rule.head.args.concat([begin, dcg.variable]));
		}
		return rule;
	}

	// Body to DCG
	function body_to_dcg(expr, last, thread) {
		var free;
		if( pl.type.is_term( expr ) && expr.indicator === "!/0" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr, new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ":/2" ) {
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(":", [expr.args[0], right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "\\+/1" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			free = thread.next_free_variable();
			return {
				value: new Term(",", [new Term(expr.id, [left.value]), new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_term( expr ) && (expr.indicator === ",/2" || expr.indicator === "->/2") ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], left.variable, thread);
			if( right.error ) return right;
			return {
				value: new Term(expr.id, [left.value, right.value]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === ";/2" ) {
			var left = body_to_dcg(expr.args[0], last, thread);
			if( left.error ) return left;
			var right = body_to_dcg(expr.args[1], last, thread);
			if( right.error ) return right;
			return {
				value: new Term(",", [new Term(";", [left.value, right.value]), new Term("=", [left.variable, right.variable])]),
				variable: right.variable,
				error: false
			};
		} else if( pl.type.is_term( expr ) && expr.indicator === "{}/1" ) {
			free = thread.next_free_variable();
			return {
				value: new Term(",", [expr.args[0], new Term("=", [last, free])]),
				variable: free,
				error: false
			};
		} else if( pl.type.is_empty_list( expr ) ) {
			return {
				value: new Term("true", []),
				variable: last,
				error: false
			};
		} else if( pl.type.is_list( expr ) ) {
			free = thread.next_free_variable();
			var pointer = expr;
			var prev;
			while( pointer.indicator === "./2" ) {
				prev = pointer;
				pointer = pointer.args[1];
			}
			if( pl.type.is_variable( pointer ) ) {
				return {
					value: pl.error.instantiation("DCG/0"),
					variable: last,
					error: true
				};
			} else if( !pl.type.is_empty_list( pointer ) ) {
				return {
					value: pl.error.type("list", expr, "DCG/0"),
					variable: last,
					error: true
				};
			} else {
				prev.args[1] = free;
				return {
					value: new Term("=", [last, expr]),
					variable: free,
					error: false
				};
			}
		} else if( pl.type.is_callable( expr ) ) {
			free = thread.next_free_variable();
			expr = new Term( expr.id, expr.args.concat([last,free]) );
			return {
				value: expr,
				variable: free,
				error: false
			};
		} else {
			return {
				value: pl.error.type( "callable", expr, "DCG/0" ),
				variable: last,
				error: true
			};
		}
	}
	
	// Body conversion
	function body_conversion( expr ) {
		if( pl.type.is_variable( expr ) )
			return new Term( "call", [expr] );
		else if( pl.type.is_term( expr ) && [",/2", ";/2", "->/2"].indexOf(expr.indicator) !== -1 )
			return new Term( expr.id, [body_conversion( expr.args[0] ), body_conversion( expr.args[1] )] );
		else if( pl.type.is_term(expr) && expr.indicator === ":/2" ) {
			var body = body_conversion(expr.args[1]);
			return new Term(":", [expr.args[0], body]);
		}
		return expr;
	}
	
	// List to Prolog list
	function arrayToList( array, cons ) {
		var list = cons ? cons : new Term( "[]", [] );
		for(var i = array.length-1; i >= 0; i-- )
			list = new Term( ".", [array[i], list] );
		return list;
	}

	// Array difference
	function difference(xs, ys) {
		var zs = [];
		for(var i = 0; i < xs.length; i++) {
			if(indexOf(zs, xs[i]) === -1 && indexOf(ys, xs[i]) === -1)
				zs.push(xs[i]);
		}
		return zs;
	}
	
	// Remove element from array
	function remove( array, element ) {
		for( var i = array.length - 1; i >= 0; i-- ) {
			if( array[i] === element ) {
				array.splice(i, 1);
			}
		}
	}
	
	// Remove duplicate elements
	function nub( array ) {
		var seen = {};
		var unique = [];
		for( var i = 0; i < array.length; i++ ) {
			if( !(array[i] in seen) ) {
				unique.push( array[i] );
				seen[array[i]] = true;
			}
		}
		return unique;
	}

	// Retract a rule
	function retract(thread, point, indicator, rule, get_module) {
		if(get_module.rules[indicator]) {
			for(var i = 0; i < get_module.rules[indicator].length; i++) {
				if(get_module.rules[indicator][i] === rule) {
					get_module.rules[indicator].splice(i, 1);
					get_module.update_indices_predicate(indicator);
					thread.success( point );
					break;
				}
			}
		}
	}
	
	// call/n
	function callN(n) {
		return function(thread, point, atom) {
			var closure = atom.args[0], args = atom.args.slice(1, n);
			var module_atom;
			if(pl.type.is_term(closure) && closure.indicator === ":/2") {
				if(!pl.type.is_atom(closure.args[0])) {
					thread.throw_error(pl.error.type("module", closure.args[0], atom.indicator));
					return;
				}
				module_atom = closure.args[0];
				closure = closure.args[1];
			}
			if(pl.type.is_variable(closure)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(closure)) {
				thread.throw_error(pl.error.type("callable", closure, atom.indicator));
			} else {
				var goal = body_conversion(new Term(closure.id, closure.args.concat(args)));
				if(!pl.type.is_callable(goal)) {
					thread.throw_error(pl.error.type("callable", goal, atom.indicator));
					return;
				}
				if(module_atom)
					goal = new Term(":", [module_atom, goal]);
				thread.prepend([new State(point.goal.replace(goal), point.substitution, point)]);
			}
		};
	}
	
	// String to indicator
	function str_indicator( str ) {
		for( var i = str.length - 1; i >= 0; i-- )
			if( str.charAt(i) === "/" )
				return new Term( "/", [new Term( str.substring(0, i) ), new Num( parseInt(str.substring(i+1)), false )] );
	}

	// Greatest common divisor
	function gcd(a, b) {
		if(b === 0)
			return a;
		return Math.abs(gcd(b, a % b));
	}
	
	

	// PROLOG OBJECTS
	
	// Variables
	function Var( id ) {
		this.id = id;
		this.ground = false;
	}
	
	// Numbers
	function Num( value, is_float ) {
		this.is_float = is_float !== undefined ? is_float : Math.trunc(value) !== value;
		this.value = this.is_float ? value : Math.trunc(value);
		this.index = this.value;
		this.ground = true;
	}
	
	// Terms
	var term_ref = 0;
	function Term( id, args, ref ) {
		term_ref++;
		this.ref = ref || term_ref;
		this.id = id;
		this.args = args || [];
		this.indicator = id + "/" + this.args.length;
		this.index = this.indicator;
		this.ground = true;
		for(var i = 0; i < this.args.length; i++) {
			if(this.args[i].hasOwnProperty("ground") && this.args[i].ground === false) {
				this.ground = false;
				break;
			}
		}
	}

	// Streams
	var stream_ref = 0;
	function Stream( stream, mode, alias, type, reposition, eof_action ) {
		this.id = stream_ref++;
		this.stream = stream;
		this.mode = mode; // "read" or "write" or "append"
		this.alias = alias;
		this.type = type !== undefined ? type : "text"; // "text" or "binary"
		this.reposition = reposition !== undefined ? reposition : true; // true or false
		this.eof_action = eof_action !== undefined ? eof_action : "eof_code"; // "error" or "eof_code" or "reset"
		this.position = this.mode === "append" ? "end_of_stream" : 0;
		this.output = this.mode === "write" || this.mode === "append";
		this.input = this.mode === "read";
		this.line_position = 0;
		this.line_count = 1;
		this.char_count = 0;
	}
	
	// Substitutions
	function Substitution( links, attrs ) {
		links = links || {};
		attrs = attrs || {};
		this.links = links;
		this.attrs = attrs;
	}
	
	// States
	function State( goal, subs, parent ) {
		subs = subs || new Substitution();
		parent = parent || null;
		this.goal = goal;
		this.substitution = subs;
		this.parent = parent;
	}
	
	// Rules
	function Rule( head, body, dynamic ) {
		this.head = head;
		this.body = body;
		this.dynamic = dynamic ? dynamic : false;
	}

	// Session
	function Session( limit ) {
		limit = typeof limit === "number" && limit > 0 ? limit : null;
		this.rename = 0;
		this.modules = {};
		this.modules.user = new Module("user", {}, "all", {
			session: this,
			dependencies: ["system"]
		});
		this.modules.system = pl.modules.system;
		this.rules = this.modules.user.rules;
		this.total_threads = 0;
		this.renamed_variables = {};
		this.public_predicates = this.modules.user.public_predicates;
		this.multifile_predicates = this.modules.user.multifile_predicates;
		this.limit = limit;
		this.streams = {
			"user_input": new Stream(
				nodejs_flag ? nodejs_user_input : tau_user_input,
				"read", "user_input", "text", false, "reset" ),
			"user_output": new Stream(
				nodejs_flag ? nodejs_user_output : tau_user_output,
				"append", "user_output", "text", false, "reset" ),
			"user_error": new Stream(
				nodejs_flag ? nodejs_user_error : tau_user_error,
				"append", "user_error", "text", false, "reset" ),
		};
		this.file_system = nodejs_flag ? nodejs_file_system : tau_file_system;
		this.standard_input = this.streams["user_input"];
		this.standard_output = this.streams["user_output"];
		this.standard_error = this.streams["user_error"];
		this.current_input = this.streams["user_input"];
		this.current_output = this.streams["user_output"];
		this.working_directory = "/"; // only for browser
		this.format_success = function( state ) { return state.substitution; };
		this.format_error = function( state ) { return state.goal; };
		this.flag = {	
			bounded: pl.flag.bounded.value,
			max_integer: pl.flag.max_integer.value,
			min_integer: pl.flag.min_integer.value,
			integer_rounding_function: pl.flag.integer_rounding_function.value,
			char_conversion: pl.flag.char_conversion.value,
			debug: pl.flag.debug.value,
			max_arity: pl.flag.max_arity.value,
			unknown: pl.flag.unknown.value,
			double_quotes: pl.flag.double_quotes.value,
			occurs_check: pl.flag.occurs_check.value,
			dialect: pl.flag.dialect.value,
			version_data: pl.flag.version_data.value,
			nodejs: pl.flag.nodejs.value,
			argv: pl.flag.argv.value
		};
		this.__loaded_modules = [];
		this.__char_conversion = {};
		this.__operators = {
			1200: { ":-": ["fx", "xfx"],  "-->": ["xfx"], "?-": ["fx"] },
			1150: { "meta_predicate": ["fx"] },
			1100: { ";": ["xfy"] },
			1050: { "->": ["xfy"], "*->": ["xfy"] },
			1000: { ",": ["xfy"] },
			900: { "\\+": ["fy"] },
			700: {
				"=": ["xfx"], "\\=": ["xfx"], "==": ["xfx"], "\\==": ["xfx"],
				"@<": ["xfx"], "@=<": ["xfx"], "@>": ["xfx"], "@>=": ["xfx"],
				"=..": ["xfx"], "is": ["xfx"], "=:=": ["xfx"], "=\\=": ["xfx"],
				"<": ["xfx"], "=<": ["xfx"], ">": ["xfx"], ">=": ["xfx"]
			},
			600: { ":": ["xfy"] },
			500: { "+": ["yfx"], "-": ["yfx"], "/\\": ["yfx"], "\\/": ["yfx"] },
			400: {
				"*": ["yfx"], "/": ["yfx"], "//": ["yfx"], "rem": ["yfx"],
				"mod": ["yfx"], "<<": ["yfx"], ">>": ["yfx"], "div": ["yfx"]
			},
			200: { "**": ["xfx"], "^": ["xfy"], "-": ["fy"], "+": ["fy"], "\\": ["fy"] }
		};
		this.thread = new Thread( this );
	}
	
	// Threads
	function Thread( session ) {
		this.epoch = Date.now();
		this.session = session;
		this.session.total_threads++;
		this.format_success = session.format_success;
		this.format_error = session.format_error;
		this.total_steps = 0;
		this.cpu_time = 0;
		this.points = [];
		this.debugger = false;
		this.debugger_states = [];
		this.level = new Term("top_level");
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
		this.warnings = [];
		this.__calls = [];
		this.__goal_expansion = false;
		this.__stacks = {};
	}
	
	// Modules
	function Module(id, rules, exports, options) {
		options = options === undefined ? {} : options;
		options.public_predicates = options.public_predicates === undefined ? {} : options.public_predicates;
		options.multifile_predicates = options.multifile_predicates === undefined ? {} : options.multifile_predicates;
		options.meta_predicates = options.meta_predicates === undefined ? {} : options.meta_predicates;
		options.session = options.session === undefined ? null : options.session;
		options.dependencies = options.dependencies === undefined ? [] : options.dependencies;
		this.id = id;
		this.rules = rules;
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		this.public_predicates = options.public_predicates;
		this.multifile_predicates = options.multifile_predicates;
		this.meta_predicates = options.meta_predicates;
		this.src_predicates = {};
		this.dependencies = options.dependencies;
		this.exports = exports;
		this.is_library = options.session === null;
		this.modules = {};
		if(options.session) {
			options.session.modules[id] = this;
			for(var i = 0; i < options.dependencies.length; i++) {
				var lib = options.dependencies[i];
				if(!options.session.modules.hasOwnProperty(lib))
					options.session.modules[lib] = pl.modules[lib];
			}
		} else {
			pl.modules[id] = this;
		}
		if(exports !== "all") {
			for(var i = 0; i < exports.length; i++) {
				this.public_predicates[exports[i]] =
					options.public_predicates.hasOwnProperty(exports[i]) &&
					options.public_predicates[exports[i]] === true;
			}
		}
		this.update_indices_clauses();
	}
	
	// Check if a predicate is exported
	Module.prototype.exports_predicate = function(indicator) {
		return this.exports === "all" || indexOf(this.exports, indicator) !== -1;
	};

	// Check if a predicate is public
	Module.prototype.is_public_predicate = function(indicator) {
		return !this.public_predicates.hasOwnProperty(indicator) || this.public_predicates[indicator] === true;
	};
	
	// Check if a predicate is multifile
	Module.prototype.is_multifile_predicate = function( indicator ) {
		return this.multifile_predicates.hasOwnProperty(indicator) && this.multifile_predicates[indicator] === true;
	};

	// Check if a predicate is a meta-predicate
	Module.prototype.is_meta_predicate = function( indicator ) {
		if(this.meta_predicates.hasOwnProperty(indicator))
			return this.meta_predicates[indicator];
		return null;
	};

	// Update indices of all predicates
	Module.prototype.update_indices_clauses = function() {
		this.indexed_clauses = {};
		this.non_indexable_clauses = {};
		for(var indicator in this.rules)
			this.update_indices_predicate(indicator);
	};

	// Update indices of a predicate
	Module.prototype.update_indices_predicate = function(indicator) {
		this.indexed_clauses[indicator] = {};
		this.non_indexable_clauses[indicator] = [];
		if(!Array.isArray(this.rules[indicator]))
			return;
		for(var i = 0; i < this.rules[indicator].length; i++) {
			var clause = this.rules[indicator][i];
			this.add_index_predicate(clause);
		}
	};

	// Add indexed cluuse to a predicate
	Module.prototype.add_index_predicate = function(clause) {
		var indicator = clause.head.indicator;
		var index = clause.head.args.length > 0 ? clause.head.args[0].index : undefined;
		if(index) {
			if(!this.indexed_clauses.hasOwnProperty(indicator))
				this.indexed_clauses[indicator] = {};
			if(!this.indexed_clauses[indicator].hasOwnProperty(index)) {
				this.indexed_clauses[indicator][index] = [];
				if(this.non_indexable_clauses.hasOwnProperty(indicator))
					for(var j = 0; j < this.non_indexable_clauses[indicator].length; j++)
						this.indexed_clauses[indicator][index].push(this.non_indexable_clauses[indicator][j]);
			}
			this.indexed_clauses[indicator][index].push(clause);
		} else {
			if(!this.non_indexable_clauses.hasOwnProperty(indicator))
				this.non_indexable_clauses[indicator] = [];
			this.non_indexable_clauses[indicator].push(clause);
			for(var index in this.indexed_clauses[indicator])
				this.indexed_clauses[indicator][index].push(clause);
		}
	};



	// UNIFY PROLOG OBJECTS

	// Variables
	Var.prototype.unify = function(obj, occurs_check) {
		if(occurs_check && indexOf(obj.variables(), this.id) !== -1 && !pl.type.is_variable(obj))
			return null;
		var links = {};
		links[this.id] = obj;
		return new Substitution(links);
	};

	// Numbers
	Num.prototype.unify = function(obj, occurs_check) {
		if(pl.type.is_number(obj) && this.value === obj.value && this.is_float === obj.is_float)
			return new Substitution();
		return null;
	};

	// Terms
	Term.prototype.unify = function(obj, occurs_check) {
		if(!pl.type.is_term(obj) && obj.unify !== undefined) {
			return obj.unify(this, occurs_check);
		} else if(pl.type.is_term(obj) && this.indicator === obj.indicator) {
			var subs = new Substitution();
			for(var i = 0; i < this.args.length; i++) {
				var mgu = pl.unify(this.args[i].apply(subs), obj.args[i].apply(subs), occurs_check);
				if(mgu === null)
					return null;
				for(var x in mgu.links)
					subs.links[x] = mgu.links[x];
				subs = subs.apply(mgu);
			}
			return subs;
		}
		return null;
	};

	// Streams
	Stream.prototype.unify = function(obj, _occurs_check) {
		if(pl.type.is_stream(obj) && this.id === obj.id)
			return new Substitution();
		return null;
	};

	Stream.prototype.compare = function(obj) {
		if(this.id < obj.id)
			return -1;
		else if(this.id === obj.id)
			return 0;
		else
			return 1;
	};
	
	

	// PROLOG OBJECTS TO STRING
	
	// Variables
	Var.prototype.toString = function( options ) {
		options = options === undefined ? {} : options;
		if(options.variable_names) {
			var pointer = options.variable_names;
			while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
				var head = pointer.args[0];
				if(pl.type.is_term(head) && head.indicator === "=/2"
				&& pl.type.is_variable(head.args[1]) && head.args[1].id === this.id
				&& pl.type.is_atom(head.args[0]))
					return head.args[0].id;
				pointer = pointer.args[1];
			}
		}
		return this.id;
	};
	
	// Numbers
	Num.prototype.toString = function( _ ) {
		var str = this.value.toString();
		var e = str.indexOf("e");
		if(e !== -1) {
			if(str.indexOf(".") !== -1)
				return str;
			else
				return str.replace("e", ".0e");
		}
		return this.is_float && indexOf(str, ".") === -1 ? this.value + ".0" : str;
	};
	
	// Terms
	Term.prototype.toString = function( options, priority, from ) {
		options = !options ? {} : options;
		options.quoted = options.quoted === undefined ? false: options.quoted;
		options.ignore_ops = options.ignore_ops === undefined ? false : options.ignore_ops;
		options.numbervars = options.numbervars === undefined ? false : options.numbervars;
		options.variable_names = options.variable_names === undefined ? false : options.variable_names;
		priority = priority === undefined ? {priority: 1200, class: "", indicator: ""} : priority;
		from = from === undefined ? "" : from;
		var arg_priority = {priority: 999, class: "", indicator: ""};
		if( options.numbervars && this.indicator === "$VAR/1" && pl.type.is_integer( this.args[0] ) && this.args[0].value >= 0 ) {
			var i = this.args[0].value;
			var number = Math.floor( i/26 );
			var letter =  i % 26;
			return "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[letter] + (number !== 0 ? number : "");
		}
		switch( this.indicator ){
			case "[]/0":
			case "{}/0":
			case "!/0":
				return this.id;
			case "{}/1":
				if( options.ignore_ops === false ) {
					return "{" + this.args[0].toString( options ) + "}";
				} else {
					return "{}(" + this.args[0].toString( options ) + ")";
				}
			case "./2":
				if( options.ignore_ops === false ) {
					var list = "[" + this.args[0].toString( options, arg_priority );
					var pointer = this.args[1];
					while( pointer.indicator === "./2" ) {
						list += "," + pointer.args[0].toString( options, arg_priority );
						pointer = pointer.args[1];
					}
					if( pointer.indicator !== "[]/0" ) {
						list += "|" + pointer.toString( options, arg_priority );
					}
					list += "]";
					return list;
				}
			default:
				var id = this.id;
				var operator = options.session ? options.session.lookup_operator( this.id, this.args.length ) : null;
				if( options.session === undefined || options.ignore_ops || operator === null ) {
					if( options.quoted && (! /^(!|[a-z][0-9a-zA-Z_]*|[#\$\&\*\+\-\.\/\:\<\=\>\?\@\^\~\\]+)$/.test( id ) && id !== "{}" && id !== "[]" || indexOf([".",",",";"], id) !== -1 || id.substring(0,2) === "/*") )
						id = "'" + redoEscape(id) + "'";
					if( this.args.length === 0 && is_graphic_token(this.id) && priority.indicator !== "")
						return "(" + id + ")";
					return id + (this.args.length > 0 ? "(" + map( this.args,
						function(x) { return x.toString(options, arg_priority); }
					).join(",") + ")" : "");
				} else {
					var priority_op = parseInt(operator.priority);
					var priority_arg = parseInt(priority.priority);
					var cond = priority_op > priority_arg || priority_op === priority_arg && (
						operator.class === "xfx" ||
						operator.class === "xfy" && this.indicator !== priority.indicator ||
						operator.class === "yfx" && this.indicator !== priority.indicator ||
						this.indicator === priority.indicator && operator.class === "yfx" && from === "right" ||
						this.indicator === priority.indicator && operator.class === "xfy" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "xf" && from === "left" ||
						this.indicator === priority.indicator && operator.class === "fx" && from === "right");
					operator.indicator = this.indicator;
					var lpar = cond ? "(" : "";
					var rpar = cond ? ")" : "";
					var space = !(is_graphic_token(this.id) || this.id === "," || this.id === ";")
						|| operator.class.length === 2
						|| operator.class.length === 3 && pl.type.is_number(this.args[1]) && this.args[1].value < 0 ? " " : "";
					if( this.args.length === 0 ) {
						return lpar + this.id + rpar;
					} else if( ["fy","fx"].indexOf( operator.class) !== -1 ) {
						return lpar + id + space + this.args[0].toString( options, operator, "right" ) + rpar;
					} else if( ["yf","xf"].indexOf( operator.class) !== -1 ) {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + id + rpar;
					} else {
						return lpar + this.args[0].toString( options, operator, "left" ) + space + this.id + space + this.args[1].toString( options, operator, "right" ) +  rpar;
					}
				}
		}
	};

	// Streams
	Stream.prototype.toString = function( _ ) {
		return "<stream>(" + this.id + ")";
	};
	
	// Substitutions
	Substitution.prototype.toString = function( options ) {
		var str = "{";
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( str !== "{" ) {
				str += ", ";
			}
			str += link + "/" + this.links[link].toString( options );
		}
		str += "}";
		return str;
	};
	
	// States
	State.prototype.toString = function( options ) {
		if( this.goal === null ) {
			return "<" + this.substitution.toString( options ) + ">";
		} else {
			return "<" + this.goal.toString( options ) + ", " + this.substitution.toString( options ) + ">";
		}
	};
	
	// Rules
	Rule.prototype.toString = function( options ) {
		if( !this.body ) {
			return this.head.toString( options ) + ".";
		} else {
			return this.head.toString( options, 1200, "left" ) + " :- " + this.body.toString( options, 1200, "right" ) + ".";
		}
	};
	
	// Session
	Session.prototype.toString = function( options ) {
		var str = "";
		for(var prop in this.modules) {
			if(this.modules.hasOwnProperty(prop) && this.modules[prop].is_library)
				str += ":- use_module(library(" + this.modules[prop] + ")).\n";
		}
		str += "\n";
		for(var key in this.modules.user.rules) {
			if(!this.modules.user.rules.hasOwnProperty(key)) continue;
			for(i = 0; i < this.modules.user.rules[key].length; i++) {
				str += this.modules.user.rules[key][i].toString(options);
				str += "\n";
			}
		}
		return str;
	};
	
	
	
	// CLONE PROLOG OBJECTS
	
	// Variables
	Var.prototype.clone = function() {
		return new Var( this.id );
	};
	
	// Numbers
	Num.prototype.clone = function() {
		return new Num( this.value, this.is_float );
	};
	
	// Terms
	Term.prototype.clone = function() {
		var term = new Term( this.id, map( this.args, function( arg ) {
			return arg.clone();
		} ) );
		if(this.definition_module)
			term.definition_module = this.definition_module;
		return term;
	};

	// Streams
	Stream.prototype.clone = function() {
		return new Stream( this.stream, this.mode, this.alias, this.type, this.reposition, this.eof_action );
	};
	
	// Substitutions
	Substitution.prototype.clone = function() {
		var links = {};
		var attrs = {};
		for( var link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].clone();
		}
		for( var attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attrs)) continue;
			attrs[attr] = {};
			for( var m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].clone();
			}
		}
		return new Substitution( links, attrs );
	};
	
	// States
	State.prototype.clone = function() {
		return new State( this.goal.clone(), this.substitution.clone(), this.parent );
	};
	
	// Rules
	Rule.prototype.clone = function() {
		return new Rule( this.head.clone(), this.body !== null ? this.body.clone() : null );
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.equals = function( obj ) {
		return pl.type.is_variable( obj ) && this.id === obj.id;
	};
	
	// Numbers
	Num.prototype.equals = function( obj ) {
		return pl.type.is_number( obj ) && this.value === obj.value && this.is_float === obj.is_float;
	};
	
	// Terms
	Term.prototype.equals = function( obj ) {
		if( !pl.type.is_term( obj ) || this.indicator !== obj.indicator ) {
			return false;
		}
		for( var i = 0; i < this.args.length; i++ ) {
			if( !this.args[i].equals( obj.args[i] ) ) {
				return false;
			}
		}
		return true;
	};

	// Streams
	Stream.prototype.equals = function( obj ) {
		return pl.type.is_stream( obj ) && this.id === obj.id;
	};
	
	// Substitutions
	Substitution.prototype.equals = function( obj ) {
	var link;
		if( !pl.type.is_substitution( obj ) ) {
			return false;
		}
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			if( !obj.links[link] || !this.links[link].equals( obj.links[link] ) ) {
				return false;
			}
		}
		for( link in obj.links ) {
			if(!obj.links.hasOwnProperty(link)) continue;
			if( !this.links[link] ) {
				return false;
			}
		}
		return true;
	};
	
	// States
	State.prototype.equals = function( obj ) {
		return pl.type.is_state( obj ) && this.goal.equals( obj.goal ) && this.substitution.equals( obj.substitution ) && this.parent === obj.parent;
	};
	
	// Rules
	Rule.prototype.equals = function( obj ) {
		return pl.type.is_rule( obj ) && this.head.equals( obj.head ) && (this.body === null && obj.body === null || this.body !== null && this.body.equals( obj.body ));
	};
	
	
	
	// RENAME VARIABLES OF PROLOG OBJECTS
	
	// Variables
	Var.prototype.rename = function( thread ) {
		return thread.get_free_variable( this );
	};
	
	// Numbers
	Num.prototype.rename = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.rename = function( thread ) {
		// ground
		if(this.ground)
			return new Term(this.id, this.args);
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].rename(thread);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.rename(thread);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].rename(thread);
			args.push(app);
		}
		return new Term(this.id, args);
	};

	// Streams
	Stream.prototype.rename = function( thread ) {
		return this;
	};
	
	// Rules
	Rule.prototype.rename = function( thread ) {
		return new Rule( this.head.rename( thread ), this.body !== null ? this.body.rename( thread ) : null );
	};



	// CHECK IF RENAME

	// Variables
	Var.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_variable(obj)
		|| links.hasOwnProperty(this.id) && links[this.id] !== obj.id
		|| links.hasOwnProperty(obj.id) && links[obj.id] !== this.id)
			return false;
		links[this.id] = obj.id;
		links[obj.id] = this.id;
		return true;
	};
	
	// Numbers
	Num.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	// Terms
	Term.prototype.is_rename = function(obj, links) {
		links = links || {};
		if(!pl.type.is_term(obj) || this.indicator !== obj.indicator)
			return false;
		for(var i = 0; i < this.args.length; i++) {
			if(!pl.is_rename(this.args[i], obj.args[i], links))
				return false;
		}
		return true;
	};

	// Streams
	Stream.prototype.is_rename = function(obj, _links) {
		return this.equals(obj);
	};
	
	
	
	// GET ID OF VARIABLES FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.variables = function() {
		return [this.id];
	};
	
	// Numbers
	Num.prototype.variables = function() {
		return [];
	};
	
	// Terms
	Term.prototype.variables = function() {
		if(this.ground)
			return [];
		return [].concat.apply( [], map( this.args, function( arg ) {
			return arg.variables();
		} ) );
	};

	// Streams
	Stream.prototype.variables = function() {
		return [];
	};
	
	// Rules
	Rule.prototype.variables = function() {
		if( this.body === null ) {
			return this.head.variables();
		} else {
			return this.head.variables().concat( this.body.variables() );
		}
	};
	
	
	
	// APPLY SUBSTITUTIONS TO PROLOG OBJECTS
	
	// Variables
	Var.prototype.apply = function( subs ) {
		if( subs.lookup( this.id ) ) {
			return subs.lookup( this.id );
		}
		return this;
	};
	
	// Numbers
	Num.prototype.apply = function( _ ) {
		return this;
	};
	
	// Terms
	Term.prototype.apply = function( subs ) {
		// ground atom
		if(this.ground)
			return this;
		// list
		if(this.indicator === "./2") {
			var arr = [];
			var pointer = this;
			while(pointer.indicator === "./2" && !pointer.ground) {
				var app = pointer.args[0].apply(subs);
				arr.push(app);
				pointer = pointer.args[1];
			}
			var list = pointer.apply(subs);
			for(var i = arr.length-1; i >= 0; i--)
				list = new Term(".", [arr[i], list]);
			return list;
		}
		// compound term
		var args = [];
		for(var i = 0; i < this.args.length; i++) {
			var app = this.args[i].apply(subs);
			args.push(app);
		}
		return new Term(this.id, args, this.ref);
	};

	// Streams
	Stream.prototype.apply = function( _ ) {
		return this;
	};
	
	// Rules
	Rule.prototype.apply = function( subs ) {
		return new Rule( this.head.apply( subs ), this.body !== null ? this.body.apply( subs ) : null );
	};
	
	// Substitutions
	Substitution.prototype.apply = function( subs ) {
		var link, links = {}, attr, attrs = {}, m;
		for( link in this.links ) {
			if(!this.links.hasOwnProperty(link)) continue;
			links[link] = this.links[link].apply(subs);
		}
		for( attr in this.attrs ) {
			if(!this.attrs.hasOwnProperty(attr)) continue;
			attrs[attr] = {};
			for( m in this.attrs[attr] ) {
				if(!this.attrs[attr].hasOwnProperty(m)) continue;
				attrs[attr][m] = this.attrs[attr][m].apply(subs);
			}
		}
		return new Substitution( links, attrs );
	};
	
	
	
	// SELECTION FUNCTION
	
	// Select term
	Term.prototype.select = function() {
		var pointer = this;
		while(pl.type.is_term(pointer) && pointer.indicator === ",/2")
			pointer = pointer.args[0];
		return pointer;
	};
	
	// Replace term
	Term.prototype.replace = function( expr ) {
		if( this.indicator === ",/2" ) {
			if( this.args[0].indicator === ",/2" ) {
				return new Term( ",", [this.args[0].replace( expr ), this.args[1]] );
			} else {
				return expr === null ? this.args[1] : new Term( ",", [expr, this.args[1]] );
			}
		} else {
			return expr;
		}
	};

	// Search term
	Term.prototype.search = function( expr ) {
		if(this == expr || this.ref === expr.ref)
			return true;
		for( var i = 0; i < this.args.length; i++ )
			if( pl.type.is_term( this.args[i] ) && this.args[i].search( expr ) )
				return true;
		return false;
	};
	
	
	
	// PROLOG SESSIONS AND THREADS

	// Push to a global stack
	Session.prototype.push_global_stack = function(stack, value) {
		return this.thread.push_global_stack(stack, value);
	};
	Thread.prototype.push_global_stack = function(stack, value) {
		if(!this.__stacks.hasOwnProperty(stack))
			this.__stacks[stack] = [];
		this.__stacks[stack].push(value);
	};

	// Pop all from a global stack
	Session.prototype.flush_global_stack = function(stack, tail) {
		return this.thread.push_global_stack(stack, tail);
	};
	Thread.prototype.flush_global_stack = function(stack, tail) {
		var list = tail || new Term("[]", []);
		if(this.__stacks.hasOwnProperty(stack)) {
			while(this.__stacks[stack].length > 0)
				list = new Term(".", [this.__stacks[stack].pop(), list]);
			delete this.__stacks[stack];
		}
		return list;
	};

	// Set max inferences
	Session.prototype.setMaxInferences = function(max) {
		this.limit = typeof max === "number" && max > 0 ? max : null;
	};
	Thread.prototype.setMaxInferences = function(max) {
		this.session.setMaxInferences(max);
		this.current_limit = this.session.limit;
		this.has_limit = this.session.limit !== null;
	};

	// Format answer
	Session.prototype.format_answer = function(answer, options) {
		return this.thread.format_answer(answer, options);
	};
	Thread.prototype.format_answer = function(answer, options) {
		return pl.format_answer(answer, this, options);
	};

	// Get current input
	Session.prototype.get_current_input = function() {
		return this.current_input;
	};
	Thread.prototype.get_current_input = function() {
		return this.session.get_current_input();
	};

	// Get current output
	Session.prototype.get_current_output = function() {
		return this.current_output;
	};
	Thread.prototype.get_current_output = function() {
		return this.session.get_current_output();
	};

	// Set current input
	Session.prototype.set_current_input = function( input ) {
		this.current_input = input;
	};
	Thread.prototype.set_current_input = function( input ) {
		return this.session.set_current_input( input );
	};

	// Set current output
	Session.prototype.set_current_output = function( output ) {
		this.current_output = output;
	};
	Thread.prototype.set_current_output = function( output ) {
		return this.session.set_current_output( output);
	};

	// Get stream by alias
	Session.prototype.get_stream_by_alias = function( alias ) {
		return this.streams[alias];
	};
	Thread.prototype.get_stream_by_alias = function( alias ) {
		return this.session.get_stream_by_alias( alias );
	};

	// Open file
	Session.prototype.file_system_open = function( path, type, mode ) {
		if(this.get_flag("nodejs").indicator === "false/0")
			path = this.absolute_file_name(path);
		return this.file_system.open( path, type, mode );
	};
	Thread.prototype.file_system_open = function( path, type, mode ) {
		return this.session.file_system_open( path, type, mode );
	};

	// Absolute file name
	Session.prototype.absolute_file_name = function(filename) {
		var absolute;
		// node.js
		if(this.get_flag("nodejs").indicator === "true/0") {
			var path = __webpack_require__(/*! path */ "?4461");
			absolute = filename;
			for(var prop in process.env) {
				if(!process.env.hasOwnProperty(prop))
					continue;
				absolute = absolute.replace(new RegExp("\\$" + prop, "g"), process.env[prop]);
			}
			return path.resolve(absolute);
		// browser
		} else {
			var cwd = this.working_directory;
			if(filename[0] === "/")
				absolute = filename;
			else
				absolute = cwd + (cwd[cwd.length-1] === "/" ? filename : "/" + filename);
			absolute = absolute.replace(/\/\.\//g, "/");
			var dirs = absolute.split("/");
			var dirs2 = [];
			for(var i = 0; i < dirs.length; i++) {
				if(dirs[i] !== "..") {
					dirs2.push(dirs[i]);
				} else {
					if(dirs2.length !== 0)
						dirs2.pop();
				}
			}
			absolute = dirs2.join("/").replace(/\/\.$/, "/");
		}
		return absolute;
	};
	Thread.prototype.absolute_file_name = function(path, cwd) {
		return this.session.absolute_file_name(path, cwd);
	};

	// Get conversion of the char
	Session.prototype.get_char_conversion = function( char ) {
		return this.__char_conversion[char] || char;
	};
	Thread.prototype.get_char_conversion = function( char ) {
		return this.session.get_char_conversion( char );
	};
	
	// Parse an expression
	Session.prototype.parse = function( string ) {
		return this.thread.parse( string );
	};
	Thread.prototype.parse = function( string ) {
		var tokenizer = new Tokenizer( this );
		tokenizer.new_text( string );
		var tokens = tokenizer.get_tokens();
		if( tokens === null )
			return false;
		var expr = parseExpr(this, tokens, 0, this.__get_max_priority(), false);
		if( expr.len !== tokens.length )
			return false;
		return { value: expr.value, expr: expr, tokens: tokens };
	};
	
	// Get flag value
	Session.prototype.get_flag = function( flag ) {
		return this.flag[flag];
	};
	Thread.prototype.get_flag = function( flag ) {
		return this.session.get_flag( flag );
	};

	// Add a rule
	Session.prototype.add_rule = function(rule, options) {
		return this.thread.add_rule(rule, options);
	};
	Thread.prototype.add_rule = function(rule, options) {
		options = options ? options : {};
		options.from = options.from ? options.from : "$tau-js";
		var module_id, get_module;
		if(pl.type.is_term(rule.head) && rule.head.indicator === ":/2") {
			if(!pl.type.is_atom(rule.head.args[0])) {
				this.throw_warning(pl.error.type("module", rule.head.args[0], "top_level/0"));
				return;
			}
			module_id = rule.head.args[0].id;
			rule.head = rule.head.args[1];
		}
		if(module_id) {
			get_module = this.session.modules[module_id];
			if(!pl.type.is_module(get_module)) {
				get_module = new Module(module_id, {}, "all", {session: this.session});
				this.session.modules[module_id] = get_module;
			}
		} else {
			get_module = this.session.modules[options.context_module];
		}
		get_module.src_predicates[rule.head.indicator] = options.from;
		if(!get_module.rules.hasOwnProperty(rule.head.indicator)) {
			get_module.rules[rule.head.indicator] = [];
		}
		get_module.rules[rule.head.indicator].push(rule);
		if(!get_module.public_predicates.hasOwnProperty(rule.head.indicator))
			get_module.public_predicates[rule.head.indicator] = false;
		// update term indexing
		get_module.add_index_predicate(rule);
		return true;
	};

	// Run a directive
	Session.prototype.run_directive = function(directive, options) {
		return this.thread.run_directive(directive, options);
	};
	Thread.prototype.run_directive = function(directive, options) {
		if(pl.type.is_directive(directive)) {
			if(pl.directive[directive.indicator])
				return pl.directive[directive.indicator](this, directive, options);
			else
				return pl.directive[directive.id + "/*"](this, directive, options);
		}
		return false;
	};
	
	// Get maximum priority of the operators
	Session.prototype.__get_max_priority = function() {
		return "1200";
	};
	Thread.prototype.__get_max_priority = function() {
		return this.session.__get_max_priority();
	};
	
	// Get next priority of the operators
	Session.prototype.__get_next_priority = function( priority ) {
		var max = 0;
		priority = parseInt( priority );
		for( var key in this.__operators ) {
			if( !this.__operators.hasOwnProperty(key) ) continue;
			var n = parseInt(key);
			if( n > max && n < priority ) max = n;
		}
		return max.toString();
	};
	Thread.prototype.__get_next_priority = function( priority ) {
		return this.session.__get_next_priority( priority );
	};
	
	// Get classes of an operator
	Session.prototype.__lookup_operator_classes = function( priority, operator ) {
		if( this.__operators.hasOwnProperty( priority ) && this.__operators[priority][operator] instanceof Array ) {
			return this.__operators[priority][operator]  || false;
		}
		return false;
	};
	Thread.prototype.__lookup_operator_classes = function( priority, operator ) {
		return this.session.__lookup_operator_classes( priority, operator );
	};

	// Get operator
	Session.prototype.lookup_operator = function( name, arity ) {
		for(var p in this.__operators)
			if(this.__operators[p][name])
				for(var i = 0; i < this.__operators[p][name].length; i++)
					if( this.__operators[p][name][i].length === arity+1 )
						return {priority: p, class: this.__operators[p][name][i]};
		return null;
	};
	Thread.prototype.lookup_operator = function( name, arity ) {
		return this.session.lookup_operator( name, arity );
	};
	
	// Throw a warning
	Session.prototype.throw_warning = function( warning ) {
		this.thread.throw_warning( warning );
	};
	Thread.prototype.throw_warning = function( warning ) {
		this.warnings.push( warning );
	};
	
	// Get warnings
	Session.prototype.get_warnings = function() {
		return this.thread.get_warnings();
	};
	Thread.prototype.get_warnings = function() {
		return this.warnings;
	};

	// Add a goal
	Session.prototype.add_goal = function( goal, unique ) {
		this.thread.add_goal( goal, unique );
	};
	Thread.prototype.add_goal = function( goal, unique, parent ) {
		parent = parent ? parent : null;
		if( unique === true )
			this.points = [];
		var vars = goal.variables();
		var links = {};
		for( var i = 0; i < vars.length; i++ )
			links[vars[i]] = new Var(vars[i]);
		this.points.push( new State( goal, new Substitution(links), parent ) );
	};

	// Consult a program from a string
	Session.prototype.consult = function(program, options) {
		return this.thread.consult(program, options);
	};
	Thread.prototype.consult = function(program, options) {
		var string = "", success = false;
		var opts = {};
		var callback = typeof options === "function" ? options : function(){};
		options = options === undefined || typeof options === "function" ? {} : options;
		opts.context_module = options.context_module === undefined ? "user" : options.context_module;
		opts.text = options.text === undefined ? true : options.text;
		opts.html = options.html === undefined ? true : options.html;
		opts.url = options.url === undefined ? true : options.url;
		opts.file = options.file === undefined ? true : options.file;
		opts.script = options.script === undefined ? true : options.script;
		opts.success = options.success === undefined ? callback : options.success;
		opts.error = options.error === undefined ? callback : options.error;
		// string
		if(typeof program === "string") {
			string = program;
			// script id
			if(opts.script && this.get_flag("nodejs").indicator === "false/0" && program != "" && document.getElementById(string)) {
				var script = document.getElementById(string);
				var type = script.getAttribute("type");
				if(type !== null && type.replace(/ /g, "").toLowerCase() === "text/prolog") {
					string = script.text;
					success = true;
				}
			}
			// file (node.js)
			if(!success && opts.file && this.get_flag("nodejs").indicator === "true/0") {
				var fs = __webpack_require__(/*! fs */ "?4a0f");
				var thread = this;
				fs.readFile(program, function(error, data) {
					if(error) {
						opts.file = false;
						thread.consult(program, opts);
					} else {
						parseProgram(thread, data.toString(), opts);
					}
				});
				return;
			}
			// http request
			if(!success && this.get_flag("nodejs").indicator === "false/0" && opts.url && program !== "" && !(/\s/.test(program))) {
				try {
					var xhttp = new XMLHttpRequest();
					var thread = this;
					xhttp.onreadystatechange = function() {
						if(this.readyState == 4) {
							if(this.status == 200) {
								string = xhttp.responseText;
								success = true;
								parseProgram(thread, string, opts);
							} else {
								opts.url = false;
								thread.consult(program, opts);
							}
						}
					}
					xhttp.open("GET", program, true);
					xhttp.send();
					return;
				} catch(ex) {
					opts.error(ex);
					return;
				}
			}
			// text
			if(!success && opts.text) {
				success = true;
			}
		// html
		} else if(opts.html && program.nodeName) {
			switch(program.nodeName.toLowerCase()) {
				case "input":
				case "textarea":
					string = program.value;
					success = true;
					break;
				default:
					string = program.innerHTML;
					success = true;
					break;
			}
		} else {
			opts.error(pl.error.existence("source_sink", new Term(string), "top_level/0"));
		}
		this.warnings = [];
		parseProgram(this, string, opts);
	};

	// Query goal from a string (without ?-)
	Session.prototype.query = function(string, options) {
		return this.thread.query(string, options);
	};
	Thread.prototype.query = function(string, options) {
		this.points = [];
		this.debugger_states = [];
		this.level = new Term("top_level");
		return parseQuery(this, string, options);
	};
	
	// Get first choice point
	Session.prototype.head_point = function() {
		return this.thread.head_point();
	};
	Thread.prototype.head_point = function() {
		return this.points[this.points.length-1];
	};
	
	// Get free variable
	Session.prototype.get_free_variable = function( variable ) {
		return this.thread.get_free_variable( variable );
	};
	Thread.prototype.get_free_variable = function( variable ) {
		var variables = [];
		if( variable.id === "_" || this.session.renamed_variables[variable.id] === undefined ) {
			this.session.rename++;
			if( this.current_point )
				variables = this.current_point.substitution.domain();
			while( indexOf( variables, pl.format_variable( this.session.rename, variable.id ) ) !== -1 ) {
				this.session.rename++;
			}
			if( variable.id === "_" ) {
				return new Var( pl.format_variable( this.session.rename, variable.id ) );
			} else {
				this.session.renamed_variables[variable.id] = pl.format_variable( this.session.rename, variable.id );
			}
		}
		return new Var( this.session.renamed_variables[variable.id] );
	};
	
	// Get next free variable
	Session.prototype.next_free_variable = function() {
		return this.thread.next_free_variable();
	};
	Thread.prototype.next_free_variable = function() {
		this.session.rename++;
		var variables = [];
		if( this.current_point )
			variables = this.current_point.substitution.domain();
		while( indexOf( variables, pl.format_variable( this.session.rename ) ) !== -1 ) {
			this.session.rename++;
		}
		return new Var( pl.format_variable( this.session.rename ) );
	};
	
	// Check if a predicate is public
	Session.prototype.is_public_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_public_predicate(indicator);
	};
	Thread.prototype.is_public_predicate = function(indicator, module_id) {
		return this.session.is_public_predicate(indicator, module_id);
	};
	
	// Check if a predicate is multifile
	Session.prototype.is_multifile_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		return pl.type.is_module(this.modules[module_id]) && this.modules[module_id].is_multifile_predicate(indicator);
	};
	Thread.prototype.is_multifile_predicate = function(indicator, module_id) {
		return this.session.is_multifile_predicate(indicator, module_id);
	};

	// Check if a predicate is a meta-predicate
	Session.prototype.is_meta_predicate = function(indicator, module_id) {
		module_id = module_id === undefined ? "user" : module_id;
		if(pl.type.is_module(this.modules[module_id]))
			return this.modules[module_id].is_meta_predicate(indicator);
		return null;
	};
	Thread.prototype.is_meta_predicate = function(indicator, module_id) {
		return this.session.is_meta_predicate(indicator, module_id);
	};
	
	// Insert states at the beginning
	Session.prototype.prepend = function( states ) {
		return this.thread.prepend( states );
	};
	Thread.prototype.prepend = function( states ) {
		for(var i = states.length-1; i >= 0; i--)
			this.points.push( states[i] );
	};
	
	// Remove the selected term and prepend the current state
	Session.prototype.success = function( point, parent ) {
		return this.thread.success( point, parent );
	}
	Thread.prototype.success = function( point, parent ) {
		var parent = typeof parent === "undefined" ? point : parent;
		this.prepend( [new State( point.goal.replace( null ), point.substitution, parent ) ] );
	};
	
	// Throw error
	Session.prototype.throw_error = function(error) {
		return this.thread.throw_error(error);
	};
	Thread.prototype.throw_error = function(error) {
		if(pl.type.is_variable(error))
			error = pl.error.instantiation(this.level.indicator);
		var state = new State(
			new Term("throw", [error]),
			new Substitution(),
			null
		);
		state.error = true;
		this.prepend([state]);
	};
	
	// Get the module of a predicate
	Session.prototype.lookup_module = function(atom, context_module) {
		return this.thread.lookup_module(atom, context_module);
	}
	Thread.prototype.lookup_module = function(atom, context_module) {
		var get_module = this.session.modules[context_module];
		if(!pl.type.is_module(get_module))
			get_module = this.session.modules.user;
		if(get_module.rules.hasOwnProperty(atom.indicator) && (
			get_module.exports_predicate(atom.indicator) ||
			get_module.rules.hasOwnProperty(this.level.indicator) ||
			context_module === get_module.id))
				return get_module;
		get_module.modules.system = pl.modules.system;
		get_module.modules.user = this.session.modules.user;
		for(var prop in get_module.modules) {
			if(!this.session.modules.hasOwnProperty(prop))
				continue;
			var get_module = this.session.modules[prop];
			if(get_module.rules.hasOwnProperty(atom.indicator) && (
				get_module.exports_predicate(atom.indicator) ||
				get_module.rules.hasOwnProperty(this.level.indicator) ||
				context_module === get_module.id))
					return get_module;
		}
		return null;
	};

	// Expand a meta-predicate
	Session.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		return this.thread.expand_meta_predicate(atom, definition_module, context_module);
	};
	Thread.prototype.expand_meta_predicate = function(atom, definition_module, context_module) {
		var get_module = this.session.modules[definition_module];
		if(!get_module)
			return;
		var meta = get_module.is_meta_predicate(atom.indicator);
		if(!meta)
			return;
		for(var i = 0; i < meta.args.length; i++) {
			if(pl.type.is_integer(meta.args[i]) || pl.type.is_atom(meta.args[i]) && indexOf([":"], meta.args[i].id) !== -1) {
				if(!pl.type.is_term(atom.args[i]) || atom.args[i].indicator !== ":/2") {
					atom.args[i] = new Term(":", [new Term(context_module), atom.args[i]]);
				}
			} else if(pl.type.is_atom(meta.args[i]) && meta.args[i].id === "^") {
				var pointer_last = atom;
				var pointer_index = i;
				var pointer = atom.args[i];
				while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
					pointer_last = pointer;
					pointer_index = 1;
					pointer = pointer.args[1];
				}
				if(!pl.type.is_term(pointer) || pointer.indicator !== ":/2") {
					pointer_last.args[pointer_index] = new Term(":", [new Term(context_module), pointer]);
				}
			}
		}
	};
	
	// Resolution step
	Session.prototype.step = function() {
		return this.thread.step();
	}
	Thread.prototype.step = function() {
		if(this.points.length === 0) {
			return;
		}
		var asyn = false;
		var point = this.points.pop();
		this.current_point = point;
		if(this.debugger)
			this.debugger_states.push(point);
		var atom = pl.type.is_term(point.goal) ? point.goal.select() : point.goal;
		if(pl.type.is_term(atom) && (atom.indicator !== ":/2" || pl.type.is_term(atom.args[1]))) {
			var context_module = null;
			var states = [];
			if(atom !== null) {
				this.total_steps++;
				var level = point;
				while(level.parent !== null && level.parent.goal.search(atom))
					level = level.parent;
				if(level.parent === null) {
					this.level = new Term("top_level");
				} else {
					this.level = level.parent.goal.select();
					if(this.level.indicator === ":/2")
						this.level = this.level.args[1];
				}
				if(pl.type.is_term(atom) && atom.indicator === ":/2") {
					context_module = atom.args[0];
					atom = atom.args[1];
					if(!pl.type.is_atom(context_module)) {
						this.throw_error(pl.error.type("module", context_module, this.level.indicator));
						return;
					}
					context_module = context_module.id;
				} else {
					if(this.level.definition_module) {
						context_module = this.level.definition_module;
					} else {
						context_module = "user";
					}
				}
				atom.context_module = context_module;
				if(atom.indicator === ",/2") {
					this.prepend([new State(
						point.goal.replace(new Term(",", [
							new Term(":", [new Term(context_module), atom.args[0]]),
							new Term(":", [new Term(context_module), atom.args[1]])])),
						point.substitution,
						point
					)]);
					return;
				}
				this.__call_indicator = atom.indicator;
				var get_module = this.lookup_module(atom, context_module);
				atom.definition_module = pl.type.is_module(get_module) ? get_module.id : "user";
				this.expand_meta_predicate(atom, atom.definition_module, context_module);
				var clauses = null;
				if(get_module && atom.args.length > 0 && atom.args[0].index && get_module.indexed_clauses.hasOwnProperty(atom.indicator) && get_module.indexed_clauses[atom.indicator].hasOwnProperty(atom.args[0].index))
					clauses = get_module.indexed_clauses[atom.indicator][atom.args[0].index];
				else
					clauses = get_module === null ? null : get_module.rules[atom.indicator];
				if(clauses === null) {
					if(!this.session.modules.user.rules.hasOwnProperty(atom.indicator)) {
						if(this.get_flag("unknown").id === "error") {
							this.throw_error( pl.error.existence( "procedure", atom.indicator, this.level.indicator));
						} else if(this.get_flag("unknown").id === "warning") {
							this.throw_warning("unknown procedure " + atom.indicator + " (from " + this.level.indicator + ")");
						}
					}
				} else if(clauses instanceof Function) {
					asyn = clauses(this, point, atom);
				} else {
					// Goal expansion
					if(this.__goal_expansion && atom.indicator === "goal_expansion/2")
						clauses = clauses.concat(pl.builtin.rules["goal_expansion/2"]);
					for(var i = 0; i < clauses.length; i++) {
						this.session.renamed_variables = {};
						var clause = clauses[i].rename(this);
						var occurs_check = this.get_flag("occurs_check").indicator === "true/0";
						var mgu = pl.unify(atom, clause.head, occurs_check);
						if(mgu !== null) {
							var state = new State();
							state.goal = point.goal.replace(clause.body);
							if(state.goal !== null)
								state.goal = state.goal.apply(mgu);
							state.substitution = point.substitution.apply(mgu);
							state.parent = point;
							states.push(state);
						}
					}
					this.prepend(states);
				}
			}
		} else {
			var term = pl.type.is_term(atom) && atom.indicator === ":/2" ? atom.args[1] : atom;
			if(pl.type.is_variable(term))
				this.throw_error(pl.error.instantiation(this.level.indicator));
			else
				this.throw_error(pl.error.type("callable", term, this.level.indicator));
		}
		return asyn;
	};
	
	// Find next computed answer
	Session.prototype.answer = function(options) {
		return this.thread.answer(options);
	};
	Thread.prototype.answer = function(options) {
		var opts = {};
		options = options || function() {};
		if(typeof options === "function") {
			opts = {
				success: options,
				error: options,
				fail: options,
				limit: options
			};
		} else {
			opts.success = options.success === undefined ? function() {} : options.success;
			opts.error = options.error === undefined ? function() {} : options.error;
			opts.fail = options.fail === undefined ? function() {} : options.fail;
			opts.limit = options.limit === undefined ? function() {} : options.limit;
		}
		this.__calls.push(opts);
		if( this.__calls.length > 1 ) {
			return;
		}
		this.again();
	};
	
	// Find all computed answers
	Session.prototype.answers = function( callback, max, after ) {
		return this.thread.answers( callback, max, after );
	}
	Thread.prototype.answers = function( callback, max, after ) {
		var answers = max === undefined ? 1000 : max;
		var thread = this;
		if( answers <= 0 ) {
			if(after)
				after();
			return;
		}
		this.answer( function( answer ) {
			callback( answer );
			if( answer !== false ) {
				setTimeout( function() {
					thread.answers( callback, answers-1, after );
				}, 0 );
			} else if(after) {
				after();
			}
		} );
	};

	// Again finding next computed answer
	Session.prototype.again = function(reset_limit) {
		return this.thread.again(reset_limit);
	};
	Thread.prototype.again = function(reset_limit) {
		while(this.__calls.length > 0) {
			this.warnings = [];
			if(reset_limit !== false)
				this.current_limit = this.session.limit;
			while((!this.has_limit || this.current_limit > 0) && this.points.length > 0 && this.head_point().goal !== null && !pl.type.is_error_state(this.head_point())) {
				if(this.has_limit)
					this.current_limit--;
				var t0 = Date.now();
				var asyn = this.step();
				var t1 = Date.now();
				this.cpu_time += t1-t0;
				if(asyn === true)
					return;
			}
			var call = this.__calls.shift();
			// limit of inferences
			if(this.has_limit && this.current_limit <= 0) {
				(function(call) {
					return setTimeout(function() {
						call.limit(null);
					}, 0);
				})(call);
			// no answer
			} else if(this.points.length === 0) {
				(function(call) {
					return setTimeout(function() {
						call.fail(false);
					}, 0);
				})(call);
			// error
			} else if(pl.type.is_error(this.head_point().goal)) {
				var error = this.format_error(this.points.pop());
				this.points = [];
				(function(error, call) {
					return setTimeout(function() {
						call.error(error);
					}, 0);
				})(error, call);
			// computed answer
			} else {
				if(this.debugger)
					this.debugger_states.push(this.head_point());
				var answer = this.format_success(this.points.pop());
				(function(answer, call) {
					return setTimeout(function() {
						call.success(answer);
					}, 0);
				})(answer, call);
			}
		}
	};
	
	// Unfolding transformation
	Session.prototype.unfold = function( rule ) {
		if(rule.body === null)
			return false;
		var head = rule.head;
		var body = rule.body;
		var atom = body.select();
		var thread = new Thread( this );
		var unfolded = [];
		thread.add_goal( atom );
		thread.step();
		for( var i = thread.points.length-1; i >= 0; i-- ) {
			var point = thread.points[i];
			var head2 = head.apply( point.substitution );
			var body2 = body.replace( point.goal );
			if( body2 !== null )
				body2 = body2.apply( point.substitution );
			unfolded.push( new Rule( head2, body2 ) );
		}
		var rules = this.modules.user.rules[head.indicator];
		var index = indexOf( rules, rule );
		if( unfolded.length > 0 && index !== -1 ) {
			rules.splice.apply( rules, [index, 1].concat(unfolded) );
			return true;
		}
		return false;
	};
	Thread.prototype.unfold = function(rule) {
		return this.session.unfold(rule);
	};

	
	
	// INTERPRET EXPRESSIONS
	
	// Variables
	Var.prototype.interpret = function( thread ) {
		return pl.error.instantiation( thread.level.indicator );
	};
	
	// Numbers
	Num.prototype.interpret = function( thread ) {
		return this;
	};
	
	// Terms
	Term.prototype.interpret = function( thread ) {
		if( pl.type.is_unitary_list( this ) ) {
			return this.args[0].interpret( thread );
		} else {
			return pl.operate( thread, this );
		}
	};
	
	
	
	// COMPARE PROLOG OBJECTS
	
	// Variables
	Var.prototype.compare = function( obj ) {
		if( this.id < obj.id ) {
			return -1;
		} else if( this.id > obj.id ) {
			return 1;
		} else {
			return 0;
		}
	};
	
	// Numbers
	Num.prototype.compare = function( obj ) {
		if( this.value === obj.value && this.is_float === obj.is_float ) {
			return 0;
		} else if( this.value < obj.value || this.value === obj.value && this.is_float && !obj.is_float ) {
			return -1;
		} else if( this.value > obj.value ) {
			return 1;
		}
	};
	
	// Terms
	Term.prototype.compare = function( obj ) {
		if( this.args.length < obj.args.length || this.args.length === obj.args.length && this.id < obj.id ) {
			return -1;
		} else if( this.args.length > obj.args.length || this.args.length === obj.args.length && this.id > obj.id ) {
			return 1;
		} else {
			for( var i = 0; i < this.args.length; i++ ) {
				var arg = pl.compare( this.args[i], obj.args[i] );
				if( arg !== 0 ) {
					return arg;
				}
			}
			return 0;
		}
	};
	

	
	// SUBSTITUTIONS
	
	// Lookup variable
	Substitution.prototype.lookup = function( variable ) {
		if( this.links[variable] ) {
			return this.links[variable];
		} else {
			return null;
		}
	};
	
	// Filter variables
	Substitution.prototype.filter = function( predicate ) {
		var links = {};
		for( var id in this.links ) {
			if(!this.links.hasOwnProperty(id)) continue;
			var value = this.links[id];
			if( predicate( id, value ) ) {
				links[id] = value;
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Exclude variables
	Substitution.prototype.exclude = function( variables ) {
		var links = {};
		for( var variable in this.links ) {
			if(!this.links.hasOwnProperty(variable)) continue;
			if( indexOf( variables, variable ) === -1 ) {
				links[variable] = this.links[variable];
			}
		}
		return new Substitution( links, this.attrs );
	};
	
	// Add link
	Substitution.prototype.add = function( variable, value ) {
		this.links[variable] = value;
	};
	
	// Get domain
	Substitution.prototype.domain = function( plain ) {
		var f = plain === true ? function(x){return x;} : function(x){return new Var(x);};
		var vars = [];
		for( var x in this.links )
			vars.push( f(x) );
		return vars;
	};

	// Get an attribute
	Substitution.prototype.get_attribute = function( variable, module ) {
		if( this.attrs[variable] )
			return this.attrs[variable][module];
	}

	// Set an attribute (in a new substitution)
	Substitution.prototype.set_attribute = function( variable, module, value ) {
		var subs = new Substitution( this.links );
		for( var v in this.attrs ) {
			if( v === variable ) {
				subs.attrs[v] = {};
				for( var m in this.attrs[v] ) {
					subs.attrs[v][m] = this.attrs[v][m];
				}
			} else {
				subs.attrs[v] = this.attrs[v];
			}
		}
		if( !subs.attrs[variable] ) {
			subs.attrs[variable] = {};
		}
		subs.attrs[variable][module] = value;
		return subs;
	}

	// Check if a variables has attributes
	Substitution.prototype.has_attributes = function( variable ) {
		return this.attrs[variable] && this.attrs[variable] !== {};
	}
	
	
	
	// GENERATE JAVASCRIPT CODE FROM PROLOG OBJECTS
	
	// Variables
	Var.prototype.compile = function() {
		return 'new pl.type.Var("' + this.id.toString() + '")';
	};
	
	// Numbers
	Num.prototype.compile = function() {
		return 'new pl.type.Num(' + this.value.toString() + ', ' + this.is_float.toString() + ')';
	};
	
	// Terms
	Term.prototype.compile = function() {
		return 'new pl.type.Term("' + this.id.replace(/"/g, '\\"') + '", [' + map( this.args, function( arg ) {
			return arg.compile();
		} ) + '])';
	};
	
	// Rules
	Rule.prototype.compile = function() {
		return 'new pl.type.Rule(' + this.head.compile() + ', ' + (this.body === null ? 'null' : this.body.compile()) + ')';
	};
	
	// Sessions
	Session.prototype.compile = function() {
		var str, obj = [], rules;
		for( var _indicator in this.modules.user.rules ) {
			if(!this.modules.user.rules.hasOwnProperty(_indicator)) continue;
			var indicator = this.modules.user.rules[_indicator];
			rules = [];
			str = "\"" + _indicator + "\": [";
			for(var i = 0; i < indicator.length; i++) {
				rules.push(indicator[i].compile());
			}
			str += rules.join();
			str += "]";
			obj.push( str );
		}
		return "{" + obj.join() + "};";
	};

	// Module
	Module.prototype.compile = function() {
		var length = 0;
		var dependencies = 0;
		var str = "var pl;\n";
		str += "(function(pl) {\n";
		// name
		str += "\tvar name = \"" + this.id + "\";\n";
		// predicates
		str += "\tvar predicates = function() {\n";
		str += "\t\treturn {\n";
		for(var prop in this.rules) {
			if(length > 0)
				str += ",\n";
			str += "\t\t\t\"" + prop + "\": ";
			if(typeof this.rules[prop] === "function") {
				str += this.rules[prop];
			} else {
				str += "[\n";
				for(var i = 0; i < this.rules[prop].length; i++) {
					str += "\t\t\t\t" + this.rules[prop][i].compile();
					if(i < this.rules[prop].length-1)
						str += ",";
					str += "\n";
				}
				str += "\t\t\t]";
			}
			length++;
		}
		str += "\n\t\t};\n";
		str += "\t};\n";
		// exports
		str += "\tvar exports = [";
		for(var i = 0; i < this.exports.length; i++) {
			if(i > 0)
				str += ", ";
			str += "\"" + this.exports[i] + "\"";
		}
		str += "];\n";
		// options
		str += "\tvar options = function() {\n";
		str += "\t\treturn {\n";
		// dependencies
		str += "\t\t\tdependencies: [";
		for(var prop in this.modules) {
			if(dependencies > 0)
				str += ", ";
			str += "\"" + prop + "\"";
			dependencies++;
		}
		str += "]\n";
		str += "\t\t};\n";
		str += "};\n";
		// fixed code
		str += "\tif(typeof module !== 'undefined') {\n";
		str += "\t\tmodule.exports = function(p) {\n";
		str += "\t\t\tpl = p;\n";
		str += "\t\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t\t};\n";
		str += "\t} else {\n";
		str += "\t\tnew pl.type.Module(name, predicates(), exports, options());\n";
		str += "\t}\n";
		str += "})(pl);\n";
		return str;
	};
	
	
	
	// PROLOG TO JAVASCRIPT
	Var.prototype.toJavaScript = function() {
		return this.toString();
	};
	
	// Numbers
	Num.prototype.toJavaScript = function() {
		return this.value;
	};
	
	// Terms
	Term.prototype.toJavaScript = function(options) {
		// Atom => String
		if( this.args.length === 0 && this.indicator !== "[]/0" ) {
			return this.toString(options);
		} else if( pl.type.is_list( this ) ) {
			// List => Array
			var all_obj = true;
			var arr = [];
			var obj = {};
			var pointer = this;
			var value;
			while( pointer.indicator === "./2" ) {
				value = pointer.args[0].toJavaScript(options);
				arr.push( value );
				all_obj = all_obj && pl.type.is_term(pointer.args[0]) && pointer.args[0].indicator === "-/2" && pl.type.is_atom(pointer.args[0].args[0]);
				if(all_obj)
					obj[pointer.args[0].args[0].id] = pointer.args[0].args[1].toJavaScript(options);
				pointer = pointer.args[1];
			}
			if( pointer.indicator === "[]/0" )
				return all_obj && arr.length > 0 ? obj : arr;

		}
		return this.toString(options);
	};
	
	
	
	// RULES
	
	// Return singleton variables in the session
	Rule.prototype.singleton_variables = function(include_named) {
		include_named = include_named || false;
		var variables = this.head.variables();
		var count = {};
		var singleton = [];
		if(this.body !== null)
			variables = variables.concat(this.body.variables());
		for(var i = 0; i < variables.length; i++) {
			if(count[variables[i]] === undefined)
				count[variables[i]] = 0;
			count[variables[i]]++;
		}
		for(var key in count) {
			if(!count.hasOwnProperty(key))
				continue;
			if(count[key] === 1) {
				var charcode = codePointAt(key, 1);
				if(!include_named || key === "_")
					if(key === "_" || key[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
						continue;
				singleton.push(key);
			}
		}
		return singleton;
	};



	// NODEJS

	var nodejs_flag = typeof process !== 'undefined' && !process.browser

	var nodejs_arguments = nodejs_flag ?
		arrayToList( map(process.argv.slice(1), function(arg) { return new Term( arg ); })) :
		new Term("[]", []);
	
	
	
	// PROLOG

	var pl = {
		
		// Environment
		__env: nodejs_flag ? __webpack_require__.g : window,
		
		// Modules
		modules: {},
		
		// Version
		version: version,
		
		// Parser
		parser: {
			tokenizer: Tokenizer,
			expression: parseExpr
		},
		
		// Utils
		utils: {
			
			// String to indicator
			str_indicator: str_indicator,
			// Code point at
			codePointAt: codePointAt,
			// From code point
			fromCodePoint: fromCodePoint,
			// Length of string
			stringLength: stringLength
			
		},
		
		// Statistics
		statistics: {
			
			// Number of created terms
			getCountTerms: function() {
				return term_ref;
			}
			
		},
		
		// JavaScript to Prolog
		fromJavaScript: {
			
			// Type testing
			test: {
				
				// Boolean
				boolean: function( obj, tobj ) {
					return obj === true || obj === false;
				},
				
				// Number
				number: function( obj, tobj ) {
					return typeof obj === "number";
				},
				
				// String
				string: function( obj, tobj ) {
					return typeof obj === "string";
				},
				
				// List
				list: function( obj, tobj ) {
					return obj instanceof Array;
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return obj === undefined;
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					return tobj && !(obj instanceof Array) && typeof obj === "object";
				},
				
				// Any
				any: function( _, tobj ) {
					return true;
				}
				
			},
			
			// Function conversion
			conversion: {
				
				// Bolean
				boolean: function( obj, tobj ) {
					return new Term( obj ? "true" : "false", [] );
				},
				
				// Number
				number: function( obj, tobj ) {
					return new Num( obj, obj % 1 !== 0 );
				},
				
				// String
				string: function( obj, tobj ) {
					return new Term( obj, [] );
				},
				
				// List
				list: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var arr = [];
					var elem;
					for( var i = 0; i < obj.length; i++ ) {
						elem = pl.fromJavaScript.apply( obj[i], tobj );
						if( elem === undefined )
							return undefined;
						arr.push( elem );
					}
					return arrayToList( arr );
				},
				
				// Variable
				variable: function( obj, tobj ) {
					return new Var( "_" );
				},

				// Object
				object: function( obj, tobj ) {
					tobj = tobj === undefined ? false : tobj;
					var list = new Term("[]", []);
					var arr = [];
					for(var prop in obj) {
						if(!obj.hasOwnProperty(prop)) continue;
						arr.push(new Term("-", [
							pl.fromJavaScript.apply(prop, tobj),
							pl.fromJavaScript.apply(obj[prop], tobj)
						]));
					}
					return arrayToList(arr);
				},
				
				// Any
				any: function( obj, tobj ) {
					return undefined;
				}
				
			},
			
			// Transform object
			apply: function( obj, tobj ) {
				tobj = tobj === undefined ? false : tobj;
				for( var i in pl.fromJavaScript.test )
					if( i !== "any" && pl.fromJavaScript.test[i]( obj, tobj ) )
						return pl.fromJavaScript.conversion[i]( obj, tobj );
				return pl.fromJavaScript.conversion.any( obj, tobj );
			}
		},
		
		// Types
		type: {
			
			// Objects
			Var: Var,
			Num: Num,
			Term: Term,
			Rule: Rule,
			State: State,
			Stream: Stream,
			Module: Module,
			Thread: Thread,
			Session: Session,
			Substitution: Substitution,
			File: TauFile,
			Directory: TauDirectory,
			
			// Order
			order: [Var, Num, Term, Stream],
			
			// Compare types
			compare: function( x, y ) {
				var ord_x = indexOf( pl.type.order, x.constructor );
				var ord_y = indexOf( pl.type.order, y.constructor );
				if( ord_x < ord_y ) {
					return -1;
				} else if( ord_x > ord_y ) {
					return 1;
				} else {
					if( x.constructor === Num )
						if( x.is_float && y.is_float )
							return 0;
						else if( x.is_float )
							return -1;
						else if( y.is_float )
							return 1;
					return 0;
				}
			},
			
			// Is a substitution
			is_substitution: function( obj ) {
				return obj instanceof Substitution;
			},
			
			// Is a state
			is_state: function( obj ) {
				return obj instanceof State;
			},
			
			// Is a rule
			is_rule: function( obj ) {
				return obj instanceof Rule;
			},
			
			// Is a variable
			is_variable: function( obj ) {
				return obj instanceof Var;
			},

			// Is a stream
			is_stream: function( obj ) {
				return obj instanceof Stream;
			},
			
			// Is an anonymous variable
			is_anonymous_var: function( obj ) {
				return obj instanceof Var && obj.id === "_";
			},
			
			// Is a callable term
			is_callable: function( obj ) {
				return obj instanceof Term
				&& (indexOf([",/2",";/2","->/2"], obj.indicator) === -1
				|| pl.type.is_callable(obj.args[0]) && pl.type.is_callable(obj.args[1]))
				|| obj instanceof Var;
			},
			
			// Is a number
			is_number: function( obj ) {
				return obj instanceof Num;
			},
			
			// Is an integer
			is_integer: function( obj ) {
				return obj instanceof Num && !obj.is_float;
			},
			
			// Is a float
			is_float: function( obj ) {
				return obj instanceof Num && obj.is_float;
			},
			
			// Is a term
			is_term: function( obj ) {
				return obj instanceof Term;
			},
			
			// Is an atom
			is_atom: function( obj ) {
				return obj instanceof Term && obj.args.length === 0;
			},
			
			// Is a ground term
			is_ground: function( obj ) {
				if( obj instanceof Var ) return false;
				if( obj instanceof Term )
					for( var i = 0; i < obj.args.length; i++ )
						if( !pl.type.is_ground( obj.args[i] ) )
							return false;
				return true;
			},
			
			// Is atomic
			is_atomic: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 || obj instanceof Num;
			},
			
			// Is compound
			is_compound: function( obj ) {
				return obj instanceof Term && obj.args.length > 0;
			},
			
			// Is a list
			is_list: function( obj ) {
				return obj instanceof Term && (obj.indicator === "[]/0" || obj.indicator === "./2");
			},
			
			// Is an empty list
			is_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a non empty list
			is_non_empty_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2";
			},
			
			// Is a fully list
			is_fully_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Var || obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is a instantiated list
			is_instantiated_list: function( obj ) {
				while( obj instanceof Term && obj.indicator === "./2" ) {
					obj = obj.args[1];
				}
				return obj instanceof Term && obj.indicator === "[]/0";
			},
			
			// Is an unitary list
			is_unitary_list: function( obj ) {
				return obj instanceof Term && obj.indicator === "./2" && obj.args[1] instanceof Term && obj.args[1].indicator === "[]/0";
			},
			
			// Is a character
			is_character: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && (obj.id.length === 1 || obj.id.length > 0 && obj.id.length <= 2 && codePointAt( obj.id, 0 ) >= 65536);
			},
			
			// Is a in_character
			is_in_character: function( obj ) {
				return obj instanceof Term && (obj.indicator === "end_of_file/0"
				|| obj.id.length === 1
				|| obj.id.length > 0 && obj.id.length <= 2 && codePointAt(obj.id, 0) >= 65536);
			},
			
			// Is a character_code
			is_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 1114111;
			},
			
			// Is a in_character_code
			is_in_character_code: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 1114111;
			},

			// Is a byte
			is_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= 0 && obj.value <= 255;
			},

			// Is a in_byte
			is_in_byte: function( obj ) {
				return obj instanceof Num && !obj.is_float && obj.value >= -1 && obj.value <= 255;
			},
			
			// Is an operator
			is_operator: function( obj ) {
				return obj instanceof Term && pl.arithmetic.evaluation[obj.indicator];
			},
			
			// Is a directive
			is_directive: function( obj ) {
				return obj instanceof Term && (pl.directive[obj.indicator] !== undefined || pl.directive[obj.id + "/*"] !== undefined);
			},
			
			// Is a built-in predicate
			is_builtin: function( obj ) {
				return obj instanceof Term && pl.builtin.rules.hasOwnProperty(obj.indicator) && obj.indicator !== "goal_expansion/2";
			},
			
			// Is an error
			is_error: function( obj ) {
				return obj instanceof Term && obj.indicator === "throw/1";
			},

			// Is an error state
			is_error_state: function( obj ) {
				return pl.type.is_state( obj ) && obj.error && obj.error === true;
			},
			
			// Is a predicate indicator
			is_predicate_indicator: function( obj ) {
				return obj instanceof Term && obj.indicator === "//2" && obj.args[0] instanceof Term && obj.args[0].args.length === 0 && obj.args[1] instanceof Num && obj.args[1].is_float === false;
			},
			
			// Is a flag
			is_flag: function( obj ) {
				return obj instanceof Term && obj.args.length === 0 && pl.flag[obj.id] !== undefined;
			},
			
			// Is a valid value for a flag
			is_value_flag: function( flag, obj ) {
				if( !pl.type.is_flag( flag ) ) return false;
				for( var value in pl.flag[flag.id].allowed ) {
					if(!pl.flag[flag.id].allowed.hasOwnProperty(value)) continue;
					if( pl.flag[flag.id].allowed[value].equals( obj ) ) return true;
				}
				return false;
			},

			// Is a io mode
			is_io_mode: function( obj ) {
				return pl.type.is_atom( obj ) && ["read","write","append"].indexOf( obj.id ) !== -1;
			},

			// Is a stream option
			is_stream_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "alias/1" && pl.type.is_atom(obj.args[0]) ||
					obj.indicator === "reposition/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "type/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary") ||
					obj.indicator === "eof_action/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")
				);
			},

			// Is a stream position
			is_stream_position: function( obj ) {
				return pl.type.is_term(obj) && (
					obj.indicator === "end_of_stream/0" ||
					obj.indicator === "past_end_of_stream/0" ||
					obj.indicator === "position/3"
						&& pl.type.is_integer(obj.args[0])
						&& pl.type.is_integer(obj.args[1])
						&& pl.type.is_integer(obj.args[2])
				)
			},

			// Is a stream property
			is_stream_property: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "input/0" || 
					obj.indicator === "output/0" || 
					obj.indicator === "alias/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "file_name/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom( obj.args[0] )) ||
					obj.indicator === "reposition/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false")) ||
					obj.indicator === "type/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "text" || obj.args[0].id === "binary")) ||
					obj.indicator === "mode/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "read" || obj.args[0].id === "write" || obj.args[0].id === "append")) ||
					obj.indicator === "eof_action/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "error" || obj.args[0].id === "eof_code" || obj.args[0].id === "reset")) ||
					obj.indicator === "end_of_stream/1" && (pl.type.is_variable( obj.args[0] ) || pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "at" || obj.args[0].id === "past" || obj.args[0].id === "not")) ||
					obj.indicator === "position/1"
						&& (pl.type.is_variable(obj.args[0]) || pl.type.is_term(obj.args[0]) && obj.args[0].indicator === "position/3"
							&& (pl.type.is_variable(obj.args[0].args[0]) || pl.type.is_integer(obj.args[0].args[0]))
							&& (pl.type.is_variable(obj.args[0].args[1]) || pl.type.is_integer(obj.args[0].args[1]))
							&& (pl.type.is_variable(obj.args[0].args[2]) || pl.type.is_integer(obj.args[0].args[2])))
				);
			},

			// Is a streamable term
			is_streamable: function( obj ) {
				return obj.__proto__.stream !== undefined;
			},

			// Is a read option
			is_read_option: function( obj ) {
				return pl.type.is_term( obj ) && ["variables/1","variable_names/1","singletons/1"].indexOf( obj.indicator ) !== -1;
			},

			// Is a write option
			is_write_option: function( obj ) {
				return pl.type.is_term( obj ) && (
					obj.indicator === "quoted/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "ignore_ops/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "numbervars/1" && pl.type.is_atom(obj.args[0]) && (obj.args[0].id === "true" || obj.args[0].id === "false") ||
					obj.indicator === "variable_names/1" && pl.type.is_fully_list(obj.args[0])
				);
			},

			// Is a close option
			is_close_option: function( obj ) {
				return pl.type.is_term( obj ) &&
					obj.indicator === "force/1" &&
					pl.type.is_atom(obj.args[0]) &&
					(obj.args[0].id === "true" || obj.args[0].id === "false");
			},
			
			// Is a modifiable flag
			is_modifiable_flag: function( obj ) {
				return pl.type.is_flag( obj ) && pl.flag[obj.id].changeable;
			},

			// Is a module
			is_module: function( obj ) {
				return obj instanceof Module;
			},

			// Is a virtual file
			is_file: function( obj ) {
				return obj instanceof TauFile;
			},

			// Is a virtual directory
			is_directory: function( obj ) {
				return obj instanceof TauDirectory;
			},

			// Is a predicate property
			is_predicate_property: function(obj) {
				return pl.type.is_term(obj) && (
					obj.indicator === "built_in/0" ||
					obj.indicator === "static/0" ||
					obj.indicator === "dynamic/0" ||
					obj.indicator === "native_code/0" ||
					obj.indicator === "multifile/0" ||
					obj.indicator === "meta_predicate/1"
				);
			},

			// Is a meta-argument specifier
			is_meta_argument_specifier: function(obj) {
				return pl.type.is_integer(obj) && obj.value >= 0 ||
					pl.type.is_atom(obj) && indexOf(["+", "-", "?", "*", "^", ":", "//"], obj.id) !== -1;
			},

			// Is a time property
			is_time_property: function( obj ) {
				return pl.type.is_term(obj) && obj.args.length === 1 
				&& (pl.type.is_variable(obj.args[0]) || pl.type.is_integer(obj.args[0]))
				&& indexOf(["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"], obj.id) !== -1;
			},
			
		},

		// Arithmetic functions
		arithmetic: {
			
			// Evaluation
			evaluation: {
				"e/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.E; }
				},
				"pi/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Math.PI; }
				},
				"tau/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return 2*Math.PI; }
				},
				"epsilon/0": {
					type_args: null,
					type_result: true,
					fn: function( _ ) { return Number.EPSILON; }
				},
				"+/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return x; }
				},
				"-/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return -x; }
				},
				"\\/1": {
					type_args: false,
					type_result: false,
					fn: function( x, _ ) { return ~x; }
				},
				"abs/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.abs( x ); }
				},
				"sign/1": {
					type_args: null,
					type_result: null,
					fn: function( x, _ ) { return Math.sign( x ); }
				},
				"float_integer_part/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"float_fractional_part/1": {
					type_args: true,
					type_result: true,
					fn: function( x, _ ) { return x - parseInt( x ); }
				},
				"float/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return parseFloat( x ); }
				},
				"floor/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.floor( x ); }
				},
				"truncate/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return parseInt( x ); }
				},
				"round/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.round( x ); }
				},
				"ceiling/1": {
					type_args: true,
					type_result: false,
					fn: function( x, _ ) { return Math.ceil( x ); }
				},
				"sin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sin( x ); }
				},
				"cos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cos( x ); }
				},
				"tan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tan( x ); }
				},
				"asin/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.asin(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"acos/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) <= 1 ? Math.acos(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"atan/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.atan( x ); }
				},
				"atan2/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x === 0 && y === 0 ? pl.error.evaluation("undefined", thread.__call_indicator) : Math.atan2(x, y); }
				},
				"acosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 1 ? Math.acosh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"asinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.asinh( x ); }
				},
				"atanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return Math.abs(x) < 1 ? Math.atanh(x) : pl.error.evaluation("undefined", thread.__call_indicator); }
				},
				"cosh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.cosh( x ); }
				},
				"sinh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.sinh( x ); }
				},
				"tanh/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.tanh( x ); }
				},
				"exp/1": {
					type_args: null,
					type_result: true,
					fn: function( x, _ ) { return Math.exp( x ); }
				},
				"sqrt/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x >= 0 ? Math.sqrt( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log( x ) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x > 0 && y > 0 ? Math.log(y)/Math.log(x) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"log10/1": {
					type_args: null,
					type_result: true,
					fn: function( x, thread ) { return x > 0 ? Math.log(x)/Math.log(10) : pl.error.evaluation( "undefined", thread.__call_indicator ); }
				},
				"+/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x + y; }
				},
				"-/2": {
					type_args: null,
					type_result: null,
					fn:  function( x, y, _ ) { return x - y; }
				},
				"*/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return x * y; }
				},
				"//2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return y ? x / y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"///2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.trunc( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"div/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? Math.floor( x / y ) : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"**/2": {
					type_args: null,
					type_result: true,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"^/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, thread ) { return x == 0 && y < 0 ? pl.error.evaluation("zero_divisor", thread.__call_indicator) : Math.pow(x, y); }
				},
				"<</2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x << y; }
				},
				">>/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x >> y; }
				},
				"/\\/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x & y; }
				},
				"\\//2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x | y; }
				},
				"xor/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return x ^ y; }
				},
				"rem/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x % y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"mod/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, thread ) { return y ? x - Math.floor( x / y ) * y : pl.error.evaluation( "zero_divisor", thread.__call_indicator ); }
				},
				"max/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.max( x, y ); }
				},
				"min/2": {
					type_args: null,
					type_result: null,
					fn: function( x, y, _ ) { return Math.min( x, y ); }
				},
				"gcd/2": {
					type_args: false,
					type_result: false,
					fn: function( x, y, _ ) { return gcd(x, y); }
				}
				
			}
			
		},
		
		// Directives
		directive: {
			
			// dynamic/1
			"dynamic/1": function( thread, atom, options ) {
				var indicators = atom.args[0];
				if(!pl.type.is_list(indicators))
					indicators = arrayToList([indicators]);
				var pointer = indicators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					indicator = pointer.args[0];
					if( pl.type.is_variable( indicator ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
						thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
					} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_atom( indicator.args[0] ) ) {
						thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
					} else if( !pl.type.is_integer( indicator.args[1] ) ) {
						thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
					} else {
						var key = indicator.args[0].id + "/" + indicator.args[1].value;
						var get_module = thread.session.modules[options.context_module];
						get_module.public_predicates[key] = true;
						if( !get_module.rules[key] )
						get_module.rules[key] = [];
					}
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				}
			},

			// dynamic/[2..]
			"dynamic/*": function( thread, atom ) {
				for(var i = 0; i < atom.args.length; i++) {
					pl.directive["dynamic/1"](thread, new Term("dynamic", [atom.args[i]]));
				}
			},
			
			// multifile/1
			"multifile/1": function( thread, atom, options ) {
				var indicator = atom.args[0];
				if( pl.type.is_variable( indicator ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_compound( indicator ) || indicator.indicator !== "//2" ) {
					thread.throw_warning( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
				} else if( pl.type.is_variable( indicator.args[0] ) || pl.type.is_variable( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( indicator.args[0] ) ) {
					thread.throw_warning( pl.error.type( "atom", indicator.args[0], atom.indicator ) );
				} else if( !pl.type.is_integer( indicator.args[1] ) ) {
					thread.throw_warning( pl.error.type( "integer", indicator.args[1], atom.indicator ) );
				} else {
					var predicate_indicator = atom.args[0].args[0].id + "/" + atom.args[0].args[1].value;
					var get_module = thread.session.modules[options.context_module];
					get_module.multifile_predicates[predicate_indicator] = true;
					if(!get_module.rules.hasOwnProperty(predicate_indicator)) {
						get_module.rules[predicate_indicator] = [];
						get_module.public_predicates[predicate_indicator] = false;
					}
				}
			},

			// meta_predicate/1
			"meta_predicate/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				var head = atom.args[0];
				if( pl.type.is_variable(head) ) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_warning(pl.error.type("callable", head, atom.indicator));
				} else {
					for(var i = 0; i < head.args.length; i++) {
						var arg = head.args[i];
						if(!pl.type.is_meta_argument_specifier(arg)) {
							thread.throw_warning(pl.error.type("meta_argument_specifier", arg, atom.indicator));
							return;
						}
					}
					thread.session.modules[options.context_module].meta_predicates[head.indicator] = head;
				}
			},
			
			// set_prolog_flag
			"set_prolog_flag/2": function( thread, atom ) {
				var flag = atom.args[0], value = atom.args[1];
				if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_atom( flag ) ) {
					thread.throw_warning( pl.error.type( "atom", flag, atom.indicator ) );
				} else if( !pl.type.is_flag( flag ) ) {
					thread.throw_warning( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
				} else if( !pl.type.is_modifiable_flag( flag ) ) {
					thread.throw_warning( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
				} else if( !pl.type.is_value_flag( flag, value ) ) {
					thread.throw_warning( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
				} else {
					thread.session.flag[flag.id] = value;
				}
			},

			// module/2
			"module/2": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0], exports = atom.args[1];
				if(pl.type.is_variable(module_id) || pl.type.is_variable(exports)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_atom(module_id)) {
					thread.throw_warning(pl.error.type("atom", module_id, atom.indicator));
				} else if(!pl.type.is_list(exports)) {
					thread.throw_warning(pl.error.type("list", exports, atom.indicator));
				} else {
					if(!pl.type.is_module(thread.session.modules[module_id.indicator])) {
						var pointer = exports;
						var indicators = [];
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var predicate = pointer.args[0];
							if(!pl.type.is_predicate_indicator(predicate)) {
								thread.throw_warning(pl.error.type("predicate_indicator", predicate, atom.indicator));
							} else {
								indicators.push(predicate.args[0].id + "/" + predicate.args[1].value);
							}
							pointer = pointer.args[1];
						}
						if(pl.type.is_variable(pointer)) {
							thread.throw_warning(pl.error.instantiation(atom.indicator));
						} else if(!pl.type.is_empty_list(pointer)) {
							thread.throw_warning(pl.error.type("list", exports, atom.indicator));
						}
						var new_module = new Module(module_id.id, {}, indicators, {
							session: thread.session
						});
						thread.session.modules[module_id.id] = new_module;
						thread.session.modules[options.context_module].modules[module_id.id] = new_module;
						options.context_module = module_id.id;
					} else {
						thread.throw_warning(pl.error.permission("create", "module", module_id, atom.indicator));
					}
				}
			},
			
			// use_module/1
			"use_module/1": function(thread, atom, options) {
				var options = options === undefined ? {} : options;
				options.context_module = options.context_module === undefined ? "user" : options.context_module;
				var module_id = atom.args[0];
				if(pl.type.is_variable(module_id)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_term(module_id)) {
					thread.throw_warning(pl.error.type("term", module_id, atom.indicator));
				} else {
					if(module_id.indicator === "library/1") {
						var name = module_id.args[0].id;
						var get_module = pl.modules[name];
						if(pl.type.is_module(get_module)) {
							if(!thread.session.modules[options.context_module].modules.hasOwnProperty(name)) {
								thread.session.modules[name] = get_module;
								thread.session.modules[options.context_module].modules[name] = get_module;
								for(var i = 0; i < get_module.dependencies.length; i++) {
									var term = new Term("use_module", [new Term("library", [new Term(get_module.dependencies[i])])]);
									pl.directive["use_module/1"](thread, term, {
										context_module: name
									});
								}
							}
						} else {
							thread.throw_warning(pl.error.existence("module", module_id, atom.indicator));
						}
					} else {
						var name = module_id.id;
						thread.consult(name, {
							context_module: options.context_module,
							text: false,
							success: function() {
								parseProgram(thread, options.string, options);
							},
							error: function() {
								options.error(pl.error.existence("module", module_id, atom.indicator));
							}
						});
						return true;
					}
				}
			},
			
			// char_conversion/2
			"char_conversion/2": function(thread, atom, options) {
				var inchar = atom.args[0], outchar = atom.args[1];
				if(pl.type.is_variable(inchar) || pl.type.is_variable(outchar)) {
					thread.throw_warning(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_character(inchar)) {
					thread.throw_warning(pl.error.type("character", inchar, atom.indicator));
				} else if(!pl.type.is_character(outchar)) {
					thread.throw_warning(pl.error.type("character", outchar, atom.indicator));
				} else {
					if(inchar.id === outchar.id) {
						delete thread.session.__char_conversion[inchar.id];
					} else {
						thread.session.__char_conversion[inchar.id] = outchar.id;
					}
					options.tokens = options.tokenizer.get_tokens(options.current_token);
					options.current_token = 0;
					return true;
				}
			},
			
			// op/3
			"op/3": function( thread, atom ) {
				var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
				if(pl.type.is_atom(operators))
					operators = new Term(".", [operators, new Term("[]")]);
				if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
					thread.throw_warning( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_integer( priority ) ) {
					thread.throw_warning( pl.error.type( "integer", priority, atom.indicator ) );
				} else if( !pl.type.is_atom( type ) ) {
					thread.throw_warning( pl.error.type( "atom", type, atom.indicator ) );
				} else if( !pl.type.is_list( operators ) ) {
					thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
				} else if( pl.type.is_empty_list( operators ) ) {
					thread.throw_warning( pl.error.permission( "create", "operator", operators, atom.indicator ) );
				} else {
					var pointer = operators;
					while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
						var operator = pointer.args[0];
						pointer = pointer.args[1];
						if( pl.type.is_variable( operator ) ) {
							thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						} else if( !pl.type.is_atom( operator ) ) {
							thread.throw_warning( pl.error.type( "atom", operator, atom.indicator ) );
						} else if( priority.value < 0 || priority.value > 1200 ) {
							thread.throw_warning( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						} else if( operator.id === "," ) {
							thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						} else if( operator.id === "{}" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "[]" ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
							thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
							thread.throw_warning( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						} else {
							var fix = { prefix: null, infix: null, postfix: null };
							for( var p in thread.session.__operators ) {
								if(!thread.session.__operators.hasOwnProperty(p)) continue;
								var classes = thread.session.__operators[p][operator.id];
								if( classes ) {
									if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
									if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
									if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
									if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
									if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
									if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
									if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
								}
							}
							var current_class;
							switch( type.id ) {
								case "fy": case "fx": current_class = "prefix"; break;
								case "yf": case "xf": current_class = "postfix"; break;
								default: current_class = "infix"; break;
							}
							if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
								thread.throw_warning( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							} else {
								if( fix[current_class] ) {
									remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
									if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
										delete thread.session.__operators[fix[current_class].priority][operator.id];
									}
								}
								if( priority.value > 0 ) {
									if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
									if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
									thread.session.__operators[priority.value][operator.id].push( type.id );
								}
							}
						}
					}
					if(pl.type.is_variable(pointer)) {
						thread.throw_warning( pl.error.instantiation( atom.indicator ) );
						return;
					} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
						thread.throw_warning( pl.error.type( "list", operators, atom.indicator ) );
						return;
					}
				}
			},

			// initialization/1
			"initialization/1": function(thread, atom, options) {
				var goal = atom.args[0];
				options.initialization.push(goal);
			}
			
		},
		
		// Flags
		flag: {
			
			// Bounded numbers
			bounded: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( "true" ),
				changeable: false
			},
			
			// Maximum integer
			max_integer: {
				allowed: [new Num( Number.MAX_SAFE_INTEGER )],
				value: new Num( Number.MAX_SAFE_INTEGER ),
				changeable: false
			},
			
			// Minimum integer
			min_integer: {
				allowed: [new Num( Number.MIN_SAFE_INTEGER )],
				value: new Num( Number.MIN_SAFE_INTEGER ),
				changeable: false
			},
			
			// Rounding function
			integer_rounding_function: {
				allowed: [new Term( "down" ), new Term( "toward_zero" )],
				value: new Term( "toward_zero" ),
				changeable: false
			},
			
			// Character conversion
			char_conversion: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "on" ),
				changeable: true
			},
			
			// Debugger
			debug: {
				allowed: [new Term( "on" ), new Term( "off" )],
				value: new Term( "off" ),
				changeable: true
			},
			
			// Maximum arity of predicates
			max_arity: {
				allowed: [new Term( "unbounded" )],
				value: new Term( "unbounded" ),
				changeable: false
			},
			
			// Unkwnow predicates behavior
			unknown: {
				allowed: [new Term( "error" ), new Term( "fail" ), new Term( "warning" )],
				value: new Term( "error" ),
				changeable: true
			},
			
			// Double quotes behavior
			double_quotes: {
				allowed: [new Term( "chars" ), new Term( "codes" ), new Term( "atom" )],
				value: new Term( "chars" ),
				changeable: true
			},
			
			// Occurs check behavior
			occurs_check: {
				allowed: [new Term( "false" ), new Term( "true" )],
				value: new Term( "false" ),
				changeable: true
			},
			
			// Dialect
			dialect: {
				allowed: [new Term( "tau" )],
				value: new Term( "tau" ),
				changeable: false
			},
			
			// Version
			version_data: {
				allowed: [new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] )],
				value: new Term( "tau", [new Num(version.major,false), new Num(version.minor,false), new Num(version.patch,false), new Term(version.status)] ),
				changeable: false
			},
			
			// NodeJS
			nodejs: {
				allowed: [new Term( "true" ), new Term( "false" )],
				value: new Term( nodejs_flag ? "true" : "false" ),
				changeable: false
			},

			// Arguments
			argv: {
				allowed: [nodejs_arguments],
				value: nodejs_arguments,
				changeble: false
			}
			
		},
		
		// Unify
		unify: function(t1, t2, occurs_check) {
			occurs_check = occurs_check === undefined ? false : occurs_check;
			var left = Array.isArray(t1) ? t1 : [t1];
			var right = Array.isArray(t2) ? t2 : [t2];
			if(left.length !== right.length)
				return null;
			var subs = new Substitution();
			while(left.length > 0) {
				var s = left.pop();
				var t = right.pop();
				if(pl.type.is_variable(s))
					s = s.apply(subs);
				if(pl.type.is_variable(t))
					t = t.apply(subs);
				// same object
				if(s == t)
					continue;
				// compound terms
				if(pl.type.is_term(s) && pl.type.is_term(t)) {
					if(s.indicator !== t.indicator)
						return null;
					for(var i = s.args.length-1; i >= 0; i--) {
						left.push(s.args[i]);
						right.push(t.args[i]);
					}
				// numbers
				} else if(pl.type.is_number(s) && pl.type.is_number(t)) {
					if(s.value !== t.value || s.is_float !== t.is_float)
						return null;
				// variable - term
				} else if(pl.type.is_variable(s)) {
					t = t.apply(subs);
					// x = x
					if(pl.type.is_variable(t) && s.id === t.id)
						continue;
					// occurs check
					if(occurs_check === true && indexOf(t.variables(), s.id) !== -1)
						return null;
					// anonymous variable
					if(s.id !== "_")
						subs.add(s.id, t);
				// term - variable
				} else if(pl.type.is_variable(t)) {
					left.push(t);
					right.push(s);
				// user-defined terms
				} else if(s.unify !== undefined) {
					var user_subs = s.apply(subs).unify(t.apply(subs), occurs_check);
					if(user_subs == null)
						return null;
					for(var i in user_subs.links)
						subs.add(i, user_subs.links[i]);
				} else {
					return null;
				}
			}
			return subs.apply(subs);
		},

		// Is rename
		is_rename: function(obj1, obj2, links) {
			links = links || {};
			if(obj1.is_rename && obj2.is_rename)
				return obj1.is_rename(obj2, links);
			else if(obj1.equals && obj2.equals)
				return obj1.equals(obj2);
			else
				return false;
		},
		
		// Compare
		compare: function( obj1, obj2 ) {
			var type = pl.type.compare( obj1, obj2 );
			return type !== 0 ? type : obj1.compare( obj2 );
		},
		
		// Arithmetic comparison
		arithmetic_compare: function( thread, obj1, obj2 ) {
			var expr1 = obj1.interpret( thread );
			if( !pl.type.is_number( expr1 ) ) {
				return expr1;
			} else {
				var expr2 = obj2.interpret( thread );
				if( !pl.type.is_number( expr2 ) ) {
					return expr2;
				} else {
					return expr1.value < expr2.value ? -1 : (expr1.value > expr2.value ? 1 : 0);
				}
			}
		},
		
		// Operate
		operate: function( thread, obj ) {
			if( pl.type.is_operator( obj ) ) {
				var op = pl.type.is_operator( obj );
				var args = [], value;
				var type = false;
				for( var i = 0; i < obj.args.length; i++ ) {
					value = obj.args[i].interpret( thread );
					if( !pl.type.is_number( value ) ) {
						return value;
					} else if( op.type_args !== null && value.is_float !== op.type_args ) {
						return pl.error.type( op.type_args ? "float" : "integer", value, thread.__call_indicator );
					} else {
						args.push( value.value );
					}
					type = type || value.is_float;
				}
				args.push( thread );
				value = pl.arithmetic.evaluation[obj.indicator].fn.apply( this, args );
				if(obj.indicator === "^/2" && !type && value !== parseInt(value, 10))
					return pl.error.type( "float", new Num(args[0],false), thread.__call_indicator );
				type = op.type_result === null ? type : op.type_result;
				if( pl.type.is_term( value ) ) {
					return value;
				} else if( value === Number.POSITIVE_INFINITY || value === Number.NEGATIVE_INFINITY ) {
					return pl.error.evaluation( "float_overflow", thread.__call_indicator );
				} else if( type === false && thread.get_flag( "bounded" ).id === "true" && (value > thread.get_flag( "max_integer" ).value || value < thread.get_flag( "min_integer" ).value) ) {
					return pl.error.evaluation( "int_overflow", thread.__call_indicator );
				} else {
					return new Num( value, type );
				}
			} else {
				return pl.error.type( "evaluable", str_indicator(obj.indicator), thread.__call_indicator );
			}
		},
		
		// Errors
		error: {
			
			// Existence error
			existence: function( type, object, indicator ) {
				if( typeof object === "string" )
					object = str_indicator( object );
				return new Term( "error", [new Term( "existence_error", [new Term( type ), object] ), str_indicator( indicator )] );
			},
			
			// Type error
			type: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "type_error", [new Term( expected ), found] ), str_indicator( indicator )] );
			},
			
			// Instantation error
			instantiation: function( indicator ) {
				return new Term( "error", [new Term( "instantiation_error" ), str_indicator( indicator )] );
			},
			
			// Uninstantation error
			uninstantiation: function( found, indicator ) {
				return new Term( "error", [new Term( "uninstantiation_error", [new Term( found )] ), str_indicator( indicator )] );
			},
			
			// Domain error
			domain: function( expected, found, indicator ) {
				return new Term( "error", [new Term( "domain_error", [new Term( expected ), found]), str_indicator( indicator )] );
			},
			
			// Representation error
			representation: function( flag, indicator ) {
				return new Term( "error", [new Term( "representation_error", [new Term( flag )] ), str_indicator( indicator )] );
			},
			
			// Permission error
			permission: function( operation, type, found, indicator ) {
				return new Term( "error", [new Term( "permission_error", [new Term( operation ), new Term( type ), found] ), str_indicator( indicator )] );
			},
			
			// Evaluation error
			evaluation: function( error, indicator ) {
				return new Term( "error", [new Term( "evaluation_error", [new Term( error )] ), str_indicator( indicator )] );
			},
			
			// Syntax error
			syntax: function( token, expected, last ) {
				token = token || {value: "", line: 0, column: 0, matches: [""], start: 0};
				var position = last && token.matches.length > 0 ? token.start + token.matches[0].length : token.start;
				var found = last ? new Term("token_not_found") : new Term("found", [new Term(token.value.toString())]);
				var info = new Term( ".", [new Term( "line", [new Num(token.line+1)] ), new Term( ".", [new Term( "column", [new Num(position)] ), new Term( ".", [found, new Term( "[]", [] )] )] )] );
				return new Term( "error", [new Term( "syntax_error", [new Term( expected )] ), info] );
			},
			
			// Syntax error by predicate
			syntax_by_predicate: function( expected, indicator ) {
				return new Term( "error", [new Term( "syntax_error", [new Term( expected ) ] ), str_indicator( indicator )] );
			}
			
		},
		
		// Warnings
		warning: {
			
			// Singleton variables
			singleton: function( variables, rule, line ) {
				var list = new Term( "[]" );
				for( var i = variables.length-1; i >= 0; i-- )
					list = new Term( ".", [new Var(variables[i]), list] );
				return new Term( "warning", [new Term( "singleton_variables", [list, str_indicator(rule)]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			},
			
			// Failed goal
			failed_goal: function( goal, line ) {
				return new Term( "warning", [new Term( "failed_goal", [goal]), new Term(".",[new Term( "line", [ new Num( line, false ) ]), new Term("[]")])] );
			}

		},
		
		// Format of renamed variables
		format_variable: function( id, variable ) {
			var charcode = variable && variable.length > 0 ? codePointAt(variable, 1) : 0;
			if(variable === "_" || variable && variable[0] === "_" && (charcode === 95 || charcode >= 65 && charcode <= 90))
				return "__" + id;
			return "_" + id;
		},
		
		// Format of computed answers
		format_answer: function( answer, thread, options ) {
			if( thread instanceof Session )
				thread = thread.thread;
			var options = options ? options : {};
			options.session = thread ? thread.session : undefined;
			if( pl.type.is_error( answer ) ) {
				return "uncaught exception: " + answer.args[0].toString(options);
			} else if( answer === false ) {
				return "false";
			} else if( answer === null ) {
				return "limit exceeded";
			} else {
				var i = 0;
				var str = "";
				if( pl.type.is_substitution( answer ) ) {
					var dom = answer.domain( true );
					for( var link in answer.links ){
						if( !answer.links.hasOwnProperty(link) ) continue;
						if( pl.type.is_variable(answer.links[link]) ) {
							var links = {};
							links[answer.links[link].id] = new Var(link);
							answer = answer.apply( new Substitution(links) );
						}
					}
					answer = answer.filter( function( id, value ) {
						return !pl.type.is_variable( value ) ||
							pl.type.is_variable( value ) && answer.has_attributes( id ) ||
							indexOf( dom, value.id ) !== -1 && id !== value.id;
					} );
				}
				for( var link in answer.links ) {
					if(!answer.links.hasOwnProperty(link))
						continue;
					if( pl.type.is_variable( answer.links[link] ) && link === answer.links[link].id ) {
						var attrs = answer.attrs[link];
						for( var module in attrs ) {
							if(!attrs.hasOwnProperty(module))
								continue;
							i++;
							if( str !== "" )
								str += ", ";
							str += "put_attr(" + link + ", " + module + ", " + attrs[module].toString(options) + ")";
						}
					} else {
						i++;
						if( str !== "" )
							str += ", ";
						str += link.toString( options ) + " = " +
							answer.links[link].toString( options, {priority: "700", class: "xfx", indicator: "=/2"}, "right" );
					}
				}
				if( i === 0 ) {
					return "true";
				} else {
					return str;
				}
			}
		},
		
		// Flatten default errors
		flatten_error: function( error ) {
			if( !pl.type.is_error( error ) ) return null;
			error = error.args[0];
			var obj = {};
			obj.type = error.args[0].id;
			obj.thrown = obj.type === "syntax_error" ? null : error.args[1].id;
			obj.expected = null;
			obj.found = null;
			obj.representation = null;
			obj.existence = null;
			obj.existence_type = null;
			obj.line = null;
			obj.column = null;
			obj.permission_operation = null;
			obj.permission_type = null;
			obj.evaluation_type = null;
			if( obj.type === "type_error" || obj.type === "domain_error" ) {
				obj.expected = error.args[0].args[0].id;
				obj.found = error.args[0].args[1].toString();
			} else if( obj.type === "syntax_error" ) {
				if( error.args[1].indicator === "./2" ) {
					obj.expected = error.args[0].args[0].id;
					obj.found = error.args[1].args[1].args[1].args[0];
					obj.found = obj.found.id === "token_not_found" ? obj.found.id : obj.found.args[0].id;
					obj.line = error.args[1].args[0].args[0].value;
					obj.column = error.args[1].args[1].args[0].args[0].value;
				} else {
					obj.thrown = error.args[1].id;
				}
			} else if( obj.type === "permission_error" ) {
				obj.found = error.args[0].args[2].toString();
				obj.permission_operation = error.args[0].args[0].id;
				obj.permission_type = error.args[0].args[1].id;
			} else if( obj.type === "evaluation_error" ) {
				obj.evaluation_type = error.args[0].args[0].id;
			} else if( obj.type === "representation_error" ) {
				obj.representation = error.args[0].args[0].id;
			} else if( obj.type === "existence_error" ) {
				obj.existence = error.args[0].args[1].toString();
				obj.existence_type = error.args[0].args[0].id;
			}
			return obj;
		},
		
		// Create new session
		create: function( limit ) {
			return new pl.type.Session( limit );
		}
		
	};

	// Built-in predicates
	pl.builtin = new Module("system", {

		// TERM AND GOAL EXPANSION

		// goal_expansion/2
		"goal_expansion/2": [
			new Rule(new Term("goal_expansion", [new Term(",", [new Var("X"),new Var("Y")]),new Term(",", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term(";", [new Var("X"),new Var("Y")]),new Term(";", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("->", [new Var("X"),new Var("Y")]),new Term("->", [new Var("X_"),new Var("Y_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Y"),new Var("Y_")]),new Term("=", [new Var("Y_"),new Var("Y")])])]),new Term(",", [new Term("=", [new Var("X"),new Var("X_")]),new Term("goal_expansion", [new Var("Y"),new Var("Y_")])])])),
			new Rule(new Term("goal_expansion", [new Term("catch", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("catch", [new Var("X_"),new Var("Y"),new Var("Z_")])]), new Term(";", [new Term(",", [new Term("goal_expansion", [new Var("X"),new Var("X_")]),new Term(";", [new Term("goal_expansion", [new Var("Z"),new Var("Z_")]),new Term("=", [new Var("Z_"),new Var("Z")])])]),new Term(",", [new Term("=", [new Var("X_"),new Var("X")]),new Term("goal_expansion", [new Var("Z"),new Var("Z_")])])])),
			new Rule(new Term("goal_expansion", [new Term("\\+", [new Var("X")]),new Term("\\+", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("once", [new Var("X")]),new Term("once", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("findall", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("setof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("bagof", [new Var("X"),new Var("Y"),new Var("Z")]),new Term("findall", [new Var("X"),new Var("Y_"),new Var("Z")])]), new Term("goal_expansion", [new Var("Y"),new Var("Y_")])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X")]),new Term("call", [new Var("X_")])]), new Term(",", [new Term("nonvar", [new Var("X")]),new Term("goal_expansion", [new Var("X"),new Var("X_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term("[]", [])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term("[]", [])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term("[]", [])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term("[]", [])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term("[]", [])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term("[]", [])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])])),
			new Rule(new Term("goal_expansion", [new Term("call", [new Var("X"),new Var("A1"),new Var("A2"),new Var("A3"),new Var("A4"),new Var("A5"),new Var("A6"),new Var("A7")]),new Term("call", [new Var("F_")])]), new Term(",", [new Term("=..", [new Var("F"),new Term(".", [new Var("X"),new Term(".", [new Var("A1"),new Term(".", [new Var("A2"),new Term(".", [new Var("A3"),new Term(".", [new Var("A4"),new Term(".", [new Var("A5"),new Term(".", [new Var("A6"),new Term(".", [new Var("A7"),new Term("[]", [])])])])])])])])])]),new Term("goal_expansion", [new Var("F"),new Var("F_")])]))
		],



		// SYSTEM PREDICATES ($)

		// '$push_global_stack'/2
		"$push_global_stack/2": function(thread, point, atom) {
			var stack = atom.args[0], value = atom.args[1];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				thread.push_global_stack(stack.id, value);
				thread.success(point);
			}
		},

		// '$flush_global_stack'/3
		"$flush_global_stack/3": function(thread, point, atom) {
			var stack = atom.args[0], list = atom.args[1], tail = atom.args[2];
			if(!pl.type.is_variable(stack)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else {
				var values = thread.flush_global_stack(stack.id, tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [list, values])),
					point.substitution,
					point
				)]);
			}
		},

		// '$free_variable_set'/3
		"$free_variable_set/3": function(thread, point, atom) {
			var goal_in = atom.args[0], goal_out = atom.args[1], vars = atom.args[2];
			var bv = [];
			var pointer = goal_in;
			while(pl.type.is_term(pointer) && pointer.indicator === "^/2") {
				bv = bv.concat(pointer.args[0].variables());
				pointer = pointer.args[1];
			}
			var gv = pointer.variables();
			var fv = arrayToList(map(difference(gv, bv), function(v) {
				return new Var(v);
			}));
			thread.prepend([
				new State(
					point.goal.replace(new Term(",", [
						new Term("=", [goal_out, pointer]),
						new Term("=", [vars, fv]) 
					])),
					point.substitution,
					point
				)
			]);
		},

		// '$member'/2
		"$member/2": [
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("X"),new pl.type.Var("_")])]), null),
			new pl.type.Rule(new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Term(".", [new pl.type.Var("_"),new pl.type.Var("Xs")])]), new pl.type.Term("$member", [new pl.type.Var("X"),new pl.type.Var("Xs")]))
		],

		// '$bind_bagof_keys/2'/2
		"$bind_bagof_keys/2": [
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term("[]", []),new pl.type.Var("_")]), null),
			new pl.type.Rule(new pl.type.Term("$bind_bagof_keys", [new pl.type.Term(".", [new pl.type.Term("-", [new pl.type.Var("Key"),new pl.type.Var("_")]),new pl.type.Var("Bag")]),new pl.type.Var("Vars")]), new pl.type.Term(",", [new pl.type.Term("term_variables", [new pl.type.Var("Key"),new pl.type.Var("Vars"),new pl.type.Var("_")]),new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Bag"),new pl.type.Var("Vars")])]))
		],

		// '$findall'/4
		"$findall/4": [
			new pl.type.Rule(new pl.type.Term("$findall", [new pl.type.Var("Template0"),new pl.type.Var("Goal0"),new pl.type.Var("Instances"),new pl.type.Var("Tail")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Term("-", [new pl.type.Var("Template0"),new pl.type.Var("Goal0")]),new pl.type.Term("-", [new pl.type.Var("Template1"),new pl.type.Var("Goal1")])]),new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("Goal1")]),new pl.type.Term(",", [new pl.type.Term("copy_term", [new pl.type.Var("Template1"),new pl.type.Var("Template2")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Template2")]),new pl.type.Term("false", [])])])])]),new pl.type.Term("$flush_global_stack", [new pl.type.Var("Var"),new pl.type.Var("Instances"),new pl.type.Var("Tail")])]))
		],

		// '$bagof'/3
		"$bagof/3": [
			new pl.type.Rule(new pl.type.Term("$bagof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Answer")]),new pl.type.Var("KeySorted")])])])])])]))
		],

		// '$setof'/3
		"$setof/3": [
			new pl.type.Rule(new pl.type.Term("$setof", [new pl.type.Var("Template"),new pl.type.Var("Goal0"),new pl.type.Var("Answer")]), new pl.type.Term(",", [new pl.type.Term("$free_variable_set", [new pl.type.Term("^", [new pl.type.Var("Template"),new pl.type.Var("Goal0")]),new pl.type.Var("Goal1"),new pl.type.Var("FV")]),new pl.type.Term(",", [new pl.type.Term("findall", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Template")]),new pl.type.Var("Goal1"),new pl.type.Var("Answers"),new pl.type.Term("[]", [])]),new pl.type.Term(",", [new pl.type.Term("$bind_bagof_keys", [new pl.type.Var("Answers"),new pl.type.Var("_")]),new pl.type.Term(",", [new pl.type.Term("keygroup", [new pl.type.Var("Answers"),new pl.type.Var("KeyGroups")]),new pl.type.Term(",", [new pl.type.Term("keysort", [new pl.type.Var("KeyGroups"),new pl.type.Var("KeySorted")]),new pl.type.Term(",", [new pl.type.Term("$member", [new pl.type.Term("-", [new pl.type.Var("FV"),new pl.type.Var("Unsorted")]),new pl.type.Var("KeySorted")]),new pl.type.Term("sort", [new pl.type.Var("Unsorted"),new pl.type.Var("Answer")])])])])])])]))
		],

		// '$if/3'
		"$if/3": [
			new pl.type.Rule(new pl.type.Term("$if", [new pl.type.Var("If"),new pl.type.Var("Then"),new pl.type.Var("Else")]), new pl.type.Term(";", [new pl.type.Term(",", [new pl.type.Term("call", [new pl.type.Var("If")]),new pl.type.Term(",", [new pl.type.Term("$push_global_stack", [new pl.type.Var("Stack"),new pl.type.Var("_")]),new pl.type.Term("call", [new pl.type.Var("Then")])])]),new pl.type.Term(",", [new pl.type.Term("$flush_global_stack", [new pl.type.Var("Stack"),new pl.type.Term("[]", []),new pl.type.Term("[]", [])]),new pl.type.Term("call", [new pl.type.Var("Else")])])]))
		],


		// ATTRIBUTED VARIABLES
		
		//put_attr/3
		"put_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var subs = point.substitution.set_attribute( variable.id, module, value );
				thread.prepend( [new State( point.goal.replace(null), subs, point )] );
			}
		},

		// get_attr/3
		"get_attr/3": function( thread, point, atom ) {
			var variable = atom.args[0], module = atom.args[1], value = atom.args[2];
			if( !pl.type.is_variable(variable) ) {
				thread.throw_error( pl.error.type( "variable", variable, atom.indicator ) );
			} else if( !pl.type.is_atom(module) ) {
				thread.throw_error( pl.error.type( "atom", module, atom.indicator ) );
			} else {
				var attr = point.substitution.get_attribute( variable.id, module );
				if( attr ) {
					thread.prepend( [new State(
						point.goal.replace( new Term("=", [value, attr]) ),
						point.substitution,
						point
					)] );
				}
			}
		},


		
		// INPUT AND OUTPUT
		
		// op/3
		"op/3": function( thread, point, atom ) {
			var priority = atom.args[0], type = atom.args[1], operators = atom.args[2];
			if(pl.type.is_atom(operators))
				operators = new Term(".", [operators, new Term("[]")]);
			if( pl.type.is_variable( priority ) || pl.type.is_variable( type ) || pl.type.is_variable( operators ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( !pl.type.is_atom( type ) ) {
				thread.throw_error( pl.error.type( "atom", type, atom.indicator ) );
			} else if( !pl.type.is_list( operators ) ) {
				thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
			} else if( pl.type.is_empty_list( operators ) ) {
				thread.throw_error( pl.error.permission( "create", "operator", operators, atom.indicator ) );
			} else {
				var pointer = operators;
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var operator = pointer.args[0];
					pointer = pointer.args[1];
					if( pl.type.is_variable( operator ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( operator ) ) {
						thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
						return;
					} else if( priority.value < 0 || priority.value > 1200 ) {
						thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
						return;
					} else if( operator.id === "," ) {
						thread.throw_error( pl.error.permission( "modify", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "{}" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "[]" ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( operator.id === "|" && priority.value !== 0 && (priority.value < 1001 || type.id.length !== 3 ) ) {
						thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
						return;
					} else if( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"].indexOf( type.id ) === -1 ) {
						thread.throw_error( pl.error.domain( "operator_specifier", type, atom.indicator ) );
						return;
					} else {
						var fix = { prefix: null, infix: null, postfix: null };
						for( var p in thread.session.__operators ) {
							if(!thread.session.__operators.hasOwnProperty(p)) continue;
							var classes = thread.session.__operators[p][operator.id];
							if( classes ) {
								if( indexOf( classes, "fx" ) !== -1 ) { fix.prefix = { priority: p, type: "fx" }; }
								if( indexOf( classes, "fy" ) !== -1 ) { fix.prefix = { priority: p, type: "fy" }; }
								if( indexOf( classes, "xf" ) !== -1 ) { fix.postfix = { priority: p, type: "xf" }; }
								if( indexOf( classes, "yf" ) !== -1 ) { fix.postfix = { priority: p, type: "yf" }; }
								if( indexOf( classes, "xfx" ) !== -1 ) { fix.infix = { priority: p, type: "xfx" }; }
								if( indexOf( classes, "xfy" ) !== -1 ) { fix.infix = { priority: p, type: "xfy" }; }
								if( indexOf( classes, "yfx" ) !== -1 ) { fix.infix = { priority: p, type: "yfx" }; }
							}
						}
						var current_class;
						switch( type.id ) {
							case "fy": case "fx": current_class = "prefix"; break;
							case "yf": case "xf": current_class = "postfix"; break;
							default: current_class = "infix"; break;
						}
						if(fix.infix && current_class === "postfix" || fix.postfix && current_class === "infix") {
							thread.throw_error( pl.error.permission( "create", "operator", operator, atom.indicator ) );
							return;
						} else {
							if( fix[current_class] ) {
								remove( thread.session.__operators[fix[current_class].priority][operator.id], fix[current_class].type );
								if( thread.session.__operators[fix[current_class].priority][operator.id].length === 0 ) {
									delete thread.session.__operators[fix[current_class].priority][operator.id];
								}
							}
							if( priority.value > 0 ) {
								if( !thread.session.__operators[priority.value] ) thread.session.__operators[priority.value.toString()] = {};
								if( !thread.session.__operators[priority.value][operator.id] ) thread.session.__operators[priority.value][operator.id] = [];
								thread.session.__operators[priority.value][operator.id].push( type.id );
							}
						}
					}
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
					return;
				} else if(!pl.type.is_term(pointer) || pointer.indicator !== "[]/0") {
					thread.throw_error( pl.error.type( "list", operators, atom.indicator ) );
					return;
				} else {
					thread.success(point);
				}
			}
		},
		
		// current_op/3
		"current_op/3": function( thread, point, atom ) {
			var priority = atom.args[0], specifier = atom.args[1], operator = atom.args[2];
			var points = [];
			if( !pl.type.is_variable( priority ) && !pl.type.is_integer( priority ) ) {
				thread.throw_error( pl.error.type( "integer", priority, atom.indicator ) );
			} else if( pl.type.is_integer( priority ) && ( priority.value < 0 || priority.value > 1200 ) ) {
				thread.throw_error( pl.error.domain( "operator_priority", priority, atom.indicator ) );
			} else if( !pl.type.is_variable( specifier ) && !pl.type.is_atom( specifier ) ) {
				thread.throw_error( pl.error.type( "atom", specifier, atom.indicator ) );
			} else if( pl.type.is_atom( specifier ) && indexOf( ["fy", "fx", "yf", "xf", "xfx", "yfx", "xfy"], specifier.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "operator_specifier", specifier, atom.indicator ) );
			} else if( !pl.type.is_variable( operator ) && !pl.type.is_atom( operator ) ) {
				thread.throw_error( pl.error.type( "atom", operator, atom.indicator ) );
			} else {
				for( var p in thread.session.__operators )
					for( var o in thread.session.__operators[p] )
						for( var i = 0; i < thread.session.__operators[p][o].length; i++ )
							points.push( new State(
								point.goal.replace(
									new Term( ",", [
										new Term( "=", [new Num( p, false ), priority] ),
										new Term( ",", [
											new Term( "=", [new Term( thread.session.__operators[p][o][i], [] ), specifier] ),
											new Term( "=", [new Term( o, [] ), operator] )
										] )
									] )
								),
								point.substitution,
								point
							) );
				thread.prepend( points );
			}
		},
	


		// LOGIC AND CONTROL STRUCTURES
	
		// ;/2 (disjunction)
		";/2": function(thread, point, atom) {
			var left = atom.args[0], right = atom.args[1];
			var context_left = left.args[0];
			var free_left = left.indicator === ":/2" ? left.args[1] : left;
			// if then else
			if(pl.type.is_term(free_left) && free_left.indicator === "->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, new Term("call", [free_left.args[0]])]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				var goal_fst = point.goal.replace(new Term( ",", [cond, new Term(",", [new Term("!"), then])] ) );
				var goal_snd = point.goal.replace(new Term( ",", [new Term("!"), otherwise]));
				thread.prepend([
					new State(goal_fst, point.substitution, point),
					new State(goal_snd, point.substitution, point)
				]);
			// soft-cut
			} else if(pl.type.is_term(free_left) && free_left.indicator === "*->/2") {
				var cond = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[0]]) : free_left.args[0];
				var then = left.indicator === ":/2" ? new Term(":", [context_left, free_left.args[1]]) : free_left.args[1];
				var otherwise = right;
				thread.prepend([new State(
					point.goal.replace(new Term("$if", [cond, then, otherwise])),
					point.substitution,
					point
				)]);
			// otherwise
			} else {
				thread.prepend([
					new State(point.goal.replace(left), point.substitution, point),
					new State(point.goal.replace(right), point.substitution, point)
				]);
			}
		},
		
		// !/0 (cut)
		"!/0": function( thread, point, atom ) {
			var parent_cut, last_cut, states = [];
			parent_cut = point;
			last_cut = null;
			while( parent_cut.parent !== null && parent_cut.parent.goal.search( atom ) ) {
				last_cut = parent_cut;
				parent_cut = parent_cut.parent;
				if(parent_cut.goal !== null) {
					var selected = parent_cut.goal.select();
					if(selected && selected.indicator === ":/2")
						selected = selected.args[1];
					if( selected && selected.id === "call" && selected.search(atom) ) {
						parent_cut = last_cut;
						break;
					}
				}
			}
			var setup_call_cleanup = null;
			for( var i = thread.points.length-1; i >= 0; i-- ) {
				var state = thread.points[i];
				var node = state.parent;
				while( node !== null && node !== parent_cut.parent ) {
					node = node.parent;
				}
				if( node === null && node !== parent_cut.parent )
					states.push( state );
				else if(state.setup_call_cleanup_goal)
					setup_call_cleanup = state.setup_call_cleanup_goal
			}
			thread.points = states.reverse();
			thread.prepend([new State(
				point.goal.replace(setup_call_cleanup),
				point.substitution,
				point
			)]);
		},
		
		// \+ (negation)
		"\\+/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			if( pl.type.is_variable( goal ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( goal ) ) {
				thread.throw_error( pl.error.type( "callable", goal, atom.indicator ) );
			} else {
				// TRANSPARENT VERSION OF THE NEGATION
				/*var neg_thread;
				if(point.negation_thread) {
					neg_thread = point.negation_thread;
				} else {
					neg_thread = new Thread( thread.session );
					neg_thread.add_goal( goal );
					point.negation_thread = neg_thread;
				}
				neg_thread.answer( function( answer ) {
					if(answer === false) {
						thread.success( point );
					} else if(pl.type.is_error( answer )) {
						thread.throw_error( answer.args[0] );
					} else if(answer === null) {
						thread.prepend( [point] );
						thread.current_limit = 0;
					}
					thread.again( answer !== null );
				} );
				return true;*/
				
				// '\+'(X) :- call(X), !, fail.
				// '\+'(_).
				thread.prepend( [
					new State( point.goal.replace( new Term( ",", [new Term( ",", [ new Term( "call", [goal] ), new Term( "!", [] ) ] ), new Term( "fail", [] ) ] ) ), point.substitution, point ),
					new State( point.goal.replace( null ), point.substitution, point )
				] );
			}
		},
		
		// ->/2 (implication)
		"->/2": function( thread, point, atom ) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]),
				new Term(",", [new Term("!"), then])
			]));
			thread.prepend( [new State( goal, point.substitution, point )] );
		},

		// *->/2 (soft-cut)
		"*->/2": function(thread, point, atom) {
			var cond = atom.args[0], then = atom.args[1];
			var goal = point.goal.replace(new Term(",", [
				new Term("call", [cond]), then]));
			thread.prepend([new State(goal, point.substitution, point)]);
		},
		
		// fail/0
		"fail/0": function( _1, _2, _3 ) {},
		
		// false/0
		"false/0": function( _1, _2, _3 ) {},
		
		// true/0
		"true/0": function( thread, point, _ ) {
			thread.success( point );
		},
		
		// call/1..8
		"call/1": callN(1),
		"call/2": callN(2),
		"call/3": callN(3),
		"call/4": callN(4),
		"call/5": callN(5),
		"call/6": callN(6),
		"call/7": callN(7),
		"call/8": callN(8),
		
		// once/1
		"once/1": function( thread, point, atom ) {
			var goal = atom.args[0];
			thread.prepend( [new State( point.goal.replace( new Term( ",", [new Term( "call", [goal] ), new Term( "!", [] )] ) ), point.substitution, point )] );
		},
		
		// forall/2
		"forall/2": function( thread, point, atom ) {
			var generate = atom.args[0], test = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "\\+", [new Term( ",", [new Term( "call", [generate] ), new Term( "\\+", [new Term( "call", [test] )] )] )] ) ), point.substitution, point )] );
		},
		
		// repeat/0
		"repeat/0": function( thread, point, _ ) {
			thread.prepend( [new State( point.goal.replace( null ), point.substitution, point ), point] );
		},

		// EXCEPTIONS
		
		// throw/1
		"throw/1": function( thread, point, atom ) {
			var error = atom.args[0];
			if(pl.type.is_variable(error)) {
				thread.throw_error(pl.error.instantiation(thread.level.indicator));
			} else {
				for(var i = 0; i < thread.points.length; i++) {
					var state = thread.points[i];
					if(state.setup_call_cleanup_catch) {
						thread.points = [new State(
							new Term(",", [
								new Term("catch", [
									state.setup_call_cleanup_catch,
									new Var("_"),
									new Term("throw", [error])
								]),
								new Term("throw", [error])
							]),
							point.substitution,
							point
						)];
						return;
					}
					
				}
				thread.throw_error(error);
			}
		},
		
		// catch/3
		"catch/3": function(thread, point, atom) {
			var goal = atom.args[0], catcher = atom.args[1], recover = atom.args[2];
			var nthread;
			if(!point.catch) {
				nthread = new Thread(thread.session);
				nthread.debugger = thread.debugger;
				nthread.format_success = function(state) { return state.substitution; };
				nthread.format_error = function(state) { return state.goal; };
				nthread.add_goal(goal, true, point);
				point.catch = nthread;
			} else {
				nthread = point.catch;
			}
			var callback = function(answer) {
				if(pl.type.is_error(answer)) {
					var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
					var state = new State();
					var mgu = pl.unify(answer.args[0], catcher, occurs_check);
					if(mgu !== null) {
						state.substitution = point.substitution.apply(mgu);
						state.goal = point.goal.replace(recover).apply(mgu);
						state.parent = point;
						thread.prepend([state]);
					} else {
						thread.throw_error(answer.args[0]);
					}
				} else if(answer !== false && answer !== null) {
					var state = answer === null ? [] : new State(
						point.goal.apply(answer).replace(null),
						point.substitution.apply(answer),
						point
					);
					thread.prepend([state, point]);
				} else if(answer === null) {
					thread.prepend([point]);
					if(thread.has_limit)
						thread.current_limit = 0;
				}
				thread.again(answer !== null);
			};
			nthread.answer(callback);
			return true;
		},

		// call_cleanup/2
		"call_cleanup/2": function(thread, point, atom) {
			var call = atom.args[0], cleanup = atom.args[1];
			if(pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				var nthread, callback;
				if(point.hasOwnProperty("setup_call_cleanup_thread")) {
					nthread = point.setup_call_cleanup_thread;
					callback = point.setup_call_cleanup_callback;
				} else {
					var goal = new Term("call", [call]);
					nthread = new Thread(thread.session);
					nthread.add_goal(goal, true, point);
					callback = function(answer) {
						if(answer === null) {
							var state = new State(
								point.goal,
								point.substitution,
								point
							);
							state.setup_call_cleanup_thread = nthread;
							state.setup_call_cleanup_callback = callback;
							thread.prepend([state]);
						} else if(answer === false) {
							var cleanup_and_fail = new Term(",", [
								new Term("call", [cleanup]),
								new Term("fail")
							]);
							var state = new State(
								point.goal.replace(cleanup_and_fail),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else if(pl.type.is_error(answer)) {
							var cleanup_and_throw = new Term(",", [
								new Term("call", [cleanup]),
								answer
							]);
							var state = new State(
								point.goal.replace(cleanup_and_throw),
								point.substitution,
								point
							);
							thread.prepend([state]);
						} else {
							if(nthread.points.length === 0) {
								var state = new State(
									point.goal.replace(
										new Term("call", [cleanup])
									).apply(answer),
									point.substitution.apply(answer),
									point
								);
								thread.prepend([state]);
							} else {
								var state1 = new State(
									point.goal.apply(answer).replace(null),
									point.substitution.apply(answer),
									point
								);
								var state2 = new State(
									point.goal,
									point.substitution,
									point
								);
								state2.setup_call_cleanup_thread = nthread;
								state2.setup_call_cleanup_callback = callback;
								state2.setup_call_cleanup_goal = cleanup.apply(answer);
								state2.setup_call_cleanup_catch = cleanup;
								thread.prepend([state1, state2]);
							}
						}
						thread.again();
					}
				}
				nthread.answer(callback);
				return true;
			}
		},

		// setup_call_cleanup/3
		"setup_call_cleanup/3": function(thread, point, atom) {
			var setup = atom.args[0], call = atom.args[1], cleanup = atom.args[2];
			if(pl.type.is_variable(setup) || pl.type.is_variable(call) || pl.type.is_variable(cleanup)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(setup)) {
				thread.throw_error(pl.error.type("callable", setup, atom.indicator));
			} else if(!pl.type.is_callable(call)) {
				thread.throw_error(pl.error.type("callable", call, atom.indicator));
			} else if(!pl.type.is_callable(cleanup)) {
				thread.throw_error(pl.error.type("callable", cleanup, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term(",", [
						new Term("once", [setup]),
						new Term("call_cleanup", [call, cleanup])
					])),
					point.substitution,
					point
				)]);
			}
		},
		
		// UNIFICATION
		
		// =/2 (unification)
		"=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// unify_with_occurs_check/2
		"unify_with_occurs_check/2": function( thread, point, atom ) {
			var state = new State();
			var mgu = pl.unify( atom.args[0], atom.args[1], true );
			if( mgu !== null ) {
				state.goal = point.goal.apply( mgu ).replace( null );
				state.substitution = point.substitution.apply( mgu );
				state.parent = point;
				thread.prepend( [state] );
			}
		},
		
		// \=/2
		"\\=/2": function( thread, point, atom ) {
			var occurs_check = thread.get_flag( "occurs_check" ).indicator === "true/0";
			var mgu = pl.unify( atom.args[0], atom.args[1], occurs_check );
			if( mgu === null ) {
				thread.success( point );
			}
		},
		
		// subsumes_term/2
		/*
		subsumes_term(General, Specific) :-
			\+ \+ (
			term_variables(Specific, Vars1),
			unify_with_occurs_check(General, Specific),
			term_variables(Vars1, Vars2),
			Vars1 == Vars2
		).
		*/
		"subsumes_term/2": function( thread, point, atom ) {
			var general = atom.args[0], specific = atom.args[1];
			var vars1 = thread.next_free_variable();
			var vars2 = thread.next_free_variable();
			thread.prepend([new State(
				point.goal.replace(new Term("\\+", [
					new Term("\\+", [
						new Term(",", [
							new Term("term_variables", [specific, vars1]),
							new Term(",", [
								new Term("unify_with_occurs_check", [general, specific]),
								new Term(",", [
									new Term("term_variables", [vars1, vars2]),
									new Term("==", [vars1, vars2])
								])
							])
						])
					])
				])),
				point.substitution,
				point
			)]);
		},
		
		// ALL SOLUTIONS

		// findall/3
		"findall/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			var tail = new Term("[]", []);
			thread.prepend([new State(
				point.goal.replace(new Term("findall", [template, goal, instances, tail])),
				point.substitution,
				point
			)]);
		},

		// findall/4
		"findall/4": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2], tail = atom.args[3];
			var proper_goal = goal;
			if(pl.type.is_term(goal) && goal.indicator === ":/2")
				proper_goal = goal.args[1];
			if(pl.type.is_variable(proper_goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(proper_goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error(pl.error.type("list", instances, atom.indicator));
			} else if(!pl.type.is_variable(tail) && !pl.type.is_list(tail)) {
				thread.throw_error(pl.error.type("list", tail, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$findall", [template, goal, instances, tail])),
					point.substitution,
					point
				)]);
			}
		},
		
		// bagof/3
		"bagof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$bagof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},

		// setof/3
		"setof/3": function(thread, point, atom) {
			var template = atom.args[0], goal = atom.args[1], instances = atom.args[2];
			if(pl.type.is_variable(goal)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(goal)) {
				thread.throw_error(pl.error.type("callable", goal, atom.indicator));
			} else if(!pl.type.is_variable(instances) && !pl.type.is_list(instances)) {
				thread.throw_error( pl.error.type("list", instances, atom.indicator));
			} else {
				thread.prepend([new State(
					point.goal.replace(new Term("$setof", [template, goal, instances])),
					point.substitution,
					point
				)]);
			}
		},
		
		// TERM CREATION AND DECOMPOSITION
		
		// functor/3
		"functor/3": function( thread, point, atom ) {
			var subs;
			var term = atom.args[0], name = atom.args[1], arity = atom.args[2];
			if( pl.type.is_variable( term ) && (pl.type.is_variable( name ) || pl.type.is_variable( arity )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( arity ) && !pl.type.is_integer( arity ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[2], atom.indicator ) );
			} else if( !pl.type.is_variable( name ) && !pl.type.is_atomic( name ) ) {
				thread.throw_error( pl.error.type( "atomic", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && !pl.type.is_atom( name ) && pl.type.is_integer( arity ) && arity.value > 0 ) {
				thread.throw_error( pl.error.type( "atom", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( term ) && pl.type.is_integer( arity ) && arity.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[2], atom.indicator ) );
			} else if( pl.type.is_variable( term ) ) {
				if( atom.args[2].value >= 0 ) {
					var args = [];
					for( var i = 0; i < arity.value; i++ )
						args.push( thread.next_free_variable() );
					var functor = pl.type.is_number( name ) ? name : new Term( name.id, args );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [term, functor] ) ), point.substitution, point )] );
				}
			} else {
				var id = pl.type.is_number( term ) ? term : new Term( term.id, [] );
				var length = pl.type.is_number( term ) ? new Num( 0, false ) : new Num( term.args.length, false );
				var goal = new Term( ",", [new Term( "=", [id, name] ), new Term( "=", [length, arity] )] );
				thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
			}
		},
		
		// arg/3
		"arg/3": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) || pl.type.is_variable( atom.args[1] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[0], atom.indicator ) );
			} else if( atom.args[0].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_compound( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "compound", atom.args[1], atom.indicator ) );
			} else {
				var n = atom.args[0].value;
				if( n > 0 && n <= atom.args[1].args.length ) {
					var goal = new Term( "=", [atom.args[1].args[n-1], atom.args[2]] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				}
			}
		},
		
		// =../2 (univ)
		"=../2": function( thread, point, atom ) {
			var list;
			if( pl.type.is_variable( atom.args[0] ) && (pl.type.is_variable( atom.args[1] )
			|| pl.type.is_non_empty_list( atom.args[1] ) && pl.type.is_variable( atom.args[1].args[0] )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_fully_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "list", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_variable( atom.args[0] ) && pl.type.is_empty_list( atom.args[1] ) ) {
				thread.throw_error( pl.error.domain( "non_empty_list", atom.args[1], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[0] ) ) {
				if( pl.type.is_term( atom.args[0] ) && atom.args[0].args.length > 0 ) {
					list = new Term( "[]" );
					for( var i = atom.args[0].args.length - 1; i >= 0; i-- ) {
						list = new Term( ".", [atom.args[0].args[i], list] );
					}
					list = new Term( ".", [new Term( atom.args[0].id ), list] );
				} else {
					list = new Term( ".", [atom.args[0], new Term( "[]" )] );
				}
				thread.prepend( [new State( point.goal.replace( new Term( "=", [list, atom.args[1]] ) ), point.substitution, point )] );
			} else if( !pl.type.is_variable( atom.args[1] ) ) {
				var args = [];
				list = atom.args[1].args[1];
				while( list.indicator === "./2" ) {
					args.push( list.args[0] );
					list = list.args[1];
				}
				if( pl.type.is_variable( atom.args[0] ) && pl.type.is_variable( list ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( args.length === 0 && pl.type.is_compound( atom.args[1].args[0] ) ) {
					thread.throw_error( pl.error.type( "atomic", atom.args[1].args[0], atom.indicator ) );
				} else if( args.length > 0 && (pl.type.is_compound( atom.args[1].args[0] ) || pl.type.is_number( atom.args[1].args[0] )) ) {
					thread.throw_error( pl.error.type( "atom", atom.args[1].args[0], atom.indicator ) );
				} else {
					if( args.length === 0 ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[1].args[0], atom.args[0]], point ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( atom.args[1].args[0].id, args ), atom.args[0]] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// copy_term/2
		"copy_term/2": function(thread, point, atom) {
			var original_term = atom.args[0], renamed_term = atom.args[1];
			thread.session.renamed_variables = {};
			var new_term = original_term.rename(thread);
			thread.session.renamed_variables = {};
			thread.prepend([
				new State(
					point.goal.replace(new Term("=", [renamed_term, new_term])),
					point.substitution,
					point)
				]
			);
		},
		
		// term_variables/2
		"term_variables/2": [
			new pl.type.Rule(new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars")]), new pl.type.Term("term_variables", [new pl.type.Var("Term"),new pl.type.Var("Vars"),new pl.type.Term("[]", [])]))
		],

		// term_variables/3
		"term_variables/3": function(thread, point, atom) {
			var term = atom.args[0], vars = atom.args[1], tail = atom.args[2];
			if( !pl.type.is_fully_list( vars ) ) {
				thread.throw_error( pl.error.type( "list", vars, atom.indicator ) );
			} else {
				var list = arrayToList(map(nub(term.variables()), function(v) {
					return new Var(v);
				}), tail);
				thread.prepend([new State(
					point.goal.replace(new Term("=", [vars, list])),
					point.substitution,
					point
				)]);
			}
		},

		// numbervars/3
		"numbervars/3": function(thread, point, atom) {
			var term = atom.args[0], start = atom.args[1], end = atom.args[2];
			if(pl.type.is_variable(start)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_integer(start)) {
				thread.throw_error(pl.error.type("integer", start, atom.indicator));
			} else if(!pl.type.is_variable(end) && !pl.type.is_integer(end)) {
				thread.throw_error(pl.error.type("integer", end, atom.indicator));
			} else {
				var variables = nub(term.variables());
				var value = start.value;
				var unif_body = new Term("true");
				for(var i = 0; i < variables.length; i++) {
					unif_body = new Term(",", [
						new Term("=", [
							new Var(variables[i]),
							new Term("$VAR", [new Num(value, false)])]),
							unif_body]);
					value++;
				}
				var unif_end = new Term("=", [end, new Num(value, false)]);
				if(pl.type.is_variable(end) || end.value === value) {
					thread.prepend([new State(
						point.goal.replace(new Term(",", [unif_body, unif_end])),
						point.substitution,
						point
					)]);
				}
			}
		},
		
		// CLAUSE RETRIEVAL AND INFORMATION
		
		// clause/2
		"clause/2": function(thread, point, atom) {
			var head = atom.args[0], body = atom.args[1];
			var module_id = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			var get_module = thread.session.modules[module_id];
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(body) && !pl.type.is_callable(body)) {
				thread.throw_error(pl.error.type("callable", body, atom.indicator));
			} else if(head.indicator === ",/2" || thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
			} else if(pl.type.is_module(get_module) && get_module.rules[head.indicator]) {
				if(get_module.is_public_predicate(head.indicator)) {
					var states = [];
					if(typeof get_module.rules[head.indicator] === "function") {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
						return;
					}
					for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
						var rule = get_module.rules[head.indicator][i];
						thread.session.renamed_variables = {};
						rule = rule.rename(thread);
						if(rule.body === null)
							rule.body = new Term("true");
						var goal = new Term(",", [
							new Term("=", [rule.head, head]),
							new Term("=", [rule.body, body])
						]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				} else {
					thread.throw_error(pl.error.permission("access", "private_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// current_predicate/1
		"current_predicate/1": function(thread, point, atom) {
			var indicator = atom.args[0];
			var module_id;
			if(pl.type.is_term(indicator) && indicator.indicator === ":/2") {
				if(!pl.type.is_atom(indicator.args[0])) {
					thread.throw_error(pl.error.type("module", indicator.args[0], atom.indicator));
					return;
				}
				module_id = indicator.args[0].id;
				indicator = indicator.args[1];
			} else {
				module_id = "user";
			}
			if(!pl.type.is_variable(indicator) && (!pl.type.is_compound(indicator) || indicator.indicator !== "//2")) {
				thread.throw_error(pl.error.type( "predicate_indicator", indicator, atom.indicator));
			} else if(!pl.type.is_variable( indicator ) && !pl.type.is_variable(indicator.args[0]) && !pl.type.is_atom(indicator.args[0])) {
				thread.throw_error(pl.error.type( "atom", indicator.args[0], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && !pl.type.is_variable(indicator.args[1]) && !pl.type.is_integer(indicator.args[1])) {
				thread.throw_error(pl.error.type("integer", indicator.args[1], atom.indicator));
			} else if(!pl.type.is_variable(indicator) && pl.type.is_integer(indicator.args[1]) && indicator.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", indicator.args[1], atom.indicator));
			} else {
				var states = [];
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					for(var prop in get_module.rules) {
						if(!get_module.rules.hasOwnProperty(prop))
							continue;
						var predicate = str_indicator(prop);
						var goal = new Term("=", [predicate, indicator]);
						states.push(new State(point.goal.replace(goal), point.substitution, point));
					}
					thread.prepend(states);
				}
			}
		},

		// current_module/1
		"current_module/1": function(thread, point, atom) {
			var module_id = atom.args[0];
			if(!pl.type.is_variable(module_id) && !pl.type.is_atom(module_id)) {
				thread.throw_error(pl.error.type("atom", module_id, atom.indicator));
			} else {
				if(pl.type.is_variable(module_id)) {
					var states = [];
					for(var prop in thread.session.modules) {
						if(!thread.session.modules.hasOwnProperty(prop))
							continue;
						states.push(new State(
							point.goal.replace(new Term("=", [module_id, new Term(prop)])),
							point.substitution,
							point
						));
					}
					thread.prepend(states);
				} else {
					if(thread.session.modules.hasOwnProperty(module_id.id))
						thread.success(point);
				}
			}
		},

		// predicate_property/2
		"predicate_property/2": function(thread, point, atom) {
			var head = atom.args[0], property = atom.args[1];
			var module_id;
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				if(!pl.type.is_atom(head.args[0])) {
					thread.throw_error(pl.error.type("module", head.args[0], atom.indicator));
					return;
				}
				module_id = head.args[0].id;
				head = head.args[1];
			}
			if(!pl.type.is_variable(head) && !pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_predicate_property(property)) {
				thread.throw_error(pl.error.domain("predicate_property", property, atom.indicator));
			} else {
				var get_module = module_id ? thread.session.modules[module_id] : thread.session.modules.user;
				var points = [];
				// all predicates
				if(pl.type.is_variable(head)) {
					// built-in predicates (built_in + static + native_code + meta_predicate?)
					if(!module_id) {
						for(var prop in pl.builtin.rules) {
							if(!pl.builtin.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
							if(pl.builtin.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									pl.builtin.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
					// user-defined predicates
					if(pl.type.is_module(get_module)) {
						for(var prop in get_module.rules) {
							if(!get_module.rules.hasOwnProperty(prop))
								continue;
							var indicator = str_indicator(prop);
							var args = [];
							for(var i = 0; i < indicator.args[1].value; i++)
								args.push(thread.next_free_variable());
							var unif_head = new Term(indicator.args[0].id, args);
							var current_properties = [];
							if(thread.is_public_predicate(prop, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(get_module.rules[prop] instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(prop, module_id))
								current_properties.push(new Term("multifile"));
							if(get_module.meta_predicates.hasOwnProperty(prop))
								current_properties.push(new Term("meta_predicate", [
									get_module.meta_predicates[prop]
								]));
							// all predicates, one property / all properties
							for(var i = 0; i < current_properties.length; i++) {
								if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
									points.push(new State(
										point.goal.replace(new Term(",", [
											new Term("=", [head, unif_head]),
											new Term("=", [property, current_properties[i]])
										])),
										point.substitution,
										point
									));
								}
							}
						}
					}
				// one predicate
				} else {
					var builtin = !module_id && pl.type.is_builtin(head);
					var predicate = builtin ? pl.builtin.rules[head.indicator] : get_module.rules[head.indicator];
					get_module = builtin ? pl.builtin : get_module;
					if(predicate) {
						var current_properties;
						if(builtin) {
							current_properties = [
								new Term("static"),
								new Term("built_in"),
								new Term("native_code")
							];
						} else {
							current_properties = [];
							if(thread.is_public_predicate(head.indicator, module_id))
								current_properties.push(new Term("dynamic"));
							else
								current_properties.push(new Term("static"));
							if(predicate instanceof Function)
								current_properties.push(new Term("native_code"));
							if(thread.is_multifile_predicate(head.indicator, module_id))
								current_properties.push(new Term("multifile"));
						}
						if(get_module.meta_predicates.hasOwnProperty(head.indicator))
							current_properties.push(new Term("meta_predicate", [
								get_module.meta_predicates[head.indicator]
							]));
						var args = [];
						for(var i = 0; i < head.args.length; i++)
							args.push(thread.next_free_variable());
						var unif_head = new Term(head.id, args);
						// one predicate, one property / all properties
						for(var i = 0; i < current_properties.length; i++) {
							if(pl.type.is_variable(property) || current_properties[i].indicator === property.indicator) {
								points.push(new State(
									point.goal.replace(new Term(",", [
										new Term("=", [head, unif_head]),
										new Term("=", [property, current_properties[i]])
									])),
									point.substitution,
									point
								));
							}
						}
					}
				}
				thread.prepend(points);
			}
		},

		// listing/0
		"listing/0": function( thread, point, atom ) {
			var context_module = atom.context_module ? atom.context_module : "user";
			var rules = {};
			if(pl.type.is_module(thread.session.modules[context_module])) {
				rules = thread.session.modules[context_module].rules;
			}
			var str = "";
			for(var indicator in rules) {
				if(!rules.hasOwnProperty(indicator)) continue;
				var predicate = rules[indicator];
				str += "% " + indicator + "\n";
				if(predicate instanceof Array) {
					for(var i = 0; i < predicate.length; i++)
						str += predicate[i].toString( {session: thread.session} ) + "\n";
				} else {
					str += "/*\n" + predicate.toString() + "\n*/";
				}
				str += "\n";
			}
			thread.prepend( [new State(
				point.goal.replace(new Term("write", [new Term(str, [])])),
				point.substitution,
				point
			)] );
		},

		// listing/1
		"listing/1": function( thread, point, atom ) {
			var indicator = atom.args[0];
			var context_module = "user";
			if(indicator.indicator === ":/2") {
				context_module = indicator.args[0].id;
				indicator = indicator.args[1];
			}
			if(pl.type.is_variable(indicator)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_predicate_indicator(indicator)) {
				thread.throw_error( pl.error.type( "predicate_indicator", indicator, atom.indicator ) );
			} else {
				var rules = {};
				if(pl.type.is_module(thread.session.modules[context_module])) {
					rules = thread.session.modules[context_module].rules;
				}
				var str = "";
				var str_indicator = indicator.args[0].id + "/" + indicator.args[1].value;
				if(rules.hasOwnProperty(str_indicator)) {
					var predicate = rules[str_indicator];
					if(predicate instanceof Array) {
						for(var i = 0; i < predicate.length; i++)
							str += predicate[i].toString( {session: thread.session} ) + "\n";
					} else {
						str += "/*\n" + predicate.toString() + "\n*/";
					}
					str += "\n";
				}
				thread.prepend( [new State(
					point.goal.replace(new Term("write", [new Term(str, [])])),
					point.substitution,
					point
				)] );
			}
		},

		// LIST OPERATIONS

		// sort/2
		"sort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					arr.push( pointer.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					var sorted_arr = arr.sort( pl.compare );
					for( var i = sorted_arr.length-1; i > 0; i-- ) {
						if( sorted_arr[i].equals(sorted_arr[i-1]) )
							sorted_arr.splice(i,1);
					}
					var sorted_list = new Term( "[]" );
					for( var i = sorted_arr.length-1; i >= 0; i-- ) {
						sorted_list = new Term( ".", [sorted_arr[i], sorted_list] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keysort/2
		"keysort/2": function( thread, point, atom ) {
			var list = atom.args[0], expected = atom.args[1];
			if( pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( expected ) && !pl.type.is_fully_list( expected ) ) {
				thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
			} else {
				var arr = [];
				var elem;
				var pointer = list;
				while( pointer.indicator === "./2" ) {
					elem = pointer.args[0];
					if( pl.type.is_variable( elem ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_term( elem ) || elem.indicator !== "-/2" ) {
						thread.throw_error( pl.error.type( "pair", elem, atom.indicator ) );
						return;
					}
					elem.args[0].pair = elem.args[1];
					arr.push( elem.args[0] );
					pointer = pointer.args[1];
				}
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_empty_list( pointer ) ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error( pl.error.type( "pair", head, atom.indicator ) );
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error( pl.error.type( "list", expected, atom.indicator ) );
							return;
						}
					}
					var sorted_arr = arr.sort( pl.compare );
					var sorted_list = new pl.type.Term( "[]" );
					for( var i = sorted_arr.length - 1; i >= 0; i-- ) {
						sorted_list = new pl.type.Term( ".", [new pl.type.Term( "-", [sorted_arr[i], sorted_arr[i].pair] ), sorted_list] );
						delete sorted_arr[i].pair;
					}
					thread.prepend( [new pl.type.State( point.goal.replace( new pl.type.Term( "=", [sorted_list, expected] ) ), point.substitution, point )] );
				}
			}
		},

		// keygroup
		"keygroup/2": function(thread, point, atom) {
			var list = atom.args[0], expected = atom.args[1];
			if(pl.type.is_variable(list)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(expected) && !pl.type.is_fully_list(expected)) {
				thread.throw_error(pl.error.type("list", expected, atom.indicator));
			} else {
				var keys = [];
				var values = [];
				var pointer = list
				while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
					var elem = pointer.args[0];
					if(pl.type.is_variable(elem)) {
						thread.throw_error(pl.error.instantiation(atom.indicator));
						return;
					} else if(!pl.type.is_term(elem) || elem.indicator !== "-/2") {
						thread.throw_error(pl.error.type("pair", elem, atom.indicator));
						return;
					}
					var key = elem.args[0], value = elem.args[1];
					var index = -1;
					for(var i = 0; i < keys.length; i++) {
						if(pl.compare(key, keys[i]) === 0) {
							index = i;
							break;
						}
					}
					if(index === -1) {
						index = keys.length;
						keys.push(key);
						values.push([]);
					}
					values[index].push(value);
					pointer = pointer.args[1];
				}
				if(pl.type.is_variable(pointer)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_empty_list(pointer)) {
					thread.throw_error(pl.error.type("list", list, atom.indicator));
				} else {
					if(!pl.type.is_variable(expected)) {
						var pointer = expected;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							var head = pointer.args[0];
							if(!pl.type.is_variable(head) && (!pl.type.is_term(head) || head.indicator !== "-/2")) {
								thread.throw_error(pl.error.type("pair", head, atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
						if(!pl.type.is_variable(pointer) && !pl.type.is_empty_list(pointer)) {
							thread.throw_error(pl.error.type("list", expected, atom.indicator));
							return;
						}
					}
					group = new Term("[]", []);
					for(var i = keys.length-1; i >= 0; i--)
						group = new Term(".", [new Term("-", [keys[i], arrayToList(values[i])]), group]);
					thread.prepend([
						new State(
							point.goal.replace(new pl.type.Term("=", [expected, group])),
							point.substitution,
							point
						)
					]);
				}
			}
		},
		
		// CLAUSE CREATION AND DESTRUCTION
		
		// asserta/1
		"asserta/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator] = [new Rule(head, body, true)].concat(get_module.rules[head.indicator]);
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// assertz/1
		"assertz/1": function(thread, point, atom) {
			var clause = atom.args[0];
			var module_id = "user";
			if(pl.type.is_term(clause) && clause.indicator === ":/2") {
				module_id = clause.args[0].id;
				clause = clause.args[1];
			}
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, get_module;
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = body_conversion(clause.args[1]);
				} else {
					head = clause;
					body = null;
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
				} else if(body !== null && !pl.type.is_callable(body)) {
					thread.throw_error( pl.error.type("callable", body, atom.indicator));
				} else if((!pl.type.is_module(thread.session.modules[module_id])
				|| thread.is_public_predicate(head.indicator, module_id))
				&& head.indicator !== ",/2"
				&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
					if(!pl.type.is_module(thread.session.modules[module_id])) {
						get_module = new Module(module_id, {}, "all", {session: thread.session});
						thread.session.modules[module_id] = get_module;
					} else {
						get_module = thread.session.modules[module_id];
					}
					if(get_module.rules[head.indicator] === undefined)
						get_module.rules[head.indicator] = [];
					get_module.public_predicates[head.indicator] = true;
					get_module.rules[head.indicator].push(new Rule(head, body, true));
					get_module.update_indices_predicate(head.indicator);
					thread.success(point);
				} else {
					thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
				}
			}
		},
		
		// retract/1
		"retract/1": function(thread, point, atom) {
			var clause = atom.args[0];
			if(pl.type.is_variable(clause)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(clause)) {
				thread.throw_error(pl.error.type("callable", clause, atom.indicator));
			} else {
				var head, body, module_atom, module_id;
				if(clause.indicator === ":/2") {
					module_atom = clause.args[0];
					clause = clause.args[1];
					if(!pl.type.is_atom(module_atom)) {
						thread.throw_error(pl.error.type("module", module_atom, atom.indicator));
						return;
					}
				} else {
					module_atom = new Term("user");
				}
				if(clause.indicator === ":-/2") {
					head = clause.args[0];
					body = clause.args[1];
				} else {
					head = clause;
					body = new Term("true");
				}
				if(pl.type.is_variable(head)) {
					thread.throw_error(pl.error.instantiation(atom.indicator));
					return;
				} else if(!pl.type.is_callable(head)) {
					thread.throw_error(pl.error.type("callable", head, atom.indicator));
					return;
				}
				module_id = module_atom.id;
				var get_module = thread.session.modules[module_id];
				if(!pl.type.is_module(get_module))
					return;
				if(!point.retract) {
					if(thread.is_public_predicate(head.indicator, module_id)
					&& head.indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
						if(get_module.rules[head.indicator] !== undefined) {
							var states = [];
							if(typeof get_module.rules[head.indicator] === "function") {
								thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
								return;
							}
							for(var i = 0; i < get_module.rules[head.indicator].length; i++) {
								thread.session.renamed_variables = {};
								var orule = get_module.rules[head.indicator][i];
								var rule = orule.rename(thread);
								if(rule.body === null)
									rule.body = new Term("true", []);
								var occurs_check = thread.get_flag("occurs_check").indicator === "true/0";
								var mgu = pl.unify(new Term(",", [head, body]), new Term(",", [rule.head, rule.body]), occurs_check);
								if(mgu !== null) {
									var state = new State(
										point.goal.replace(new Term(",", [
											new Term(":", [
												module_atom,
												new Term("retract", [new Term(":-", [head, body])]),
											]),
											new Term(",", [
												new Term("=", [head, rule.head]),
												new Term("=", [body, rule.body])
											])
										])), point.substitution, point);
									state.retract = orule;
									states.push(state);
								}
							}
							thread.prepend(states);
						}
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
					}
				} else {
					retract(thread, point, head.indicator, point.retract, get_module);
				}
			}
		},
		
		// retractall/1
		"retractall/1": function(thread, point, atom) {
			var head = atom.args[0];
			var context_module = "user";
			if(pl.type.is_term(head) && head.indicator === ":/2") {
				context_module = head.args[0].id;
				head = head.args[1];
			}
			if(pl.type.is_variable(head)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_callable(head)) {
				thread.throw_error(pl.error.type("callable", head, atom.indicator));
			} else if(!thread.is_public_predicate(head.indicator, context_module)
			|| head.indicator === ",/2"
			|| thread.session.modules.system.rules.hasOwnProperty(head.indicator)) {
				thread.throw_error(pl.error.permission("modify", "static_procedure", str_indicator(head.indicator), atom.indicator));
			} else {
				thread.prepend([
					new State(point.goal.replace(new Term(",", [
						new Term(":", [
							new Term(context_module),
							new Term("retract", [new pl.type.Term(":-", [head, new Var("_")])])
						]),
						new Term("fail", [])
					])), point.substitution, point),
					new State(point.goal.replace(null), point.substitution, point)
				]);
			}
		},

		// abolish/1
		"abolish/1": function(thread, point, atom) {
			var predicate = atom.args[0];
			var module_id;
			if(pl.type.is_term(predicate) && predicate.indicator === ":/2") {
				if(!pl.type.is_atom(predicate.args[0])) {
					thread.throw_error(pl.error.type("module", predicate.args[0], atom.indicator));
					return;
				}
				module_id = predicate.args[0].id;
				predicate = predicate.args[1];
			} else {
				module_id = "user";
			}
			if(pl.type.is_variable(predicate) || pl.type.is_term(predicate) && predicate.indicator === "//2"
			&& (pl.type.is_variable(predicate.args[0]) || pl.type.is_variable(predicate.args[1]))) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(predicate) || predicate.indicator !== "//2") {
				thread.throw_error(pl.error.type("predicate_indicator", predicate, atom.indicator));
			} else if(!pl.type.is_atom(predicate.args[0])) {
				thread.throw_error(pl.error.type("atom", predicate.args[0], atom.indicator));
			} else if(!pl.type.is_integer(predicate.args[1])) {
				thread.throw_error(pl.error.type("integer", predicate.args[1], atom.indicator));
			} else if(predicate.args[1].value < 0) {
				thread.throw_error(pl.error.domain("not_less_than_zero", predicate.args[1], atom.indicator));
			} else if(pl.type.is_number(thread.get_flag("max_arity")) && predicate.args[1].value > thread.get_flag("max_arity").value) {
				thread.throw_error(pl.error.representation("max_arity", atom.indicator));
			} else {
				var get_module = thread.session.modules[module_id];
				if(pl.type.is_module(get_module)) {
					var indicator = predicate.args[0].id + "/" + predicate.args[1].value;
					if(thread.is_public_predicate(indicator, module_id)
					&& indicator !== ",/2"
					&& !thread.session.modules.system.rules.hasOwnProperty(indicator)) {
						delete get_module.rules[indicator];
						delete get_module.indexed_clauses[indicator];
						delete get_module.non_indexable_clauses[indicator];
						delete get_module.public_predicates[indicator];
						delete get_module.multifile_predicates[indicator];
						thread.success(point);
					} else {
						thread.throw_error(pl.error.permission("modify", "static_procedure", atom.args[0], atom.indicator));
					}
				} else {
					thread.success(point);
				}
			}
		},
		
		// ATOM PROCESSING
		
		// atom_length/2
		"atom_length/2": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom.args[0] ) ) {
				thread.throw_error( pl.error.type( "atom", atom.args[0], atom.indicator ) );
			} else if( !pl.type.is_variable( atom.args[1] ) && !pl.type.is_integer( atom.args[1] ) ) {
				thread.throw_error( pl.error.type( "integer", atom.args[1], atom.indicator ) );
			} else if( pl.type.is_integer( atom.args[1] ) && atom.args[1].value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", atom.args[1], atom.indicator ) );
			} else {
				var length = new Num( stringLength(atom.args[0].id), false );
				thread.prepend( [new State( point.goal.replace( new Term( "=", [length, atom.args[1]] ) ), point.substitution, point )] );
			}
		},
		
		// atom_concat/3
		"atom_concat/3": function( thread, point, atom ) {
			var str, goal, start = atom.args[0], end = atom.args[1], whole = atom.args[2];
			if( pl.type.is_variable( whole ) && (pl.type.is_variable( start ) || pl.type.is_variable( end )) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( start ) && !pl.type.is_atom( start ) ) {
				thread.throw_error( pl.error.type( "atom", start, atom.indicator ) );
			} else if( !pl.type.is_variable( end ) && !pl.type.is_atom( end ) ) {
				thread.throw_error( pl.error.type( "atom", end, atom.indicator ) );
			} else if( !pl.type.is_variable( whole ) && !pl.type.is_atom( whole ) ) {
				thread.throw_error( pl.error.type( "atom", whole, atom.indicator ) );
			} else {
				var v1 = pl.type.is_variable( start );
				var v2 = pl.type.is_variable( end );
				//var v3 = pl.type.is_variable( whole );
				if( !v1 && !v2 ) {
					goal = new Term( "=", [whole, new Term( start.id + end.id )] );
					thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
				} else if( v1 && !v2 ) {
					str = whole.id.substr( 0, whole.id.length - end.id.length );
					if( str + end.id === whole.id ) {
						goal = new Term( "=", [start, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else if( v2 && !v1 ) {
					str = whole.id.substr( start.id.length );
					if( start.id + str === whole.id ) {
						goal = new Term( "=", [end, new Term( str )] );
						thread.prepend( [new State( point.goal.replace( goal ), point.substitution, point )] );
					}
				} else {
					var states = [];
					for( var i = 0; i <= whole.id.length; i++ ) {
						var atom1 = new Term( whole.id.substr( 0, i ) );
						var atom2 = new Term( whole.id.substr( i ) );
						goal = new Term( ",", [new Term( "=", [atom1, start] ), new Term( "=", [atom2, end] )] );
						states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
					}
					thread.prepend( states );
				}
			}
		},
		
		// sub_atom/5
		"sub_atom/5": function( thread, point, atom ) {
			var i, atom1 = atom.args[0], before = atom.args[1], length = atom.args[2], after = atom.args[3], subatom = atom.args[4];
			if( pl.type.is_variable( atom1 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else if( !pl.type.is_variable( before ) && !pl.type.is_integer( before ) ) {
				thread.throw_error( pl.error.type( "integer", before, atom.indicator ) );
			} else if( !pl.type.is_variable( length ) && !pl.type.is_integer( length ) ) {
				thread.throw_error( pl.error.type( "integer", length, atom.indicator ) );
			} else if( !pl.type.is_variable( after ) && !pl.type.is_integer( after ) ) {
				thread.throw_error( pl.error.type( "integer", after, atom.indicator ) );
			} else if( pl.type.is_integer( before ) && before.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", before, atom.indicator ) );
			} else if( pl.type.is_integer( length ) && length.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", length, atom.indicator ) );
			} else if( pl.type.is_integer( after ) && after.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", after, atom.indicator ) );
			} else if( !pl.type.is_variable( subatom ) && !pl.type.is_atom( subatom ) ) {
				thread.throw_error( pl.error.type( "atom", subatom, atom.indicator ) );
			} else {
				var bs = [], ls = [], as = [];
				if( pl.type.is_variable( before ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						bs.push( i );
					}
				} else {
					bs.push( before.value );
				}
				if( pl.type.is_variable( length ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						ls.push( i );
					}
				} else {
					ls.push( length.value );
				}
				if( pl.type.is_variable( after ) ) {
					for( i = 0; i <= atom1.id.length; i++ ) {
						as.push( i );
					}
				} else {
					as.push( after.value );
				}
				var states = [];
				for( var _i in bs ) {
					if(!bs.hasOwnProperty(_i)) continue;
					i = bs[_i];
					for( var _j in ls ) {
						if(!ls.hasOwnProperty(_j)) continue;
						var j = ls[_j];
						var k = atom1.id.length - i - j;
						if( indexOf( as, k ) !== -1 ) {
						if( i+j+k === atom1.id.length ) {
								var str = atom1.id.substr( i, j );
								if( atom1.id === atom1.id.substr( 0, i ) + str + atom1.id.substr( i+j, k ) ) {
									var pl1 = new Term( "=", [new Term( str ), subatom] );
									var pl2 = new Term( "=", [before, new Num( i )] );
									var pl3 = new Term( "=", [length, new Num( j )] );
									var pl4 = new Term( "=", [after, new Num( k )] );
									var goal = new Term( ",", [ new Term( ",", [ new Term( ",", [pl2, pl3] ), pl4] ), pl1] );
									states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
								}
							}
						}
					}
				}
				thread.prepend( states );
			}
		},
		
		// atom_chars/2
		"atom_chars/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("character", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Term( atom1.id.charAt( i ) ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// atom_codes/2
		"atom_codes/2": function( thread, point, atom ) {
			var atom1 = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( atom1 ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( atom1 ) && !pl.type.is_atom( atom1 ) ) {
				thread.throw_error( pl.error.type( "atom", atom1, atom.indicator ) );
			} else {
				if( !pl.type.is_variable( atom1 ) ) {
					if(!pl.type.is_variable(list)) {
						var pointer = list;
						while(pl.type.is_term(pointer) && pointer.indicator === "./2") {
							if(!pl.type.is_character_code(pointer.args[0]) && !pl.type.is_variable(pointer.args[0])) {
								thread.throw_error(pl.error.type("integer", pointer.args[0], atom.indicator));
								return;
							}
							pointer = pointer.args[1];
						}
					}
					var list1 = new Term( "[]" );
					var unilen = stringLength(atom1.id);
					for( var i = unilen-1; i >= 0; i-- ) {
						list1 = new Term( ".", [new Num( codePointAt(atom1.id,i), false ), list1] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list1] ) ), point.substitution, point )] );
				} else {			
					var pointer = list;
					var v = pl.type.is_variable( atom1 );
					var str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) && v ) {
								thread.throw_error( pl.error.instantiation( atom.indicator ) );
								return;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					if( pl.type.is_variable( pointer ) && v ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					} else if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [new Term( str ), atom1] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// char_code/2
		"char_code/2": function( thread, point, atom ) {
			var char = atom.args[0], code = atom.args[1];
			if( pl.type.is_variable( char ) && pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else {
				if( pl.type.is_variable( code ) ) {
					var code1 = new Num( codePointAt(char.id,0 ), false );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [code1, code] ) ), point.substitution, point )] );
				} else {
					var char1 = new Term( fromCodePoint( code.value ) );
					thread.prepend( [new State( point.goal.replace( new Term( "=", [char1, char] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_chars/2
		"number_chars/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.type( "character", pointer.args[0], atom.indicator ) );
								return;
							}
						} else {
							str += pointer.args[0].id;
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Term( str.charAt( i ) ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// number_codes/2
		"number_codes/2": function( thread, point, atom ) {
			var str, num = atom.args[0], list = atom.args[1];
			if( pl.type.is_variable( num ) && pl.type.is_variable( list ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( num ) && !pl.type.is_number( num ) ) {
				thread.throw_error( pl.error.type( "number", num, atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else {
				var isvar = pl.type.is_variable( num );
				if( !pl.type.is_variable( list ) ) {	
					var pointer = list;
					var total = true;
					str = "";
					while( pointer.indicator === "./2" ) {
						if( !pl.type.is_character_code( pointer.args[0] ) ) {
							if( pl.type.is_variable( pointer.args[0] ) ) {
								total = false;
							} else if( !pl.type.is_variable( pointer.args[0] ) ) {
								thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
								return;
							}
						} else {
							str += fromCodePoint( pointer.args[0].value );
						}
						pointer = pointer.args[1];
					}
					total = total && pl.type.is_empty_list( pointer );
					if( !pl.type.is_empty_list( pointer ) && !pl.type.is_variable( pointer ) ) {
						thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
						return;
					}
					if( !total && isvar ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( total ) {
						if( pl.type.is_variable( pointer ) && isvar ) {
							thread.throw_error( pl.error.instantiation( atom.indicator ) );
							return;
						} else {
							var expr = thread.parse( str );
							var num2 = expr.value;
							if( !pl.type.is_number( num2 ) || expr.tokens[expr.tokens.length-1].space ) {
								thread.throw_error( pl.error.syntax_by_predicate( "parseable_number", atom.indicator ) );
							} else {
								thread.prepend( [new State( point.goal.replace( new Term( "=", [num, num2] ) ), point.substitution, point )] );
							}
							return;
						}
					}
				}
				if( !isvar ) {
					str = num.toString();
					var list2 = new Term( "[]" );
					for( var i = str.length - 1; i >= 0; i-- ) {
						list2 = new Term( ".", [ new Num( codePointAt(str,i), false ), list2 ] );
					}
					thread.prepend( [new State( point.goal.replace( new Term( "=", [list, list2] ) ), point.substitution, point )] );
				}
			}
		},
		
		// upcase_atom/2
		"upcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], upcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( upcase ) && !pl.type.is_atom( upcase ) ) {
				thread.throw_error( pl.error.type( "atom", upcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [upcase, new Term( original.id.toUpperCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// downcase_atom/2
		"downcase_atom/2": function( thread, point, atom ) {
			var original = atom.args[0], downcase = atom.args[1];
			if( pl.type.is_variable( original ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( original ) ) {
				thread.throw_error( pl.error.type( "atom", original, atom.indicator ) );
			} else if( !pl.type.is_variable( downcase ) && !pl.type.is_atom( downcase ) ) {
				thread.throw_error( pl.error.type( "atom", downcase, atom.indicator ) );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [downcase, new Term( original.id.toLowerCase(), [] )] ) ), point.substitution, point )] );
			}
		},
		
		// atomic_concat/3
		"atomic_concat/3": function( thread, point, atom ) {
			var atomic1 = atom.args[0], atomic2 = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( atomic1 ) || pl.type.is_variable( atomic2 ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic1 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic1, atom.indicator ) );
			} else if( !pl.type.is_atomic( atomic2 ) ) {
				thread.throw_error( pl.error.type( "atomic", atomic2, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				if( pl.type.is_atom( atomic1 ) ) {
					id += atomic1.id;
				} else {
					id += "" + atomic1.value;
				}
				if( pl.type.is_atom( atomic2 ) ) {
					id += atomic2.id;
				} else {
					id += "" + atomic2.value;
				}
				var atom = new Term(id, []);
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom, concat] ) ), point.substitution, point )] );
			}
		},

		// atomic_list_concat/2
		"atomic_list_concat/2": function( thread, point, atom ) {
			var list = atom.args[0], concat = atom.args[1];
			thread.prepend( [new State( point.goal.replace( new Term( "atomic_list_concat", [list, new Term( "", [] ), concat] ) ), point.substitution, point )] );
		},
		
		// atomic_list_concat/3
		"atomic_list_concat/3": function( thread, point, atom ) {
			var list = atom.args[0], separator = atom.args[1], concat = atom.args[2];
			if( pl.type.is_variable( separator ) || pl.type.is_variable( list ) && pl.type.is_variable( concat ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( list ) && !pl.type.is_list( list ) ) {
				thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
			} else if( !pl.type.is_atom( separator ) && !pl.type.is_number( separator ) ) {
				thread.throw_error( pl.error.type( "atomic", separator, atom.indicator ) );
			} else if( !pl.type.is_variable( concat ) && !pl.type.is_atom( concat ) ) {
				thread.throw_error( pl.error.type( "atom", concat, atom.indicator ) );
			} else {
				var id = "";
				var pointer = list;
				while( pl.type.is_term( pointer ) && pointer.indicator === "./2" ) {
					if( pl.type.is_variable( pointer.args[0] ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_atom( pointer.args[0] ) && !pl.type.is_number( pointer.args[0] ) ) {
						thread.throw_error( pl.error.type( "atomic", pointer.args[0], atom.indicator ) );
						return;
					}
					if( id !== "" )
						id += separator.id;
					if( pl.type.is_atom( pointer.args[0] ) )
						id += pointer.args[0].id;
					else
						id += "" + pointer.args[0].value;
					pointer = pointer.args[1];
				}
				id = new Term( id, [] );
				if( pl.type.is_variable( pointer ) ) {
					thread.throw_error( pl.error.instantiation( atom.indicator ) );
				} else if( !pl.type.is_term( pointer ) || pointer.indicator !== "[]/0" ) {
					thread.throw_error( pl.error.type( "list", list, atom.indicator ) );
				} else {
					thread.prepend( [new State( point.goal.replace( new Term( "=", [id, concat] ) ), point.substitution, point )] );
				}
			}
		},
		
		// TERM COMPARISON
		
		"@=</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) <= 0 ) {
				thread.success( point );
			}
		},
		
		"==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) === 0 ) {
				thread.success( point );
			}
		},
		
		"\\==/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) !== 0 ) {
				thread.success( point );
			}
		},
		
		"@</2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) < 0 ) {
				thread.success( point );
			}
		},
		
		"@>/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) > 0 ) {
				thread.success( point );
			}
		},
		
		"@>=/2": function( thread, point, atom ) {
			if( pl.compare( atom.args[0], atom.args[1] ) >= 0 ) {
				thread.success( point );
			}
		},
		
		"compare/3": function( thread, point, atom ) {
			var order = atom.args[0], left = atom.args[1], right = atom.args[2];
			if( !pl.type.is_variable( order ) && !pl.type.is_atom( order ) ) {
				thread.throw_error( pl.error.type( "atom", order, atom.indicator ) );
			} else if( pl.type.is_atom( order ) && ["<", ">", "="].indexOf( order.id ) === -1 ) {
				thread.throw_error( pl.error.domain( "order", order, atom.indicator ) );
			} else {
				var compare = pl.compare( left, right );
				compare = compare === 0 ? "=" : (compare === -1 ? "<" : ">");
				thread.prepend( [new State( point.goal.replace( new Term( "=", [order, new Term( compare, [] )] ) ), point.substitution, point )] );
			}
		},
		
		// EVALUATION
		
		// is/2
		"is/2": function( thread, point, atom ) {
			var op = atom.args[1].interpret( thread );
			if( !pl.type.is_number( op ) ) {
				thread.throw_error( op );
			} else {
				thread.prepend( [new State( point.goal.replace( new Term( "=", [atom.args[0], op], atom.indicator ) ), point.substitution, point )] );
			}
		},
		
		// between/3
		"between/3": function( thread, point, atom ) {
			var lower = atom.args[0], upper = atom.args[1], bet = atom.args[2];
			if( pl.type.is_variable( lower ) || pl.type.is_variable( upper ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( lower ) ) {
				thread.throw_error( pl.error.type( "integer", lower, atom.indicator ) );
			} else if( !pl.type.is_integer( upper ) ) {
				thread.throw_error( pl.error.type( "integer", upper, atom.indicator ) );
			} else if( !pl.type.is_variable( bet ) && !pl.type.is_integer( bet ) ) {
				thread.throw_error( pl.error.type( "integer", bet, atom.indicator ) );
			} else {
				if( pl.type.is_variable( bet ) ) {
					if( lower.value <= upper.value ) {
						var states = [new State( point.goal.replace( new Term( "=", [bet, lower] ) ), point.substitution, point )];
						states.push( new State( point.goal.replace( new Term( "between", [new Num( lower.value+1, false ), upper, bet] ) ), point.substitution, point ) );
						thread.prepend( states );
					}
				} else if( lower.value <= bet.value && upper.value >= bet.value ) {
					thread.success( point );
				}
			}
		},
		
		// succ/2
		"succ/2": function( thread, point, atom ) {
			var n = atom.args[0], m = atom.args[1];
			if( pl.type.is_variable( n ) && pl.type.is_variable( m ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && !pl.type.is_integer( n ) ) {
				thread.throw_error( pl.error.type( "integer", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && !pl.type.is_integer( m ) ) {
				thread.throw_error( pl.error.type( "integer", m, atom.indicator ) );
			} else if( !pl.type.is_variable( n ) && n.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", n, atom.indicator ) );
			} else if( !pl.type.is_variable( m ) && m.value < 0 ) {
				thread.throw_error( pl.error.domain( "not_less_than_zero", m, atom.indicator ) );
			} else {
				if( pl.type.is_variable( m ) || m.value > 0 ) {
					if( pl.type.is_variable( n ) ) {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [n, new Num( m.value-1, false )] ) ), point.substitution, point )] );
					} else {
						thread.prepend( [new State( point.goal.replace( new Term( "=", [m, new Num( n.value+1, false )] ) ), point.substitution, point )] );
					}
				}
			}
		},
		
		// =:=/2
		"=:=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp === 0 ) {
				thread.success( point );
			}
		},
		
		// =\=/2
		"=\\=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp !== 0 ) {
				thread.success( point );
			}
		},
		
		// </2
		"</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp < 0 ) {
				thread.success( point );
			}
		},
		
		// =</2
		"=</2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp <= 0 ) {
				thread.success( point );
			}
		},
		
		// >/2
		">/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp > 0 ) {
				thread.success( point );
			}
		},
		
		// >=/2
		">=/2": function( thread, point, atom ) {
			var cmp = pl.arithmetic_compare( thread, atom.args[0], atom.args[1] );
			if( pl.type.is_term( cmp ) ) {
				thread.throw_error( cmp );
			} else if( cmp >= 0 ) {
				thread.success( point );
			}
		},
		
		// TYPE TEST
		
		// var/1
		"var/1": function( thread, point, atom ) {
			if( pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atom/1
		"atom/1": function( thread, point, atom ) {
			if( pl.type.is_atom( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// atomic/1
		"atomic/1": function( thread, point, atom ) {
			if( pl.type.is_atomic( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// compound/1
		"compound/1": function( thread, point, atom ) {
			if( pl.type.is_compound( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// integer/1
		"integer/1": function( thread, point, atom ) {
			if( pl.type.is_integer( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// float/1
		"float/1": function( thread, point, atom ) {
			if( pl.type.is_float( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// number/1
		"number/1": function( thread, point, atom ) {
			if( pl.type.is_number( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// nonvar/1
		"nonvar/1": function( thread, point, atom ) {
			if( !pl.type.is_variable( atom.args[0] ) ) {
				thread.success( point );
			}
		},
		
		// ground/1
		"ground/1": function( thread, point, atom ) {
			if( atom.variables().length === 0 ) {
				thread.success( point );
			}
		},
		
		// acyclic_term/1
		"acyclic_term/1": function( thread, point, atom ) {
			var test = point.substitution.apply( point.substitution );
			var variables = atom.args[0].variables();
			for( var i = 0; i < variables.length; i++ )
				if( point.substitution.links[variables[i]] !== undefined && !point.substitution.links[variables[i]].equals( test.links[variables[i]] ) )
					return;
			thread.success( point );
		},
		
		// callable/1
		"callable/1": function( thread, point, atom ) {
			var callable = atom.args[0];
			if(pl.type.is_term(callable)) {
				thread.success( point );
			}
		},

		// is_list/1
		"is_list/1": function( thread, point, atom ) {
			var list = atom.args[0];
			while( pl.type.is_term( list ) && list.indicator === "./2" )
				list = list.args[1];
			if( pl.type.is_term( list ) && list.indicator === "[]/0" )
				thread.success( point );
		},



		// STREAM SELECTION AND CONTROL

		// current_input/1
		"current_input/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias(stream.id);
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_input()])),
					point.substitution,
					point)
				] );
			}
		},

		// current_output/1
		"current_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			if(!pl.type.is_variable(stream)
			&& (!pl.type.is_stream(stream) || !thread.get_stream_by_alias(stream.alias)
										   && !thread.get_stream_by_alias(stream.id))
			&& (!pl.type.is_atom(stream) || !thread.get_stream_by_alias(stream.id))) {
				thread.throw_error( pl.error.domain("stream", stream, atom.indicator) );
			} else {
				if(pl.type.is_atom(stream))
					stream = thread.get_stream_by_alias( stream.id );
				thread.prepend( [new State(
					point.goal.replace(new Term("=", [stream, thread.get_current_output()])),
					point.substitution,
					point)
				] );
			}
		},

		// set_input/1
		"set_input/1": function( thread, point, atom ) {
			var input = atom.args[0];
			var stream = pl.type.is_stream( input ) ? input : thread.get_stream_by_alias( input.id );
			if( pl.type.is_variable( input ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( input ) && !pl.type.is_atom( input ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", input, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(input.alias)
													&& !thread.get_stream_by_alias(input.id) ) {
				thread.throw_error( pl.error.existence( "stream", input, atom.indicator ) );
			} else if( stream.output === true ) {
				thread.throw_error( pl.error.permission( "input", "stream", input, atom.indicator ) );
			} else {
				thread.set_current_input( stream );
				thread.success( point );
			}
		},

		// set_output/1
		"set_output/1": function( thread, point, atom ) {
			var output = atom.args[0];
			var stream = pl.type.is_stream( output ) ? output : thread.get_stream_by_alias( output.id );
			if( pl.type.is_variable( output ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( output ) && !pl.type.is_atom( output ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", output, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) || !thread.get_stream_by_alias(output.alias)
													&& !thread.get_stream_by_alias(output.id) ) {
				thread.throw_error( pl.error.existence( "stream", output, atom.indicator ) );
			} else if( stream.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", output, atom.indicator ) );
			} else {
				thread.set_current_output( stream );
				thread.success( point );
			}
		},

		// open/3
		"open/3": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2];
			thread.prepend( [new State(
				point.goal.replace(new Term("open", [dest, mode, stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// open/4
		"open/4": function( thread, point, atom ) {
			var dest = atom.args[0], mode = atom.args[1], stream = atom.args[2], options = atom.args[3];
			if( pl.type.is_variable( dest ) || pl.type.is_variable( mode ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( mode ) && !pl.type.is_atom( mode ) ) {
				thread.throw_error( pl.error.type( "atom", mode, atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.uninstantiation( stream, atom.indicator ) );
			} else if( !pl.type.is_atom( dest ) && !pl.type.is_streamable( dest ) ) {
				thread.throw_error( pl.error.domain( "source_sink", dest, atom.indicator ) );
			} else if( !pl.type.is_io_mode( mode ) ) {
				thread.throw_error( pl.error.domain( "io_mode", mode, atom.indicator ) );
			} else {
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_stream_option( property ) ) {
						thread.throw_error( pl.error.domain( "stream_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id;
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var alias = obj_options["alias"];
					if( alias && thread.get_stream_by_alias(alias) ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", new Term("alias", [new Term(alias, [])]), atom.indicator ) );
						return;
					}
					if( !obj_options["type"] )
						obj_options["type"] = "text";
					var file;
					if( pl.type.is_atom( dest ) )
						file = thread.file_system_open( dest.id, obj_options["type"], mode.id );
					else
						file = dest.stream( obj_options["type"], mode.id );
					if( file === false ) {
						thread.throw_error( pl.error.permission( "open", "source_sink", dest, atom.indicator ) );
						return;
					} else if( file === null ) {
						thread.throw_error( pl.error.existence( "source_sink", dest, atom.indicator ) );
						return;
					}
					var newstream = new Stream(
						file, mode.id,
						obj_options["alias"],
						obj_options["type"],
						obj_options["reposition"] === "true",
						obj_options["eof_action"] );
					if( alias )
						thread.session.streams[alias] = newstream;
					else
						thread.session.streams[newstream.id] = newstream;
					thread.prepend( [new State(
						point.goal.replace( new Term( "=", [stream, newstream] ) ),
						point.substitution,
						point
					)] );
				}
			}
		},

		// close/1
		"close/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State(
				point.goal.replace(new Term("close", [stream, new Term("[]", [])])),
				point.substitution,
				point
			)] );
		},

		// close/2
		"close/2": function( thread, point, atom ) {
			var stream = atom.args[0], options = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_close_option( property ) ) {
						thread.throw_error( pl.error.domain( "close_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					if(stream2 === thread.session.standard_input || stream2 === thread.session.standard_output || stream2 === thread.session.standard_error) {
						thread.success( point );
						return;
					} else if( stream2 === thread.session.current_input ) {
						thread.session.current_input = thread.session.standard_input;
					} else if( stream2 === thread.session.current_output ) {
						thread.session.current_output = thread.session.standard_output;
					}
					if( stream2.alias !== null && stream2.alias !== undefined )
						delete thread.session.streams[stream2.alias];
					else
						delete thread.session.streams[stream2.id];
					if( stream2.output )
						stream2.stream.flush();
					var closed = stream2.stream.close();
					stream2.stream = null;
					if( obj_options.force === true || closed === true ) {
						thread.success( point );
					}
				}
			}
		},

		// flush_output/0
		"flush_output/0": [
			new Rule(new Term("flush_output", []), new Term(",", [new Term("current_output", [new Var("S")]),new Term("flush_output", [new Var("S")])]))
		],

		// flush_output/1
		"flush_output/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input === true ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else {
				stream2.stream.flush();
				thread.success( point );
			}
		},

		// stream_property/2
		"stream_property/2": function( thread, point, atom ) {
			var stream = atom.args[0], property = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) ) {
				thread.throw_error( pl.error.domain( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && (!pl.type.is_stream( stream2 ) || stream2.stream === null) ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_variable( property ) && !pl.type.is_stream_property( property ) ) {
				thread.throw_error( pl.error.domain( "stream_property", property, atom.indicator ) );
			} else {
				var streams = [];
				var states = [];
				var propvar = pl.type.is_variable(property);
				if( !pl.type.is_variable( stream ) )
					streams.push( stream2 );
				else
					for( var key in thread.session.streams )
						streams.push( thread.session.streams[key] );
				for( var i = 0; i < streams.length; i++ ) {
					var properties = [];
					// file_name/1
					if( (propvar || property.indicator === "file_name/1") && streams[i].filename )
						properties.push( new Term( "file_name", [new Term(streams[i].file_name, [])] ) );
					// mode/1
					if(propvar || property.indicator === "mode/1")
						properties.push( new Term( "mode", [new Term(streams[i].mode, [])] ) );
					// input/0 or output/0
					if(propvar || property.indicator === "input/0" || property.indicator === "output/0")
						properties.push( new Term( streams[i].input ? "input" : "output", [] ) );
					// alias/1
					if( (propvar || property.indicator === "alias/1") && streams[i].alias )
						properties.push( new Term( "alias", [new Term(streams[i].alias, [])] ) );
					// position/1
					if(propvar || property.indicator === "position/1")
						properties.push( new Term( "position", [
							new Term("position", [
								new Num(streams[i].char_count, false),
								new Num(streams[i].line_count, false),
								new Num(streams[i].line_position, false)
							])
						] ) );
					// end_of_stream/1
					if(propvar || property.indicator === "end_of_stream/1")
						properties.push( new Term( "end_of_stream", [new Term(
							streams[i].position === "end_of_stream" || streams[i].stream.eof && streams[i].stream.eof(streams[i].position) ? "at" :
							streams[i].position === "past_end_of_stream" ? "past" :
							"not", [])] ) );
					// eof_action/1
					if(propvar || property.indicator === "eof_action/1")	
						properties.push( new Term( "eof_action", [new Term(streams[i].eof_action, [])] ) );
					// reposition/1
					if(propvar || property.indicator === "reposition/1")
						properties.push( new Term( "reposition", [new Term(streams[i].reposition ? "true" : "false", [])] ) );
					// type/1
					if(propvar || property.indicator === "type/1")
						properties.push( new Term( "type", [new Term(streams[i].type, [])] ) );
					for( var j = 0; j < properties.length; j++ ) {
						states.push( new State(
							point.goal.replace( new Term( ",", [
								new Term("=", [pl.type.is_variable( stream ) ? stream : stream2, streams[i]]),
								new Term("=", [property, properties[j]])]) ),
							point.substitution,
							point
						) );
					}
				}
				thread.prepend( states );
			}
		},

		// stream_position_data
		"stream_position_data/3": function(thread, point, atom) {
			var field = atom.args[0], position = atom.args[1], value = atom.args[2];
			if(pl.type.is_variable(position)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_term(position) || position.indicator !== "position/3") {
				thread.throw_error(pl.error.domain("stream_position", position, atom.indicator));
			} else if(!pl.type.is_variable(field) && !pl.type.is_atom(field)) {
				thread.throw_error(pl.error.type("atom", field, atom.indicator));
			} else if(!pl.type.is_variable(value) && !pl.type.is_integer(value)) {
				thread.throw_error(pl.error.type("integer", value, atom.indicator));
			} else {
				var fields = ["char_count", "line_count", "line_position"];
				var states = [];
				var data_pos = {char_count: 0, line_count: 1, line_position: 2};
				if(pl.type.is_variable(field)) {
					for(var i = 0; i < fields.length; i++) {
						states.push(new State(point.goal.replace(
							new Term(",", [
								new Term("=", [new Term(fields[i]), field]),
								new Term("=", [value, position.args[data_pos[fields[i]]]])
							])
						), point.substitution, point));
					}
				} else if(data_pos.hasOwnProperty(field.id)) {
					states.push(new State(point.goal.replace(
						new Term("=", [value, position.args[data_pos[field.id]]])
					), point.substitution, point));
				}
				thread.prepend(states);
			}
		},

		// at_end_of_stream/0
		"at_end_of_stream/0": [
			new Rule(new Term("at_end_of_stream", []), new pl.type.Term(",", [new Term("current_input", [new Var("S")]),new Term(",", [new Term("stream_property", [new Var("S"),new Term("end_of_stream", [new Var("E")])]),new Term(",", [new Term("!", []),new Term(";", [new Term("=", [new Var("E"),new Term("at", [])]),new Term("=", [new Var("E"),new Term("past", [])])])])])]))
		],

		// at_end_of_stream/1
		"at_end_of_stream/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else {
				var e = thread.next_free_variable();
				thread.prepend( [new State(
					point.goal.replace(
						new Term(",", [new Term("stream_property", [stream2,new Term("end_of_stream", [e])]),
						new Term(",", [new Term("!", []),new Term(";", [new Term("=", [e,new Term("at", [])]),
						new Term("=", [e,new Term("past", [])])])])])
					),
					point.substitution,
					point
				)] );
			}
		},

		// set_stream_position/2
		"set_stream_position/2": function( thread, point, atom ) {
			var stream = atom.args[0], position = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( position ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( !pl.type.is_stream_position( position ) ) {
				thread.throw_error( pl.error.domain( "stream_position", position, atom.indicator ) );
			} else if( stream2.reposition === false ) {
				thread.throw_error( pl.error.permission( "reposition", "stream", stream, atom.indicator ) );
			} else {
				if( position.indicator === "position/3" ) {
					stream2.position = position.args[0].value;
					stream2.char_count = position.args[0].value;
					stream2.line_count = position.args[1].value;
					stream2.line_position = position.args[2].value;
				} else {
					stream2.position = position.id;
				}
				thread.success( point );
			}
		},



		//  CHARACTER INPUT OUTPUT
		
		// get_char/1
		"get_char/1": [
			new Rule(new Term("get_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_char", [new Var("S"),new Var("C")])]))
		],

		// get_char/2
		"get_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_char === "\n") {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// get_code/1
		"get_code/1": [
			new Rule(new Term("get_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_code", [new Var("S"),new Var("C")])]))
		],

		// get_code/2
		"get_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream_code = codePointAt( stream_code, 0 );
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
						if(stream_code === 10) {
							stream2.line_count++;
							stream2.line_position = 0;
						}
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_char/1
		"peek_char/1": [
			new Rule(new Term("peek_char", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_char", [new Var("S"),new Var("C")])]))
		],

		// peek_char/2
		"peek_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( char ) && !pl.type.is_in_character( char ) ) {
				thread.throw_error( pl.error.type( "in_character", char, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_char;
				if( stream2.position === "end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else if( stream2.position === "past_end_of_stream" ) {
					stream_char = "end_of_file";
					stream2.position = "past_end_of_stream";
				} else {
					stream_char = stream2.stream.get( 1, stream2.position );
					if( stream_char === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_char === "end_of_stream") {
						stream_char = "end_of_file";
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Term(stream_char,[]), char] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// peek_code/1
		"peek_code/1": [
			new Rule(new Term("peek_code", [new Var("C")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_code", [new Var("S"),new Var("C")])]))
		],

		// peek_code/2
		"peek_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( code ) && !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( pl.type.is_integer( code ) && !pl.type.is_in_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "in_character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_code;
				if( stream2.position === "end_of_stream" ) {
					stream_code = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_code = stream2.stream.get( 1, stream2.position );
					if( stream_code === null ) {
						thread.throw_error( pl.error.representation( "character", atom.indicator ) );
						return;
					} else if(stream_code === "end_of_stream") {
						stream_code = -1;
					} else {
						stream_code = codePointAt( stream_code, 0 );
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_code, false), code] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_char/1
		"put_char/1": [
			new Rule(new Term("put_char", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Var("C")])]))
		],

		// put_char/2
		"put_char/2": function( thread, point, atom ) {
			var stream = atom.args[0], char = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( char ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_character( char ) ) {
				thread.throw_error( pl.error.type( "character", char, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( char.id, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(char.id === "\n") {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// put_code/1
		"put_code/1": [
			new Rule(new Term("put_code", [new Var("C")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_code", [new Var("S"),new Var("C")])]))
		],

		// put_code/2
		"put_code/2": function( thread, point, atom ) {
			var stream = atom.args[0], code = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( code ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( code ) ) {
				thread.throw_error( pl.error.type( "integer", code, atom.indicator ) );
			} else if( !pl.type.is_character_code( code ) ) {
				thread.throw_error( pl.error.representation( "character_code", atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put( fromCodePoint( code.value ), stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					if(code.value === 10) {
						stream2.line_count++;
						stream2.line_position = 0;
					}
					thread.success( point );
				}
			}
		},

		// nl/0
		"nl/0": [
			new Rule(new Term("nl"), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_char", [new Var("S"),new Term("\n")])]))
		],

		// nl/1
		"nl/1": function( thread, point, atom ) {
			var stream = atom.args[0];
			thread.prepend( [new State( 
				point.goal.replace( new Term("put_char", [stream, new Term("\n", [])]) ),
				point.substitution,
				point
			)] );
		},



		// BYTE INPUT/OUTPUT

		// get_byte/1
		"get_byte/1": [
			new Rule(new Term("get_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("get_byte", [new Var("S"),new Var("B")])]))
		],

		// get_byte/2
		"get_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
						stream2.position = "past_end_of_stream";
					} else {
						stream2.position++;
						stream2.char_count++;
						stream2.line_position++;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},
		
		// peek_byte/1
		"peek_byte/1": [
			new Rule(new Term("peek_byte", [new Var("B")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("peek_byte", [new Var("S"),new Var("B")])]))
		],

		// peek_byte/2
		"peek_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_variable( byte ) && !pl.type.is_in_byte( byte ) ) {
				thread.throw_error( pl.error.type( "in_byte", byte, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "input", "text_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				var stream_byte;
				if( stream2.position === "end_of_stream" ) {
					stream_byte = -1;
					stream2.position = "past_end_of_stream";
				} else {
					stream_byte = stream2.stream.get_byte( stream2.position );
					if( stream_byte === null ) {
						thread.throw_error( pl.error.representation( "byte", atom.indicator ) );
						return;
					} else if(stream_byte === "end_of_stream") {
						stream_byte = -1;
					}
				}
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [new Num(stream_byte,false), byte] ) ),
					point.substitution,
					point
				)] );
			}
		},

		// put_byte/1
		"put_byte/1": [
			new Rule(new Term("put_byte", [new Var("B")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("put_byte", [new Var("S"),new Var("B")])]))
		],

		// put_byte/2
		"put_byte/2": function( thread, point, atom ) {
			var stream = atom.args[0], byte = atom.args[1];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( byte ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_byte( byte ) ) {
				thread.throw_error( pl.error.type( "byte", byte, atom.indicator ) );
			} else if( !pl.type.is_variable( stream ) && !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "text" ) {
				thread.throw_error( pl.error.permission( "output", "text_stream", stream, atom.indicator ) );
			} else {
				if( stream2.stream.put_byte( byte.value, stream2.position ) ) {
					if(typeof stream2.position === "number")
						stream2.position++;
					stream2.char_count++;
					stream2.line_position++;
					thread.success( point );
				}
			}
		},



		// TERM INPUT/OUTPUT

		// read/1
		"read/1": [
			new Rule(new Term("read", [new Var("T")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")])]))
		],

		// read/2
		"read/2": [
			new Rule(new Term("read", [new Var("S"), new Var("T")]), new Term("read_term", [new Var("S"),new Var("T"),new Term("[]")]))
		],

		// read_term/2
		"read_term/2": [
			new Rule(new Term("read_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_input", [new Var("S")]),new Term("read_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],

		// read_term/3
		"read_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.output ) {
				thread.throw_error( pl.error.permission( "input", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "input", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "input", "past_end_of_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "eof_code" ) {
				expr = {
					value: new Term("end_of_file", []),
					type: SUCCESS,
					len: -1
				};
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_read_option( property ) ) {
						thread.throw_error( pl.error.domain( "read_option", property, atom.indicator ) );
						return;
					}
					obj_options[property.id] = property.args[0];
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					var char, tokenizer, expr;
					var text = "";
					var tokens = [];
					var last_token = null;
					var lexical_error = false;
					// Get term
					while( last_token === null || lexical_error || last_token.name !== "atom" || last_token.value !== "." || tokens.length > 0 && expr.type === ERROR ) {
						char = stream2.stream.get( 1, stream2.position );
						while(char !== null && char !== "." && char !== "end_of_stream" && char !== "past_end_of_stream") {
							stream2.position++;
							text += char;
							char = stream2.stream.get( 1, stream2.position );
						}
						if( char === null ) {
							thread.throw_error( pl.error.representation( "character", atom.indicator ) );
							return;
						} else if( char === "end_of_stream" || char === "past_end_of_stream" ) {
							if(tokens === null || tokens.length === 0) {
								stream2.position = "past_end_of_stream";
								expr = {
									value: new Term("end_of_file", []),
									type: SUCCESS,
									len: -1
								};
								break;
							} else if(expr) {
								thread.throw_error( pl.error.syntax( last_token, "unexpected end of file", false ) );
								return;
							} else {
								thread.throw_error( pl.error.syntax( last_token, "token not found", true ) );
								return;
							}
						} else if(char === ".") {
							stream2.position++;
							text += char;
						}
						tokenizer = new Tokenizer( thread );
						tokenizer.new_text( text );
						tokens = tokenizer.get_tokens();
						num_token = tokens !== null && tokens.length > 1 ? tokens[tokens.length-2] : null;
						last_token = tokens !== null && tokens.length > 0 ? tokens[tokens.length-1] : null;
						if(tokens === null)
							continue;
						lexical_error = false;
						for(var i = 0; i < tokens.length && !lexical_error; i++)
							lexical_error = tokens[i].name === "lexical";
						if(lexical_error)
							continue;
						expr = parseExpr(thread, tokens, 0, thread.__get_max_priority(), false);
						if(num_token && num_token.name === "number" && !num_token.float && !num_token.blank && last_token.value === ".") {
							var next_char = stream2.stream.get(1, stream2.position);
							if(next_char >= '0' && next_char <= '9') {
								stream2.position++;
								text += next_char;
								last_token = null;
								continue;
							}
						}
					}
					if(last_token) {
						if(last_token.line_position === last_token.len)
							stream2.line_position += last_token.line_position;
						else
							stream2.line_position = last_token.line_position;
						stream2.line_count += last_token.line_count;
						stream2.char_count += last_token.len;
					}
					// Succeed analyzing term
					if( expr.type === SUCCESS && (expr.len === -1 || expr.len === tokens.length-1 && last_token.value === "." )) {
						thread.session.renamed_variables = {};
						expr = expr.value.rename( thread );
						var eq = new Term( "=", [term, expr] );
						// Variables
						if( obj_options.variables ) {
							var vars = arrayToList( map( nub( expr.variables() ), function(v) { return new Var(v); } ) );
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variables, vars] )] )
						}
						// Variable names
						if( obj_options.variable_names ) {
							var vars = nub(expr.variables());
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.variable_names, plvars] )] );
						}
						// Singletons
						if( obj_options.singletons ) {
							var vars = nub(new Rule(expr, null).singleton_variables(true));
							var plvars = [];
							for(var i = 0; i < vars.length; i++) {
								var v = vars[i];
								for( var prop in thread.session.renamed_variables ) {
									if( thread.session.renamed_variables.hasOwnProperty( prop ) ) {
										if( thread.session.renamed_variables[ prop ] === v ) {
											plvars.push(new Term( "=", [new Term( prop, []), new Var(v)] ));
											break;
										}
									}
								}
							}
							plvars = arrayToList(plvars);
							eq = new Term( ",", [eq, new Term( "=", [obj_options.singletons, plvars] )] );
						}
						thread.prepend( [new State( point.goal.replace( eq ), point.substitution, point )] );
					// Failed analyzing term
					} else {
						if( expr.type === SUCCESS )
							thread.throw_error( pl.error.syntax( tokens[expr.len], "unexpected token", false ) );
						else
							thread.throw_error( expr.value );
					}
				}
			}
		},

		// write/1
		"write/1": [
			new Rule(new Term("write", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write", [new Var("S"),new Var("T")])]))
		],
		
		// write/2
		"write/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("false", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// writeq/1
		"writeq/1": [
			new Rule(new Term("writeq", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("writeq", [new Var("S"),new Var("T")])]))
		],
		
		// writeq/2
		"writeq/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("false")]),
							new Term(".", [new Term("numbervars", [new Term("true")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},
		
		// write_canonical/1
		"write_canonical/1": [
			new Rule(new Term("write_canonical", [new Var("T")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_canonical", [new Var("S"),new Var("T")])]))
		],
		
		// write_canonical/2
		"write_canonical/2": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1];
			thread.prepend( [new State( 
				point.goal.replace( new Term("write_term", [stream, term,
					new Term(".", [new Term("quoted", [new Term("true", [])]),
						new Term(".", [new Term("ignore_ops", [new Term("true")]),
							new Term(".", [new Term("numbervars", [new Term("false")]), new Term("[]",[])])])])]) ),
				point.substitution,
				point
			)] );
		},

		// write_term/2
		"write_term/2": [
			new Rule(new Term("write_term", [new Var("T"),new Var("O")]), new Term(",", [new Term("current_output", [new Var("S")]),new Term("write_term", [new Var("S"),new Var("T"),new Var("O")])]))
		],
		
		// write_term/3
		"write_term/3": function( thread, point, atom ) {
			var stream = atom.args[0], term = atom.args[1], options = atom.args[2];
			var stream2 = pl.type.is_stream( stream ) ? stream : thread.get_stream_by_alias( stream.id );
			if( pl.type.is_variable( stream ) || pl.type.is_variable( options ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_list( options ) ) {
				thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
			} else if( !pl.type.is_stream( stream ) && !pl.type.is_atom( stream ) ) {
				thread.throw_error( pl.error.domain( "stream_or_alias", stream, atom.indicator ) );
			} else if( !pl.type.is_stream( stream2 ) || stream2.stream === null ) {
				thread.throw_error( pl.error.existence( "stream", stream, atom.indicator ) );
			} else if( stream2.input ) {
				thread.throw_error( pl.error.permission( "output", "stream", stream, atom.indicator ) );
			} else if( stream2.type === "binary" ) {
				thread.throw_error( pl.error.permission( "output", "binary_stream", stream, atom.indicator ) );
			} else if( stream2.position === "past_end_of_stream" && stream2.eof_action === "error" ) {
				thread.throw_error( pl.error.permission( "output", "past_end_of_stream", stream, atom.indicator ) );
			} else {
				// Get options
				var obj_options = {};
				var pointer = options;
				var property;
				while( pl.type.is_term(pointer) && pointer.indicator === "./2" ) {
					property = pointer.args[0];
					if( pl.type.is_variable( property ) ) {
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
						return;
					} else if( !pl.type.is_write_option( property ) ) {
						thread.throw_error( pl.error.domain( "write_option", property, atom.indicator ) );
						return;
					}
					if(property.indicator === "variable_names/1")
						obj_options[property.id] = property.args[0];
					else
						obj_options[property.id] = property.args[0].id === "true";
					pointer = pointer.args[1];
				}
				if( pointer.indicator !== "[]/0" ) {
					if( pl.type.is_variable( pointer ) )
						thread.throw_error( pl.error.instantiation( atom.indicator ) );
					else
						thread.throw_error( pl.error.type( "list", options, atom.indicator ) );
					return;
				} else {
					obj_options.session = thread.session;
					var text = term.toString( obj_options );
					stream2.stream.put( text, stream2.position );
					if( typeof stream2.position === "number" )
						stream2.position += text.length;
					var nl = (text.match(/\n/g) || []).length;
					stream2.line_count += nl;
					if(nl > 0)
						stream2.line_position = text.length - text.lastIndexOf("\n") - 1;
					else
						stream2.line_position += text.length;
					stream2.char_count += text.length;
					thread.success( point );
				}
			}
		},
		
		// IMPLEMENTATION DEFINED HOOKS
		
		// halt/0
		"halt/0": function( thread, point, _ ) {
			if( thread.get_flag("nodejs").indicator === "true/0" )
				process.exit();
			thread.points = [];
		},
		
		// halt/1
		"halt/1": function( thread, point, atom ) {
			var int = atom.args[0];
			if( pl.type.is_variable( int ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_integer( int ) ) {
				thread.throw_error( pl.error.type( "integer", int, atom.indicator ) );
			} else {
				if( thread.get_flag("nodejs").indicator === "true/0" )
					process.exit(int.value);
				thread.points = [];
			}
		},
		
		// current_prolog_flag/2
		"current_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( !pl.type.is_variable( flag ) && !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_variable( flag ) && !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else {
				var states = [];
				for( var name in pl.flag ) {
					if(!pl.flag.hasOwnProperty(name)) continue;
					var goal = new Term( ",", [new Term( "=", [new Term( name ), flag] ), new Term( "=", [thread.get_flag(name), value] )] );
					states.push( new State( point.goal.replace( goal ), point.substitution, point ) );
				}
				thread.prepend( states );
			}
		},
		
		// set_prolog_flag/2
		"set_prolog_flag/2": function( thread, point, atom ) {
			var flag = atom.args[0], value = atom.args[1];
			if( pl.type.is_variable( flag ) || pl.type.is_variable( value ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_atom( flag ) ) {
				thread.throw_error( pl.error.type( "atom", flag, atom.indicator ) );
			} else if( !pl.type.is_flag( flag ) ) {
				thread.throw_error( pl.error.domain( "prolog_flag", flag, atom.indicator ) );
			} else if( !pl.type.is_modifiable_flag( flag ) ) {
				thread.throw_error( pl.error.permission( "modify", "flag", flag, atom.indicator ) );
			} else if( !pl.type.is_value_flag( flag, value ) ) {
				thread.throw_error( pl.error.domain( "flag_value", new Term( "+", [flag, value] ), atom.indicator ) );
			} else {
				thread.session.flag[flag.id] = value;
				thread.success( point );
			}
		},



		// LOAD PROLOG SOURCE FILES

		// consult/1
		"consult/1": function(thread, point, atom) {
			var src = atom.args[0];
			var context_module = "user";
			if(src.indicator === ":/2") {
				context_module = src.args[0].id;
				src = src.args[1];
			}
			if(pl.type.is_variable(src)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_atom(src)) {
				thread.throw_error( pl.error.type( "atom", src, atom.indicator ) );
			} else {
				if(thread.consult(src.id, {
					context_module: context_module,
					text: false,
					html: false,
					success: function() {
						thread.success(point);
						thread.again();
					},
					error: function(err) {
						thread.throw_error(err);
						thread.again();
					}
				}));
				return true;
			}
		},



		// TIME AND DATES

		// get_time/1
		"get_time/1": function( thread, point, atom ) {
			var time = atom.args[0];
			if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else {
				var current = new Num(Date.now(), true);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [time, current] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_property
		"time_property/2": function(thread, point, atom) {
			var time = atom.args[0], property = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error(pl.error.instantiation(atom.indicator));
			} else if(!pl.type.is_variable(time) && !pl.type.is_number(time)) {
				thread.throw_error(pl.error.type("number", time, atom.indicator));
			} else if(!pl.type.is_variable(property) && !pl.type.is_time_property(property)) {
				thread.throw_error(pl.error.domain("time_property", property, atom.indicator));
			} else {
				var props;
				if(pl.type.is_variable(property)) {
					props = ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "weekday"];
				} else {
					props = [property.id];
				}
				var date = new Date(time.value);
				var value;
				var states = [];
				for(var i = 0; i < props.length; i++) {
					switch(props[i]) {
						case "year":
							value = new Term("year", [new Num(date.getFullYear(), false)]);
							break;
						case "month":
							value = new Term("month", [new Num(date.getMonth(), false)]);
							break;
						case "day":
							value = new Term("day", [new Num(date.getDate(), false)]);
							break;
						case "hours":
							value = new Term("hours", [new Num(date.getHours(), false)]);
							break;
						case "minutes":
							value = new Term("minutes", [new Num(date.getMinutes(), false)]);
							break;
						case "seconds":
							value = new Term("seconds", [new Num(date.getSeconds(), false)]);
							break;
						case "milliseconds":
							value = new Term("milliseconds", [new Num(date.getMilliseconds(), false)]);
							break;
						case "weekday":
							value = new Term("weekday", [new Num(date.getDay(), false)]);
							break;
					}
					states.push(new State(
						point.goal.replace( new Term( "=", [property, value] ) ), 
						point.substitution,
						point
					));
				}
				thread.prepend(states);
			}
		},

		// time_year/2
		"time_year/2": function( thread, point, atom ) {
			var time = atom.args[0], year = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(year) && !pl.type.is_integer(year)) {
				thread.throw_error( pl.error.type( "integer", year, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getFullYear(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [year, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},

		// time_month/2
		"time_month/2": function( thread, point, atom ) {
			var time = atom.args[0], month = atom.args[1];
			if(pl.type.is_variable(time)) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if(!pl.type.is_number(time)) {
				thread.throw_error( pl.error.type( "number", time, atom.indicator ) );
			} else if(!pl.type.is_variable(month) && !pl.type.is_integer(month)) {
				thread.throw_error( pl.error.type( "integer", month, atom.indicator ) );
			} else {
				var value = new Num(new Date(time.value).getMonth(), false);
				thread.prepend( [new State(
					point.goal.replace( new Term( "=", [month, value] ) ), 
					point.substitution,
					point
				)] );
			}
		},



		// GRAMMARS

		// phrase/3
		"phrase/3": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1], s = atom.args[2];
			var context_module = "user";
			if(grbody.indicator === ":/2") {
				context_module = grbody.args[0].id;
				grbody = grbody.args[1];
			}
			if( pl.type.is_variable( grbody ) ) {
				thread.throw_error( pl.error.instantiation( atom.indicator ) );
			} else if( !pl.type.is_callable( grbody ) ) {
				thread.throw_error( pl.error.type( "callable", grbody, atom.indicator ) );
			} else {
				var goal = body_to_dcg( grbody.clone(), s0, thread );
				goal.value = new Term(":", [new Term(context_module), new Term("call", [goal.value])]);
				if(goal !== null) {
					thread.prepend( [new State(
						point.goal.replace( new Term( ",", [goal.value, new Term("=", [goal.variable, s])] ) ), 
						point.substitution,
						point
					)] );
				}
			}
		},

		// phrase/2
		"phrase/2": function( thread, point, atom ) {
			var grbody = atom.args[0], s0 = atom.args[1];
			thread.prepend( [new State(
				point.goal.replace( new Term( "phrase", [grbody, s0, new Term("[]", [])] ) ), 
				point.substitution,
				point
			)] );
		},



		// TAU PROLOG INFORMATION

		// version/0
		"version/0": function( thread, point, atom ) {
			var msg = "Welcome to Tau Prolog version " + version.major + "." + version.minor + "." + version.patch + "\n";
			msg += "Tau Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\n";
			msg += "Please run ?- license. for legal details.\n";
			msg += "For online help and background, visit http:/tau-prolog.org";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		},

		// license/0
		"license/0": function( thread, point, atom ) {
			var msg = "Tau Prolog. A Prolog interpreter in JavaScript.\n";
			msg += "Copyright (C) 2017 - 2022 Jos Antonio Riaza Valverde\n\n";
			msg += "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n";
			msg += "1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n";
			msg += "2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n";
			msg += "3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n";
			msg += "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n";
			msg += "You should have received a copy of the BSD 3-Clause License along with this program. If not, see https://opensource.org/licenses/BSD-3-Clause";
			thread.prepend( [new State(
				point.goal.replace( new Term( "write", [new Term( msg, [] )] ) ), 
				point.substitution,
				point
			)] );
		}

	}, "all", {
		meta_predicates: {
			// '$findall'(?, 0, -, ?)
			"$findall/4": new Term("$findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// '$bagof'(?, ^, -)
			"$bagof/3": new Term("$bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$setof'(?, ^, -)
			"$setof/3": new Term("$setof", [new Term("?"), new Term("^"), new Term("-")]),
			// '$if'(0, 0, 0)
			"$if/3": new Term("$if", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// (0;0)
			";/2": new Term(";", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"->/2": new Term("->", [new Num(0, false), new Num(0, false)]),
			// (0->0)
			"*->/2": new Term("*->", [new Num(0, false), new Num(0, false)]),
			// (\+0)
			"\\+/1": new Term("\\+", [new Num(0, false)]),
			// abolish(:)
			"abolish/1": new Term("abolish", [new Term(":")]),
			// asserta(:)
			"asserta/1": new Term("asserta", [new Term(":")]),
			// assertz(:)
			"assertz/1": new Term("assertz", [new Term(":")]),
			// bagof(?, ^, -)
			"bagof/3": new Term("bagof", [new Term("?"), new Term("^"), new Term("-")]),
			// call(0)
			"call/1": new Term("call", [new Num(0, false)]),
			// call(1, ?)
			"call/2": new Term("call", [new Num(1, false), new Term("?")]),
			// call(2, ?, ?)
			"call/3": new Term("call", [new Num(2, false), new Term("?"), new Term("?")]),
			// call(3, ?, ?, ?)
			"call/4": new Term("call", [new Num(3, false), new Term("?"), new Term("?"), new Term("?")]),
			// call(4, ?, ?, ?, ?)
			"call/5": new Term("call", [new Num(4, false), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(5, ?, ?, ?, ?, ?)
			"call/6": new Term("call", [new Num(5, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(6, ?, ?, ?, ?, ?, ?)
			"call/7": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call(7, ?, ?, ?, ?, ?, ?, ?)
			"call/8": new Term("call", [new Num(6, false), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?"), new Term("?")]),
			// call_cleanup(0, 0)
			"call_cleanup/2": new Term("call_cleanup", [new Num(0, false), new Num(0, false)]),
			// catch(0, ?, 0)
			"catch/3": new Term("catch", [new Num(0, false), new Term("?"), new Num(0, false)]),
			// consult(:)
			"consult/1": new Term("consult", [new Term(":")]),
			// clause(:, ?)
			"clause/2": new Term("clause", [new Term(":"), new Term("?")]),
			// current_predicate(?, :)
			"current_predicate/2": new Term("current_predicate", [new Term("?"), new Term(":")]),
			// findall(?, 0, -)
			"findall/3": new Term("findall", [new Term("?"), new Num(0, false), new Term("-")]),
			// findall(?, 0, -, ?)
			"findall/4": new Term("findall", [new Term("?"), new Num(0, false), new Term("-"), new Term("?")]),
			// forall(0, 0)
			"forall/2": new Term("forall", [new Num(0, false), new Num(0, false)]),
			// listing(:)
			"listing/1": new Term("listing", [new Term(":")]),
			// once(0)
			"once/1": new Term("once", [new Num(0, false)]),
			// phrase(:, ?)
			"phrase/2": new Term("phrase", [new Term(":"),new Term("?")]),
			// phrase(:, ?, ?)
			"phrase/3": new Term("phrase", [new Term(":"),new Term("?"), new Term("?")]),
			// retract(:)
			"retract/1": new Term("retract", [new Term(":")]),
			// retractall(:)
			"retractall/1": new Term("retractall", [new Term(":")]),
			// setup_call_cleanup(0, 0, 0)
			"setup_call_cleanup/3": new Term("setup_call_cleanup", [new Num(0, false), new Num(0, false), new Num(0, false)]),
			// setof(?, ^, -)
			"setof/3": new Term("setof", [new Term("?"), new Term("^"), new Term("-")])
		}
	});

	if( true ) {
		module.exports = pl;
	} else {}
	
})();


/***/ }),

/***/ "./node_modules/tau-prolog/modules/promises.js":
/*!*****************************************************!*\
  !*** ./node_modules/tau-prolog/modules/promises.js ***!
  \*****************************************************/
/***/ ((module) => {

var pl;
(function(pl) {

	// Extend Tau Prolog prototypes
	var extend = function(pl) {

		// Consult a program from a string
		pl.type.Session.prototype.promiseConsult = function(program, options) {
			return this.thread.promiseConsult(program, options);
		};

		pl.type.Thread.prototype.promiseConsult = function(program, options) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				var opts = {};
				options = options === undefined ? {} : options;
				opts.context_module = options.context_module;
				opts.text = options.text;
				opts.html = options.html;
				opts.url = options.url;
				opts.file = options.file;
				opts.script = options.script;
				opts.success = resolve;
				opts.error = reject;
				thread.consult(program, opts);
			});
		};

		// Query goal from a string (without ?-)
		pl.type.Session.prototype.promiseQuery = function(string) {
			return this.thread.promiseQuery(string);
		};

		pl.type.Thread.prototype.promiseQuery = function(string) {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.query(string, {
					success: resolve,
					error: reject
				});
			});
		};

		// Find next computed answer
		pl.type.Session.prototype.promiseAnswer = function() {
			return this.thread.promiseAnswer();
		};

		pl.type.Thread.prototype.promiseAnswer = function() {
			var thread = this;
			return new Promise(function(resolve, reject) {
				thread.answer({
					success: resolve,
					fail: resolve,
					error: reject,
					limit: reject
				});
			});
		};

		// Find all computed answers (asynchronous generator function)
		pl.type.Session.prototype.promiseAnswers = function() {
			return this.thread.promiseAnswers();
		};
		pl.type.Thread.prototype.promiseAnswers = async function*() {
			while(true) {
				var answer = await this.promiseAnswer();
				if(answer !== false)
					yield answer;
				else
					return;
			}
		};

	}

	if(true) {
		module.exports = function(p) {
			pl = p;
			extend(pl);
		};
	} else {}

})(pl);

/***/ }),

/***/ "./app/res/tokens/adjectives.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/adjectives.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "big",
    "small",
    "helpful",
    "red",
    "black",
    "great"
];


/***/ }),

/***/ "./app/res/tokens/copulas.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/copulas.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "is",
    "are",
    "be"
];


/***/ }),

/***/ "./app/res/tokens/definite_articles.ts":
/*!*********************************************!*\
  !*** ./app/res/tokens/definite_articles.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "the"
];


/***/ }),

/***/ "./app/res/tokens/existential_quantifiers.ts":
/*!***************************************************!*\
  !*** ./app/res/tokens/existential_quantifiers.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "some"
];


/***/ }),

/***/ "./app/res/tokens/hverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/hverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "do",
    "does"
];


/***/ }),

/***/ "./app/res/tokens/indefinite_articles.ts":
/*!***********************************************!*\
  !*** ./app/res/tokens/indefinite_articles.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "a",
    "an"
];


/***/ }),

/***/ "./app/res/tokens/iverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/iverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "exist",
    "exists",
    "run",
    "grow",
    "die",
    "live"
];


/***/ }),

/***/ "./app/res/tokens/mverbs.ts":
/*!**********************************!*\
  !*** ./app/res/tokens/mverbs.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "eat",
    "drink",
    "watch",
    "make",
    "hit",
    "click"
];


/***/ }),

/***/ "./app/res/tokens/negations.ts":
/*!*************************************!*\
  !*** ./app/res/tokens/negations.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "doesn't",
    "does not",
    'not',
    "don't",
    'do not'
];


/***/ }),

/***/ "./app/res/tokens/nonsubconj.ts":
/*!**************************************!*\
  !*** ./app/res/tokens/nonsubconj.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "and",
    "or"
];


/***/ }),

/***/ "./app/res/tokens/nouns.ts":
/*!*********************************!*\
  !*** ./app/res/tokens/nouns.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "cat",
    "mat",
    "table",
    "dog",
    "nodejs",
    "color",
    "button",
    "div",
    "president",
    "trump"
];


/***/ }),

/***/ "./app/res/tokens/prepositions.ts":
/*!****************************************!*\
  !*** ./app/res/tokens/prepositions.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "to",
    "with",
    "from",
    "of",
    "over",
    "on",
    "at"
];


/***/ }),

/***/ "./app/res/tokens/relprons.ts":
/*!************************************!*\
  !*** ./app/res/tokens/relprons.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "that"
];


/***/ }),

/***/ "./app/res/tokens/subconj.ts":
/*!***********************************!*\
  !*** ./app/res/tokens/subconj.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "if",
    "when",
    "because",
    "while"
];


/***/ }),

/***/ "./app/res/tokens/then.ts":
/*!********************************!*\
  !*** ./app/res/tokens/then.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "then"
];


/***/ }),

/***/ "./app/res/tokens/universal_quantifiers.ts":
/*!*************************************************!*\
  !*** ./app/res/tokens/universal_quantifiers.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = [
    "every",
    "all",
    "each",
    "any"
];


/***/ }),

/***/ "./app/src/actuator/Actuator.ts":
/*!**************************************!*\
  !*** ./app/src/actuator/Actuator.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActuator = void 0;
const Action_1 = __webpack_require__(/*! ./actions/Action */ "./app/src/actuator/actions/Action.ts");
function getActuator(brain) {
    return new BaseActuator(brain);
}
exports.getActuator = getActuator;
class BaseActuator {
    constructor(brain, ed = brain.ed) {
        this.brain = brain;
        this.ed = ed;
        this.onUpdate = (clauses) => __awaiter(this, void 0, void 0, function* () {
            clauses.forEach(c => {
                (0, Action_1.getAction)(c, this.brain.ed, this).run();
            });
        });
        this.pointOut = (ids) => __awaiter(this, void 0, void 0, function* () {
            this.brain.ed.values.forEach(o => {
                o.style ? o.style.outline = '' : 0;
            });
            ids.forEach(id => {
                const elem = this.brain.ed.get(id);
                elem && elem.style ? elem.style.outline = '#f00 solid 2px' : 0;
            });
        });
        this.onSense = (clauses, opts) => __awaiter(this, void 0, void 0, function* () {
            for (const c of clauses) {
                yield this.brain.assert(c, opts);
            }
        });
    }
}


/***/ }),

/***/ "./app/src/actuator/Ed.ts":
/*!********************************!*\
  !*** ./app/src/actuator/Ed.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function getEd() {
    return new BaseEd();
}
exports["default"] = getEd;
class BaseEd {
    constructor(dictionary = {}) {
        this.dictionary = dictionary;
    }
    get(id) {
        return this.dictionary[id];
    }
    set(id, object) {
        this.dictionary[id] = object;
    }
    get keys() {
        return Object.keys(this.dictionary);
    }
    get values() {
        return Object.values(this.dictionary);
    }
}


/***/ }),

/***/ "./app/src/actuator/actions/Action.ts":
/*!********************************************!*\
  !*** ./app/src/actuator/actions/Action.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAction = void 0;
const BasicClause_1 = __webpack_require__(/*! ../../clauses/BasicClause */ "./app/src/clauses/BasicClause.ts");
const ChangeColor_1 = __webpack_require__(/*! ./ChangeColor */ "./app/src/actuator/actions/ChangeColor.ts");
const MakeButton_1 = __webpack_require__(/*! ./MakeButton */ "./app/src/actuator/actions/MakeButton.ts");
const NoOp_1 = __webpack_require__(/*! ./NoOp */ "./app/src/actuator/actions/NoOp.ts");
function getAction(clause, ed, actuator) {
    if (clause instanceof BasicClause_1.BasicClause) { // TODO: DON'T EXPOSE CLASS!!
        switch (clause.predicate) {
            case 'button':
                return new MakeButton_1.MakeButton(clause.args[0], ed, actuator);
            case 'red':
                return new ChangeColor_1.ChangeColor(clause.args[0], 'red', ed);
            case 'green':
                return new ChangeColor_1.ChangeColor(clause.args[0], 'green', ed);
        }
    }
    return new NoOp_1.NoOp(clause);
}
exports.getAction = getAction;


/***/ }),

/***/ "./app/src/actuator/actions/ChangeColor.ts":
/*!*************************************************!*\
  !*** ./app/src/actuator/actions/ChangeColor.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeColor = void 0;
class ChangeColor {
    constructor(id, color, ed) {
        this.id = id;
        this.color = color;
        this.ed = ed;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            const object = this.ed.get(this.id);
            object.style.background = this.color;
        });
    }
}
exports.ChangeColor = ChangeColor;


/***/ }),

/***/ "./app/src/actuator/actions/MakeButton.ts":
/*!************************************************!*\
  !*** ./app/src/actuator/actions/MakeButton.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MakeButton = void 0;
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
const Sensor_1 = __webpack_require__(/*! ../sensors/Sensor */ "./app/src/actuator/sensors/Sensor.ts");
class MakeButton {
    constructor(id, ed, actuator) {
        this.id = id;
        this.ed = ed;
        this.actuator = actuator;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ed.get(this.id)) {
                const button = document.createElement('button');
                button.innerText = 'button';
                button.id = this.id.toString();
                document.body.appendChild(button);
                this.ed.set(this.id, button);
                // adding a style-of-button entity
                const styleId = (0, Id_1.getRandomId)();
                console.log(button.id, styleId);
                const clauses = [(0, Clause_1.clauseOf)('style', styleId), (0, Clause_1.clauseOf)('of', styleId, this.id)];
                this.ed.set(styleId, button.style);
                this.actuator.onSense(clauses, { noAnaphora: true });
                (0, Sensor_1.makeSensor)(this.actuator, this.id, button);
            }
        });
    }
}
exports.MakeButton = MakeButton;


/***/ }),

/***/ "./app/src/actuator/actions/NoOp.ts":
/*!******************************************!*\
  !*** ./app/src/actuator/actions/NoOp.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoOp = void 0;
class NoOp {
    constructor(clause) {
        this.clause = clause;
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            console.warn(`No action corresponding to predicate: ${this.clause.toProlog()}`);
        });
    }
}
exports.NoOp = NoOp;


/***/ }),

/***/ "./app/src/actuator/sensors/ClickSensor.ts":
/*!*************************************************!*\
  !*** ./app/src/actuator/sensors/ClickSensor.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClickSensor = void 0;
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
class ClickSensor {
    constructor(id, object, actuator) {
        this.id = id;
        this.object = object;
        this.actuator = actuator;
        object.addEventListener('click', () => {
            actuator.onSense([(0, Clause_1.clauseOf)('clicked', id)]);
        });
    }
}
exports.ClickSensor = ClickSensor;


/***/ }),

/***/ "./app/src/actuator/sensors/Sensor.ts":
/*!********************************************!*\
  !*** ./app/src/actuator/sensors/Sensor.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeSensor = void 0;
const ClickSensor_1 = __webpack_require__(/*! ./ClickSensor */ "./app/src/actuator/sensors/ClickSensor.ts");
function makeSensor(actuator, id, object) {
    return new ClickSensor_1.ClickSensor(id, object, actuator);
}
exports.makeSensor = makeSensor;


/***/ }),

/***/ "./app/src/ast/phrases/Complement.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/Complement.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
class Complement {
    constructor(preposition, nounPhrase) {
        this.preposition = preposition;
        this.nounPhrase = nounPhrase;
    }
    toClause(args) {
        var _a, _b;
        const subjId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (() => { throw new Error('undefined subject id'); })();
        const newId = (0, Id_1.getRandomId)();
        return (0, Clause_1.clauseOf)(this.preposition.string, subjId, newId)
            .and(this.nounPhrase.toClause(Object.assign(Object.assign({}, args), { roles: { subject: newId } })));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = Complement;


/***/ }),

/***/ "./app/src/ast/phrases/CopulaSubordinateClause.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/phrases/CopulaSubordinateClause.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class CopulaSubordinateClause {
    constructor(relpron, predicate, copula) {
        this.relpron = relpron;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a;
        return this.predicate.toClause(Object.assign(Object.assign({}, args), { roles: { subject: (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject } }));
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaSubordinateClause;


/***/ }),

/***/ "./app/src/ast/phrases/NounPhrase.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/phrases/NounPhrase.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
class NounPhrase {
    constructor(adjectives, complements, noun, quantifier, article, subordClause) {
        this.adjectives = adjectives;
        this.complements = complements;
        this.noun = noun;
        this.quantifier = quantifier;
        this.article = article;
        this.subordClause = subordClause;
    }
    isUniQuant() {
        var _a, _b;
        return (_b = (_a = this.quantifier) === null || _a === void 0 ? void 0 : _a.isUniversal()) !== null && _b !== void 0 ? _b : false;
    }
    toClause(args) {
        var _a, _b, _c, _d;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Id_1.getRandomId)();
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        return this
            .adjectives
            .map(a => a.string)
            .concat(this.noun ? [this.noun.string] : [])
            .map(p => (0, Clause_1.clauseOf)(p, subjectId))
            .reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)())
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)()))
            .and((_d = (_c = this.subordClause) === null || _c === void 0 ? void 0 : _c.toClause(newArgs)) !== null && _d !== void 0 ? _d : (0, Clause_1.emptyClause)());
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = NounPhrase;


/***/ }),

/***/ "./app/src/ast/sentences/ComplexSentence.ts":
/*!**************************************************!*\
  !*** ./app/src/ast/sentences/ComplexSentence.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
/**
 * A sentence that relates two simple sentences hypotactically, in a
 * condition-outcome relationship.
 */
class ComplexSentence {
    constructor(condition, outcome, subconj) {
        this.condition = condition;
        this.outcome = outcome;
        this.subconj = subconj;
    }
    toClause(args) {
        // TODO: sometimes the condition and outcome have the SAME subject
        const newArgs1 = Object.assign(Object.assign({}, args), { roles: { subject: (0, Id_1.getRandomId)() } });
        const newArgs2 = Object.assign(Object.assign({}, args), { roles: { subject: (0, Id_1.getRandomId)() } });
        const condition = this.condition.toClause(newArgs1);
        const outcome = this.outcome.toClause(newArgs2);
        return condition.implies(outcome);
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = ComplexSentence;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaQuestion.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaQuestion.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ./CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
class CopulaQuestion {
    constructor(subject, predicate, copula) {
        this.subject = subject;
        this.predicate = predicate;
        this.copula = copula;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Id_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        //TODO: in case of a universally quantified question eg: "are all cats smart?" the prolog
        // produced should NOT be an implication, but rather a check that all cats are smart.
        return new CopulaSentence_1.default(this.subject, this.copula, this.predicate).toClause(newArgs);
    }
    get isSideEffecty() {
        return false;
    }
}
exports["default"] = CopulaQuestion;


/***/ }),

/***/ "./app/src/ast/sentences/CopulaSentence.ts":
/*!*************************************************!*\
  !*** ./app/src/ast/sentences/CopulaSentence.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
class CopulaSentence {
    constructor(subject, copula, predicate, negation) {
        this.subject = subject;
        this.copula = copula;
        this.predicate = predicate;
        this.negation = negation;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Id_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const subject = this.subject.toClause(newArgs);
        const predicate = this.predicate.toClause(newArgs).copy({ negate: !!this.negation });
        return this.subject.isUniQuant() ?
            subject.implies(predicate) :
            subject.and(predicate, { asRheme: true });
    }
    get isSideEffecty() {
        return true;
    }
}
exports["default"] = CopulaSentence;


/***/ }),

/***/ "./app/src/ast/sentences/IntransitiveSentence.ts":
/*!*******************************************************!*\
  !*** ./app/src/ast/sentences/IntransitiveSentence.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../../clauses/Id */ "./app/src/clauses/Id.ts");
class IntransitiveSentence {
    constructor(subject, iverb, complements, negation) {
        this.subject = subject;
        this.iverb = iverb;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        var _a, _b;
        const subjectId = (_b = (_a = args === null || args === void 0 ? void 0 : args.roles) === null || _a === void 0 ? void 0 : _a.subject) !== null && _b !== void 0 ? _b : (0, Id_1.getRandomId)({ asVar: this.subject.isUniQuant() });
        const newArgs = Object.assign(Object.assign({}, args), { roles: { subject: subjectId } });
        const theme = this.subject.toClause(newArgs);
        const rheme = (0, Clause_1.clauseOf)(this.iverb.string, subjectId)
            .and(this.complements.map(c => c.toClause(newArgs)).reduce((c1, c2) => c1.and(c2)));
        return theme.and(rheme, { asRheme: true });
    }
}
exports["default"] = IntransitiveSentence;


/***/ }),

/***/ "./app/src/ast/sentences/MonotransitiveSentence.ts":
/*!*********************************************************!*\
  !*** ./app/src/ast/sentences/MonotransitiveSentence.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class MonotransitiveSentence {
    constructor(subject, mverb, object, complements, negation) {
        this.subject = subject;
        this.mverb = mverb;
        this.object = object;
        this.complements = complements;
        this.negation = negation;
    }
    get isSideEffecty() {
        return true;
    }
    toClause(args) {
        throw new Error("Method not implemented.");
    }
}
exports["default"] = MonotransitiveSentence;


/***/ }),

/***/ "./app/src/ast/tokens/AbstractToken.ts":
/*!*********************************************!*\
  !*** ./app/src/ast/tokens/AbstractToken.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class AbstractToken {
    constructor(string) {
        this.string = string;
    }
}
exports["default"] = AbstractToken;


/***/ }),

/***/ "./app/src/ast/tokens/Adjective.ts":
/*!*****************************************!*\
  !*** ./app/src/ast/tokens/Adjective.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Adjective extends AbstractToken_1.default {
}
exports["default"] = Adjective;


/***/ }),

/***/ "./app/src/ast/tokens/Article.ts":
/*!***************************************!*\
  !*** ./app/src/ast/tokens/Article.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Article extends AbstractToken_1.default {
    isDefinite() {
        return definite_articles_1.default.includes(this.string);
    }
    toString() {
        return `Article(${this.string}, isDefinite=${this.isDefinite()})`;
    }
}
exports["default"] = Article;


/***/ }),

/***/ "./app/src/ast/tokens/Copula.ts":
/*!**************************************!*\
  !*** ./app/src/ast/tokens/Copula.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Copula extends AbstractToken_1.default {
}
exports["default"] = Copula;


/***/ }),

/***/ "./app/src/ast/tokens/FullStop.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/FullStop.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class FullStop extends AbstractToken_1.default {
}
exports["default"] = FullStop;


/***/ }),

/***/ "./app/src/ast/tokens/HVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/HVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class HVerb extends AbstractToken_1.default {
}
exports["default"] = HVerb;


/***/ }),

/***/ "./app/src/ast/tokens/IVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/IVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class IVerb extends AbstractToken_1.default {
}
exports["default"] = IVerb;


/***/ }),

/***/ "./app/src/ast/tokens/MVerb.ts":
/*!*************************************!*\
  !*** ./app/src/ast/tokens/MVerb.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class MVerb extends AbstractToken_1.default {
}
exports["default"] = MVerb;


/***/ }),

/***/ "./app/src/ast/tokens/Negation.ts":
/*!****************************************!*\
  !*** ./app/src/ast/tokens/Negation.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Negation extends AbstractToken_1.default {
}
exports["default"] = Negation;


/***/ }),

/***/ "./app/src/ast/tokens/NonSubordinatingConjunction.ts":
/*!***********************************************************!*\
  !*** ./app/src/ast/tokens/NonSubordinatingConjunction.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class NonSubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = NonSubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Noun.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Noun.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Noun extends AbstractToken_1.default {
}
exports["default"] = Noun;


/***/ }),

/***/ "./app/src/ast/tokens/Preposition.ts":
/*!*******************************************!*\
  !*** ./app/src/ast/tokens/Preposition.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Preposition extends AbstractToken_1.default {
}
exports["default"] = Preposition;


/***/ }),

/***/ "./app/src/ast/tokens/Quantifier.ts":
/*!******************************************!*\
  !*** ./app/src/ast/tokens/Quantifier.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Quantifier extends AbstractToken_1.default {
    isUniversal() {
        return universal_quantifiers_1.default.includes(this.string);
    }
    isExistential() {
        return existential_quantifiers_1.default.includes(this.string);
    }
}
exports["default"] = Quantifier;


/***/ }),

/***/ "./app/src/ast/tokens/RelativePronoun.ts":
/*!***********************************************!*\
  !*** ./app/src/ast/tokens/RelativePronoun.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class RelativePronoun extends AbstractToken_1.default {
}
exports["default"] = RelativePronoun;


/***/ }),

/***/ "./app/src/ast/tokens/SubordinatingConjunction.ts":
/*!********************************************************!*\
  !*** ./app/src/ast/tokens/SubordinatingConjunction.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class SubordinatingConjunction extends AbstractToken_1.default {
}
exports["default"] = SubordinatingConjunction;


/***/ }),

/***/ "./app/src/ast/tokens/Then.ts":
/*!************************************!*\
  !*** ./app/src/ast/tokens/Then.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const AbstractToken_1 = __importDefault(__webpack_require__(/*! ./AbstractToken */ "./app/src/ast/tokens/AbstractToken.ts"));
class Then extends AbstractToken_1.default {
}
exports["default"] = Then;


/***/ }),

/***/ "./app/src/brain/ActuatorBrain.ts":
/*!****************************************!*\
  !*** ./app/src/brain/ActuatorBrain.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Actuator_1 = __webpack_require__(/*! ../actuator/Actuator */ "./app/src/actuator/Actuator.ts");
const PrologBrain_1 = __importDefault(__webpack_require__(/*! ./PrologBrain */ "./app/src/brain/PrologBrain.ts"));
class ActuatorBrain extends PrologBrain_1.default {
    constructor() {
        super();
        this.actuator = (0, Actuator_1.getActuator)(this);
    }
    execute(natlang) {
        const _super = Object.create(null, {
            execute: { get: () => super.execute }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const results = yield _super.execute.call(this, natlang);
            const pointedOutIds = results.flatMap(m => Object.values(m)).filter(id => id.toString().includes('id'));
            this.actuator.pointOut(pointedOutIds);
            return results;
        });
    }
    assert(clause, opts) {
        const _super = Object.create(null, {
            assert: { get: () => super.assert }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const before = yield this.snapshot();
            const results = yield _super.assert.call(this, clause, opts);
            this.actuator.onUpdate(yield this.diff(before));
            return results;
        });
    }
}
exports["default"] = ActuatorBrain;


/***/ }),

/***/ "./app/src/brain/Anaphora.ts":
/*!***********************************!*\
  !*** ./app/src/brain/Anaphora.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAnaphora = void 0;
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../clauses/Id */ "./app/src/clauses/Id.ts");
const Brain_1 = __webpack_require__(/*! ./Brain */ "./app/src/brain/Brain.ts");
function getAnaphora(clause) {
    return new BaseAnaphora(clause);
}
exports.getAnaphora = getAnaphora;
class BaseAnaphora {
    constructor(clause) {
        this.clause = clause;
    }
    mapTo(universe) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.clause.entities.every(e => (0, Id_1.isVar)(e))) { // this is a pure implication //TODO: possbile problem: every cat that is on the mat
                return {};
            }
            const themeEnts = this.clause.theme.entities;
            // get descriptions of entities in theme omitting relations with entities in rheme
            const themeDescs = this.clause.theme.flatList();
            // get descriptions of entities in rheme omitting relations with entities in theme
            const rhemeDescs = this.clause.rheme.flatList()
                .filter(c => themeEnts.every(e => !c.entities.includes(e)));
            const mapToVar = this.clause.entities
                .map(e => ({ [e]: (0, Id_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            const reverseMapToVar = Object.fromEntries(Object.entries(mapToVar).map(e => [e[1], e[0]]));
            const bigDescClause = themeDescs
                .concat(rhemeDescs)
                .reduce((c1, c2) => c1.and(c2), (0, Clause_1.emptyClause)())
                .copy({ map: mapToVar });
            const candidates = yield universe.query(bigDescClause);
            const chosen = (_a = candidates[0]) !== null && _a !== void 0 ? _a : {}; //TODO: better criterion !!!
            const anaphora = Object
                .keys(chosen)
                .map(k => { var _a; return ({ [reverseMapToVar[k]]: (_a = chosen[k]) !== null && _a !== void 0 ? _a : reverseMapToVar[k] }); })
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
            return anaphora;
        });
    }
    mapToClause(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            const brain = yield (0, Brain_1.getBrain)({ withActuator: false });
            yield brain.assert(clause);
            return this.mapTo(brain);
        });
    }
}


/***/ }),

/***/ "./app/src/brain/Brain.ts":
/*!********************************!*\
  !*** ./app/src/brain/Brain.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBrain = void 0;
const ActuatorBrain_1 = __importDefault(__webpack_require__(/*! ./ActuatorBrain */ "./app/src/brain/ActuatorBrain.ts"));
const Ontology_1 = __webpack_require__(/*! ./Ontology */ "./app/src/brain/Ontology.ts");
const PrologBrain_1 = __importDefault(__webpack_require__(/*! ./PrologBrain */ "./app/src/brain/PrologBrain.ts"));
function getBrain(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const cons = (opts === null || opts === void 0 ? void 0 : opts.withActuator) ? ActuatorBrain_1.default : PrologBrain_1.default;
        return new cons().inject((0, Ontology_1.getOntology)());
    });
}
exports.getBrain = getBrain;


/***/ }),

/***/ "./app/src/brain/Ontology.ts":
/*!***********************************!*\
  !*** ./app/src/brain/Ontology.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOntology = void 0;
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
function getOntology() {
    return new BaseOntology();
}
exports.getOntology = getOntology;
class BaseOntology {
    get objects() {
        return [
            ['id100', document.body]
        ];
    }
    get clauses() {
        return [
            (0, Clause_1.clauseOf)('body', 'id100')
        ];
    }
}


/***/ }),

/***/ "./app/src/brain/PrologBrain.ts":
/*!**************************************!*\
  !*** ./app/src/brain/PrologBrain.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ../clauses/Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ../clauses/Id */ "./app/src/clauses/Id.ts");
const Parser_1 = __webpack_require__(/*! ../parser/Parser */ "./app/src/parser/Parser.ts");
const Prolog_1 = __webpack_require__(/*! ../prolog/Prolog */ "./app/src/prolog/Prolog.ts");
const Anaphora_1 = __webpack_require__(/*! ./Anaphora */ "./app/src/brain/Anaphora.ts");
const Ed_1 = __importDefault(__webpack_require__(/*! ../actuator/Ed */ "./app/src/actuator/Ed.ts"));
class PrologBrain {
    constructor(kb = (0, Prolog_1.getProlog)(), ed = (0, Ed_1.default)()) {
        this.kb = kb;
        this.ed = ed;
    }
    inject(ontology) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const c of ontology.clauses) {
                yield this.assert(c);
            }
            ontology.objects.forEach(o => {
                this.ed.set(o[0], o[1]);
            });
            return this;
        });
    }
    execute(natlang) {
        return __awaiter(this, void 0, void 0, function* () {
            let x = [];
            for (const ast of (0, Parser_1.getParser)(natlang).parseAll()) {
                x = yield (ast.isSideEffecty ? this.assert(ast.toClause()) : this.query(ast.toClause()));
            }
            console.log(x);
            return x;
        });
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const mapToVar = query.entities
                .map(e => ({ [e]: (0, Id_1.toVar)(e) }))
                .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
            const q = query
                .copy({ map: mapToVar })
                .toProlog({ anyFactId: true })
                .reduce((a, b) => `${a}, ${b}`) + '.'; // TODO: deal with dot at a lower level ?
            return yield this.kb.query(q);
        });
    }
    assert(clause, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const anaphoraMap = (opts === null || opts === void 0 ? void 0 : opts.noAnaphora) ? {} : yield (0, Anaphora_1.getAnaphora)(clause).mapTo(this);
            const toBeAsserted = clause
                .copy({ map: anaphoraMap })
                .toProlog({ anyFactId: false });
            for (const c of toBeAsserted) { // TODO: bug finding one entity multiple times
                console.log('asserting', c);
                yield this.kb.assert(c);
            }
            return [];
        });
    }
    snapshot() {
        return __awaiter(this, void 0, void 0, function* () {
            const is = (yield this.query((0, Clause_1.clauseOf)('X', 'Y')))
                .map(e => (0, Clause_1.clauseOf)(e.X, e.Y));
            const does = (yield this.query((0, Clause_1.clauseOf)('P', 'A', 'B')))
                .map(e => (0, Clause_1.clauseOf)(e.P, e.A, e.B));
            const isNot = (yield this.query((0, Clause_1.clauseOf)('X', 'Y').copy({ negate: true })))
                .map(e => (0, Clause_1.clauseOf)(e.X, e.Y));
            const doesNot = (yield this.query((0, Clause_1.clauseOf)('P', 'A', 'B').copy({ negate: true })))
                .map(e => (0, Clause_1.clauseOf)(e.P, e.A, e.B));
            return { be: is, rel: does, relNot: doesNot, beNot: isNot };
        });
    }
    diff(before) {
        return __awaiter(this, void 0, void 0, function* () {
            const now = yield this.snapshot();
            const beDiff = now.be.filter(c => !(before.be.map(c => c.hashCode)).includes(c.hashCode));
            const relDiff = now.rel.filter(c => !(before.rel.map(c => c.hashCode)).includes(c.hashCode));
            const res = beDiff.concat(relDiff);
            return res.filter((e, i) => res.map(c => c.hashCode).indexOf(e.hashCode) === i); //TODO: de-uglify deduplication
        });
    }
}
exports["default"] = PrologBrain;


/***/ }),

/***/ "./app/src/clauses/And.ts":
/*!********************************!*\
  !*** ./app/src/clauses/And.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ./Clause */ "./app/src/clauses/Clause.ts");
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
class And {
    constructor(clauses, negated = false, isImply = false, hashCode = (0, Clause_1.hashString)(JSON.stringify(arguments)), theme = clauses[0], rheme = clauses[1]) {
        this.clauses = clauses;
        this.negated = negated;
        this.isImply = isImply;
        this.hashCode = hashCode;
        this.theme = theme;
        this.rheme = rheme;
    }
    and(other, opts) {
        return (opts === null || opts === void 0 ? void 0 : opts.asRheme) ?
            new And([this, other]) :
            new And([...this.flatList(), ...other.flatList()]);
    }
    copy(opts) {
        return new And(this.clauses.map(c => c.copy(Object.assign(Object.assign({}, opts), { negate: false }))), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return this.negated ? [this] : this.clauses.flatMap(c => c.flatList());
    }
    get entities() {
        return Array.from(new Set(this.clauses.flatMap(c => c.entities)));
    }
    implies(conclusion) {
        return new Imply_1.default(this, conclusion);
    }
    toProlog(opts) {
        return this.clauses.length === 1 && this.negated ? //TODO: fix this crap
            this.clauses[0].copy({ negate: true }).toProlog(opts) :
            this.clauses.flatMap(c => c.toProlog(opts));
    }
}
exports["default"] = And;


/***/ }),

/***/ "./app/src/clauses/BasicClause.ts":
/*!****************************************!*\
  !*** ./app/src/clauses/BasicClause.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicClause = void 0;
const Clause_1 = __webpack_require__(/*! ./Clause */ "./app/src/clauses/Clause.ts");
const Id_1 = __webpack_require__(/*! ./Id */ "./app/src/clauses/Id.ts");
const Imply_1 = __importDefault(__webpack_require__(/*! ./Imply */ "./app/src/clauses/Imply.ts"));
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
class BasicClause {
    constructor(predicate, args, negated = false, isImply = false, hashCode = (0, Clause_1.hashString)(JSON.stringify(arguments)), rheme = (0, Clause_1.emptyClause)()) {
        this.predicate = predicate;
        this.args = args;
        this.negated = negated;
        this.isImply = isImply;
        this.hashCode = hashCode;
        this.rheme = rheme;
    }
    and(other, opts) {
        return new And_1.default(this.flatList().concat(other.flatList()));
    }
    copy(opts) {
        return new BasicClause(this.predicate, this.args.map(a => { var _a; return (opts === null || opts === void 0 ? void 0 : opts.map) ? (_a = opts === null || opts === void 0 ? void 0 : opts.map[a]) !== null && _a !== void 0 ? _a : a : a; }), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this];
    }
    toProlog(opts) {
        const pred = this.args.length === 1 ? 'be' : 'rel';
        const args = [(opts === null || opts === void 0 ? void 0 : opts.anyFactId) ? '_' : (0, Id_1.getRandomId)(), ...this.args.slice(0, 2), this.predicate, !this.negated];
        return [`${pred}(${args.reduce((a, b) => a + ', ' + b)})`];
    }
    get entities() {
        return Array.from(new Set(this.args));
    }
    get theme() {
        return this;
    }
    implies(conclusion) {
        return new Imply_1.default(this, conclusion);
    }
}
exports.BasicClause = BasicClause;


/***/ }),

/***/ "./app/src/clauses/Clause.ts":
/*!***********************************!*\
  !*** ./app/src/clauses/Clause.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashString = exports.emptyClause = exports.clauseOf = void 0;
const BasicClause_1 = __webpack_require__(/*! ./BasicClause */ "./app/src/clauses/BasicClause.ts");
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
function clauseOf(predicate, ...args) {
    return new BasicClause_1.BasicClause(predicate, args);
}
exports.clauseOf = clauseOf;
const emptyClause = () => new And_1.default([]);
exports.emptyClause = emptyClause;
function hashString(string) {
    return string.split('').map(c => c.charCodeAt(0)).reduce((hash, cc) => {
        const h1 = ((hash << 5) - hash) + cc;
        return h1 & h1; // Convert to 32bit integer
    });
}
exports.hashString = hashString;


/***/ }),

/***/ "./app/src/clauses/Id.ts":
/*!*******************************!*\
  !*** ./app/src/clauses/Id.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVar = exports.toVar = exports.getRandomId = void 0;
function getRandomId(opts) {
    const newId = `id${parseInt(1000 * Math.random() + '')}`;
    return (opts === null || opts === void 0 ? void 0 : opts.asVar) ? toVar(newId) : newId;
}
exports.getRandomId = getRandomId;
function toVar(id) {
    return (!Number.isNaN(Number(id)) ? `id${id}` : id + '').toUpperCase();
}
exports.toVar = toVar;
function isVar(e) {
    return Number.isNaN(Number(e)) && (e.toString()[0] === e.toString()[0].toUpperCase());
}
exports.isVar = isVar;


/***/ }),

/***/ "./app/src/clauses/Imply.ts":
/*!**********************************!*\
  !*** ./app/src/clauses/Imply.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Clause_1 = __webpack_require__(/*! ./Clause */ "./app/src/clauses/Clause.ts");
const And_1 = __importDefault(__webpack_require__(/*! ./And */ "./app/src/clauses/And.ts"));
class Imply {
    constructor(condition, conclusion, negated = false, isImply = true, hashCode = (0, Clause_1.hashString)(JSON.stringify(arguments)), theme = condition.theme) {
        this.condition = condition;
        this.conclusion = conclusion;
        this.negated = negated;
        this.isImply = isImply;
        this.hashCode = hashCode;
        this.theme = theme;
    }
    and(other, opts) {
        return new And_1.default([this, other]);
    }
    copy(opts) {
        return new Imply(this.condition.copy(opts), this.conclusion.copy(opts), (opts === null || opts === void 0 ? void 0 : opts.negate) ? !this.negated : this.negated);
    }
    flatList() {
        return [this];
    }
    /**
     * Generates horn clauses, one for each conclusion.
     * Since prolog only supports that kind of implication.
     * @returns
     */
    toProlog(opts) {
        const conditionString = this.condition
            .toProlog(Object.assign(Object.assign({}, opts), { anyFactId: true }))
            .reduce((c1, c2) => `${c1}, ${c2}`);
        const conclusions = this.conclusion.flatList();
        return conclusions.map(c => `${c.toProlog(Object.assign(Object.assign({}, opts), { anyFactId: true }))[0]} :- ${conditionString}`); //TODO: [0] is to be dealt with better
    }
    get entities() {
        return this.condition.entities.concat(this.conclusion.entities);
    }
    get rheme() {
        return this; // dunno what I'm doin'
    }
    implies(conclusion) {
        throw new Error('not implemented!');
    }
}
exports["default"] = Imply;


/***/ }),

/***/ "./app/src/index.ts":
/*!**************************!*\
  !*** ./app/src/index.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Anaphora_1 = __webpack_require__(/*! ./brain/Anaphora */ "./app/src/brain/Anaphora.ts");
const Parser_1 = __webpack_require__(/*! ./parser/Parser */ "./app/src/parser/Parser.ts");
// PROLOG TEST //////////////////////////////////////////
// const pro = getProlog();
// (window as any).pro = pro;
// (async () => {
//     await pro.assert('capra(scemo)')
//     await pro.assert('mammal(peloso)')
//     await pro.assert('mammal(fido)')
//     await pro.assert('mammal(X) :- capra(X)')
//     console.log(await pro.query('mammal(X).'))
//     await pro.retract('capra(scemo)')
//     console.log(await pro.query('mammal(X).'))
// })();
// //      //////////////////////////////////////////
//////////////////////////////////////////////////////////////
// console.log((tokenOf('a') as Article).isDefinite())
// console.log(tokenOf('a')  instanceof Article)
// console.log(tokenOf('a')  instanceof Quantifier)
// console.log(tokenOf('every')  instanceof Quantifier)
// console.log(tokenOf('a').toString())
//////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////
// const lexer = getLexer('the cat is a cat.')
// console.log(lexer)
// console.log('is it a noun?', lexer.assert(Noun, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it a copula?', lexer.assert(Copula, {errorOut:false}) )
// console.log(lexer.peek)
// console.log('is it an article?', lexer.assert(Article, {errorOut:false}) )
// console.log(lexer.peek)
///////////////////////////////////////////////////////
// console.log(getParser('the cat is big').parse())
// console.log(getParser('the big cat').parse() )
// console.log(getParser('the big cat on the table is eating tuna').parse() )
// console.log(getParser('the big cat on the mat').parse() )
// console.log(getParser('every dog is stupid').parse() )
// console.log(getParser('the cat that is smart').parse() )
// console.log(getParser('nodejs is not helpful').parse() )
// console.log(getParser('if the dog is stupid then the cat is happy').parse() )
// console.log(getParser('the cat is happy if the dog is stupid').parse() )
// console.log((window as any).ast = getParser('the color of the button is red').parse())
// console.log((window as any).ast = getParser('the color of the button on the black div is red').parse())
// COMPILER TESTS
// function test(string: string) {
//     console.log(string)
//     const clause = getParser(string).parse().toClause().copy({ map: { 'id1': 1000, 'id2': 2000 } })
//     // console.log(clause.flatList().map(c => c.toString()))
//     console.log(clause.toProlog())
//     // console.log(clause)
//     // console.log('entities', clause.entities)
//     // console.log('theme', clause.theme)
//     // console.log('rheme', clause.rheme)
//     // console.log(clause.about('id0'))
// }
// test('the cat is on the mat')
// // test('the cat that is red is on the mat')
// // test('the big cat that is on the mat is black')
// test('every cat is red')
// test('every red cat is on the mat')
// // test('the cat exists on the mat')
// test('if the cat is on the mat then the cat is red')
// // test('the cat is not red')
// test('every cat is not red')
// test('trump is not a great president'); // probably need an and predicate
// END COMPILER TESTS
// (async () => {
//     const brain = await getBrain();
//     const c = clauseOf('capra', 'uno')
//         .concat(clauseOf('capra', 2))
//         .concat(clauseOf('capra', 3))
//         .concat(clauseOf('white', 3))
//         .concat(clauseOf('cat', 4))
//         .concat(clauseOf('white', 4))
//     await brain.assert(c);
//     console.log(await brain.query(clauseOf('white', 'X').concat(clauseOf('cat', 'X'))))
// })()
// (async () => {
//     const state = {
//         timer : setTimeout(()=>{},0),
//         brain : await getBrain(),
//         debouncingTime : 0
//     }
//     const p = document.createElement('p')
//     document.getElementById('root')?.appendChild(p)
//     const textarea = document.createElement('textarea')
//     textarea.style.height = '50vh'
//     textarea.style.width = '50vw'
//     document.getElementById('root')?.appendChild(textarea)
//     const onInput = async () => {
//         const text = textarea.value
//         const ast = getParser(text).parse()
//         const clause = ast.toProlog()
//         if (!clause){
//             return 
//         }
//         const mapping = getSandbox(clause).mapTo(state.brain)
//         p.innerHTML = `${(ast as any).constructor.name}: ${clause.toString()}`
//         if (ast instanceof CopulaQuestion){
//             console.log(await state.brain.query(clause))
//         }else{
//             console.log('asserted:', clause.toString())
//         }
//     }
//     textarea.oninput = e => {
//         clearTimeout(state.timer)
//         state.timer = setTimeout(()=>{
//             onInput()
//         }, state.debouncingTime)
//     }
// })();
// (async () => {
//     const prolog = await getBrain();
//     (window as any).prolog = prolog
//     await prolog.assert(clauseOf('cat', 'a'))
//     await prolog.assert(clauseOf('cat', 'b'))
//     await prolog.assert(clauseOf('cat', 'c'))
//     await prolog.assert(clauseOf('white', 'a'))
//     await prolog.assert(clauseOf('dog', 'd'))
//     await prolog.assert(clauseOf('eat', 'a', 'rabbit'))
//     await prolog.assert(clauseOf('eat', 'a', 'mouse'))
//     await prolog.assert(clauseOf('eat', 'a', 'birdie'))
//     await prolog.assert(clauseOf('eat', 'd', 'bone'))
//     await prolog.assert(clauseOf('table', 'tb1'))
//     // const res = await prolog.query(clauseOf('cat', 'X').concat(clauseOf('eat', 'X', 'Y').concat(clauseOf('dog', 'Z'))))
//     // const clause = clauseOf('cat', 'id0').concat(clauseOf('dog', 'id1')).concat(clauseOf('capra', 'id55')) 
//     // const clause = getParser('the cat that is black is smart').parse().toProlog()
//     const clause = getParser('the cat that is white is on the table').parse().toProlog()
//     console.log(clause.toString())
//     const res = await getSandbox(clause).mapTo(prolog)
//     console.log(res)
//     console.log(clause.rheme.copy({ map: res }).toString())
// })();
// prologPlay()
// compileLogicTest()
// const x = getParser('the cat is black').parse().toClause().toProlog({anyFactId:false})
// console.log(x)
// const y = getParser('is the cat black').parse().toClause().toProlog({anyFactId :true})
// console.log(y)
// const x = getParser('the cat is on the mat. the cat is red. the cat is black')
//         .parseAll()
//         .map(c=>c.toClause().toProlog())
// console.log(x)
// (async ()=>{
//     const map = await getAnaphora(getParser('the black cat').parse().toClause()).mapToClause(getParser('the black cat').parse().toClause())
//     console.log(map)
//     const map2 = await getAnaphora(getParser('the red cat').parse().toClause()).mapToClause(getParser('the black cat').parse().toClause())
//     console.log(map2)
// })()
(() => __awaiter(void 0, void 0, void 0, function* () {
    // if the button is red then the button is green
    const small = (0, Parser_1.getParser)('the button is red').parse().toClause();
    const universe = (0, Parser_1.getParser)('the stupid button is green').parse().toClause();
    const map = yield (0, Anaphora_1.getAnaphora)(small).mapToClause(universe);
    console.log(map);
}))();
// playground()


/***/ }),

/***/ "./app/src/lexer/EagerLexer.ts":
/*!*************************************!*\
  !*** ./app/src/lexer/EagerLexer.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tokenOf_1 = __importDefault(__webpack_require__(/*! ./tokenOf */ "./app/src/lexer/tokenOf.ts"));
class EagerLexer {
    constructor(sourceCode) {
        this.sourceCode = sourceCode;
        //TODO: reconstruct "do not" and "does not" tokens
        //TODO: nouns vs adjectives
        this.tokens = sourceCode.trim().split(/\s+|\./).map(e => !e ? '.' : e).map(tokenOf_1.default);
        console.debug('tokens', this.tokens);
        this._pos = 0;
    }
    next() {
        this._pos++;
    }
    get pos() {
        return this._pos;
    }
    backTo(pos) {
        this._pos = pos;
    }
    get peek() {
        return this.tokens[this._pos];
    }
    croak(errorMsg) {
        throw new Error(`${errorMsg} at ${this._pos}`);
    }
    /**
     * Return current token iff of given type and move to next;
     * else return undefined and don't move.
     * @param args
     * @returns
     */
    assert(clazz, args) {
        var _a, _b;
        const current = this.peek;
        if (current instanceof clazz) {
            this.next();
            return current;
        }
        else if ((_a = args.errorOut) !== null && _a !== void 0 ? _a : true) {
            this.croak((_b = args.errorMsg) !== null && _b !== void 0 ? _b : '');
        }
        else {
            return undefined;
        }
    }
    get isEnd() {
        return this.pos >= this.tokens.length;
    }
}
exports["default"] = EagerLexer;


/***/ }),

/***/ "./app/src/lexer/Lexer.ts":
/*!********************************!*\
  !*** ./app/src/lexer/Lexer.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLexer = void 0;
const EagerLexer_1 = __importDefault(__webpack_require__(/*! ./EagerLexer */ "./app/src/lexer/EagerLexer.ts"));
function getLexer(sourceCode) {
    return new EagerLexer_1.default(sourceCode);
}
exports.getLexer = getLexer;


/***/ }),

/***/ "./app/src/lexer/tokenOf.ts":
/*!**********************************!*\
  !*** ./app/src/lexer/tokenOf.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const adjectives_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/adjectives */ "./app/res/tokens/adjectives.ts"));
const indefinite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/indefinite_articles */ "./app/res/tokens/indefinite_articles.ts"));
const definite_articles_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/definite_articles */ "./app/res/tokens/definite_articles.ts"));
const copulas_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/copulas */ "./app/res/tokens/copulas.ts"));
const hverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/hverbs */ "./app/res/tokens/hverbs.ts"));
const iverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/iverbs */ "./app/res/tokens/iverbs.ts"));
const mverbs_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/mverbs */ "./app/res/tokens/mverbs.ts"));
const negations_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/negations */ "./app/res/tokens/negations.ts"));
const nonsubconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nonsubconj */ "./app/res/tokens/nonsubconj.ts"));
const nouns_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/nouns */ "./app/res/tokens/nouns.ts"));
const prepositions_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/prepositions */ "./app/res/tokens/prepositions.ts"));
const existential_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/existential_quantifiers */ "./app/res/tokens/existential_quantifiers.ts"));
const universal_quantifiers_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/universal_quantifiers */ "./app/res/tokens/universal_quantifiers.ts"));
const relprons_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/relprons */ "./app/res/tokens/relprons.ts"));
const subconj_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/subconj */ "./app/res/tokens/subconj.ts"));
const then_1 = __importDefault(__webpack_require__(/*! ../../res/tokens/then */ "./app/res/tokens/then.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const HVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/HVerb */ "./app/src/ast/tokens/HVerb.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const NonSubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/NonSubordinatingConjunction */ "./app/src/ast/tokens/NonSubordinatingConjunction.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const FullStop_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/FullStop */ "./app/src/ast/tokens/FullStop.ts"));
function tokenOf(string) {
    if (indefinite_articles_1.default.concat(definite_articles_1.default).includes(string)) {
        return new Article_1.default(string);
    }
    else if (copulas_1.default.includes(string)) {
        return new Copula_1.default(string);
    }
    else if (hverbs_1.default.includes(string)) {
        return new HVerb_1.default(string);
    }
    else if (iverbs_1.default.includes(string)) {
        return new IVerb_1.default(string);
    }
    else if (mverbs_1.default.includes(string)) {
        return new MVerb_1.default(string);
    }
    else if (negations_1.default.includes(string)) {
        return new Negation_1.default(string);
    }
    else if (nonsubconj_1.default.includes(string)) {
        return new NonSubordinatingConjunction_1.default(string);
    }
    else if (prepositions_1.default.includes(string)) {
        return new Preposition_1.default(string);
    }
    else if (existential_quantifiers_1.default.concat(universal_quantifiers_1.default).includes(string)) {
        return new Quantifier_1.default(string);
    }
    else if (then_1.default.includes(string)) {
        return new Then_1.default(string);
    }
    else if (relprons_1.default.includes(string)) {
        return new RelativePronoun_1.default(string);
    }
    else if (subconj_1.default.includes(string)) {
        return new SubordinatingConjunction_1.default(string);
    }
    else if (nouns_1.default.includes(string)) {
        return new Noun_1.default(string);
    }
    else if (adjectives_1.default.includes(string)) {
        return new Adjective_1.default(string);
    }
    else if ('.' === string) {
        return new FullStop_1.default('.');
    }
    return new Adjective_1.default(string);
}
exports["default"] = tokenOf;


/***/ }),

/***/ "./app/src/parser/BasicParser.ts":
/*!***************************************!*\
  !*** ./app/src/parser/BasicParser.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const Complement_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/Complement */ "./app/src/ast/phrases/Complement.ts"));
const NounPhrase_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/NounPhrase */ "./app/src/ast/phrases/NounPhrase.ts"));
const ComplexSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/ComplexSentence */ "./app/src/ast/sentences/ComplexSentence.ts"));
const CopulaQuestion_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaQuestion */ "./app/src/ast/sentences/CopulaQuestion.ts"));
const CopulaSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/CopulaSentence */ "./app/src/ast/sentences/CopulaSentence.ts"));
const IntransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/IntransitiveSentence */ "./app/src/ast/sentences/IntransitiveSentence.ts"));
const MonotransitiveSentence_1 = __importDefault(__webpack_require__(/*! ../ast/sentences/MonotransitiveSentence */ "./app/src/ast/sentences/MonotransitiveSentence.ts"));
const Adjective_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Adjective */ "./app/src/ast/tokens/Adjective.ts"));
const Article_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Article */ "./app/src/ast/tokens/Article.ts"));
const Copula_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Copula */ "./app/src/ast/tokens/Copula.ts"));
const IVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/IVerb */ "./app/src/ast/tokens/IVerb.ts"));
const MVerb_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/MVerb */ "./app/src/ast/tokens/MVerb.ts"));
const Negation_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Negation */ "./app/src/ast/tokens/Negation.ts"));
const Noun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Noun */ "./app/src/ast/tokens/Noun.ts"));
const Preposition_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Preposition */ "./app/src/ast/tokens/Preposition.ts"));
const Quantifier_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Quantifier */ "./app/src/ast/tokens/Quantifier.ts"));
const SubordinatingConjunction_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/SubordinatingConjunction */ "./app/src/ast/tokens/SubordinatingConjunction.ts"));
const Then_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/Then */ "./app/src/ast/tokens/Then.ts"));
const Lexer_1 = __webpack_require__(/*! ../lexer/Lexer */ "./app/src/lexer/Lexer.ts");
const CopulaSubordinateClause_1 = __importDefault(__webpack_require__(/*! ../ast/phrases/CopulaSubordinateClause */ "./app/src/ast/phrases/CopulaSubordinateClause.ts"));
const RelativePronoun_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/RelativePronoun */ "./app/src/ast/tokens/RelativePronoun.ts"));
const FullStop_1 = __importDefault(__webpack_require__(/*! ../ast/tokens/FullStop */ "./app/src/ast/tokens/FullStop.ts"));
class BasicParser {
    constructor(sourceCode) {
        this.parseDeclaration = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCompound)) !== null && _a !== void 0 ? _a : this.try(this.parseSimple)) !== null && _b !== void 0 ? _b : this.errorOut('parseDeclaration()');
        };
        this.parseQuestion = () => {
            var _a;
            return (_a = this.try(this.parseBinaryQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseQuestion()');
        };
        this.parseSimple = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseCopulaSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseVerbSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseSimple()');
        };
        this.parseCompound = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseComplex)) !== null && _a !== void 0 ? _a : this.try(this.parseConjunctive)) !== null && _b !== void 0 ? _b : this.errorOut('parseCompound()');
        };
        this.parseVerbSentence = () => {
            var _a, _b;
            return (_b = (_a = this.try(this.parseIntransitiveSentence)) !== null && _a !== void 0 ? _a : this.try(this.parseMonotransitiveSentence)) !== null && _b !== void 0 ? _b : this.errorOut('parseVerbSentence()');
        };
        this.parseCopulaSentence = () => {
            const subject = this.parseNounPhrase();
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSentence(), expected copula' });
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const predicate = this.parseNounPhrase();
            return new CopulaSentence_1.default(subject, copula, predicate, negation);
        };
        this.parseComplex = () => {
            const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: false });
            if (subconj) {
                const condition = this.parseSimple();
                this.lx.assert(Then_1.default, { errorOut: false });
                const outcome = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
            else {
                const outcome = this.parseSimple();
                const subconj = this.lx.assert(SubordinatingConjunction_1.default, { errorOut: true, errorMsg: 'expected subordinating conjunction' });
                const condition = this.parseSimple();
                return new ComplexSentence_1.default(condition, outcome, subconj);
            }
        };
        this.parseIntransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const iverb = this.lx.assert(IVerb_1.default, { errorMsg: 'parseIntransitiveSentence(), expected i-verb' });
            const complements = this.parseComplements();
            return new IntransitiveSentence_1.default(subject, iverb, complements, negation);
        };
        this.parseMonotransitiveSentence = () => {
            const subject = this.parseNounPhrase();
            const negation = this.lx.assert(Negation_1.default, { errorOut: false });
            const mverb = this.lx.assert(MVerb_1.default, { errorMsg: 'parseMonotransitiveSentence(), expected i-verb' });
            const cs1 = this.parseComplements();
            const object = this.parseNounPhrase();
            const cs2 = this.parseComplements();
            return new MonotransitiveSentence_1.default(subject, mverb, object, cs1.concat(cs2), negation);
        };
        this.parseBinaryQuestion = () => {
            var _a;
            return (_a = this.try(this.parseCopulaQuestion)) !== null && _a !== void 0 ? _a : this.errorOut('parseBinaryQuestion()');
        };
        this.parseCopulaQuestion = () => {
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaQuestion(), expected copula' });
            const subject = this.parseNounPhrase();
            const predicate = this.parseNounPhrase();
            return new CopulaQuestion_1.default(subject, predicate, copula);
        };
        this.parseNounPhrase = () => {
            const quantifier = this.lx.assert(Quantifier_1.default, { errorOut: false });
            const article = this.lx.assert(Article_1.default, { errorOut: false });
            let adjectives = [];
            let adj;
            while (adj = this.lx.assert(Adjective_1.default, { errorOut: false })) {
                adjectives.push(adj);
            }
            const noun = this.lx.assert(Noun_1.default, { errorOut: false });
            const subordinateClause = this.try(this.parseSubordinateClause);
            const complements = this.parseComplements();
            return new NounPhrase_1.default(adjectives, complements, noun, quantifier, article, subordinateClause);
        };
        this.parseComplements = () => {
            const complements = [];
            let comp;
            while (comp = this.try(this.parseComplement)) {
                complements.push(comp);
            }
            return complements;
        };
        this.parseComplement = () => {
            const preposition = this.lx.assert(Preposition_1.default, { errorMsg: 'parseComplement() expected preposition' });
            const nounPhrase = this.parseNounPhrase();
            return new Complement_1.default(preposition, nounPhrase);
        };
        this.parseSubordinateClause = () => {
            var _a;
            return (_a = this.try(this.parseCopulaSubordinateClause)) !== null && _a !== void 0 ? _a : this.errorOut('parseSubordinateClause()');
        };
        this.parseCopulaSubordinateClause = () => {
            const relpron = this.lx.assert(RelativePronoun_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected relative pronoun' });
            const copula = this.lx.assert(Copula_1.default, { errorMsg: 'parseCopulaSubordinateClause() expected copula' });
            const subject = this.parseNounPhrase();
            return new CopulaSubordinateClause_1.default(relpron, subject, copula);
        };
        this.parseConjunctive = () => {
            throw new Error('NOT IMPLEMENTED! TODO!');
        };
        this.lx = (0, Lexer_1.getLexer)(sourceCode);
    }
    try(method) {
        const memento = this.lx.pos;
        try {
            return method();
        }
        catch (error) {
            console.debug(error.message);
            this.lx.backTo(memento);
        }
    }
    errorOut(errorMsg) {
        this.lx.croak(errorMsg);
        throw new Error(errorMsg);
    }
    parseAll() {
        const results = [];
        while (!this.lx.isEnd) {
            results.push(this.parse());
            this.lx.assert(FullStop_1.default, { errorOut: false });
        }
        return results;
    }
    parse() {
        var _a, _b, _c;
        return (_c = (_b = (_a = this.try(this.parseQuestion)) !== null && _a !== void 0 ? _a : this.try(this.parseDeclaration)) !== null && _b !== void 0 ? _b : this.try(this.parseNounPhrase) // for quick topic reference
        ) !== null && _c !== void 0 ? _c : this.errorOut('parse()');
    }
}
exports["default"] = BasicParser;


/***/ }),

/***/ "./app/src/parser/Parser.ts":
/*!**********************************!*\
  !*** ./app/src/parser/Parser.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParser = void 0;
const BasicParser_1 = __importDefault(__webpack_require__(/*! ./BasicParser */ "./app/src/parser/BasicParser.ts"));
function getParser(sourceCode) {
    return new BasicParser_1.default(sourceCode);
}
exports.getParser = getParser;


/***/ }),

/***/ "./app/src/prolog/Prolog.ts":
/*!**********************************!*\
  !*** ./app/src/prolog/Prolog.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProlog = void 0;
const TauProlog_1 = __importDefault(__webpack_require__(/*! ./TauProlog */ "./app/src/prolog/TauProlog.ts"));
function getProlog() {
    return new TauProlog_1.default();
}
exports.getProlog = getProlog;


/***/ }),

/***/ "./app/src/prolog/TauProlog.ts":
/*!*************************************!*\
  !*** ./app/src/prolog/TauProlog.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const tau_prolog_1 = __importDefault(__webpack_require__(/*! tau-prolog */ "./node_modules/tau-prolog/modules/core.js"));
__webpack_require__(/*! tau-prolog/modules/promises.js */ "./node_modules/tau-prolog/modules/promises.js")(tau_prolog_1.default);
class TauProlog {
    constructor() {
        this.session = tau_prolog_1.default.create();
    }
    assert(clause, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`assert${(opts === null || opts === void 0 ? void 0 : opts.z) ? 'z' : 'a'}( ( ${clause} ) ).`);
            yield this.session.promiseAnswer();
            return [];
        });
    }
    retract(clause) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(`retract(${clause}).`);
            yield this.session.promiseAnswer();
            return [];
        });
    }
    performQuery(code) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield this.session.promiseQuery(code);
            let answers = [];
            try {
                for (var _b = __asyncValues(this.session.promiseAnswers()), _c; _c = yield _b.next(), !_c.done;) {
                    let ans = _c.value;
                    const links = ans.links;
                    const entry = Object.keys(links)
                        .map(k => { var _a; return ({ [k]: (_a = links[k].value) !== null && _a !== void 0 ? _a : links[k].id }); })
                        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)));
                    answers.push(entry);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return answers;
        });
    }
    query(code) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.performQuery(code);
            }
            catch (e) {
                console.warn(this.parseError(e));
                return []; //TODO: fix bug if error not finding anything although there could be something!
            }
        });
    }
    parseError(e) {
        const error = e.args[0].args[0].id;
        if (error == 'existence_error') {
            const missingPredicate = e.args[0].args[0].args[1].args[0].id;
            return { error, missingPredicate };
        }
        else {
            return e;
        }
    }
    predicates(opts) {
        return Object.keys(this.session.rules)
            .map(r => r.split('/'))
            .filter(t => (opts === null || opts === void 0 ? void 0 : opts.arity) !== undefined ? parseInt(t[1]) === (opts === null || opts === void 0 ? void 0 : opts.arity) : true)
            .map(t => t[0]);
    }
}
exports["default"] = TauProlog;


/***/ }),

/***/ "?a95c":
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4ec4":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?b05a":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a1b8":
/*!********************!*\
  !*** os (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?1b04":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4a0f":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4461":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./app/src/index.ts");
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxpQkFBSTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdFQUFlO0FBQzdDO0FBQ0EsMkRBQTJELHFCQUFxQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0RBQWtELEVBQUU7QUFDcEQ7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsbUJBQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFVBQVUsc0JBQXNCO0FBQ3pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsaUJBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0VBQWdFO0FBQ2hFLDREQUE0RDtBQUM1RCwwREFBMEQ7QUFDMUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7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Q0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxRQUFRO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVSx3QkFBd0I7QUFDN0U7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsd0JBQXdCO0FBQzdFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQTZDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNB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LENBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFM0MsTUFBTSxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxLQUFLLENBQUMscUJBQVEsRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQ25ELEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLHFCQUFRLEVBQUMsQ0FBQyxDQUFDLENBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVoRCxNQUFNLEtBQUssR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBUSxFQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUN0RSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxxQkFBUSxFQUFDLENBQUMsQ0FBQyxDQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTNDLE1BQU0sT0FBTyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLHFCQUFRLEVBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2lCQUM3RSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxxQkFBUSxFQUFDLENBQUMsQ0FBQyxDQUFXLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFaEQsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUU7UUFDL0QsQ0FBQztLQUFBO0lBRUssSUFBSSxDQUFDLE1BQWtCOztZQUV6QixNQUFNLEdBQUcsR0FBRyxNQUFN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bmFyaXMveHh4Ly4vbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGliL3JlYWRsaW5lLXN5bmMuanMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vbm9kZV9tb2R1bGVzL3RhdS1wcm9sb2cvbW9kdWxlcy9jb3JlLmpzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL25vZGVfbW9kdWxlcy90YXUtcHJvbG9nL21vZHVsZXMvcHJvbWlzZXMuanMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvYWRqZWN0aXZlcy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9jb3B1bGFzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2RlZmluaXRlX2FydGljbGVzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2V4aXN0ZW50aWFsX3F1YW50aWZpZXJzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2h2ZXJicy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9pbmRlZmluaXRlX2FydGljbGVzLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL2l2ZXJicy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy9tdmVyYnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvbmVnYXRpb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL25vbnN1YmNvbmoudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvbm91bnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvcHJlcG9zaXRpb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL3JlbHByb25zLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9yZXMvdG9rZW5zL3N1YmNvbmoudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3Jlcy90b2tlbnMvdGhlbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvcmVzL3Rva2Vucy91bml2ZXJzYWxfcXVhbnRpZmllcnMudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hY3R1YXRvci9BY3R1YXRvci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FjdHVhdG9yL0VkLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYWN0dWF0b3IvYWN0aW9ucy9BY3Rpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hY3R1YXRvci9hY3Rpb25zL0NoYW5nZUNvbG9yLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYWN0dWF0b3IvYWN0aW9ucy9NYWtlQnV0dG9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYWN0dWF0b3IvYWN0aW9ucy9Ob09wLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYWN0dWF0b3Ivc2Vuc29ycy9DbGlja1NlbnNvci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FjdHVhdG9yL3NlbnNvcnMvU2Vuc29yLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3BocmFzZXMvQ29tcGxlbWVudC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9waHJhc2VzL0NvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3BocmFzZXMvTm91blBocmFzZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9zZW50ZW5jZXMvQ29tcGxleFNlbnRlbmNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3NlbnRlbmNlcy9Db3B1bGFRdWVzdGlvbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC9zZW50ZW5jZXMvQ29wdWxhU2VudGVuY2UudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3Qvc2VudGVuY2VzL0ludHJhbnNpdGl2ZVNlbnRlbmNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3NlbnRlbmNlcy9Nb25vdHJhbnNpdGl2ZVNlbnRlbmNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9BYnN0cmFjdFRva2VuLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9BZGplY3RpdmUudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0FydGljbGUudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0NvcHVsYS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvRnVsbFN0b3AudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL0hWZXJiLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9JVmVyYi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvTVZlcmIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL05lZ2F0aW9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9Ob25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL05vdW4udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL1ByZXBvc2l0aW9uLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9RdWFudGlmaWVyLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYXN0L3Rva2Vucy9SZWxhdGl2ZVByb25vdW4udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9hc3QvdG9rZW5zL1N1Ym9yZGluYXRpbmdDb25qdW5jdGlvbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2FzdC90b2tlbnMvVGhlbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2JyYWluL0FjdHVhdG9yQnJhaW4udHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9icmFpbi9BbmFwaG9yYS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2JyYWluL0JyYWluLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvYnJhaW4vT250b2xvZ3kudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9icmFpbi9Qcm9sb2dCcmFpbi50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2NsYXVzZXMvQW5kLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvY2xhdXNlcy9CYXNpY0NsYXVzZS50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2NsYXVzZXMvQ2xhdXNlLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvY2xhdXNlcy9JZC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2NsYXVzZXMvSW1wbHkudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2xleGVyL0VhZ2VyTGV4ZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9sZXhlci9MZXhlci50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL2xleGVyL3Rva2VuT2YudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9wYXJzZXIvQmFzaWNQYXJzZXIudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4Ly4vYXBwL3NyYy9wYXJzZXIvUGFyc2VyLnRzIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC8uL2FwcC9zcmMvcHJvbG9nL1Byb2xvZy50cyIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvLi9hcHAvc3JjL3Byb2xvZy9UYXVQcm9sb2cudHMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGlifGNoaWxkX3Byb2Nlc3MiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGlifGNyeXB0byIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvaWdub3JlZHwvaG9tZS9haW1hbi9naXRSZXBvcy90cy12b2ljZS1mb3ItZ29vZC9ub2RlX21vZHVsZXMvcmVhZGxpbmUtc3luYy9saWJ8ZnMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3JlYWRsaW5lLXN5bmMvbGlifG9zIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy9yZWFkbGluZS1zeW5jL2xpYnxwYXRoIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC9pZ25vcmVkfC9ob21lL2FpbWFuL2dpdFJlcG9zL3RzLXZvaWNlLWZvci1nb29kL25vZGVfbW9kdWxlcy90YXUtcHJvbG9nL21vZHVsZXN8ZnMiLCJ3ZWJwYWNrOi8vQGx1eGx1bmFyaXMveHh4L2lnbm9yZWR8L2hvbWUvYWltYW4vZ2l0UmVwb3MvdHMtdm9pY2UtZm9yLWdvb2Qvbm9kZV9tb2R1bGVzL3RhdS1wcm9sb2cvbW9kdWxlc3xwYXRoIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvd2VicGFjay9iZWZvcmUtc3RhcnR1cCIsIndlYnBhY2s6Ly9AbHV4bHVuYXJpcy94eHgvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL0BsdXhsdW5hcmlzL3h4eC93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIHJlYWRsaW5lU3luY1xuICogaHR0cHM6Ly9naXRodWIuY29tL2Fuc2VraS9yZWFkbGluZS1zeW5jXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGFuc2VraVxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyXG4gIElTX1dJTiA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicsXG5cbiAgQUxHT1JJVEhNX0NJUEhFUiA9ICdhZXMtMjU2LWNiYycsXG4gIEFMR09SSVRITV9IQVNIID0gJ3NoYTI1NicsXG4gIERFRkFVTFRfRVJSX01TRyA9ICdUaGUgY3VycmVudCBlbnZpcm9ubWVudCBkb2VzblxcJ3Qgc3VwcG9ydCBpbnRlcmFjdGl2ZSByZWFkaW5nIGZyb20gVFRZLicsXG5cbiAgZnMgPSByZXF1aXJlKCdmcycpLFxuICBUVFkgPSBwcm9jZXNzLmJpbmRpbmcoJ3R0eV93cmFwJykuVFRZLFxuICBjaGlsZFByb2MgPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJyksXG4gIHBhdGhVdGlsID0gcmVxdWlyZSgncGF0aCcpLFxuXG4gIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICAgcHJvbXB0OiAgICAgICAgICAgICAnPiAnLFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgbWFzazogICAgICAgICAgICAgICAnKicsXG4gICAgbGltaXQ6ICAgICAgICAgICAgICBbXSxcbiAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdJbnB1dCBhbm90aGVyLCBwbGVhc2UuJDwoIFspbGltaXQoXSk+JyxcbiAgICBkZWZhdWx0SW5wdXQ6ICAgICAgICcnLFxuICAgIHRydWVWYWx1ZTogICAgICAgICAgW10sXG4gICAgZmFsc2VWYWx1ZTogICAgICAgICBbXSxcbiAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlLFxuICAgIGtlZXBXaGl0ZXNwYWNlOiAgICAgZmFsc2UsXG4gICAgZW5jb2Rpbmc6ICAgICAgICAgICAndXRmOCcsXG4gICAgYnVmZmVyU2l6ZTogICAgICAgICAxMDI0LFxuICAgIHByaW50OiAgICAgICAgICAgICAgdm9pZCAwLFxuICAgIGhpc3Rvcnk6ICAgICAgICAgICAgdHJ1ZSxcbiAgICBjZDogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgIHBoQ29udGVudDogICAgICAgICAgdm9pZCAwLFxuICAgIHByZUNoZWNrOiAgICAgICAgICAgdm9pZCAwXG4gICAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICB9LFxuXG4gIGZkUiA9ICdub25lJywgZmRXLCB0dHlSLCBpc1Jhd01vZGUgPSBmYWxzZSxcbiAgZXh0SG9zdFBhdGgsIGV4dEhvc3RBcmdzLCB0ZW1wZGlyLCBzYWx0ID0gMCxcbiAgbGFzdElucHV0ID0gJycsIGlucHV0SGlzdG9yeSA9IFtdLCByYXdJbnB1dCxcbiAgX0RCR191c2VFeHQgPSBmYWxzZSwgX0RCR19jaGVja09wdGlvbnMgPSBmYWxzZSwgX0RCR19jaGVja01ldGhvZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRIb3N0QXJncyhvcHRpb25zKSB7XG4gIC8vIFNlbmQgYW55IHRleHQgdG8gY3JhenkgV2luZG93cyBzaGVsbCBzYWZlbHkuXG4gIGZ1bmN0aW9uIGVuY29kZUFyZyhhcmcpIHtcbiAgICByZXR1cm4gYXJnLnJlcGxhY2UoL1teXFx3XFx1MDA4MC1cXHVGRkZGXS9nLCBmdW5jdGlvbihjaHIpIHtcbiAgICAgIHJldHVybiAnIycgKyBjaHIuY2hhckNvZGVBdCgwKSArICc7JztcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBleHRIb3N0QXJncy5jb25jYXQoKGZ1bmN0aW9uKGNvbmYpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIE9iamVjdC5rZXlzKGNvbmYpLmZvckVhY2goZnVuY3Rpb24ob3B0aW9uTmFtZSkge1xuICAgICAgaWYgKGNvbmZbb3B0aW9uTmFtZV0gPT09ICdib29sZWFuJykge1xuICAgICAgICBpZiAob3B0aW9uc1tvcHRpb25OYW1lXSkgeyBhcmdzLnB1c2goJy0tJyArIG9wdGlvbk5hbWUpOyB9XG4gICAgICB9IGVsc2UgaWYgKGNvbmZbb3B0aW9uTmFtZV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChvcHRpb25zW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgYXJncy5wdXNoKCctLScgKyBvcHRpb25OYW1lLCBlbmNvZGVBcmcob3B0aW9uc1tvcHRpb25OYW1lXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH0pKHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICAgIGRpc3BsYXk6ICAgICAgICAnc3RyaW5nJyxcbiAgICBkaXNwbGF5T25seTogICAgJ2Jvb2xlYW4nLFxuICAgIGtleUluOiAgICAgICAgICAnYm9vbGVhbicsXG4gICAgaGlkZUVjaG9CYWNrOiAgICdib29sZWFuJyxcbiAgICBtYXNrOiAgICAgICAgICAgJ3N0cmluZycsXG4gICAgbGltaXQ6ICAgICAgICAgICdzdHJpbmcnLFxuICAgIGNhc2VTZW5zaXRpdmU6ICAnYm9vbGVhbidcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH0pKTtcbn1cblxuLy8gcGlwaW5nIHZpYSBmaWxlcyAoZm9yIE5vZGUuanMgdjAuMTAtKVxuZnVuY3Rpb24gX2V4ZWNGaWxlU3luYyhvcHRpb25zLCBleGVjT3B0aW9ucykge1xuXG4gIGZ1bmN0aW9uIGdldFRlbXBmaWxlKG5hbWUpIHtcbiAgICB2YXIgZmlsZXBhdGgsIHN1ZmZpeCA9ICcnLCBmZDtcbiAgICB0ZW1wZGlyID0gdGVtcGRpciB8fCByZXF1aXJlKCdvcycpLnRtcGRpcigpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGZpbGVwYXRoID0gcGF0aFV0aWwuam9pbih0ZW1wZGlyLCBuYW1lICsgc3VmZml4KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZkID0gZnMub3BlblN5bmMoZmlsZXBhdGgsICd3eCcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlID09PSAnRUVYSVNUJykge1xuICAgICAgICAgIHN1ZmZpeCsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZzLmNsb3NlU3luYyhmZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVwYXRoO1xuICB9XG5cbiAgdmFyIGhvc3RBcmdzLCBzaGVsbFBhdGgsIHNoZWxsQXJncywgcmVzID0ge30sIGV4aXRDb2RlLCBleHRNZXNzYWdlLFxuICAgIHBhdGhTdGRvdXQgPSBnZXRUZW1wZmlsZSgncmVhZGxpbmUtc3luYy5zdGRvdXQnKSxcbiAgICBwYXRoU3RkZXJyID0gZ2V0VGVtcGZpbGUoJ3JlYWRsaW5lLXN5bmMuc3RkZXJyJyksXG4gICAgcGF0aEV4aXQgPSBnZXRUZW1wZmlsZSgncmVhZGxpbmUtc3luYy5leGl0JyksXG4gICAgcGF0aERvbmUgPSBnZXRUZW1wZmlsZSgncmVhZGxpbmUtc3luYy5kb25lJyksXG4gICAgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyksIHNoYXN1bSwgZGVjaXBoZXIsIHBhc3N3b3JkO1xuXG4gIHNoYXN1bSA9IGNyeXB0by5jcmVhdGVIYXNoKEFMR09SSVRITV9IQVNIKTtcbiAgc2hhc3VtLnVwZGF0ZSgnJyArIHByb2Nlc3MucGlkICsgKHNhbHQrKykgKyBNYXRoLnJhbmRvbSgpKTtcbiAgcGFzc3dvcmQgPSBzaGFzdW0uZGlnZXN0KCdoZXgnKTtcbiAgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXIoQUxHT1JJVEhNX0NJUEhFUiwgcGFzc3dvcmQpO1xuXG4gIGhvc3RBcmdzID0gZ2V0SG9zdEFyZ3Mob3B0aW9ucyk7XG4gIGlmIChJU19XSU4pIHtcbiAgICBzaGVsbFBhdGggPSBwcm9jZXNzLmVudi5Db21TcGVjIHx8ICdjbWQuZXhlJztcbiAgICBwcm9jZXNzLmVudi5RID0gJ1wiJzsgLy8gVGhlIHF1b3RlIChcIikgdGhhdCBpc24ndCBlc2NhcGVkLlxuICAgIC8vIGAoKWAgZm9yIGlnbm9yZSBzcGFjZSBieSBlY2hvXG4gICAgc2hlbGxBcmdzID0gWycvVjpPTicsICcvUycsICcvQycsXG4gICAgICAnKCVRJScgKyBzaGVsbFBhdGggKyAnJVElIC9WOk9OIC9TIC9DICVRJScgKyAvKiBFU0xpbnQgYnVnPyAqLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhdGgtY29uY2F0XG4gICAgICAgICclUSUnICsgZXh0SG9zdFBhdGggKyAnJVElJyArXG4gICAgICAgICAgaG9zdEFyZ3MubWFwKGZ1bmN0aW9uKGFyZykgeyByZXR1cm4gJyAlUSUnICsgYXJnICsgJyVRJSc7IH0pLmpvaW4oJycpICtcbiAgICAgICAgJyAmIChlY2hvICFFUlJPUkxFVkVMISk+JVElJyArIHBhdGhFeGl0ICsgJyVRJSVRJSkgMj4lUSUnICsgcGF0aFN0ZGVyciArICclUSUnICtcbiAgICAgICcgfCVRJScgKyBwcm9jZXNzLmV4ZWNQYXRoICsgJyVRJSAlUSUnICsgX19kaXJuYW1lICsgJ1xcXFxlbmNyeXB0LmpzJVElJyArXG4gICAgICAgICcgJVElJyArIEFMR09SSVRITV9DSVBIRVIgKyAnJVElICVRJScgKyBwYXNzd29yZCArICclUSUnICtcbiAgICAgICAgJyA+JVElJyArIHBhdGhTdGRvdXQgKyAnJVElJyArXG4gICAgICAnICYgKGVjaG8gMSk+JVElJyArIHBhdGhEb25lICsgJyVRJSddO1xuICB9IGVsc2Uge1xuICAgIHNoZWxsUGF0aCA9ICcvYmluL3NoJztcbiAgICBzaGVsbEFyZ3MgPSBbJy1jJyxcbiAgICAgIC8vIFVzZSBgKClgLCBub3QgYHt9YCBmb3IgYC1jYCAodGV4dCBwYXJhbSlcbiAgICAgICcoXCInICsgZXh0SG9zdFBhdGggKyAnXCInICsgLyogRVNMaW50IGJ1Zz8gKi8gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxuICAgICAgICAgIGhvc3RBcmdzLm1hcChmdW5jdGlvbihhcmcpIHsgcmV0dXJuIFwiICdcIiArIGFyZy5yZXBsYWNlKC8nL2csIFwiJ1xcXFwnJ1wiKSArIFwiJ1wiOyB9KS5qb2luKCcnKSArXG4gICAgICAgICc7IGVjaG8gJD8+XCInICsgcGF0aEV4aXQgKyAnXCIpIDI+XCInICsgcGF0aFN0ZGVyciArICdcIicgK1xuICAgICAgJyB8XCInICsgcHJvY2Vzcy5leGVjUGF0aCArICdcIiBcIicgKyBfX2Rpcm5hbWUgKyAnL2VuY3J5cHQuanNcIicgK1xuICAgICAgICAnIFwiJyArIEFMR09SSVRITV9DSVBIRVIgKyAnXCIgXCInICsgcGFzc3dvcmQgKyAnXCInICtcbiAgICAgICAgJyA+XCInICsgcGF0aFN0ZG91dCArICdcIicgK1xuICAgICAgJzsgZWNobyAxID5cIicgKyBwYXRoRG9uZSArICdcIiddO1xuICB9XG4gIGlmIChfREJHX2NoZWNrTWV0aG9kKSB7IF9EQkdfY2hlY2tNZXRob2QoJ19leGVjRmlsZVN5bmMnLCBob3N0QXJncyk7IH1cbiAgdHJ5IHtcbiAgICBjaGlsZFByb2Muc3Bhd24oc2hlbGxQYXRoLCBzaGVsbEFyZ3MsIGV4ZWNPcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlcy5lcnJvciA9IG5ldyBFcnJvcihlLm1lc3NhZ2UpO1xuICAgIHJlcy5lcnJvci5tZXRob2QgPSAnX2V4ZWNGaWxlU3luYyAtIHNwYXduJztcbiAgICByZXMuZXJyb3IucHJvZ3JhbSA9IHNoZWxsUGF0aDtcbiAgICByZXMuZXJyb3IuYXJncyA9IHNoZWxsQXJncztcbiAgfVxuXG4gIHdoaWxlIChmcy5yZWFkRmlsZVN5bmMocGF0aERvbmUsIHtlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZ30pLnRyaW0oKSAhPT0gJzEnKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWVtcHR5XG4gIGlmICgoZXhpdENvZGUgPVxuICAgICAgZnMucmVhZEZpbGVTeW5jKHBhdGhFeGl0LCB7ZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2Rpbmd9KS50cmltKCkpID09PSAnMCcpIHtcbiAgICByZXMuaW5wdXQgPVxuICAgICAgZGVjaXBoZXIudXBkYXRlKGZzLnJlYWRGaWxlU3luYyhwYXRoU3Rkb3V0LCB7ZW5jb2Rpbmc6ICdiaW5hcnknfSksXG4gICAgICAgICdoZXgnLCBvcHRpb25zLmVuY29kaW5nKSArXG4gICAgICBkZWNpcGhlci5maW5hbChvcHRpb25zLmVuY29kaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBleHRNZXNzYWdlID0gZnMucmVhZEZpbGVTeW5jKHBhdGhTdGRlcnIsIHtlbmNvZGluZzogb3B0aW9ucy5lbmNvZGluZ30pLnRyaW0oKTtcbiAgICByZXMuZXJyb3IgPSBuZXcgRXJyb3IoREVGQVVMVF9FUlJfTVNHICsgKGV4dE1lc3NhZ2UgPyAnXFxuJyArIGV4dE1lc3NhZ2UgOiAnJykpO1xuICAgIHJlcy5lcnJvci5tZXRob2QgPSAnX2V4ZWNGaWxlU3luYyc7XG4gICAgcmVzLmVycm9yLnByb2dyYW0gPSBzaGVsbFBhdGg7XG4gICAgcmVzLmVycm9yLmFyZ3MgPSBzaGVsbEFyZ3M7XG4gICAgcmVzLmVycm9yLmV4dE1lc3NhZ2UgPSBleHRNZXNzYWdlO1xuICAgIHJlcy5lcnJvci5leGl0Q29kZSA9ICtleGl0Q29kZTtcbiAgfVxuXG4gIGZzLnVubGlua1N5bmMocGF0aFN0ZG91dCk7XG4gIGZzLnVubGlua1N5bmMocGF0aFN0ZGVycik7XG4gIGZzLnVubGlua1N5bmMocGF0aEV4aXQpO1xuICBmcy51bmxpbmtTeW5jKHBhdGhEb25lKTtcblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiByZWFkbGluZUV4dChvcHRpb25zKSB7XG4gIHZhciBob3N0QXJncywgcmVzID0ge30sIGV4dE1lc3NhZ2UsXG4gICAgZXhlY09wdGlvbnMgPSB7ZW52OiBwcm9jZXNzLmVudiwgZW5jb2Rpbmc6IG9wdGlvbnMuZW5jb2Rpbmd9O1xuXG4gIGlmICghZXh0SG9zdFBhdGgpIHtcbiAgICBpZiAoSVNfV0lOKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuUFNNb2R1bGVQYXRoKSB7IC8vIFdpbmRvd3MgUG93ZXJTaGVsbFxuICAgICAgICBleHRIb3N0UGF0aCA9ICdwb3dlcnNoZWxsLmV4ZSc7XG4gICAgICAgIGV4dEhvc3RBcmdzID0gWyctRXhlY3V0aW9uUG9saWN5JywgJ0J5cGFzcycsICctRmlsZScsIF9fZGlybmFtZSArICdcXFxccmVhZC5wczEnXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxuICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIFNjcmlwdCBIb3N0XG4gICAgICAgIGV4dEhvc3RQYXRoID0gJ2NzY3JpcHQuZXhlJztcbiAgICAgICAgZXh0SG9zdEFyZ3MgPSBbJy8vbm9sb2dvJywgX19kaXJuYW1lICsgJ1xcXFxyZWFkLmNzLmpzJ107IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGF0aC1jb25jYXRcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXh0SG9zdFBhdGggPSAnL2Jpbi9zaCc7XG4gICAgICBleHRIb3N0QXJncyA9IFtfX2Rpcm5hbWUgKyAnL3JlYWQuc2gnXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXRoLWNvbmNhdFxuICAgIH1cbiAgfVxuICBpZiAoSVNfV0lOICYmICFwcm9jZXNzLmVudi5QU01vZHVsZVBhdGgpIHsgLy8gV2luZG93cyBTY3JpcHQgSG9zdFxuICAgIC8vIFNjcmlwdFBXIChXaW4gWFAgYW5kIFNlcnZlcjIwMDMpIG5lZWRzIFRUWSBzdHJlYW0gYXMgU1RESU4uXG4gICAgLy8gSW4gdGhpcyBjYXNlLCBJZiBTVERJTiBpc24ndCBUVFksIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICBleGVjT3B0aW9ucy5zdGRpbyA9IFtwcm9jZXNzLnN0ZGluXTtcbiAgfVxuXG4gIGlmIChjaGlsZFByb2MuZXhlY0ZpbGVTeW5jKSB7XG4gICAgaG9zdEFyZ3MgPSBnZXRIb3N0QXJncyhvcHRpb25zKTtcbiAgICBpZiAoX0RCR19jaGVja01ldGhvZCkgeyBfREJHX2NoZWNrTWV0aG9kKCdleGVjRmlsZVN5bmMnLCBob3N0QXJncyk7IH1cbiAgICB0cnkge1xuICAgICAgcmVzLmlucHV0ID0gY2hpbGRQcm9jLmV4ZWNGaWxlU3luYyhleHRIb3N0UGF0aCwgaG9zdEFyZ3MsIGV4ZWNPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7IC8vIG5vbi16ZXJvIGV4aXQgY29kZVxuICAgICAgZXh0TWVzc2FnZSA9IGUuc3RkZXJyID8gKGUuc3RkZXJyICsgJycpLnRyaW0oKSA6ICcnO1xuICAgICAgcmVzLmVycm9yID0gbmV3IEVycm9yKERFRkFVTFRfRVJSX01TRyArIChleHRNZXNzYWdlID8gJ1xcbicgKyBleHRNZXNzYWdlIDogJycpKTtcbiAgICAgIHJlcy5lcnJvci5tZXRob2QgPSAnZXhlY0ZpbGVTeW5jJztcbiAgICAgIHJlcy5lcnJvci5wcm9ncmFtID0gZXh0SG9zdFBhdGg7XG4gICAgICByZXMuZXJyb3IuYXJncyA9IGhvc3RBcmdzO1xuICAgICAgcmVzLmVycm9yLmV4dE1lc3NhZ2UgPSBleHRNZXNzYWdlO1xuICAgICAgcmVzLmVycm9yLmV4aXRDb2RlID0gZS5zdGF0dXM7XG4gICAgICByZXMuZXJyb3IuY29kZSA9IGUuY29kZTtcbiAgICAgIHJlcy5lcnJvci5zaWduYWwgPSBlLnNpZ25hbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzID0gX2V4ZWNGaWxlU3luYyhvcHRpb25zLCBleGVjT3B0aW9ucyk7XG4gIH1cbiAgaWYgKCFyZXMuZXJyb3IpIHtcbiAgICByZXMuaW5wdXQgPSByZXMuaW5wdXQucmVwbGFjZSgvXlxccyonfCdcXHMqJC9nLCAnJyk7XG4gICAgb3B0aW9ucy5kaXNwbGF5ID0gJyc7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG4vKlxuICBkaXNwbGF5OiAgICAgICAgICAgIHN0cmluZ1xuICBkaXNwbGF5T25seTogICAgICAgIGJvb2xlYW5cbiAga2V5SW46ICAgICAgICAgICAgICBib29sZWFuXG4gIGhpZGVFY2hvQmFjazogICAgICAgYm9vbGVhblxuICBtYXNrOiAgICAgICAgICAgICAgIHN0cmluZ1xuICBsaW1pdDogICAgICAgICAgICAgIHN0cmluZyAocGF0dGVybilcbiAgY2FzZVNlbnNpdGl2ZTogICAgICBib29sZWFuXG4gIGtlZXBXaGl0ZXNwYWNlOiAgICAgYm9vbGVhblxuICBlbmNvZGluZywgYnVmZmVyU2l6ZSwgcHJpbnRcbiovXG5mdW5jdGlvbiBfcmVhZGxpbmVTeW5jKG9wdGlvbnMpIHtcbiAgdmFyIGlucHV0ID0gJycsIGRpc3BsYXlTYXZlID0gb3B0aW9ucy5kaXNwbGF5LFxuICAgIHNpbGVudCA9ICFvcHRpb25zLmRpc3BsYXkgJiZcbiAgICAgIG9wdGlvbnMua2V5SW4gJiYgb3B0aW9ucy5oaWRlRWNob0JhY2sgJiYgIW9wdGlvbnMubWFzaztcblxuICBmdW5jdGlvbiB0cnlFeHQoKSB7XG4gICAgdmFyIHJlcyA9IHJlYWRsaW5lRXh0KG9wdGlvbnMpO1xuICAgIGlmIChyZXMuZXJyb3IpIHsgdGhyb3cgcmVzLmVycm9yOyB9XG4gICAgcmV0dXJuIHJlcy5pbnB1dDtcbiAgfVxuXG4gIGlmIChfREJHX2NoZWNrT3B0aW9ucykgeyBfREJHX2NoZWNrT3B0aW9ucyhvcHRpb25zKTsgfVxuXG4gIChmdW5jdGlvbigpIHsgLy8gb3BlbiBUVFlcbiAgICB2YXIgZnNCLCBjb25zdGFudHMsIHZlck51bTtcblxuICAgIGZ1bmN0aW9uIGdldEZzQigpIHtcbiAgICAgIGlmICghZnNCKSB7XG4gICAgICAgIGZzQiA9IHByb2Nlc3MuYmluZGluZygnZnMnKTsgLy8gRm9yIHJhdyBkZXZpY2UgcGF0aFxuICAgICAgICBjb25zdGFudHMgPSBwcm9jZXNzLmJpbmRpbmcoJ2NvbnN0YW50cycpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZzQjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZkUiAhPT0gJ3N0cmluZycpIHsgcmV0dXJuOyB9XG4gICAgZmRSID0gbnVsbDtcblxuICAgIGlmIChJU19XSU4pIHtcbiAgICAgIC8vIGlvanMtdjIuMy4yKyBpbnB1dCBzdHJlYW0gY2FuJ3QgcmVhZCBmaXJzdCBsaW5lLiAoIzE4KVxuICAgICAgLy8gKiogRG9uJ3QgZ2V0IHByb2Nlc3Muc3RkaW4gYmVmb3JlIGNoZWNrISAqKlxuICAgICAgLy8gRml4ZWQgdjUuMS4wXG4gICAgICAvLyBGaXhlZCB2NC4yLjRcbiAgICAgIC8vIEl0IHJlZ3Jlc3NlZCBhZ2FpbiBpbiB2NS42LjAsIGl0IGlzIGZpeGVkIGluIHY2LjIuMC5cbiAgICAgIHZlck51bSA9IChmdW5jdGlvbih2ZXIpIHsgLy8gZ2V0VmVyTnVtXG4gICAgICAgIHZhciBudW1zID0gdmVyLnJlcGxhY2UoL15cXEQrLywgJycpLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciB2ZXJOdW0gPSAwO1xuICAgICAgICBpZiAoKG51bXNbMF0gPSArbnVtc1swXSkpIHsgdmVyTnVtICs9IG51bXNbMF0gKiAxMDAwMDsgfVxuICAgICAgICBpZiAoKG51bXNbMV0gPSArbnVtc1sxXSkpIHsgdmVyTnVtICs9IG51bXNbMV0gKiAxMDA7IH1cbiAgICAgICAgaWYgKChudW1zWzJdID0gK251bXNbMl0pKSB7IHZlck51bSArPSBudW1zWzJdOyB9XG4gICAgICAgIHJldHVybiB2ZXJOdW07XG4gICAgICB9KShwcm9jZXNzLnZlcnNpb24pO1xuICAgICAgaWYgKCEodmVyTnVtID49IDIwMzAyICYmIHZlck51bSA8IDQwMjA0IHx8IHZlck51bSA+PSA1MDAwMCAmJiB2ZXJOdW0gPCA1MDEwMCB8fCB2ZXJOdW0gPj0gNTA2MDAgJiYgdmVyTnVtIDwgNjAyMDApICYmXG4gICAgICAgICAgcHJvY2Vzcy5zdGRpbi5pc1RUWSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICAgIGZkUiA9IHByb2Nlc3Muc3RkaW4uZmQ7XG4gICAgICAgIHR0eVIgPSBwcm9jZXNzLnN0ZGluLl9oYW5kbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoZSBzdHJlYW0gYnkgZnMub3BlblN5bmMoJ1xcXFxcXFxcLlxcXFxDT04nLCAncicpIGNhbid0IHN3aXRjaCB0byByYXcgbW9kZS5cbiAgICAgICAgICAvLyAnQ09OSU4kJyBtaWdodCBmYWlsIG9uIFhQLCAyMDAwLCA3ICh4ODYpLlxuICAgICAgICAgIGZkUiA9IGdldEZzQigpLm9wZW4oJ0NPTklOJCcsIGNvbnN0YW50cy5PX1JEV1IsIHBhcnNlSW50KCcwNjY2JywgOCkpO1xuICAgICAgICAgIHR0eVIgPSBuZXcgVFRZKGZkUiwgdHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3Muc3Rkb3V0LmlzVFRZKSB7XG4gICAgICAgIGZkVyA9IHByb2Nlc3Muc3Rkb3V0LmZkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmZFcgPSBmcy5vcGVuU3luYygnXFxcXFxcXFwuXFxcXENPTicsICd3Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmZFcgIT09ICdudW1iZXInKSB7IC8vIFJldHJ5XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZkVyA9IGdldEZzQigpLm9wZW4oJ0NPTk9VVCQnLCBjb25zdGFudHMuT19SRFdSLCBwYXJzZUludCgnMDY2NicsIDgpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7IC8qIGlnbm9yZSAqLyB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5zdGRpbi5pc1RUWSkge1xuICAgICAgICBwcm9jZXNzLnN0ZGluLnBhdXNlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmRSID0gZnMub3BlblN5bmMoJy9kZXYvdHR5JywgJ3InKTsgLy8gZGV2aWNlIGZpbGUsIG5vdCBwcm9jZXNzLnN0ZGluXG4gICAgICAgICAgdHR5UiA9IHByb2Nlc3Muc3RkaW4uX2hhbmRsZTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZS5qcyB2MC4xMiByZWFkKCkgZmFpbHMuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmRSID0gZnMub3BlblN5bmMoJy9kZXYvdHR5JywgJ3InKTtcbiAgICAgICAgICB0dHlSID0gbmV3IFRUWShmZFIsIGZhbHNlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyAvKiBpZ25vcmUgKi8gfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5zdGRvdXQuaXNUVFkpIHtcbiAgICAgICAgZmRXID0gcHJvY2Vzcy5zdGRvdXQuZmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZkVyA9IGZzLm9wZW5TeW5jKCcvZGV2L3R0eScsICd3Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLyogaWdub3JlICovIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKCkgeyAvLyB0cnkgcmVhZFxuICAgIHZhciBhdEVvbCwgbGltaXQsXG4gICAgICBpc0Nvb2tlZCA9ICFvcHRpb25zLmhpZGVFY2hvQmFjayAmJiAhb3B0aW9ucy5rZXlJbixcbiAgICAgIGJ1ZmZlciwgcmVxU2l6ZSwgcmVhZFNpemUsIGNodW5rLCBsaW5lO1xuICAgIHJhd0lucHV0ID0gJyc7XG5cbiAgICAvLyBOb2RlLmpzIHYwLjEwLSByZXR1cm5zIGFuIGVycm9yIGlmIHNhbWUgbW9kZSBpcyBzZXQuXG4gICAgZnVuY3Rpb24gc2V0UmF3TW9kZShtb2RlKSB7XG4gICAgICBpZiAobW9kZSA9PT0gaXNSYXdNb2RlKSB7IHJldHVybiB0cnVlOyB9XG4gICAgICBpZiAodHR5Ui5zZXRSYXdNb2RlKG1vZGUpICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgaXNSYXdNb2RlID0gbW9kZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChfREJHX3VzZUV4dCB8fCAhdHR5UiB8fFxuICAgICAgICB0eXBlb2YgZmRXICE9PSAnbnVtYmVyJyAmJiAob3B0aW9ucy5kaXNwbGF5IHx8ICFpc0Nvb2tlZCkpIHtcbiAgICAgIGlucHV0ID0gdHJ5RXh0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgZnMud3JpdGVTeW5jKGZkVywgb3B0aW9ucy5kaXNwbGF5KTtcbiAgICAgIG9wdGlvbnMuZGlzcGxheSA9ICcnO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kaXNwbGF5T25seSkgeyByZXR1cm47IH1cblxuICAgIGlmICghc2V0UmF3TW9kZSghaXNDb29rZWQpKSB7XG4gICAgICBpbnB1dCA9IHRyeUV4dCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJlcVNpemUgPSBvcHRpb25zLmtleUluID8gMSA6IG9wdGlvbnMuYnVmZmVyU2l6ZTtcbiAgICAvLyBDaGVjayBgYWxsb2NVbnNhZmVgIHRvIG1ha2Ugc3VyZSBvZiB0aGUgbmV3IEFQSS5cbiAgICBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jID8gQnVmZmVyLmFsbG9jKHJlcVNpemUpIDogbmV3IEJ1ZmZlcihyZXFTaXplKTtcblxuICAgIGlmIChvcHRpb25zLmtleUluICYmIG9wdGlvbnMubGltaXQpIHtcbiAgICAgIGxpbWl0ID0gbmV3IFJlZ0V4cCgnW14nICsgb3B0aW9ucy5saW1pdCArICddJyxcbiAgICAgICAgJ2cnICsgKG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/ICcnIDogJ2knKSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHJlYWRTaXplID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlYWRTaXplID0gZnMucmVhZFN5bmMoZmRSLCBidWZmZXIsIDAsIHJlcVNpemUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS5jb2RlICE9PSAnRU9GJykge1xuICAgICAgICAgIHNldFJhd01vZGUoZmFsc2UpO1xuICAgICAgICAgIGlucHV0ICs9IHRyeUV4dCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlYWRTaXplID4gMCkge1xuICAgICAgICBjaHVuayA9IGJ1ZmZlci50b1N0cmluZyhvcHRpb25zLmVuY29kaW5nLCAwLCByZWFkU2l6ZSk7XG4gICAgICAgIHJhd0lucHV0ICs9IGNodW5rO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2h1bmsgPSAnXFxuJztcbiAgICAgICAgcmF3SW5wdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNodW5rICYmIHR5cGVvZiAobGluZSA9IChjaHVuay5tYXRjaCgvXiguKj8pW1xcclxcbl0vKSB8fCBbXSlbMV0pID09PSAnc3RyaW5nJykge1xuICAgICAgICBjaHVuayA9IGxpbmU7XG4gICAgICAgIGF0RW9sID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXIgY3RybC1jaGFyc1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgIGlmIChjaHVuaykgeyBjaHVuayA9IGNodW5rLnJlcGxhY2UoL1tcXHgwMC1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXS9nLCAnJyk7IH1cbiAgICAgIGlmIChjaHVuayAmJiBsaW1pdCkgeyBjaHVuayA9IGNodW5rLnJlcGxhY2UobGltaXQsICcnKTsgfVxuXG4gICAgICBpZiAoY2h1bmspIHtcbiAgICAgICAgaWYgKCFpc0Nvb2tlZCkge1xuICAgICAgICAgIGlmICghb3B0aW9ucy5oaWRlRWNob0JhY2spIHtcbiAgICAgICAgICAgIGZzLndyaXRlU3luYyhmZFcsIGNodW5rKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMubWFzaykge1xuICAgICAgICAgICAgZnMud3JpdGVTeW5jKGZkVywgKG5ldyBBcnJheShjaHVuay5sZW5ndGggKyAxKSkuam9pbihvcHRpb25zLm1hc2spKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXQgKz0gY2h1bms7XG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5rZXlJbiAmJiBhdEVvbCB8fFxuICAgICAgICBvcHRpb25zLmtleUluICYmIGlucHV0Lmxlbmd0aCA+PSByZXFTaXplKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgaWYgKCFpc0Nvb2tlZCAmJiAhc2lsZW50KSB7IGZzLndyaXRlU3luYyhmZFcsICdcXG4nKTsgfVxuICAgIHNldFJhd01vZGUoZmFsc2UpO1xuICB9KSgpO1xuXG4gIGlmIChvcHRpb25zLnByaW50ICYmICFzaWxlbnQpIHtcbiAgICBvcHRpb25zLnByaW50KGRpc3BsYXlTYXZlICsgKG9wdGlvbnMuZGlzcGxheU9ubHkgPyAnJyA6XG4gICAgICAgIChvcHRpb25zLmhpZGVFY2hvQmFjayA/IChuZXcgQXJyYXkoaW5wdXQubGVuZ3RoICsgMSkpLmpvaW4ob3B0aW9ucy5tYXNrKVxuICAgICAgICAgIDogaW5wdXQpICsgJ1xcbicpLCAvLyBtdXN0IGF0IGxlYXN0IHdyaXRlICdcXG4nXG4gICAgICBvcHRpb25zLmVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLmRpc3BsYXlPbmx5ID8gJycgOlxuICAgIChsYXN0SW5wdXQgPSBvcHRpb25zLmtlZXBXaGl0ZXNwYWNlIHx8IG9wdGlvbnMua2V5SW4gPyBpbnB1dCA6IGlucHV0LnRyaW0oKSk7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5BcnJheShhcnJheSwgdmFsaWRhdG9yKSB7XG4gIHZhciBmbGF0QXJyYXkgPSBbXTtcbiAgZnVuY3Rpb24gX2ZsYXR0ZW5BcnJheShhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgYXJyYXkuZm9yRWFjaChfZmxhdHRlbkFycmF5KTtcbiAgICB9IGVsc2UgaWYgKCF2YWxpZGF0b3IgfHwgdmFsaWRhdG9yKGFycmF5KSkge1xuICAgICAgZmxhdEFycmF5LnB1c2goYXJyYXkpO1xuICAgIH1cbiAgfVxuICBfZmxhdHRlbkFycmF5KGFycmF5KTtcbiAgcmV0dXJuIGZsYXRBcnJheTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlUGF0dGVybihwYXR0ZXJuKSB7XG4gIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1tcXHgwMC1cXHg3Zl0vZywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb250cm9sLXJlZ2V4XG4gICAgZnVuY3Rpb24ocykgeyByZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgcy5jaGFyQ29kZUF0KCkudG9TdHJpbmcoMTYpKS5zdWJzdHIoLTIpOyB9KTtcbn1cblxuLy8gbWFyZ2VPcHRpb25zKG9wdGlvbnMxLCBvcHRpb25zMiAuLi4gKVxuLy8gbWFyZ2VPcHRpb25zKHRydWUsIG9wdGlvbnMxLCBvcHRpb25zMiAuLi4gKVxuLy8gICAgYXJnMT10cnVlIDogU3RhcnQgZnJvbSBkZWZhdWx0T3B0aW9ucyBhbmQgcGljayBlbGVtZW50cyBvZiB0aGF0LlxuZnVuY3Rpb24gbWFyZ2VPcHRpb25zKCkge1xuICB2YXIgb3B0aW9uc0xpc3QgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgIG9wdGlvbk5hbWVzLCBmcm9tRGVmYXVsdDtcblxuICBpZiAob3B0aW9uc0xpc3QubGVuZ3RoICYmIHR5cGVvZiBvcHRpb25zTGlzdFswXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgZnJvbURlZmF1bHQgPSBvcHRpb25zTGlzdC5zaGlmdCgpO1xuICAgIGlmIChmcm9tRGVmYXVsdCkge1xuICAgICAgb3B0aW9uTmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0T3B0aW9ucyk7XG4gICAgICBvcHRpb25zTGlzdC51bnNoaWZ0KGRlZmF1bHRPcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3B0aW9uc0xpc3QucmVkdWNlKGZ1bmN0aW9uKG9wdGlvbnMsIG9wdGlvbnNQYXJ0KSB7XG4gICAgaWYgKG9wdGlvbnNQYXJ0ID09IG51bGwpIHsgcmV0dXJuIG9wdGlvbnM7IH1cblxuICAgIC8vID09PT09PT09IERFUFJFQ0FURUQgPT09PT09PT1cbiAgICBpZiAob3B0aW9uc1BhcnQuaGFzT3duUHJvcGVydHkoJ25vRWNob0JhY2snKSAmJlxuICAgICAgICAhb3B0aW9uc1BhcnQuaGFzT3duUHJvcGVydHkoJ2hpZGVFY2hvQmFjaycpKSB7XG4gICAgICBvcHRpb25zUGFydC5oaWRlRWNob0JhY2sgPSBvcHRpb25zUGFydC5ub0VjaG9CYWNrO1xuICAgICAgZGVsZXRlIG9wdGlvbnNQYXJ0Lm5vRWNob0JhY2s7XG4gICAgfVxuICAgIGlmIChvcHRpb25zUGFydC5oYXNPd25Qcm9wZXJ0eSgnbm9UcmltJykgJiZcbiAgICAgICAgIW9wdGlvbnNQYXJ0Lmhhc093blByb3BlcnR5KCdrZWVwV2hpdGVzcGFjZScpKSB7XG4gICAgICBvcHRpb25zUGFydC5rZWVwV2hpdGVzcGFjZSA9IG9wdGlvbnNQYXJ0Lm5vVHJpbTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zUGFydC5ub1RyaW07XG4gICAgfVxuICAgIC8vID09PT09PT09IC9ERVBSRUNBVEVEID09PT09PT09XG5cbiAgICBpZiAoIWZyb21EZWZhdWx0KSB7IG9wdGlvbk5hbWVzID0gT2JqZWN0LmtleXMob3B0aW9uc1BhcnQpOyB9XG4gICAgb3B0aW9uTmFtZXMuZm9yRWFjaChmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBpZiAoIW9wdGlvbnNQYXJ0Lmhhc093blByb3BlcnR5KG9wdGlvbk5hbWUpKSB7IHJldHVybjsgfVxuICAgICAgdmFsdWUgPSBvcHRpb25zUGFydFtvcHRpb25OYW1lXTtcbiAgICAgIHN3aXRjaCAob3B0aW9uTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gX3JlYWRsaW5lU3luYyA8LSAqICAgICogLT4gZGVmYXVsdE9wdGlvbnNcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBzdHJpbmdcbiAgICAgICAgY2FzZSAnbWFzayc6ICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgIGNhc2UgJ2xpbWl0TWVzc2FnZSc6ICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdkZWZhdWx0SW5wdXQnOiAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAnZW5jb2RpbmcnOiAgICAgICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSAhPSBudWxsID8gdmFsdWUgKyAnJyA6ICcnO1xuICAgICAgICAgIGlmICh2YWx1ZSAmJiBvcHRpb25OYW1lICE9PSAnbGltaXRNZXNzYWdlJykgeyB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKTsgfVxuICAgICAgICAgIG9wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBudW1iZXIoaW50KVxuICAgICAgICBjYXNlICdidWZmZXJTaXplJzogICAgICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlID0gcGFyc2VJbnQodmFsdWUsIDEwKSkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlOyAvLyBsaW1pdGVkIHVwZGF0aW5nIChudW1iZXIgaXMgbmVlZGVkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gPT09PT09PT09PT09PT09PSBib29sZWFuXG4gICAgICAgIGNhc2UgJ2Rpc3BsYXlPbmx5JzogICAgICAgICAgICAgICAgIC8vICpcbiAgICAgICAgY2FzZSAna2V5SW4nOiAgICAgICAgICAgICAgICAgICAgICAgLy8gKlxuICAgICAgICBjYXNlICdoaWRlRWNob0JhY2snOiAgICAgICAgICAgICAgICAvLyAqICAgICpcbiAgICAgICAgY2FzZSAnY2FzZVNlbnNpdGl2ZSc6ICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgIGNhc2UgJ2tlZXBXaGl0ZXNwYWNlJzogICAgICAgICAgICAgIC8vICogICAgKlxuICAgICAgICBjYXNlICdoaXN0b3J5JzogICAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgY2FzZSAnY2QnOiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgICAgb3B0aW9uc1tvcHRpb25OYW1lXSA9ICEhdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gYXJyYXlcbiAgICAgICAgY2FzZSAnbGltaXQnOiAgICAgICAgICAgICAgICAgICAgICAgLy8gKiAgICAqICAgICB0byBzdHJpbmcgZm9yIHJlYWRsaW5lRXh0XG4gICAgICAgIGNhc2UgJ3RydWVWYWx1ZSc6ICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdmYWxzZVZhbHVlJzogICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gZmxhdHRlbkFycmF5KHZhbHVlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgICAgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZSgvW1xcclxcbl0vZywgJycpIDogdmFsdWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gZnVuY3Rpb25cbiAgICAgICAgY2FzZSAncHJpbnQnOiAgICAgICAgICAgICAgICAgICAgICAgLy8gKiAgICAqXG4gICAgICAgIGNhc2UgJ3BoQ29udGVudCc6ICAgICAgICAgICAgICAgICAgIC8vICAgICAgKlxuICAgICAgICBjYXNlICdwcmVDaGVjayc6ICAgICAgICAgICAgICAgICAgICAvLyAgICAgICpcbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUgOiB2b2lkIDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vID09PT09PT09PT09PT09PT0gb3RoZXJcbiAgICAgICAgY2FzZSAncHJvbXB0JzogICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAqXG4gICAgICAgIGNhc2UgJ2Rpc3BsYXknOiAgICAgICAgICAgICAgICAgICAgIC8vICpcbiAgICAgICAgICBvcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogJyc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBpc01hdGNoZWQocmVzLCBjb21wcywgY2FzZVNlbnNpdGl2ZSkge1xuICByZXR1cm4gY29tcHMuc29tZShmdW5jdGlvbihjb21wKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgY29tcDtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAoY2FzZVNlbnNpdGl2ZSA/IHJlcyA9PT0gY29tcCA6IHJlcy50b0xvd2VyQ2FzZSgpID09PSBjb21wLnRvTG93ZXJDYXNlKCkpIDpcbiAgICAgIHR5cGUgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChyZXMpID09PSBjb21wIDpcbiAgICAgIHR5cGUgPT09ICdmdW5jdGlvbicgPyBjb21wKHJlcykgOlxuICAgICAgY29tcCBpbnN0YW5jZW9mIFJlZ0V4cCA/IGNvbXAudGVzdChyZXMpIDogZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlSG9tZVBhdGgocGF0aCwgZXhwYW5kKSB7XG4gIHZhciBob21lUGF0aCA9IHBhdGhVdGlsLm5vcm1hbGl6ZShcbiAgICBJU19XSU4gPyAocHJvY2Vzcy5lbnYuSE9NRURSSVZFIHx8ICcnKSArIChwcm9jZXNzLmVudi5IT01FUEFUSCB8fCAnJykgOlxuICAgIHByb2Nlc3MuZW52LkhPTUUgfHwgJycpLnJlcGxhY2UoL1tcXC9cXFxcXSskLywgJycpO1xuICBwYXRoID0gcGF0aFV0aWwubm9ybWFsaXplKHBhdGgpO1xuICByZXR1cm4gZXhwYW5kID8gcGF0aC5yZXBsYWNlKC9efig/PVxcL3xcXFxcfCQpLywgaG9tZVBhdGgpIDpcbiAgICBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBlc2NhcGVQYXR0ZXJuKGhvbWVQYXRoKSArXG4gICAgICAnKD89XFxcXC98XFxcXFxcXFx8JCknLCBJU19XSU4gPyAnaScgOiAnJyksICd+Jyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VQbGFjZWhvbGRlcih0ZXh0LCBnZW5lcmF0b3IpIHtcbiAgdmFyIFBUTl9JTk5FUiA9ICcoPzpcXFxcKChbXFxcXHNcXFxcU10qPylcXFxcKSk/KFxcXFx3K3wuLS4pKD86XFxcXCgoW1xcXFxzXFxcXFNdKj8pXFxcXCkpPycsXG4gICAgcmVQbGFjZWhvbGRlciA9IG5ldyBSZWdFeHAoJyhcXFxcJCk/KFxcXFwkPCcgKyBQVE5fSU5ORVIgKyAnPiknLCAnZycpLFxuICAgIHJlUGxhY2Vob2xkZXJDb21wYXQgPSBuZXcgUmVnRXhwKCcoXFxcXCQpPyhcXFxcJFxcXFx7JyArIFBUTl9JTk5FUiArICdcXFxcfSknLCAnZycpO1xuXG4gIGZ1bmN0aW9uIGdldFBsYWNlaG9sZGVyVGV4dChzLCBlc2NhcGUsIHBsYWNlaG9sZGVyLCBwcmUsIHBhcmFtLCBwb3N0KSB7XG4gICAgdmFyIHRleHQ7XG4gICAgcmV0dXJuIGVzY2FwZSB8fCB0eXBlb2YgKHRleHQgPSBnZW5lcmF0b3IocGFyYW0pKSAhPT0gJ3N0cmluZycgPyBwbGFjZWhvbGRlciA6XG4gICAgICB0ZXh0ID8gKHByZSB8fCAnJykgKyB0ZXh0ICsgKHBvc3QgfHwgJycpIDogJyc7XG4gIH1cblxuICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlUGxhY2Vob2xkZXIsIGdldFBsYWNlaG9sZGVyVGV4dClcbiAgICAucmVwbGFjZShyZVBsYWNlaG9sZGVyQ29tcGF0LCBnZXRQbGFjZWhvbGRlclRleHQpO1xufVxuXG5mdW5jdGlvbiBhcnJheTJjaGFybGlzdChhcnJheSwgY2FzZVNlbnNpdGl2ZSwgY29sbGVjdFN5bWJvbHMpIHtcbiAgdmFyIHZhbHVlcywgZ3JvdXAgPSBbXSwgZ3JvdXBDbGFzcyA9IC0xLCBjaGFyQ29kZSA9IDAsIHN5bWJvbHMgPSAnJywgc3VwcHJlc3NlZDtcbiAgZnVuY3Rpb24gYWRkR3JvdXAoZ3JvdXBzLCBncm91cCkge1xuICAgIGlmIChncm91cC5sZW5ndGggPiAzKSB7IC8vIGVsbGlwc2lzXG4gICAgICBncm91cHMucHVzaChncm91cFswXSArICcuLi4nICsgZ3JvdXBbZ3JvdXAubGVuZ3RoIC0gMV0pO1xuICAgICAgc3VwcHJlc3NlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChncm91cC5sZW5ndGgpIHtcbiAgICAgIGdyb3VwcyA9IGdyb3Vwcy5jb25jYXQoZ3JvdXApO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9XG5cbiAgdmFsdWVzID0gYXJyYXkucmVkdWNlKFxuICAgICAgZnVuY3Rpb24oY2hhcnMsIHZhbHVlKSB7IHJldHVybiBjaGFycy5jb25jYXQoKHZhbHVlICsgJycpLnNwbGl0KCcnKSk7IH0sIFtdKVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24oZ3JvdXBzLCBjdXJDaGFyKSB7XG4gICAgICB2YXIgY3VyR3JvdXBDbGFzcywgY3VyQ2hhckNvZGU7XG4gICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHsgY3VyQ2hhciA9IGN1ckNoYXIudG9Mb3dlckNhc2UoKTsgfVxuICAgICAgY3VyR3JvdXBDbGFzcyA9IC9eXFxkJC8udGVzdChjdXJDaGFyKSA/IDEgOlxuICAgICAgICAvXltBLVpdJC8udGVzdChjdXJDaGFyKSA/IDIgOiAvXlthLXpdJC8udGVzdChjdXJDaGFyKSA/IDMgOiAwO1xuICAgICAgaWYgKGNvbGxlY3RTeW1ib2xzICYmIGN1ckdyb3VwQ2xhc3MgPT09IDApIHtcbiAgICAgICAgc3ltYm9scyArPSBjdXJDaGFyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VyQ2hhckNvZGUgPSBjdXJDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjdXJHcm91cENsYXNzICYmIGN1ckdyb3VwQ2xhc3MgPT09IGdyb3VwQ2xhc3MgJiZcbiAgICAgICAgICAgIGN1ckNoYXJDb2RlID09PSBjaGFyQ29kZSArIDEpIHtcbiAgICAgICAgICBncm91cC5wdXNoKGN1ckNoYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwcyA9IGFkZEdyb3VwKGdyb3VwcywgZ3JvdXApO1xuICAgICAgICAgIGdyb3VwID0gW2N1ckNoYXJdO1xuICAgICAgICAgIGdyb3VwQ2xhc3MgPSBjdXJHcm91cENsYXNzO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJDb2RlID0gY3VyQ2hhckNvZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXBzO1xuICAgIH0sIFtdKTtcbiAgdmFsdWVzID0gYWRkR3JvdXAodmFsdWVzLCBncm91cCk7IC8vIGxhc3QgZ3JvdXBcbiAgaWYgKHN5bWJvbHMpIHsgdmFsdWVzLnB1c2goc3ltYm9scyk7IHN1cHByZXNzZWQgPSB0cnVlOyB9XG4gIHJldHVybiB7dmFsdWVzOiB2YWx1ZXMsIHN1cHByZXNzZWQ6IHN1cHByZXNzZWR9O1xufVxuXG5mdW5jdGlvbiBqb2luQ2h1bmtzKGNodW5rcywgc3VwcHJlc3NlZCkge1xuICByZXR1cm4gY2h1bmtzLmpvaW4oY2h1bmtzLmxlbmd0aCA+IDIgPyAnLCAnIDogc3VwcHJlc3NlZCA/ICcgLyAnIDogJy8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGhDb250ZW50KHBhcmFtLCBvcHRpb25zKSB7XG4gIHZhciB0ZXh0LCB2YWx1ZXMsIHJlc0NoYXJsaXN0ID0ge30sIGFyZztcbiAgaWYgKG9wdGlvbnMucGhDb250ZW50KSB7XG4gICAgdGV4dCA9IG9wdGlvbnMucGhDb250ZW50KHBhcmFtLCBvcHRpb25zKTtcbiAgfVxuICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgc3dpdGNoIChwYXJhbSkge1xuICAgICAgY2FzZSAnaGlkZUVjaG9CYWNrJzpcbiAgICAgIGNhc2UgJ21hc2snOlxuICAgICAgY2FzZSAnZGVmYXVsdElucHV0JzpcbiAgICAgIGNhc2UgJ2Nhc2VTZW5zaXRpdmUnOlxuICAgICAgY2FzZSAna2VlcFdoaXRlc3BhY2UnOlxuICAgICAgY2FzZSAnZW5jb2RpbmcnOlxuICAgICAgY2FzZSAnYnVmZmVyU2l6ZSc6XG4gICAgICBjYXNlICdoaXN0b3J5JzpcbiAgICAgIGNhc2UgJ2NkJzpcbiAgICAgICAgdGV4dCA9ICFvcHRpb25zLmhhc093blByb3BlcnR5KHBhcmFtKSA/ICcnIDpcbiAgICAgICAgICB0eXBlb2Ygb3B0aW9uc1twYXJhbV0gPT09ICdib29sZWFuJyA/IChvcHRpb25zW3BhcmFtXSA/ICdvbicgOiAnb2ZmJykgOlxuICAgICAgICAgIG9wdGlvbnNbcGFyYW1dICsgJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gY2FzZSAncHJvbXB0JzpcbiAgICAgIC8vIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIC8vIGNhc2UgJ2Rpc3BsYXknOlxuICAgICAgLy8gICB0ZXh0ID0gb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnZGlzcGxheVNyYycpID8gb3B0aW9ucy5kaXNwbGF5U3JjICsgJycgOiAnJztcbiAgICAgIC8vICAgYnJlYWs7XG4gICAgICBjYXNlICdsaW1pdCc6XG4gICAgICBjYXNlICd0cnVlVmFsdWUnOlxuICAgICAgY2FzZSAnZmFsc2VWYWx1ZSc6XG4gICAgICAgIHZhbHVlcyA9IG9wdGlvbnNbb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXJhbSArICdTcmMnKSA/IHBhcmFtICsgJ1NyYycgOiBwYXJhbV07XG4gICAgICAgIGlmIChvcHRpb25zLmtleUluKSB7IC8vIHN1cHByZXNzXG4gICAgICAgICAgcmVzQ2hhcmxpc3QgPSBhcnJheTJjaGFybGlzdCh2YWx1ZXMsIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSk7XG4gICAgICAgICAgdmFsdWVzID0gcmVzQ2hhcmxpc3QudmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBqb2luQ2h1bmtzKHZhbHVlcywgcmVzQ2hhcmxpc3Quc3VwcHJlc3NlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGltaXRDb3VudCc6XG4gICAgICBjYXNlICdsaW1pdENvdW50Tm90WmVybyc6XG4gICAgICAgIHRleHQgPSBvcHRpb25zW29wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2xpbWl0U3JjJykgP1xuICAgICAgICAgICdsaW1pdFNyYycgOiAnbGltaXQnXS5sZW5ndGg7XG4gICAgICAgIHRleHQgPSB0ZXh0IHx8IHBhcmFtICE9PSAnbGltaXRDb3VudE5vdFplcm8nID8gdGV4dCArICcnIDogJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGFzdElucHV0JzpcbiAgICAgICAgdGV4dCA9IGxhc3RJbnB1dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjd2QnOlxuICAgICAgY2FzZSAnQ1dEJzpcbiAgICAgIGNhc2UgJ2N3ZEhvbWUnOlxuICAgICAgICB0ZXh0ID0gcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgaWYgKHBhcmFtID09PSAnQ1dEJykge1xuICAgICAgICAgIHRleHQgPSBwYXRoVXRpbC5iYXNlbmFtZSh0ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbSA9PT0gJ2N3ZEhvbWUnKSB7XG4gICAgICAgICAgdGV4dCA9IHJlcGxhY2VIb21lUGF0aCh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAndGltZSc6XG4gICAgICBjYXNlICdsb2NhbGVEYXRlJzpcbiAgICAgIGNhc2UgJ2xvY2FsZVRpbWUnOlxuICAgICAgICB0ZXh0ID0gKG5ldyBEYXRlKCkpWyd0bycgK1xuICAgICAgICAgIHBhcmFtLnJlcGxhY2UoL14uLywgZnVuY3Rpb24oc3RyKSB7IHJldHVybiBzdHIudG9VcHBlckNhc2UoKTsgfSkgK1xuICAgICAgICAgICdTdHJpbmcnXSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IC8vIHdpdGggYXJnXG4gICAgICAgIGlmICh0eXBlb2YgKGFyZyA9IChwYXJhbS5tYXRjaCgvXmhpc3RvcnlfbShcXGQrKSQvKSB8fCBbXSlbMV0pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRleHQgPSBpbnB1dEhpc3RvcnlbaW5wdXRIaXN0b3J5Lmxlbmd0aCAtIGFyZ10gfHwgJyc7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFBoQ2hhcmxpc3QocGFyYW0pIHtcbiAgdmFyIG1hdGNoZXMgPSAvXiguKS0oLikkLy5leGVjKHBhcmFtKSwgdGV4dCA9ICcnLCBmcm9tLCB0bywgY29kZSwgc3RlcDtcbiAgaWYgKCFtYXRjaGVzKSB7IHJldHVybiBudWxsOyB9XG4gIGZyb20gPSBtYXRjaGVzWzFdLmNoYXJDb2RlQXQoMCk7XG4gIHRvID0gbWF0Y2hlc1syXS5jaGFyQ29kZUF0KDApO1xuICBzdGVwID0gZnJvbSA8IHRvID8gMSA6IC0xO1xuICBmb3IgKGNvZGUgPSBmcm9tOyBjb2RlICE9PSB0byArIHN0ZXA7IGNvZGUgKz0gc3RlcCkgeyB0ZXh0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7IH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8vIGNtZCBcImFyZ1wiIFwiIGEgciBnIFwiIFwiXCIgJ2FcInJcImcnIFwiYVwiXCJyZ1wiIFwiYXJnXG5mdW5jdGlvbiBwYXJzZUNsKGNsKSB7XG4gIHZhciByZVRva2VuID0gbmV3IFJlZ0V4cCgvKFxccyopKD86KFwifCcpKC4qPykoPzpcXDJ8JCl8KFxcUyspKS9nKSwgbWF0Y2hlcyxcbiAgICB0YWtlbiA9ICcnLCBhcmdzID0gW10sIHBhcnQ7XG4gIGNsID0gY2wudHJpbSgpO1xuICB3aGlsZSAoKG1hdGNoZXMgPSByZVRva2VuLmV4ZWMoY2wpKSkge1xuICAgIHBhcnQgPSBtYXRjaGVzWzNdIHx8IG1hdGNoZXNbNF0gfHwgJyc7XG4gICAgaWYgKG1hdGNoZXNbMV0pIHtcbiAgICAgIGFyZ3MucHVzaCh0YWtlbik7XG4gICAgICB0YWtlbiA9ICcnO1xuICAgIH1cbiAgICB0YWtlbiArPSBwYXJ0O1xuICB9XG4gIGlmICh0YWtlbikgeyBhcmdzLnB1c2godGFrZW4pOyB9XG4gIHJldHVybiBhcmdzO1xufVxuXG5mdW5jdGlvbiB0b0Jvb2wocmVzLCBvcHRpb25zKSB7XG4gIHJldHVybiAoXG4gICAgKG9wdGlvbnMudHJ1ZVZhbHVlLmxlbmd0aCAmJlxuICAgICAgaXNNYXRjaGVkKHJlcywgb3B0aW9ucy50cnVlVmFsdWUsIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkpID8gdHJ1ZSA6XG4gICAgKG9wdGlvbnMuZmFsc2VWYWx1ZS5sZW5ndGggJiZcbiAgICAgIGlzTWF0Y2hlZChyZXMsIG9wdGlvbnMuZmFsc2VWYWx1ZSwgb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSkgPyBmYWxzZSA6IHJlcyk7XG59XG5cbmZ1bmN0aW9uIGdldFZhbGlkTGluZShvcHRpb25zKSB7XG4gIHZhciByZXMsIGZvcmNlTmV4dCwgbGltaXRNZXNzYWdlLFxuICAgIG1hdGNoZXMsIGhpc3RJbnB1dCwgYXJncywgcmVzQ2hlY2s7XG5cbiAgZnVuY3Rpb24gX2dldFBoQ29udGVudChwYXJhbSkgeyByZXR1cm4gZ2V0UGhDb250ZW50KHBhcmFtLCBvcHRpb25zKTsgfVxuICBmdW5jdGlvbiBhZGREaXNwbGF5KHRleHQpIHsgb3B0aW9ucy5kaXNwbGF5ICs9ICgvW15cXHJcXG5dJC8udGVzdChvcHRpb25zLmRpc3BsYXkpID8gJ1xcbicgOiAnJykgKyB0ZXh0OyB9XG5cbiAgb3B0aW9ucy5saW1pdFNyYyA9IG9wdGlvbnMubGltaXQ7XG4gIG9wdGlvbnMuZGlzcGxheVNyYyA9IG9wdGlvbnMuZGlzcGxheTtcbiAgb3B0aW9ucy5saW1pdCA9ICcnOyAvLyBmb3IgcmVhZGxpbmVFeHRcbiAgb3B0aW9ucy5kaXNwbGF5ID0gcmVwbGFjZVBsYWNlaG9sZGVyKG9wdGlvbnMuZGlzcGxheSArICcnLCBfZ2V0UGhDb250ZW50KTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHJlcyA9IF9yZWFkbGluZVN5bmMob3B0aW9ucyk7XG4gICAgZm9yY2VOZXh0ID0gZmFsc2U7XG4gICAgbGltaXRNZXNzYWdlID0gJyc7XG5cbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0SW5wdXQgJiYgIXJlcykgeyByZXMgPSBvcHRpb25zLmRlZmF1bHRJbnB1dDsgfVxuXG4gICAgaWYgKG9wdGlvbnMuaGlzdG9yeSkge1xuICAgICAgaWYgKChtYXRjaGVzID0gL15cXHMqXFwhKD86XFwhfC0xKSg6cCk/XFxzKiQvLmV4ZWMocmVzKSkpIHsgLy8gYCEhYCBgIS0xYCArYDpwYFxuICAgICAgICBoaXN0SW5wdXQgPSBpbnB1dEhpc3RvcnlbMF0gfHwgJyc7XG4gICAgICAgIGlmIChtYXRjaGVzWzFdKSB7IC8vIG9ubHkgZGlzcGxheVxuICAgICAgICAgIGZvcmNlTmV4dCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7IC8vIHJlcGxhY2UgaW5wdXRcbiAgICAgICAgICByZXMgPSBoaXN0SW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hvdyBpdCBldmVuIGlmIGl0IGlzIGVtcHR5IChOTCBvbmx5KS5cbiAgICAgICAgYWRkRGlzcGxheShoaXN0SW5wdXQgKyAnXFxuJyk7XG4gICAgICAgIGlmICghZm9yY2VOZXh0KSB7IC8vIExvb3AgbWF5IGJyZWFrXG4gICAgICAgICAgb3B0aW9ucy5kaXNwbGF5T25seSA9IHRydWU7XG4gICAgICAgICAgX3JlYWRsaW5lU3luYyhvcHRpb25zKTtcbiAgICAgICAgICBvcHRpb25zLmRpc3BsYXlPbmx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocmVzICYmIHJlcyAhPT0gaW5wdXRIaXN0b3J5W2lucHV0SGlzdG9yeS5sZW5ndGggLSAxXSkge1xuICAgICAgICBpbnB1dEhpc3RvcnkgPSBbcmVzXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlTmV4dCAmJiBvcHRpb25zLmNkICYmIHJlcykge1xuICAgICAgYXJncyA9IHBhcnNlQ2wocmVzKTtcbiAgICAgIHN3aXRjaCAoYXJnc1swXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgJ2NkJzpcbiAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcHJvY2Vzcy5jaGRpcihyZXBsYWNlSG9tZVBhdGgoYXJnc1sxXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBhZGREaXNwbGF5KGUgKyAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcmNlTmV4dCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3B3ZCc6XG4gICAgICAgICAgYWRkRGlzcGxheShwcm9jZXNzLmN3ZCgpKTtcbiAgICAgICAgICBmb3JjZU5leHQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBubyBkZWZhdWx0XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmb3JjZU5leHQgJiYgb3B0aW9ucy5wcmVDaGVjaykge1xuICAgICAgcmVzQ2hlY2sgPSBvcHRpb25zLnByZUNoZWNrKHJlcywgb3B0aW9ucyk7XG4gICAgICByZXMgPSByZXNDaGVjay5yZXM7XG4gICAgICBpZiAocmVzQ2hlY2suZm9yY2VOZXh0KSB7IGZvcmNlTmV4dCA9IHRydWU7IH0gLy8gRG9uJ3Qgc3dpdGNoIHRvIGZhbHNlLlxuICAgIH1cblxuICAgIGlmICghZm9yY2VOZXh0KSB7XG4gICAgICBpZiAoIW9wdGlvbnMubGltaXRTcmMubGVuZ3RoIHx8XG4gICAgICAgIGlzTWF0Y2hlZChyZXMsIG9wdGlvbnMubGltaXRTcmMsIG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkpIHsgYnJlYWs7IH1cbiAgICAgIGlmIChvcHRpb25zLmxpbWl0TWVzc2FnZSkge1xuICAgICAgICBsaW1pdE1lc3NhZ2UgPSByZXBsYWNlUGxhY2Vob2xkZXIob3B0aW9ucy5saW1pdE1lc3NhZ2UsIF9nZXRQaENvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFkZERpc3BsYXkoKGxpbWl0TWVzc2FnZSA/IGxpbWl0TWVzc2FnZSArICdcXG4nIDogJycpICtcbiAgICAgIHJlcGxhY2VQbGFjZWhvbGRlcihvcHRpb25zLmRpc3BsYXlTcmMgKyAnJywgX2dldFBoQ29udGVudCkpO1xuICB9XG4gIHJldHVybiB0b0Jvb2wocmVzLCBvcHRpb25zKTtcbn1cblxuLy8gZm9yIGRldlxuZXhwb3J0cy5fREJHX3NldF91c2VFeHQgPSBmdW5jdGlvbih2YWwpIHsgX0RCR191c2VFeHQgPSB2YWw7IH07XG5leHBvcnRzLl9EQkdfc2V0X2NoZWNrT3B0aW9ucyA9IGZ1bmN0aW9uKHZhbCkgeyBfREJHX2NoZWNrT3B0aW9ucyA9IHZhbDsgfTtcbmV4cG9ydHMuX0RCR19zZXRfY2hlY2tNZXRob2QgPSBmdW5jdGlvbih2YWwpIHsgX0RCR19jaGVja01ldGhvZCA9IHZhbDsgfTtcbmV4cG9ydHMuX0RCR19jbGVhckhpc3RvcnkgPSBmdW5jdGlvbigpIHsgbGFzdElucHV0ID0gJyc7IGlucHV0SGlzdG9yeSA9IFtdOyB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5zZXREZWZhdWx0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgZGVmYXVsdE9wdGlvbnMgPSBtYXJnZU9wdGlvbnModHJ1ZSwgb3B0aW9ucyk7XG4gIHJldHVybiBtYXJnZU9wdGlvbnModHJ1ZSk7IC8vIGNvcHlcbn07XG5cbmV4cG9ydHMucXVlc3Rpb24gPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm4gZ2V0VmFsaWRMaW5lKG1hcmdlT3B0aW9ucyhtYXJnZU9wdGlvbnModHJ1ZSwgb3B0aW9ucyksIHtcbiAgICBkaXNwbGF5OiAgICAgICAgICAgIHF1ZXJ5XG4gIH0pKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xufTtcblxuZXhwb3J0cy5wcm9tcHQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHZhciByZWFkT3B0aW9ucyA9IG1hcmdlT3B0aW9ucyh0cnVlLCBvcHRpb25zKTtcbiAgcmVhZE9wdGlvbnMuZGlzcGxheSA9IHJlYWRPcHRpb25zLnByb21wdDtcbiAgcmV0dXJuIGdldFZhbGlkTGluZShyZWFkT3B0aW9ucyk7XG59O1xuXG5leHBvcnRzLmtleUluID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKG1hcmdlT3B0aW9ucyh0cnVlLCBvcHRpb25zKSwge1xuICAgIGRpc3BsYXk6ICAgICAgICAgICAgcXVlcnksXG4gICAga2V5SW46ICAgICAgICAgICAgICB0cnVlLFxuICAgIGtlZXBXaGl0ZXNwYWNlOiAgICAgdHJ1ZVxuICB9KTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG4gIC8vIGNoYXIgbGlzdFxuICByZWFkT3B0aW9ucy5saW1pdFNyYyA9IHJlYWRPcHRpb25zLmxpbWl0LmZpbHRlcihmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIHJldHVybiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJztcbiAgfSlcbiAgLm1hcChmdW5jdGlvbih0ZXh0KSB7IHJldHVybiByZXBsYWNlUGxhY2Vob2xkZXIodGV4dCArICcnLCBnZXRQaENoYXJsaXN0KTsgfSk7XG4gIC8vIHBhdHRlcm5cbiAgcmVhZE9wdGlvbnMubGltaXQgPSBlc2NhcGVQYXR0ZXJuKHJlYWRPcHRpb25zLmxpbWl0U3JjLmpvaW4oJycpKTtcblxuICBbJ3RydWVWYWx1ZScsICdmYWxzZVZhbHVlJ10uZm9yRWFjaChmdW5jdGlvbihvcHRpb25OYW1lKSB7XG4gICAgcmVhZE9wdGlvbnNbb3B0aW9uTmFtZV0gPSByZWFkT3B0aW9uc1tvcHRpb25OYW1lXS5yZWR1Y2UoZnVuY3Rpb24oY29tcHMsIGNvbXApIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGNvbXA7XG4gICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29tcHMgPSBjb21wcy5jb25jYXQoKGNvbXAgKyAnJykuc3BsaXQoJycpKTtcbiAgICAgIH0gZWxzZSB7IGNvbXBzLnB1c2goY29tcCk7IH1cbiAgICAgIHJldHVybiBjb21wcztcbiAgICB9LCBbXSk7XG4gIH0pO1xuXG4gIHJlYWRPcHRpb25zLmRpc3BsYXkgPSByZXBsYWNlUGxhY2Vob2xkZXIocmVhZE9wdGlvbnMuZGlzcGxheSArICcnLFxuICAgIGZ1bmN0aW9uKHBhcmFtKSB7IHJldHVybiBnZXRQaENvbnRlbnQocGFyYW0sIHJlYWRPcHRpb25zKTsgfSk7XG5cbiAgcmV0dXJuIHRvQm9vbChfcmVhZGxpbmVTeW5jKHJlYWRPcHRpb25zKSwgcmVhZE9wdGlvbnMpO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMucXVlc3Rpb25FTWFpbCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0lucHV0IGUtbWFpbCBhZGRyZXNzOiAnOyB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybiBleHBvcnRzLnF1ZXN0aW9uKHF1ZXJ5LCBtYXJnZU9wdGlvbnMoe1xuICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3NcbiAgICBsaW1pdDogICAgICAgICAgICAgIC9eW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvLFxuICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ0lucHV0IHZhbGlkIGUtbWFpbCBhZGRyZXNzLCBwbGVhc2UuJyxcbiAgICB0cnVlVmFsdWU6ICAgICAgICAgIG51bGwsXG4gICAgZmFsc2VWYWx1ZTogICAgICAgICBudWxsXG4gIH0sIG9wdGlvbnMsIHtcbiAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICBrZWVwV2hpdGVzcGFjZTogICAgIGZhbHNlLFxuICAgIGNkOiAgICAgICAgICAgICAgICAgZmFsc2VcbiAgfSkpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG59O1xuXG5leHBvcnRzLnF1ZXN0aW9uTmV3UGFzc3dvcmQgPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgcmVzQ2hhcmxpc3QsIG1pbiwgbWF4LFxuICAgIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICAgIGhpZGVFY2hvQmFjazogICAgICAgdHJ1ZSxcbiAgICAgIG1hc2s6ICAgICAgICAgICAgICAgJyonLFxuICAgICAgbGltaXRNZXNzYWdlOiAgICAgICAnSXQgY2FuIGluY2x1ZGU6ICQ8Y2hhcmxpc3Q+XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0FuZCB0aGUgbGVuZ3RoIG11c3QgYmU6ICQ8bGVuZ3RoPicsXG4gICAgICB0cnVlVmFsdWU6ICAgICAgICAgIG51bGwsXG4gICAgICBmYWxzZVZhbHVlOiAgICAgICAgIG51bGwsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIHRydWVcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICAgIGhpc3Rvcnk6ICAgICAgICAgICAgZmFsc2UsXG4gICAgICBjZDogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgLy8gbGltaXQgKGJ5IGNoYXJsaXN0IGV0Yy4pLFxuICAgICAgcGhDb250ZW50OiBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gPT09ICdjaGFybGlzdCcgPyByZXNDaGFybGlzdC50ZXh0IDpcbiAgICAgICAgICBwYXJhbSA9PT0gJ2xlbmd0aCcgPyBtaW4gKyAnLi4uJyArIG1heCA6IG51bGw7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gYWRkZWQ6ICAgICBjaGFybGlzdCwgbWluLCBtYXgsIGNvbmZpcm1NZXNzYWdlLCB1bm1hdGNoTWVzc2FnZVxuICAgIGNoYXJsaXN0LCBjb25maXJtTWVzc2FnZSwgdW5tYXRjaE1lc3NhZ2UsXG4gICAgbGltaXQsIGxpbWl0TWVzc2FnZSwgcmVzMSwgcmVzMjtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBjaGFybGlzdCA9IHJlcGxhY2VQbGFjZWhvbGRlcihcbiAgICBvcHRpb25zLmNoYXJsaXN0ID8gb3B0aW9ucy5jaGFybGlzdCArICcnIDogJyQ8IS1+PicsIGdldFBoQ2hhcmxpc3QpO1xuICBpZiAoaXNOYU4obWluID0gcGFyc2VJbnQob3B0aW9ucy5taW4sIDEwKSkgfHwgdHlwZW9mIG1pbiAhPT0gJ251bWJlcicpIHsgbWluID0gMTI7IH1cbiAgaWYgKGlzTmFOKG1heCA9IHBhcnNlSW50KG9wdGlvbnMubWF4LCAxMCkpIHx8IHR5cGVvZiBtYXggIT09ICdudW1iZXInKSB7IG1heCA9IDI0OyB9XG4gIGxpbWl0ID0gbmV3IFJlZ0V4cCgnXlsnICsgZXNjYXBlUGF0dGVybihjaGFybGlzdCkgK1xuICAgICddeycgKyBtaW4gKyAnLCcgKyBtYXggKyAnfSQnKTtcbiAgcmVzQ2hhcmxpc3QgPSBhcnJheTJjaGFybGlzdChbY2hhcmxpc3RdLCByZWFkT3B0aW9ucy5jYXNlU2Vuc2l0aXZlLCB0cnVlKTtcbiAgcmVzQ2hhcmxpc3QudGV4dCA9IGpvaW5DaHVua3MocmVzQ2hhcmxpc3QudmFsdWVzLCByZXNDaGFybGlzdC5zdXBwcmVzc2VkKTtcblxuICBjb25maXJtTWVzc2FnZSA9IG9wdGlvbnMuY29uZmlybU1lc3NhZ2UgIT0gbnVsbCA/IG9wdGlvbnMuY29uZmlybU1lc3NhZ2UgOlxuICAgICdSZWlucHV0IGEgc2FtZSBvbmUgdG8gY29uZmlybSBpdDogJztcbiAgdW5tYXRjaE1lc3NhZ2UgPSBvcHRpb25zLnVubWF0Y2hNZXNzYWdlICE9IG51bGwgPyBvcHRpb25zLnVubWF0Y2hNZXNzYWdlIDpcbiAgICAnSXQgZGlmZmVycyBmcm9tIGZpcnN0IG9uZS4nICtcbiAgICAgICcgSGl0IG9ubHkgdGhlIEVudGVyIGtleSBpZiB5b3Ugd2FudCB0byByZXRyeSBmcm9tIGZpcnN0IG9uZS4nO1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0lucHV0IG5ldyBwYXNzd29yZDogJzsgfVxuXG4gIGxpbWl0TWVzc2FnZSA9IHJlYWRPcHRpb25zLmxpbWl0TWVzc2FnZTtcbiAgd2hpbGUgKCFyZXMyKSB7XG4gICAgcmVhZE9wdGlvbnMubGltaXQgPSBsaW1pdDtcbiAgICByZWFkT3B0aW9ucy5saW1pdE1lc3NhZ2UgPSBsaW1pdE1lc3NhZ2U7XG4gICAgcmVzMSA9IGV4cG9ydHMucXVlc3Rpb24ocXVlcnksIHJlYWRPcHRpb25zKTtcblxuICAgIHJlYWRPcHRpb25zLmxpbWl0ID0gW3JlczEsICcnXTtcbiAgICByZWFkT3B0aW9ucy5saW1pdE1lc3NhZ2UgPSB1bm1hdGNoTWVzc2FnZTtcbiAgICByZXMyID0gZXhwb3J0cy5xdWVzdGlvbihjb25maXJtTWVzc2FnZSwgcmVhZE9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHJlczE7XG59O1xuXG5mdW5jdGlvbiBfcXVlc3Rpb25OdW0ocXVlcnksIG9wdGlvbnMsIHBhcnNlcikge1xuICB2YXIgdmFsaWRWYWx1ZTtcbiAgZnVuY3Rpb24gZ2V0VmFsaWRWYWx1ZSh2YWx1ZSkge1xuICAgIHZhbGlkVmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICAgIHJldHVybiAhaXNOYU4odmFsaWRWYWx1ZSkgJiYgdHlwZW9mIHZhbGlkVmFsdWUgPT09ICdudW1iZXInO1xuICB9XG4gIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gIGV4cG9ydHMucXVlc3Rpb24ocXVlcnksIG1hcmdlT3B0aW9ucyh7XG4gICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgIGxpbWl0TWVzc2FnZTogICAgICAgJ0lucHV0IHZhbGlkIG51bWJlciwgcGxlYXNlLidcbiAgfSwgb3B0aW9ucywge1xuICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgIGxpbWl0OiAgICAgICAgICAgICAgZ2V0VmFsaWRWYWx1ZSxcbiAgICBjZDogICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgLy8gdHJ1ZVZhbHVlLCBmYWxzZVZhbHVlLCBjYXNlU2Vuc2l0aXZlLCBrZWVwV2hpdGVzcGFjZSBkb24ndCB3b3JrLlxuICB9KSk7XG4gIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuIHZhbGlkVmFsdWU7XG59XG5leHBvcnRzLnF1ZXN0aW9uSW50ID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9xdWVzdGlvbk51bShxdWVyeSwgb3B0aW9ucywgZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCk7IH0pO1xufTtcbmV4cG9ydHMucXVlc3Rpb25GbG9hdCA9IGZ1bmN0aW9uKHF1ZXJ5LCBvcHRpb25zKSB7XG4gIHJldHVybiBfcXVlc3Rpb25OdW0ocXVlcnksIG9wdGlvbnMsIHBhcnNlRmxvYXQpO1xufTtcblxuZXhwb3J0cy5xdWVzdGlvblBhdGggPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgdmFsaWRQYXRoLCBlcnJvciA9ICcnLFxuICAgIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICckPGVycm9yKFxcbik+SW5wdXQgdmFsaWQgcGF0aCwgcGxlYXNlLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICckPCggTWluOiltaW4+JDwoIE1heDopbWF4PicsXG4gICAgICBoaXN0b3J5OiAgICAgICAgICAgIHRydWUsXG4gICAgICBjZDogICAgICAgICAgICAgICAgIHRydWVcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICAgIGtlZXBXaGl0ZXNwYWNlOiAgICAgZmFsc2UsXG4gICAgICBsaW1pdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGV4aXN0cywgc3RhdCwgcmVzO1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VIb21lUGF0aCh2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIGVycm9yID0gJyc7IC8vIGZvciB2YWxpZGF0ZVxuICAgICAgICAvLyBta2RpciAtcFxuICAgICAgICBmdW5jdGlvbiBta2RpclBhcmVudHMoZGlyUGF0aCkge1xuICAgICAgICAgIGRpclBhdGguc3BsaXQoL1xcL3xcXFxcLykucmVkdWNlKGZ1bmN0aW9uKHBhcmVudHMsIGRpcikge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBwYXRoVXRpbC5yZXNvbHZlKChwYXJlbnRzICs9IGRpciArIHBhdGhVdGlsLnNlcCkpO1xuICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhwYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZzLnN0YXRTeW5jKHBhdGgpLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gZGlyZWN0b3J5IGFscmVhZHkgZXhpc3RzOiAnICsgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50cztcbiAgICAgICAgICB9LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGV4aXN0cyA9IGZzLmV4aXN0c1N5bmModmFsdWUpO1xuICAgICAgICAgIHZhbGlkUGF0aCA9IGV4aXN0cyA/IGZzLnJlYWxwYXRoU3luYyh2YWx1ZSkgOiBwYXRoVXRpbC5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAvLyBvcHRpb25zLmV4aXN0cyBkZWZhdWx0OiB0cnVlLCBub3QtYm9vbDogbm8tY2hlY2tcbiAgICAgICAgICBpZiAoIW9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2V4aXN0cycpICYmICFleGlzdHMgfHxcbiAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuZXhpc3RzID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy5leGlzdHMgIT09IGV4aXN0cykge1xuICAgICAgICAgICAgZXJyb3IgPSAoZXhpc3RzID8gJ0FscmVhZHkgZXhpc3RzJyA6ICdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JykgK1xuICAgICAgICAgICAgICAnOiAnICsgdmFsaWRQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWV4aXN0cyAmJiBvcHRpb25zLmNyZWF0ZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgbWtkaXJQYXJlbnRzKHZhbGlkUGF0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBta2RpclBhcmVudHMocGF0aFV0aWwuZGlybmFtZSh2YWxpZFBhdGgpKTtcbiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKGZzLm9wZW5TeW5jKHZhbGlkUGF0aCwgJ3cnKSk7IC8vIHRvdWNoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZFBhdGggPSBmcy5yZWFscGF0aFN5bmModmFsaWRQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGV4aXN0cyAmJiAob3B0aW9ucy5taW4gfHwgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgICAgICAgb3B0aW9ucy5pc0ZpbGUgfHwgb3B0aW9ucy5pc0RpcmVjdG9yeSkpIHtcbiAgICAgICAgICAgIHN0YXQgPSBmcy5zdGF0U3luYyh2YWxpZFBhdGgpO1xuICAgICAgICAgICAgLy8gdHlwZSBjaGVjayBmaXJzdCAoZGlyZWN0b3J5IGhhcyB6ZXJvIHNpemUpXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pc0ZpbGUgJiYgIXN0YXQuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSAnTm90IGZpbGU6ICcgKyB2YWxpZFBhdGg7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5pc0RpcmVjdG9yeSAmJiAhc3RhdC5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gJ05vdCBkaXJlY3Rvcnk6ICcgKyB2YWxpZFBhdGg7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5taW4gJiYgc3RhdC5zaXplIDwgK29wdGlvbnMubWluIHx8XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXggJiYgc3RhdC5zaXplID4gK29wdGlvbnMubWF4KSB7XG4gICAgICAgICAgICAgIGVycm9yID0gJ1NpemUgJyArIHN0YXQuc2l6ZSArICcgaXMgb3V0IG9mIHJhbmdlOiAnICsgdmFsaWRQYXRoO1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgICAocmVzID0gb3B0aW9ucy52YWxpZGF0ZSh2YWxpZFBhdGgpKSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdzdHJpbmcnKSB7IGVycm9yID0gcmVzOyB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZXJyb3IgPSBlICsgJyc7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIC8vIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSwgY2FzZVNlbnNpdGl2ZSBkb24ndCB3b3JrLlxuICAgICAgcGhDb250ZW50OiBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gPT09ICdlcnJvcicgPyBlcnJvciA6XG4gICAgICAgICAgcGFyYW0gIT09ICdtaW4nICYmIHBhcmFtICE9PSAnbWF4JyA/IG51bGwgOlxuICAgICAgICAgIG9wdGlvbnMuaGFzT3duUHJvcGVydHkocGFyYW0pID8gb3B0aW9uc1twYXJhbV0gKyAnJyA6ICcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGFkZGVkOiAgICAgZXhpc3RzLCBjcmVhdGUsIG1pbiwgbWF4LCBpc0ZpbGUsIGlzRGlyZWN0b3J5LCB2YWxpZGF0ZVxuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0lucHV0IHBhdGggKHlvdSBjYW4gXCJjZFwiIGFuZCBcInB3ZFwiKTogJzsgfVxuXG4gIGV4cG9ydHMucXVlc3Rpb24ocXVlcnksIHJlYWRPcHRpb25zKTtcbiAgcmV0dXJuIHZhbGlkUGF0aDtcbn07XG5cbi8vIHByb3BzOiBwcmVDaGVjaywgYXJncywgaFJlcywgbGltaXRcbmZ1bmN0aW9uIGdldENsSGFuZGxlcihjb21tYW5kSGFuZGxlciwgb3B0aW9ucykge1xuICB2YXIgY2xIYW5kbGVyID0ge30sIGhJbmRleCA9IHt9O1xuICBpZiAodHlwZW9mIGNvbW1hbmRIYW5kbGVyID09PSAnb2JqZWN0Jykge1xuICAgIE9iamVjdC5rZXlzKGNvbW1hbmRIYW5kbGVyKS5mb3JFYWNoKGZ1bmN0aW9uKGNtZCkge1xuICAgICAgaWYgKHR5cGVvZiBjb21tYW5kSGFuZGxlcltjbWRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGhJbmRleFtvcHRpb25zLmNhc2VTZW5zaXRpdmUgPyBjbWQgOiBjbWQudG9Mb3dlckNhc2UoKV0gPSBjb21tYW5kSGFuZGxlcltjbWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNsSGFuZGxlci5wcmVDaGVjayA9IGZ1bmN0aW9uKHJlcykge1xuICAgICAgdmFyIGNtZEtleTtcbiAgICAgIGNsSGFuZGxlci5hcmdzID0gcGFyc2VDbChyZXMpO1xuICAgICAgY21kS2V5ID0gY2xIYW5kbGVyLmFyZ3NbMF0gfHwgJyc7XG4gICAgICBpZiAoIW9wdGlvbnMuY2FzZVNlbnNpdGl2ZSkgeyBjbWRLZXkgPSBjbWRLZXkudG9Mb3dlckNhc2UoKTsgfVxuICAgICAgY2xIYW5kbGVyLmhSZXMgPVxuICAgICAgICBjbWRLZXkgIT09ICdfJyAmJiBoSW5kZXguaGFzT3duUHJvcGVydHkoY21kS2V5KSA/XG4gICAgICAgICAgaEluZGV4W2NtZEtleV0uYXBwbHkocmVzLCBjbEhhbmRsZXIuYXJncy5zbGljZSgxKSkgOlxuICAgICAgICBoSW5kZXguaGFzT3duUHJvcGVydHkoJ18nKSA/IGhJbmRleC5fLmFwcGx5KHJlcywgY2xIYW5kbGVyLmFyZ3MpIDogbnVsbDtcbiAgICAgIHJldHVybiB7cmVzOiByZXMsIGZvcmNlTmV4dDogZmFsc2V9O1xuICAgIH07XG4gICAgaWYgKCFoSW5kZXguaGFzT3duUHJvcGVydHkoJ18nKSkge1xuICAgICAgY2xIYW5kbGVyLmxpbWl0ID0gZnVuY3Rpb24oKSB7IC8vIEl0J3MgY2FsbGVkIGFmdGVyIHByZUNoZWNrLlxuICAgICAgICB2YXIgY21kS2V5ID0gY2xIYW5kbGVyLmFyZ3NbMF0gfHwgJyc7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYXNlU2Vuc2l0aXZlKSB7IGNtZEtleSA9IGNtZEtleS50b0xvd2VyQ2FzZSgpOyB9XG4gICAgICAgIHJldHVybiBoSW5kZXguaGFzT3duUHJvcGVydHkoY21kS2V5KTtcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNsSGFuZGxlci5wcmVDaGVjayA9IGZ1bmN0aW9uKHJlcykge1xuICAgICAgY2xIYW5kbGVyLmFyZ3MgPSBwYXJzZUNsKHJlcyk7XG4gICAgICBjbEhhbmRsZXIuaFJlcyA9IHR5cGVvZiBjb21tYW5kSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIGNvbW1hbmRIYW5kbGVyLmFwcGx5KHJlcywgY2xIYW5kbGVyLmFyZ3MpIDogdHJ1ZTsgLy8gdHJ1ZSBmb3IgYnJlYWsgbG9vcFxuICAgICAgcmV0dXJuIHtyZXM6IHJlcywgZm9yY2VOZXh0OiBmYWxzZX07XG4gICAgfTtcbiAgfVxuICByZXR1cm4gY2xIYW5kbGVyO1xufVxuXG5leHBvcnRzLnByb21wdENMID0gZnVuY3Rpb24oY29tbWFuZEhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdSZXF1ZXN0ZWQgY29tbWFuZCBpcyBub3QgYXZhaWxhYmxlLicsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlLFxuICAgICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlXG4gICAgfSwgb3B0aW9ucyksXG4gICAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICAgIC8vIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSwga2VlcFdoaXRlc3BhY2UgZG9uJ3Qgd29yay5cbiAgICAgIC8vIHByZUNoZWNrLCBsaW1pdCAoYnkgY2xIYW5kbGVyKVxuICAgIGNsSGFuZGxlciA9IGdldENsSGFuZGxlcihjb21tYW5kSGFuZGxlciwgcmVhZE9wdGlvbnMpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHJlYWRPcHRpb25zLmxpbWl0ID0gY2xIYW5kbGVyLmxpbWl0O1xuICByZWFkT3B0aW9ucy5wcmVDaGVjayA9IGNsSGFuZGxlci5wcmVDaGVjaztcbiAgZXhwb3J0cy5wcm9tcHQocmVhZE9wdGlvbnMpO1xuICByZXR1cm4gY2xIYW5kbGVyLmFyZ3M7XG59O1xuXG5leHBvcnRzLnByb21wdExvb3AgPSBmdW5jdGlvbihpbnB1dEhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAvLyAtLS0tLS0tLSBkZWZhdWx0XG4gICAgaGlkZUVjaG9CYWNrOiAgICAgICBmYWxzZSxcbiAgICB0cnVlVmFsdWU6ICAgICAgICAgIG51bGwsXG4gICAgZmFsc2VWYWx1ZTogICAgICAgICBudWxsLFxuICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2UsXG4gICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlXG4gIH0sIG9wdGlvbnMpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHdoaWxlICh0cnVlKSB7IGlmIChpbnB1dEhhbmRsZXIoZXhwb3J0cy5wcm9tcHQocmVhZE9wdGlvbnMpKSkgeyBicmVhazsgfSB9XG4gIHJldHVybjtcbn07XG5cbmV4cG9ydHMucHJvbXB0Q0xMb29wID0gZnVuY3Rpb24oY29tbWFuZEhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgICBsaW1pdE1lc3NhZ2U6ICAgICAgICdSZXF1ZXN0ZWQgY29tbWFuZCBpcyBub3QgYXZhaWxhYmxlLicsXG4gICAgICBjYXNlU2Vuc2l0aXZlOiAgICAgIGZhbHNlLFxuICAgICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlXG4gICAgfSwgb3B0aW9ucyksXG4gICAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICAgIC8vIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSwga2VlcFdoaXRlc3BhY2UgZG9uJ3Qgd29yay5cbiAgICAgIC8vIHByZUNoZWNrLCBsaW1pdCAoYnkgY2xIYW5kbGVyKVxuICAgIGNsSGFuZGxlciA9IGdldENsSGFuZGxlcihjb21tYW5kSGFuZGxlciwgcmVhZE9wdGlvbnMpO1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHJlYWRPcHRpb25zLmxpbWl0ID0gY2xIYW5kbGVyLmxpbWl0O1xuICByZWFkT3B0aW9ucy5wcmVDaGVjayA9IGNsSGFuZGxlci5wcmVDaGVjaztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBleHBvcnRzLnByb21wdChyZWFkT3B0aW9ucyk7XG4gICAgaWYgKGNsSGFuZGxlci5oUmVzKSB7IGJyZWFrOyB9XG4gIH1cbiAgcmV0dXJuO1xufTtcblxuZXhwb3J0cy5wcm9tcHRTaW1TaGVsbCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgcmV0dXJuIGV4cG9ydHMucHJvbXB0KG1hcmdlT3B0aW9ucyh7XG4gICAgLy8gLS0tLS0tLS0gZGVmYXVsdFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2UsXG4gICAgaGlzdG9yeTogICAgICAgICAgICB0cnVlXG4gIH0sIG9wdGlvbnMsIHtcbiAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICBwcm9tcHQ6ICAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBJU19XSU4gP1xuICAgICAgICAnJDxjd2Q+PicgOlxuICAgICAgICAvLyAndXNlckBob3N0OmN3ZCQgJ1xuICAgICAgICAocHJvY2Vzcy5lbnYuVVNFUiB8fCAnJykgK1xuICAgICAgICAocHJvY2Vzcy5lbnYuSE9TVE5BTUUgP1xuICAgICAgICAgICdAJyArIHByb2Nlc3MuZW52LkhPU1ROQU1FLnJlcGxhY2UoL1xcLi4qJC8sICcnKSA6ICcnKSArXG4gICAgICAgICc6JDxjd2RIb21lPiQgJztcbiAgICB9KSgpXG4gIH0pKTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xufTtcblxuZnVuY3Rpb24gX2tleUluWU4ocXVlcnksIG9wdGlvbnMsIGxpbWl0KSB7XG4gIHZhciByZXM7XG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0FyZSB5b3Ugc3VyZT8gJzsgfVxuICBpZiAoKCFvcHRpb25zIHx8IG9wdGlvbnMuZ3VpZGUgIT09IGZhbHNlKSAmJiAocXVlcnkgKz0gJycpKSB7XG4gICAgcXVlcnkgPSBxdWVyeS5yZXBsYWNlKC9cXHMqOj9cXHMqJC8sICcnKSArICcgW3kvbl06ICc7XG4gIH1cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgcmVzID0gZXhwb3J0cy5rZXlJbihxdWVyeSwgbWFyZ2VPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICBoaWRlRWNob0JhY2s6ICAgICAgIGZhbHNlLFxuICAgIGxpbWl0OiAgICAgICAgICAgICAgbGltaXQsXG4gICAgdHJ1ZVZhbHVlOiAgICAgICAgICAneScsXG4gICAgZmFsc2VWYWx1ZTogICAgICAgICAnbicsXG4gICAgY2FzZVNlbnNpdGl2ZTogICAgICBmYWxzZVxuICAgIC8vIG1hc2sgZG9lc24ndCB3b3JrLlxuICB9KSk7XG4gIC8vIGFkZGVkOiAgICAgZ3VpZGVcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICByZXR1cm4gdHlwZW9mIHJlcyA9PT0gJ2Jvb2xlYW4nID8gcmVzIDogJyc7XG59XG5leHBvcnRzLmtleUluWU4gPSBmdW5jdGlvbihxdWVyeSwgb3B0aW9ucykgeyByZXR1cm4gX2tleUluWU4ocXVlcnksIG9wdGlvbnMpOyB9O1xuZXhwb3J0cy5rZXlJbllOU3RyaWN0ID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHsgcmV0dXJuIF9rZXlJbllOKHF1ZXJ5LCBvcHRpb25zLCAneW4nKTsgfTtcblxuZXhwb3J0cy5rZXlJblBhdXNlID0gZnVuY3Rpb24ocXVlcnksIG9wdGlvbnMpIHtcbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHsgcXVlcnkgPSAnQ29udGludWUuLi4nOyB9XG4gIGlmICgoIW9wdGlvbnMgfHwgb3B0aW9ucy5ndWlkZSAhPT0gZmFsc2UpICYmIChxdWVyeSArPSAnJykpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xccyskLywgJycpICsgJyAoSGl0IGFueSBrZXkpJztcbiAgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICBleHBvcnRzLmtleUluKHF1ZXJ5LCBtYXJnZU9wdGlvbnMoe1xuICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICBsaW1pdDogICAgICAgICAgICAgIG51bGxcbiAgfSwgb3B0aW9ucywge1xuICAgIC8vIC0tLS0tLS0tIGZvcmNlZFxuICAgIGhpZGVFY2hvQmFjazogICAgICAgdHJ1ZSxcbiAgICBtYXNrOiAgICAgICAgICAgICAgICcnXG4gIH0pKTtcbiAgLy8gYWRkZWQ6ICAgICBndWlkZVxuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIHJldHVybjtcbn07XG5cbmV4cG9ydHMua2V5SW5TZWxlY3QgPSBmdW5jdGlvbihpdGVtcywgcXVlcnksIG9wdGlvbnMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIHJlYWRPcHRpb25zID0gbWFyZ2VPcHRpb25zKHtcbiAgICAgIC8vIC0tLS0tLS0tIGRlZmF1bHRcbiAgICAgIGhpZGVFY2hvQmFjazogICAgICAgZmFsc2VcbiAgICB9LCBvcHRpb25zLCB7XG4gICAgICAvLyAtLS0tLS0tLSBmb3JjZWRcbiAgICAgIHRydWVWYWx1ZTogICAgICAgICAgbnVsbCxcbiAgICAgIGZhbHNlVmFsdWU6ICAgICAgICAgbnVsbCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6ICAgICAgZmFsc2UsXG4gICAgICAvLyBsaW1pdCAoYnkgaXRlbXMpLFxuICAgICAgcGhDb250ZW50OiBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICByZXR1cm4gcGFyYW0gPT09ICdpdGVtc0NvdW50JyA/IGl0ZW1zLmxlbmd0aCArICcnIDpcbiAgICAgICAgICBwYXJhbSA9PT0gJ2ZpcnN0SXRlbScgPyAoaXRlbXNbMF0gKyAnJykudHJpbSgpIDpcbiAgICAgICAgICBwYXJhbSA9PT0gJ2xhc3RJdGVtJyA/IChpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSArICcnKS50cmltKCkgOiBudWxsO1xuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIGFkZGVkOiAgICAgZ3VpZGUsIGNhbmNlbFxuICAgIGtleWxpc3QgPSAnJywga2V5MmkgPSB7fSwgY2hhckNvZGUgPSA0OSAvKiAnMScgKi8sIGRpc3BsYXkgPSAnXFxuJztcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpIHx8ICFpdGVtcy5sZW5ndGggfHwgaXRlbXMubGVuZ3RoID4gMzUpIHtcbiAgICB0aHJvdyAnYGl0ZW1zYCBtdXN0IGJlIEFycmF5IChtYXggbGVuZ3RoOiAzNSkuJztcbiAgfVxuXG4gIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbSwgaSkge1xuICAgIHZhciBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICBrZXlsaXN0ICs9IGtleTtcbiAgICBrZXkyaVtrZXldID0gaTtcbiAgICBkaXNwbGF5ICs9ICdbJyArIGtleSArICddICcgKyAoaXRlbSArICcnKS50cmltKCkgKyAnXFxuJztcbiAgICBjaGFyQ29kZSA9IGNoYXJDb2RlID09PSA1NyAvKiAnOScgKi8gPyA5NyAvKiAnYScgKi8gOiBjaGFyQ29kZSArIDE7XG4gIH0pO1xuICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5jYW5jZWwgIT09IGZhbHNlKSB7XG4gICAga2V5bGlzdCArPSAnMCc7XG4gICAga2V5MmlbJzAnXSA9IC0xO1xuICAgIGRpc3BsYXkgKz0gJ1swXSAnICtcbiAgICAgIChvcHRpb25zICYmIG9wdGlvbnMuY2FuY2VsICE9IG51bGwgJiYgdHlwZW9mIG9wdGlvbnMuY2FuY2VsICE9PSAnYm9vbGVhbicgP1xuICAgICAgICAob3B0aW9ucy5jYW5jZWwgKyAnJykudHJpbSgpIDogJ0NBTkNFTCcpICsgJ1xcbic7XG4gIH1cbiAgcmVhZE9wdGlvbnMubGltaXQgPSBrZXlsaXN0O1xuICBkaXNwbGF5ICs9ICdcXG4nO1xuXG4gIGlmIChxdWVyeSA9PSBudWxsKSB7IHF1ZXJ5ID0gJ0Nob29zZSBvbmUgZnJvbSBsaXN0OiAnOyB9XG4gIGlmICgocXVlcnkgKz0gJycpKSB7XG4gICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZ3VpZGUgIT09IGZhbHNlKSB7XG4gICAgICBxdWVyeSA9IHF1ZXJ5LnJlcGxhY2UoL1xccyo6P1xccyokLywgJycpICsgJyBbJDxsaW1pdD5dOiAnO1xuICAgIH1cbiAgICBkaXNwbGF5ICs9IHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIGtleTJpW2V4cG9ydHMua2V5SW4oZGlzcGxheSwgcmVhZE9wdGlvbnMpLnRvTG93ZXJDYXNlKCldO1xufTtcblxuZXhwb3J0cy5nZXRSYXdJbnB1dCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmF3SW5wdXQ7IH07XG5cbi8vID09PT09PT09IERFUFJFQ0FURUQgPT09PT09PT1cbmZ1bmN0aW9uIF9zZXRPcHRpb24ob3B0aW9uTmFtZSwgYXJncykge1xuICB2YXIgb3B0aW9ucztcbiAgaWYgKGFyZ3MubGVuZ3RoKSB7IG9wdGlvbnMgPSB7fTsgb3B0aW9uc1tvcHRpb25OYW1lXSA9IGFyZ3NbMF07IH1cbiAgcmV0dXJuIGV4cG9ydHMuc2V0RGVmYXVsdE9wdGlvbnMob3B0aW9ucylbb3B0aW9uTmFtZV07XG59XG5leHBvcnRzLnNldFByaW50ID0gZnVuY3Rpb24oKSB7IHJldHVybiBfc2V0T3B0aW9uKCdwcmludCcsIGFyZ3VtZW50cyk7IH07XG5leHBvcnRzLnNldFByb21wdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldE9wdGlvbigncHJvbXB0JywgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIF9zZXRPcHRpb24oJ2VuY29kaW5nJywgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMuc2V0TWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gX3NldE9wdGlvbignbWFzaycsIGFyZ3VtZW50cyk7IH07XG5leHBvcnRzLnNldEJ1ZmZlclNpemUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIF9zZXRPcHRpb24oJ2J1ZmZlclNpemUnLCBhcmd1bWVudHMpOyB9O1xuIiwiKGZ1bmN0aW9uKCkge1xyXG5cdFxyXG5cdC8vIFZFUlNJT05cclxuXHR2YXIgdmVyc2lvbiA9IHsgbWFqb3I6IDAsIG1pbm9yOiAzLCBwYXRjaDogNCwgc3RhdHVzOiBcImJldGFcIiB9O1xyXG5cclxuXHJcblxyXG5cdC8vIElPIEZJTEUgU1lTVEVNXHJcblx0XHJcblx0Ly8gVmlydHVhbCBmaWxlXHJcblx0ZnVuY3Rpb24gVGF1RmlsZShuYW1lLCB0eXBlLCBwYXJlbnQsIHRleHQpIHtcclxuXHRcdHRleHQgPSB0ZXh0ID09PSB1bmRlZmluZWQgPyBcIlwiIDogdGV4dDtcclxuXHRcdHRoaXMubmFtZSA9IG5hbWU7XHJcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0XHR0aGlzLnRleHQgPSB0ZXh0O1xyXG5cdFx0dGhpcy5jcmVhdGVkID0gRGF0ZS5ub3coKSAvIDEwMDA7XHJcblx0XHR0aGlzLm1vZGlmaWVkID0gdGhpcy5jcmVhdGVkO1xyXG5cdH1cclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obGVuZ3RoLCBwb3NpdGlvbikge1xyXG5cdFx0aWYocG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIFwiZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0fSBlbHNlIGlmKHBvc2l0aW9uID4gdGhpcy50ZXh0Lmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gXCJlbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50ZXh0LnN1YnN0cmluZyhwb3NpdGlvbiwgcG9zaXRpb24rbGVuZ3RoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5lb2YgPSBmdW5jdGlvbihwb3NpdGlvbikge1xyXG5cdFx0cmV0dXJuIHBvc2l0aW9uID09PSB0aGlzLnRleHQubGVuZ3RoO1xyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKHRleHQsIHBvc2l0aW9uKSB7XHJcblx0XHRpZihwb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0dGhpcy50ZXh0ICs9IHRleHQ7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmKHBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCBwb3NpdGlvbikgKyB0ZXh0ICsgdGhpcy50ZXh0LnN1YnN0cmluZyhwb3NpdGlvbit0ZXh0Lmxlbmd0aCk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLmdldF9ieXRlID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuXHRcdGlmKHBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIilcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcihwb3NpdGlvbi8yKTtcclxuXHRcdGlmKHRoaXMudGV4dC5sZW5ndGggPD0gaW5kZXgpXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdHZhciBjb2RlID0gY29kZVBvaW50QXQodGhpcy50ZXh0W01hdGguZmxvb3IocG9zaXRpb24vMildLCAwKTtcclxuXHRcdGlmKHBvc2l0aW9uICUgMiA9PT0gMClcclxuXHRcdFx0cmV0dXJuIGNvZGUgJiAweGZmO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRyZXR1cm4gY29kZSAvIDI1NiA+Pj4gMDtcclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5wdXRfYnl0ZSA9IGZ1bmN0aW9uKGJ5dGUsIHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgaW5kZXggPSBwb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgPyB0aGlzLnRleHQubGVuZ3RoIDogTWF0aC5mbG9vcihwb3NpdGlvbi8yKTtcclxuXHRcdGlmKHRoaXMudGV4dC5sZW5ndGggPCBpbmRleClcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgY29kZSA9IHRoaXMudGV4dC5sZW5ndGggPT09IGluZGV4ID8gLTEgOiBjb2RlUG9pbnRBdCh0aGlzLnRleHRbTWF0aC5mbG9vcihwb3NpdGlvbi8yKV0sIDApO1xyXG5cdFx0aWYocG9zaXRpb24gJSAyID09PSAwKSB7XHJcblx0XHRcdGNvZGUgPSBjb2RlIC8gMjU2ID4+PiAwO1xyXG5cdFx0XHRjb2RlID0gKChjb2RlICYgMHhmZikgPDwgOCkgfCAoYnl0ZSAmIDB4ZmYpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29kZSA9IGNvZGUgJiAweGZmO1xyXG5cdFx0XHRjb2RlID0gKChieXRlICYgMHhmZikgPDwgOCkgfCAoY29kZSAmIDB4ZmYpO1xyXG5cdFx0fVxyXG5cdFx0aWYodGhpcy50ZXh0Lmxlbmd0aCA9PT0gaW5kZXgpXHJcblx0XHRcdHRoaXMudGV4dCArPSBmcm9tQ29kZVBvaW50KGNvZGUpO1xyXG5cdFx0ZWxzZSBcclxuXHRcdFx0dGhpcy50ZXh0ID0gdGhpcy50ZXh0LnN1YnN0cmluZygwLCBpbmRleCkgKyBmcm9tQ29kZVBvaW50KGNvZGUpICsgdGhpcy50ZXh0LnN1YnN0cmluZyhpbmRleCsxKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdFRhdUZpbGUucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHRUYXVGaWxlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5tb2RpZmllZCA9IERhdGUubm93KCkgLyAxMDAwO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0VGF1RmlsZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7XHJcblx0fTtcclxuXHJcblx0Ly8gVmlydHVhbCBkaXJlY3RvcnlcclxuXHRmdW5jdGlvbiBUYXVEaXJlY3RvcnkobmFtZSwgcGFyZW50KSB7XHJcblx0XHR0aGlzLm5hbWUgPSBuYW1lO1xyXG5cdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcblx0XHR0aGlzLmZpbGVzID0ge307XHJcblx0XHR0aGlzLmxlbmd0aCA9IDA7XHJcblx0XHR0aGlzLmNyZWF0ZWQgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuXHRcdHRoaXMubW9kaWZpZWQgPSB0aGlzLmNyZWF0ZWQ7XHJcblx0fVxyXG5cclxuXHRUYXVEaXJlY3RvcnkucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKGZpbGUpIHtcclxuXHRcdGlmKHRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZSkpXHJcblx0XHRcdHJldHVybiB0aGlzLmZpbGVzW2ZpbGVdO1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fTtcclxuXHJcblx0VGF1RGlyZWN0b3J5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obmFtZSwgZmlsZSkge1xyXG5cdFx0aWYoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXHJcblx0XHRcdHRoaXMubGVuZ3RoKys7XHJcblx0XHR0aGlzLmZpbGVzW25hbWVdID0gZmlsZTtcclxuXHRcdHRoaXMubW9kaWZpZWQgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuXHR9O1xyXG5cclxuXHRUYXVEaXJlY3RvcnkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdGlmKHRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuXHRcdFx0dGhpcy5sZW5ndGgtLTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XHJcblx0XHRcdHRoaXMubW9kaWZpZWQgPSBEYXRlLm5vdygpIC8gMTAwMDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRUYXVEaXJlY3RvcnkucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XHJcblx0fTtcclxuXHJcblx0VGF1RGlyZWN0b3J5LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gNDA5NjtcclxuXHR9O1xyXG5cclxuXHQvLyBWaXJ0dWFsIGZpbGUgc3lzdGVtIGZvciBicm93c2VyXHJcblx0dGF1X2ZpbGVfc3lzdGVtID0ge1xyXG5cdFx0Ly8gQ3VycmVudCBmaWxlc1xyXG5cdFx0ZmlsZXM6IG5ldyBUYXVEaXJlY3RvcnkoXCIvXCIsIFwiL1wiLCBudWxsKSxcclxuXHRcdC8vIE9wZW4gZmlsZVxyXG5cdFx0b3BlbjogZnVuY3Rpb24ocGF0aCwgdHlwZSwgbW9kZSkge1xyXG5cdFx0XHR2YXIgZGlycyA9IHBhdGgucmVwbGFjZSgvXFwvJC8sIFwiXCIpLnNwbGl0KFwiL1wiKTtcclxuXHRcdFx0dmFyIGRpciA9IHRhdV9maWxlX3N5c3RlbS5maWxlcztcclxuXHRcdFx0dmFyIG5hbWUgPSBkaXJzW2RpcnMubGVuZ3RoLTFdO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAxOyBpIDwgZGlycy5sZW5ndGgtMTsgaSsrKSB7XHJcblx0XHRcdFx0ZGlyID0gZGlyLmxvb2t1cChkaXJzW2ldKTtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19kaXJlY3RvcnkoZGlyKSlcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBmaWxlID0gZGlyLmxvb2t1cChuYW1lKTtcclxuXHRcdFx0aWYoZmlsZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdGlmKG1vZGUgPT09IFwicmVhZFwiKVxyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0ZmlsZSA9IG5ldyBUYXVGaWxlKG5hbWUsIHR5cGUsIGRpcik7XHJcblx0XHRcdFx0ZGlyLnB1c2gobmFtZSwgZmlsZSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19maWxlKGZpbGUpKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYobW9kZSA9PT0gXCJ3cml0ZVwiKVxyXG5cdFx0XHRcdGZpbGUudGV4dCA9IFwiXCI7XHJcblx0XHRcdHJldHVybiBmaWxlO1xyXG5cdFx0fSxcclxuXHRcdC8vIEdldCBpdGVtXHJcblx0XHRnZXQ6IGZ1bmN0aW9uKHBhdGgpIHtcclxuXHRcdFx0dmFyIGRpcnMgPSBwYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XHJcblx0XHRcdHZhciBmaWxlID0gdGF1X2ZpbGVfc3lzdGVtLmZpbGVzO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAxOyBpIDwgZGlycy5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2RpcmVjdG9yeShmaWxlKSlcclxuXHRcdFx0XHRcdGZpbGUgPSBmaWxlLmxvb2t1cChkaXJzW2ldKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0cmV0dXJuIGZpbGU7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBpbnB1dCBmb3IgYnJvd3NlclxyXG5cdHRhdV91c2VyX2lucHV0ID0ge1xyXG5cdFx0YnVmZmVyOiBcIlwiLFxyXG5cdFx0Z2V0OiBmdW5jdGlvbiggbGVuZ3RoLCBfICkge1xyXG5cdFx0XHR2YXIgdGV4dDtcclxuXHRcdFx0d2hpbGUoIHRhdV91c2VyX2lucHV0LmJ1ZmZlci5sZW5ndGggPCBsZW5ndGggKSB7XHJcblx0XHRcdFx0dGV4dCA9IHdpbmRvdy5wcm9tcHQoKTtcclxuXHRcdFx0XHRpZiggdGV4dC5sZW5ndGggPT09IDAgKVxyXG5cdFx0XHRcdFx0cmV0dXJuIFwiZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdGlmKCB0ZXh0ICkge1xyXG5cdFx0XHRcdFx0dGF1X3VzZXJfaW5wdXQuYnVmZmVyICs9IHRleHQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRleHQgPSB0YXVfdXNlcl9pbnB1dC5idWZmZXIuc3Vic3RyKCAwLCBsZW5ndGggKTtcclxuXHRcdFx0dGF1X3VzZXJfaW5wdXQuYnVmZmVyID0gdGF1X3VzZXJfaW5wdXQuYnVmZmVyLnN1YnN0ciggbGVuZ3RoICk7XHJcblx0XHRcdHJldHVybiB0ZXh0O1xyXG5cdFx0fSxcclxuXHRcdGVvZjogZnVuY3Rpb24oXykge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gVXNlciBvdXRwdXQgZm9yIGJyb3dzZXJcclxuXHR0YXVfdXNlcl9vdXRwdXQgPSB7XHJcblx0XHRwdXQ6IGZ1bmN0aW9uKCB0ZXh0LCBfICkge1xyXG5cdFx0XHRjb25zb2xlLmxvZyggdGV4dCApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRmbHVzaDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBcclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIGVycm9yIGZvciBicm93c2VyXHJcblx0dGF1X3VzZXJfZXJyb3IgPSB7XHJcblx0XHRwdXQ6IGZ1bmN0aW9uKCB0ZXh0LCBfICkge1xyXG5cdFx0XHQoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoIHRleHQgKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0Zmx1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gXHJcblx0fTtcclxuXHJcblx0Ly8gVmlydHVhbCBmaWxlIHN5c3RlbSBmb3IgTm9kZS5qc1xyXG5cdG5vZGVqc19maWxlX3N5c3RlbSA9IHtcclxuXHRcdC8vIE9wZW4gZmlsZVxyXG5cdFx0b3BlbjogZnVuY3Rpb24oIHBhdGgsIHR5cGUsIG1vZGUgKSB7XHJcblx0XHRcdHZhciBmZCwgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5cdFx0XHRpZiggbW9kZSA9PT0gXCJyZWFkXCIgJiYgIWZzLmV4aXN0c1N5bmMoIHBhdGggKSApXHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0ZmQgPSBmcy5vcGVuU3luYyggcGF0aCwgbW9kZVswXSApO1xyXG5cdFx0XHR9IGNhdGNoKGV4KSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbiggbGVuZ3RoLCBwb3NpdGlvbiApIHtcclxuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKCBsZW5ndGggKTtcclxuXHRcdFx0XHRcdGZzLnJlYWRTeW5jKCBmZCwgYnVmZmVyLCAwLCBsZW5ndGgsIHBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHR2YXIgZW5kX29mX2ZpbGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSBidWZmZXIudG9TdHJpbmcoKTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW5ndGggJiYgZW5kX29mX2ZpbGU7IGkrKylcclxuXHRcdFx0XHRcdFx0ZW5kX29mX2ZpbGUgPSB0ZXh0W2ldID09PSBcIlxcdTAwMDBcIjtcclxuXHRcdFx0XHRcdHJldHVybiBlbmRfb2ZfZmlsZSA/IFwiZW5kX29mX3N0cmVhbVwiIDogYnVmZmVyLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRlb2Y6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdHMgPSBmcy5zdGF0U3luYyhwYXRoKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uID09PSBzdGF0c1tcInNpemVcIl07XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRwdXQ6IGZ1bmN0aW9uKCB0ZXh0LCBwb3NpdGlvbiApIHtcclxuXHRcdFx0XHRcdHZhciBidWZmZXIgPSBCdWZmZXIuZnJvbSggdGV4dCApO1xyXG5cdFx0XHRcdFx0aWYoIHBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApXHJcblx0XHRcdFx0XHRcdGZzLndyaXRlU3luYyggZmQsIGJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggcG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0ZnMud3JpdGVTeW5jKCBmZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBwb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRnZXRfYnl0ZTogZnVuY3Rpb24oIHBvc2l0aW9uICkge1xyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxKTtcclxuXHRcdFx0XHRcdFx0dmFyIGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkLCBidWZmZXIsIDAsIDEsIHBvc2l0aW9uKTtcclxuXHRcdFx0XHRcdFx0Ly92YXIgX3RleHQgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIDAsIGJ5dGVzUmVhZCk7XHJcblx0XHRcdFx0XHRcdHZhciBlbmRfb2ZfZmlsZSA9IGJ5dGVzUmVhZCA8IDE7XHJcblx0XHRcdFx0XHRcdHJldHVybiBlbmRfb2ZfZmlsZSA/IFwiZW5kX29mX3N0cmVhbVwiIDogYnVmZmVyLnJlYWRVSW50OCgwKTtcclxuXHRcdFx0XHRcdH0gY2F0Y2goZXgpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIFwiZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0cHV0X2J5dGU6IGZ1bmN0aW9uKGJ5dGUsIHBvc2l0aW9uKSB7XHJcblx0XHRcdFx0XHR2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oW2J5dGVdKTtcclxuXHRcdFx0XHRcdGlmKHBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIilcclxuXHRcdFx0XHRcdFx0ZnMud3JpdGVTeW5jKGZkLCBidWZmZXIpO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZihwb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIilcclxuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGZzLndyaXRlU3luYyhmZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBwb3NpdGlvbik7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdGZsdXNoOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0ZnMuY2xvc2VTeW5jKCBmZCApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgaW5wdXQgZm9yIE5vZGUuanNcclxuXHRub2RlanNfdXNlcl9pbnB1dCA9IHtcclxuXHRcdGJ1ZmZlcjogXCJcIixcclxuXHRcdGdldDogZnVuY3Rpb24oIGxlbmd0aCwgXyApIHtcclxuXHRcdFx0dmFyIHRleHQ7XHJcblx0XHRcdHZhciByZWFkbGluZVN5bmMgPSByZXF1aXJlKCdyZWFkbGluZS1zeW5jJyk7XHJcblx0XHRcdHdoaWxlKCBub2RlanNfdXNlcl9pbnB1dC5idWZmZXIubGVuZ3RoIDwgbGVuZ3RoIClcclxuXHRcdFx0XHRub2RlanNfdXNlcl9pbnB1dC5idWZmZXIgKz0gcmVhZGxpbmVTeW5jLnF1ZXN0aW9uKFwiXCIsIHtrZWVwV2hpdGVzcGFjZTogdHJ1ZX0pICsgXCJcXG5cIjtcclxuXHRcdFx0dGV4dCA9IG5vZGVqc191c2VyX2lucHV0LmJ1ZmZlci5zdWJzdHIoIDAsIGxlbmd0aCApO1xyXG5cdFx0XHRub2RlanNfdXNlcl9pbnB1dC5idWZmZXIgPSBub2RlanNfdXNlcl9pbnB1dC5idWZmZXIuc3Vic3RyKCBsZW5ndGggKTtcclxuXHRcdFx0cmV0dXJuIHRleHQ7XHJcblx0XHR9LFxyXG5cdFx0ZW9mOiBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFVzZXIgb3V0cHV0IGZvciBOb2RlLmpzXHJcblx0bm9kZWpzX3VzZXJfb3V0cHV0ID0ge1xyXG5cdFx0cHV0OiBmdW5jdGlvbiggdGV4dCwgXyApIHtcclxuXHRcdFx0cHJvY2Vzcy5zdGRvdXQud3JpdGUoIHRleHQgKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0Zmx1c2g6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBVc2VyIGVycm9yIGZvciBOb2RlLmpzXHJcblx0bm9kZWpzX3VzZXJfZXJyb3IgPSB7XHJcblx0XHRwdXQ6IGZ1bmN0aW9uKCB0ZXh0LCBfICkge1xyXG5cdFx0XHRwcm9jZXNzLnN0ZGVyci53cml0ZSggdGV4dCApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHRmbHVzaDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSBcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIENPTVBBVElUQklMSVRZXHJcblx0XHJcblx0dmFyIGluZGV4T2Y7XHJcblx0aWYoIUFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XHJcblx0XHRpbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGVsZW0pIHtcclxuXHRcdFx0dmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aWYoZWxlbSA9PT0gYXJyYXlbaV0pIHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgZWxlbSkge1xyXG5cdFx0XHRyZXR1cm4gYXJyYXkuaW5kZXhPZihlbGVtKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHR2YXIgcmVkdWNlID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcblx0XHRpZihhcnJheS5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR2YXIgZWxlbSA9IGFycmF5WzBdO1xyXG5cdFx0dmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuXHRcdGZvcih2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRlbGVtID0gZm4oZWxlbSwgYXJyYXlbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGVsZW07XHJcblx0fTtcclxuXHJcblx0dmFyIG1hcDtcclxuXHRpZighQXJyYXkucHJvdG90eXBlLm1hcCkge1xyXG5cdFx0bWFwID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcblx0XHRcdHZhciBhID0gW107XHJcblx0XHRcdHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGEucHVzaCggZm4oYXJyYXlbaV0pICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRtYXAgPSBmdW5jdGlvbihhcnJheSwgZm4pIHtcclxuXHRcdFx0cmV0dXJuIGFycmF5Lm1hcChmbik7XHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHR2YXIgZmlsdGVyO1xyXG5cdGlmKCFBcnJheS5wcm90b3R5cGUuZmlsdGVyKSB7XHJcblx0XHRmaWx0ZXIgPSBmdW5jdGlvbihhcnJheSwgZm4pIHtcclxuXHRcdFx0dmFyIGEgPSBbXTtcclxuXHRcdFx0dmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aWYoZm4oYXJyYXlbaV0pKVxyXG5cdFx0XHRcdFx0YS5wdXNoKCBhcnJheVtpXSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBhO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZmlsdGVyID0gZnVuY3Rpb24oYXJyYXksIGZuKSB7XHJcblx0XHRcdHJldHVybiBhcnJheS5maWx0ZXIoZm4pO1xyXG5cdFx0fTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGNvZGVQb2ludEF0O1xyXG5cdGlmKCFTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KSB7XHJcblx0XHRjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHN0ciwgaSkge1xyXG5cdFx0XHRyZXR1cm4gc3RyLmNoYXJDb2RlQXQoaSk7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb2RlUG9pbnRBdCA9IGZ1bmN0aW9uKHN0ciwgaSkge1xyXG5cdFx0XHRyZXR1cm4gc3RyLmNvZGVQb2ludEF0KGkpO1xyXG5cdFx0fTtcclxuXHR9XHJcblx0XHJcblx0dmFyIGZyb21Db2RlUG9pbnQ7XHJcblx0aWYoIVN0cmluZy5mcm9tQ29kZVBvaW50KSB7XHJcblx0XHRmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHRmcm9tQ29kZVBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHZhciBzdHJpbmdMZW5ndGg7XHJcblx0dmFyIHJlZ2V4QXN0cmFsU3ltYm9scyA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XHJcblx0aWYoQXJyYXkuZnJvbSlcclxuXHRcdHN0cmluZ0xlbmd0aCA9IGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbShzdHIpLmxlbmd0aDtcclxuXHRcdH07XHJcblx0ZWxzZVxyXG5cdFx0c3RyaW5nTGVuZ3RoID0gZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZShyZWdleEFzdHJhbFN5bWJvbHMsICdfJykubGVuZ3RoO1xyXG5cdFx0fTtcclxuXHJcblx0XHJcblx0XHJcblx0Ly8gUEFSU0VSXHJcblxyXG5cdHZhciBFUlJPUiA9IDA7XHJcblx0dmFyIFNVQ0NFU1MgPSAxO1xyXG5cclxuXHR2YXIgcmVnZXhfZXNjYXBlID0gLyhcXFxcYSl8KFxcXFxiKXwoXFxcXGQpfChcXFxcZSl8KFxcXFxmKXwoXFxcXG4pfChcXFxccil8KFxcXFxzKXwoXFxcXHQpfChcXFxcdil8XFxcXHgoWzAtOWEtZkEtRl0rKVxcXFx8XFxcXChbMC03XSspXFxcXHwoXFxcXFxcXFwpfChcXFxcJyl8KCcnKXwoXFxcXFwiKXwoXFxcXGApfChcXFxcLil8KC4pL2c7XHJcblx0dmFyIGVzY2FwZV9tYXAgPSB7XCJcXFxcYVwiOiA3LCBcIlxcXFxiXCI6IDgsIFwiXFxcXGRcIjogMTI3LCBcIlxcXFxlXCI6IDI3LCBcIlxcXFxmXCI6IDEyLCBcIlxcXFxuXCI6IDEwLCBcIlxcXFxyXCI6IDEzLCBcIlxcXFxzXCI6IDMyLCBcIlxcXFx0XCI6IDksIFwiXFxcXHZcIjogMTF9O1xyXG5cdGZ1bmN0aW9uIGVzY2FwZShzdHIpIHtcclxuXHRcdHZhciBzdGFjayA9IFtdO1xyXG5cdFx0dmFyIF9lcnJvciA9IGZhbHNlO1xyXG5cdFx0c3RyLnJlcGxhY2UocmVnZXhfZXNjYXBlLCBmdW5jdGlvbihtYXRjaCwgYSwgYiwgZCwgZSwgZiwgbiwgciwgcywgdCwgdiwgaGV4LCBvY3RhbCwgYmFjaywgc2luZ2xlLCBkc2luZ2xlLCBkb3VibGUsIGJhY2txdW90ZSwgZXJyb3IsIGNoYXIpIHtcclxuXHRcdFx0c3dpdGNoKHRydWUpIHtcclxuXHRcdFx0XHRjYXNlIGhleCAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdFx0c3RhY2sucHVzaCggcGFyc2VJbnQoaGV4LCAxNikgKTtcclxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHRcdGNhc2Ugb2N0YWwgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRcdHN0YWNrLnB1c2goIHBhcnNlSW50KG9jdGFsLCA4KSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRcdFx0Y2FzZSBiYWNrICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0Y2FzZSBzaW5nbGUgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRjYXNlIGRzaW5nbGUgIT09IHVuZGVmaW5lZDpcclxuXHRcdFx0XHRjYXNlIGRvdWJsZSAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdGNhc2UgYmFja3F1b3RlICE9PSB1bmRlZmluZWQ6XHJcblx0XHRcdFx0XHRzdGFjay5wdXNoKCBjb2RlUG9pbnRBdChtYXRjaC5zdWJzdHIoMSksMCkgKTtcclxuXHRcdFx0XHRcdHJldHVybiBcIlwiO1xyXG5cdFx0XHRcdGNhc2UgY2hhciAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdFx0c3RhY2sucHVzaCggY29kZVBvaW50QXQoY2hhciwwKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIFwiXCI7XHJcblx0XHRcdFx0Y2FzZSBlcnJvciAhPT0gdW5kZWZpbmVkOlxyXG5cdFx0XHRcdFx0X2Vycm9yID0gdHJ1ZTtcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0c3RhY2sucHVzaChlc2NhcGVfbWFwW21hdGNoXSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRpZihfZXJyb3IpXHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0cmV0dXJuIHN0YWNrO1xyXG5cdH1cclxuXHJcblx0Ly8gRXNjYXBlIGF0b21zXHJcblx0ZnVuY3Rpb24gZXNjYXBlQXRvbShzdHIsIHF1b3RlKSB7XHJcblx0XHR2YXIgYXRvbSA9ICcnO1xyXG5cdFx0aWYoIHN0ciA9PT0gXCJcXFxcXCIgKSByZXR1cm4gbnVsbDtcclxuXHRcdGlmKCBzdHIubGVuZ3RoIDwgMiApIHJldHVybiBzdHI7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvKCg/OlxcXFxcXFxcKSspfFxcXFwoWzAtN10rKVxcXFwvZywgZnVuY3Rpb24obWF0Y2gsIGcxLCBnMikge1xyXG5cdFx0XHRcdHJldHVybiBnMSB8fCBmcm9tQ29kZVBvaW50KHBhcnNlSW50KGcyLCA4KSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSgvKCg/OlxcXFxcXFxcKSspfFxcXFx4KFswLTlhLWZBLUZdKylcXFxcL2csIGZ1bmN0aW9uKG1hdGNoLCBnMSwgZzIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZzEgfHwgZnJvbUNvZGVQb2ludChwYXJzZUludChnMiwgMTYpKTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKC8oKD86XFxcXFxcXFwpKyl8XFxcXHUoWzAtOWEtZkEtRl17NH0pL2csIGZ1bmN0aW9uKG1hdGNoLCBnMSwgZzIpIHtcclxuXHRcdFx0XHRyZXR1cm4gZzEgfHwgZnJvbUNvZGVQb2ludChwYXJzZUludChnMiwgMTYpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGNhdGNoKGVycm9yKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGEgPSBzdHIuY2hhckF0KGkpO1xyXG5cdFx0XHR2YXIgYiA9IHN0ci5jaGFyQXQoaSsxKTtcclxuXHRcdFx0aWYoIGEgPT09IHF1b3RlICYmIGIgPT09IHF1b3RlICkge1xyXG5cdFx0XHRcdGkrKztcclxuXHRcdFx0XHRhdG9tICs9IHF1b3RlO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGEgPT09ICdcXFxcJyApIHtcclxuXHRcdFx0XHRpZiggWydhJywnYicsJ2YnLCduJywncicsJ3QnLCd2JyxcIidcIiwnXCInLCdcXFxcJywnXFxhJywnXFxiJywnXFxmJywnXFxuJywnXFxyJywnXFx0JywnXFx2J10uaW5kZXhPZihiKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0XHRpICs9IDE7XHJcblx0XHRcdFx0XHRzd2l0Y2goIGIgKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2EnOiBhdG9tICs9ICdcXGEnOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYic6IGF0b20gKz0gJ1xcYic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdmJzogYXRvbSArPSAnXFxmJzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ24nOiBhdG9tICs9ICdcXG4nOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAncic6IGF0b20gKz0gJ1xccic7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlICd0JzogYXRvbSArPSAnXFx0JzsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3YnOiBhdG9tICs9ICdcXHYnOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIidcIjogYXRvbSArPSBcIidcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ1wiJzogYXRvbSArPSAnXCInOyBicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnXFxcXCc6IGF0b20gKz0gJ1xcXFwnOyBicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGF0b20gKz0gYTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGF0b207XHJcblx0fVxyXG5cdFxyXG5cdC8vIFJlZG8gZXNjYXBlXHJcblx0ZnVuY3Rpb24gcmVkb0VzY2FwZShzdHIpIHtcclxuXHRcdHZhciBhdG9tID0gJyc7XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRzd2l0Y2goIHN0ci5jaGFyQXQoaSkgKSB7XHJcblx0XHRcdFx0Y2FzZSBcIidcIjogYXRvbSArPSBcIlxcXFwnXCI7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcXFwnOiBhdG9tICs9ICdcXFxcXFxcXCc7IGJyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSAnXFxhJzogYXRvbSArPSAnXFxcXGEnOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXGInOiBhdG9tICs9ICdcXFxcYic7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcZic6IGF0b20gKz0gJ1xcXFxmJzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFxuJzogYXRvbSArPSAnXFxcXG4nOyBicmVhaztcclxuXHRcdFx0XHRjYXNlICdcXHInOiBhdG9tICs9ICdcXFxccic7IGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ1xcdCc6IGF0b20gKz0gJ1xcXFx0JzsgYnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnXFx2JzogYXRvbSArPSAnXFxcXHYnOyBicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OiBhdG9tICs9IHN0ci5jaGFyQXQoaSk7IGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXRvbTtcclxuXHR9XHJcblxyXG5cdC8vIFN0cmluZyB0byBudW1cclxuXHRmdW5jdGlvbiBjb252ZXJ0TnVtKG51bSkge1xyXG5cdFx0dmFyIG4gPSBudW0uc3Vic3RyKDIpO1xyXG5cdFx0c3dpdGNoKG51bS5zdWJzdHIoMCwyKS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdGNhc2UgXCIweFwiOlxyXG5cdFx0XHRcdHJldHVybiBwYXJzZUludChuLCAxNik7XHJcblx0XHRcdGNhc2UgXCIwYlwiOlxyXG5cdFx0XHRcdHJldHVybiBwYXJzZUludChuLCAyKTtcclxuXHRcdFx0Y2FzZSBcIjBvXCI6XHJcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KG4sIDgpO1xyXG5cdFx0XHRjYXNlIFwiMCdcIjpcclxuXHRcdFx0XHRyZXR1cm4gZXNjYXBlKG4pWzBdO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHJldHVybiBwYXJzZUZsb2F0KG51bSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBJcyBncmFwaGljIHRva2VuXHJcblx0ZnVuY3Rpb24gaXNfZ3JhcGhpY190b2tlbihzdHJpbmcpIHtcclxuXHRcdHJldHVybiAvXlsjXFwkXFwmXFwqXFwrXFwtXFwuXFwvXFw6XFw8XFw9XFw+XFw/XFxAXFxeXFx+XFxcXF0rLy50ZXN0KHN0cmluZyk7XHJcblx0fVxyXG5cclxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zIGZvciB0b2tlbnNcclxuXHR2YXIgcnVsZXMgPSB7XHJcblx0XHR3aGl0ZXNwYWNlOiAvXlxccyooPzooPzolLiopfCg/OlxcL1xcKig/OlxcbnxcXHJ8LikqPyg/OlxcKlxcL3wkKSl8KD86XFxzKykpXFxzKi8sXHJcblx0XHR2YXJpYWJsZTogL14oPzpbQS1aX11bYS16QS1aMC05X10qKS8sXHJcblx0XHRhdG9tOiAvXihcXCF8LHw7fFthLXpdWzAtOWEtekEtWl9dKnxbI1xcJFxcJlxcKlxcK1xcLVxcLlxcL1xcOlxcPFxcPVxcPlxcP1xcQFxcXlxcflxcXFxdK3wnKD86KD86JycpfCg/OlxcXFxcXFxcKXwoPzpcXFxcJyl8W14nXSkqJykvLFxyXG5cdFx0bnVtYmVyOiAvXig/OjBvWzAtN10rfDB4WzAtOWEtZkEtRl0rfDBiWzAxXSt8MCcoPzonJ3xcXFxcW2FiZGVmbnJzdHZcXFxcJ1wiYF18XFxcXHg/XFxkK1xcXFx8W15cXFxcXSl8XFxkKyg/OlxcLlxcZCsoPzpbZUVdWystXT9cXGQrKT8pPykvLFxyXG5cdFx0c3RyaW5nOiAvXig/OlwiKFteXCJdfFwiXCJ8XFxcXFwiKSpcInxgKFteYF18YGB8XFxcXGApKmApLyxcclxuXHRcdGxfYnJhY2U6IC9eKD86XFxbKS8sXHJcblx0XHRyX2JyYWNlOiAvXig/OlxcXSkvLFxyXG5cdFx0bF9icmFja2V0OiAvXig/OlxceykvLFxyXG5cdFx0cl9icmFja2V0OiAvXig/OlxcfSkvLFxyXG5cdFx0YmFyOiAvXig/OlxcfCkvLFxyXG5cdFx0bF9wYXJlbjogL14oPzpcXCgpLyxcclxuXHRcdHJfcGFyZW46IC9eKD86XFwpKS9cclxuXHR9O1xyXG5cclxuXHQvLyBSZXBsYWNlIGNoYXJzIG9mIGNoYXJfY29udmVyc2lvbiBzZXNzaW9uXHJcblx0ZnVuY3Rpb24gcmVwbGFjZSggdGhyZWFkLCB0ZXh0ICkge1xyXG5cdFx0aWYoIHRocmVhZC5nZXRfZmxhZyggXCJjaGFyX2NvbnZlcnNpb25cIiApLmlkID09PSBcIm9uXCIgKSB7XHJcblx0XHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoLy4vZywgZnVuY3Rpb24oY2hhcikge1xyXG5cdFx0XHRcdHJldHVybiB0aHJlYWQuZ2V0X2NoYXJfY29udmVyc2lvbiggY2hhciApO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0ZXh0O1xyXG5cdH1cclxuXHJcblx0Ly8gVG9rZW5pemUgc3RyaW5nc1xyXG5cdGZ1bmN0aW9uIFRva2VuaXplcih0aHJlYWQpIHtcclxuXHRcdHRoaXMudGhyZWFkID0gdGhyZWFkO1xyXG5cdFx0dGhpcy50ZXh0ID0gXCJcIjsgLy8gQ3VycmVudCB0ZXh0IHRvIGJlIGFuYWxpemVkXHJcblx0XHR0aGlzLnRva2VucyA9IFtdOyAvLyBDb25zdW1lZCB0b2tlbnNcclxuXHR9XHJcblxyXG5cdFRva2VuaXplci5wcm90b3R5cGUuc2V0X2xhc3RfdG9rZW5zID0gZnVuY3Rpb24odG9rZW5zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50b2tlbnMgPSB0b2tlbnM7XHJcblx0fTtcclxuXHJcblx0VG9rZW5pemVyLnByb3RvdHlwZS5uZXdfdGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcclxuXHRcdHRoaXMudGV4dCA9IHRleHQ7XHJcblx0XHR0aGlzLnRva2VucyA9IFtdO1xyXG5cdH07XHJcblxyXG5cdFRva2VuaXplci5wcm90b3R5cGUuZ2V0X3Rva2VucyA9IGZ1bmN0aW9uKGluaXQpIHtcclxuXHRcdHZhciB0ZXh0O1xyXG5cdFx0dmFyIGxlbiA9IDA7IC8vIFRvdGFsIGxlbmd0aCByZXNwZWN0IHRvIHRleHRcclxuXHRcdHZhciBsaW5lID0gMDtcclxuXHRcdHZhciBzdGFydCA9IDA7XHJcblx0XHR2YXIgdG9rZW5zID0gW107XHJcblx0XHR2YXIgbGFzdF9pc19ibGFuaztcclxuXHJcblx0XHRpZihpbml0KSB7XHJcblx0XHRcdHZhciB0b2tlbiA9IHRoaXMudG9rZW5zW2luaXQtMV07XHJcblx0XHRcdGxlbiA9IHRva2VuLmxlbjtcclxuXHRcdFx0dGV4dCA9IHJlcGxhY2UoIHRoaXMudGhyZWFkLCB0aGlzLnRleHQuc3Vic3RyKHRva2VuLmxlbikgKTtcclxuXHRcdFx0bGluZSA9IHRva2VuLmxpbmU7XHJcblx0XHRcdHN0YXJ0ID0gdG9rZW4uc3RhcnQ7XHJcblx0XHR9XHJcblx0XHRlbHNlXHJcblx0XHRcdHRleHQgPSB0aGlzLnRleHQ7XHJcblxyXG5cclxuXHRcdC8vIElmIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgYW5hbGl6ZWQsIHJldHVybiBudWxsXHJcblx0XHRpZigvXlxccyokLy50ZXN0KHRleHQpKVxyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHJcblx0XHR3aGlsZSh0ZXh0ICE9PSBcIlwiKSB7XHJcblx0XHRcdHZhciBtYXRjaGVzID0gW107XHJcblx0XHRcdGxhc3RfaXNfYmxhbmsgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmKC9eXFxuLy5leGVjKHRleHQpICE9PSBudWxsKSB7XHJcblx0XHRcdFx0bGluZSsrO1xyXG5cdFx0XHRcdHN0YXJ0ID0gMDtcclxuXHRcdFx0XHRsZW4rKztcclxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4vLCBcIlwiKTtcclxuXHRcdFx0XHRsYXN0X2lzX2JsYW5rID0gdHJ1ZTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yKHZhciBydWxlIGluIHJ1bGVzKSB7XHJcblx0XHRcdFx0aWYocnVsZXMuaGFzT3duUHJvcGVydHkocnVsZSkpIHtcclxuXHRcdFx0XHRcdHZhciBtYXRjaHMgPSBydWxlc1tydWxlXS5leGVjKCB0ZXh0ICk7XHJcblx0XHRcdFx0XHRpZihtYXRjaHMpIHtcclxuXHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hzWzBdLFxyXG5cdFx0XHRcdFx0XHRcdG5hbWU6IHJ1bGUsXHJcblx0XHRcdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hzXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTGV4aWNhbCBlcnJvclxyXG5cdFx0XHRpZighbWF0Y2hlcy5sZW5ndGgpXHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0X2xhc3RfdG9rZW5zKCBbeyB2YWx1ZTogdGV4dCwgbWF0Y2hlczogW10sIG5hbWU6IFwibGV4aWNhbFwiLCBsaW5lOiBsaW5lLCBzdGFydDogc3RhcnQgfV0gKTtcclxuXHJcblx0XHRcdHZhciB0b2tlbiA9IHJlZHVjZSggbWF0Y2hlcywgZnVuY3Rpb24oYSwgYikge1xyXG5cdFx0XHRcdHJldHVybiBhLnZhbHVlLmxlbmd0aCA+PSBiLnZhbHVlLmxlbmd0aCA/IGEgOiBiO1xyXG5cdFx0XHR9ICk7XHJcblxyXG5cdFx0XHR0b2tlbi5zdGFydCA9IHN0YXJ0O1xyXG5cdFx0XHR0b2tlbi5saW5lID0gbGluZTtcclxuXHJcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UodG9rZW4udmFsdWUsIFwiXCIpO1xyXG5cdFx0XHRzdGFydCArPSB0b2tlbi52YWx1ZS5sZW5ndGg7XHJcblx0XHRcdGxlbiArPSB0b2tlbi52YWx1ZS5sZW5ndGg7XHJcblxyXG5cdFx0XHR2YXIgbmwgPSAodG9rZW4udmFsdWUubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xyXG5cdFx0XHRsaW5lICs9IG5sO1xyXG5cdFx0XHRpZihubCA+IDApIFxyXG5cdFx0XHRcdHN0YXJ0ID0gdG9rZW4udmFsdWUubGVuZ3RoIC0gdG9rZW4udmFsdWUubGFzdEluZGV4T2YoXCJcXG5cIikgLSAxO1xyXG5cdFx0XHR0b2tlbi5saW5lX2NvdW50ID0gbGluZTtcclxuXHRcdFx0dG9rZW4ubGluZV9wb3NpdGlvbiA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0c3dpdGNoKHRva2VuLm5hbWUpIHtcclxuXHRcdFx0XHRjYXNlIFwiYXRvbVwiOlxyXG5cdFx0XHRcdFx0dG9rZW4ucmF3ID0gdG9rZW4udmFsdWU7XHJcblx0XHRcdFx0XHRpZih0b2tlbi52YWx1ZS5jaGFyQXQoMCkgPT09IFwiJ1wiKSB7XHJcblx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gZXNjYXBlQXRvbSggdG9rZW4udmFsdWUuc3Vic3RyaW5nKDEsIHRva2VuLnZhbHVlLmxlbmd0aCAtIDEpLCBcIidcIiApO1xyXG5cdFx0XHRcdFx0XHRpZiggdG9rZW4udmFsdWUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdFx0dG9rZW4ubmFtZSA9IFwibGV4aWNhbFwiO1xyXG5cdFx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdG9rZW4ucmF3O1xyXG5cdFx0XHRcdFx0XHRcdHRva2VuLmVycm9yID0gXCJ1bmtub3duX2VzY2FwZV9zZXF1ZW5jZVwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdFx0XHR2YXIgc3Vic3RyID0gdG9rZW4udmFsdWUuc3Vic3RyaW5nKDAsMik7XHJcblx0XHRcdFx0XHR0b2tlbi5yYXcgPSB0b2tlbi52YWx1ZTtcclxuXHRcdFx0XHRcdHRva2VuLmZsb2F0ID0gc3Vic3RyICE9PSBcIjB4XCIgJiYgc3Vic3RyICE9PSBcIjAnXCIgJiYgdG9rZW4udmFsdWUubWF0Y2goL1suZUVdLykgIT09IG51bGw7XHJcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IGNvbnZlcnROdW0oIHRva2VuLnZhbHVlICk7XHJcblx0XHRcdFx0XHR0b2tlbi5ibGFuayA9IGxhc3RfaXNfYmxhbms7XHJcblx0XHRcdFx0XHRpZighdG9rZW4uZmxvYXQgJiYgcGwuZmxhZy5ib3VuZGVkLnZhbHVlLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIiAmJiB0b2tlbi52YWx1ZSA+IHBsLmZsYWcubWF4X2ludGVnZXIudmFsdWUudmFsdWUpIHtcclxuXHRcdFx0XHRcdFx0dG9rZW4ubmFtZSA9IFwibGV4aWNhbFwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IHRva2VuLnJhdztcclxuXHRcdFx0XHRcdFx0dG9rZW4uZXJyb3IgPSBcImludF9vdmVyZmxvd1wiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBcInN0cmluZ1wiOlxyXG5cdFx0XHRcdFx0dmFyIGRlbCA9IHRva2VuLnZhbHVlLmNoYXJBdCgwKTtcclxuXHRcdFx0XHRcdHRva2VuLnJhdyA9IHRva2VuLnZhbHVlO1xyXG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBlc2NhcGVBdG9tKCB0b2tlbi52YWx1ZS5zdWJzdHJpbmcoMSwgdG9rZW4udmFsdWUubGVuZ3RoIC0gMSksIGRlbCApO1xyXG5cdFx0XHRcdFx0aWYoIHRva2VuLnZhbHVlID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5uYW1lID0gXCJsZXhpY2FsXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gdG9rZW4ucmF3O1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5lcnJvciA9IFwidW5rbm93bl9lc2NhcGVfc2VxdWVuY2VcIlxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBcIndoaXRlc3BhY2VcIjpcclxuXHRcdFx0XHRcdHZhciBsYXN0ID0gdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV07XHJcblx0XHRcdFx0XHRpZihsYXN0KSBsYXN0LnNwYWNlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGxhc3RfaXNfYmxhbmsgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0Y2FzZSBcInJfYnJhY2tldFwiOlxyXG5cdFx0XHRcdFx0aWYoIHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdLm5hbWUgPT09IFwibF9icmFja2V0XCIgKSB7XHJcblx0XHRcdFx0XHRcdHRva2VuID0gdG9rZW5zLnBvcCgpO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5uYW1lID0gXCJhdG9tXCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnZhbHVlID0gXCJ7fVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5yYXcgPSBcInt9XCI7XHJcblx0XHRcdFx0XHRcdHRva2VuLnNwYWNlID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwicl9icmFjZVwiOlxyXG5cdFx0XHRcdFx0aWYoIHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoLTFdLm5hbWUgPT09IFwibF9icmFjZVwiICkge1xyXG5cdFx0XHRcdFx0XHR0b2tlbiA9IHRva2Vucy5wb3AoKTtcclxuXHRcdFx0XHRcdFx0dG9rZW4ubmFtZSA9IFwiYXRvbVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IFwiW11cIjtcclxuXHRcdFx0XHRcdFx0dG9rZW4ucmF3ID0gXCJbXVwiO1xyXG5cdFx0XHRcdFx0XHR0b2tlbi5zcGFjZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0dG9rZW4ubGVuID0gbGVuO1xyXG5cdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcclxuXHRcdFx0bGFzdF9pc19ibGFuayA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ID0gdGhpcy5zZXRfbGFzdF90b2tlbnMoIHRva2VucyApO1xyXG5cdFx0cmV0dXJuIHQubGVuZ3RoID09PSAwID8gbnVsbCA6IHQ7XHJcblx0fTtcclxuXHJcblx0Ly8gUGFyc2UgYW4gZXhwcmVzc2lvblxyXG5cdGZ1bmN0aW9uIHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQsIHByaW9yaXR5LCB0b3BsZXZlbCkge1xyXG5cdFx0aWYoIXRva2Vuc1tzdGFydF0pIHJldHVybiB7dHlwZTogRVJST1IsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0LTFdLCBcImV4cHJlc3Npb24gZXhwZWN0ZWRcIiwgdHJ1ZSl9O1xyXG5cdFx0dmFyIGVycm9yO1xyXG5cclxuXHRcdGlmKHByaW9yaXR5ID09PSBcIjBcIikge1xyXG5cdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbc3RhcnRdO1xyXG5cdFx0XHRzd2l0Y2godG9rZW4ubmFtZSkge1xyXG5cdFx0XHRcdGNhc2UgXCJudW1iZXJcIjpcclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCsxLCB2YWx1ZTogbmV3IHBsLnR5cGUuTnVtKHRva2VuLnZhbHVlLCB0b2tlbi5mbG9hdCl9O1xyXG5cdFx0XHRcdGNhc2UgXCJ2YXJpYWJsZVwiOlxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0KzEsIHZhbHVlOiBuZXcgcGwudHlwZS5WYXIodG9rZW4udmFsdWUpfTtcclxuXHRcdFx0XHRjYXNlIFwic3RyaW5nXCI6XHJcblx0XHRcdFx0XHR2YXIgc3RyO1xyXG5cdFx0XHRcdFx0c3dpdGNoKCB0aHJlYWQuZ2V0X2ZsYWcoIFwiZG91YmxlX3F1b3Rlc1wiICkuaWQgKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJhdG9tXCI6O1xyXG5cdFx0XHRcdFx0XHRcdHN0ciA9IG5ldyBUZXJtKCB0b2tlbi52YWx1ZSwgW10gKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcImNvZGVzXCI6XHJcblx0XHRcdFx0XHRcdFx0c3RyID0gbmV3IFRlcm0oIFwiW11cIiwgW10gKTtcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSB0b2tlbi52YWx1ZS5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RyID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IHBsLnR5cGUuTnVtKCBjb2RlUG9pbnRBdCh0b2tlbi52YWx1ZSxpKSwgZmFsc2UgKSwgc3RyXSApO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwiY2hhcnNcIjpcclxuXHRcdFx0XHRcdFx0XHRzdHIgPSBuZXcgVGVybSggXCJbXVwiLCBbXSApO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IHRva2VuLnZhbHVlLmxlbmd0aC0xOyBpID49IDA7IGktLSApXHJcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgcGwudHlwZS5UZXJtKCB0b2tlbi52YWx1ZS5jaGFyQXQoaSksIFtdICksIHN0cl0gKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCsxLCB2YWx1ZTogc3RyfTtcclxuXHRcdFx0XHRjYXNlIFwibF9wYXJlblwiOlxyXG5cdFx0XHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KzEsIHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRpZihleHByLnR5cGUgIT09IFNVQ0NFU1MpIHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0aWYodG9rZW5zW2V4cHIubGVuXSAmJiB0b2tlbnNbZXhwci5sZW5dLm5hbWUgPT09IFwicl9wYXJlblwiKSB7XHJcblx0XHRcdFx0XHRcdGV4cHIubGVuKys7XHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbZXhwci5sZW5dID8gdG9rZW5zW2V4cHIubGVuXSA6IHRva2Vuc1tleHByLmxlbi0xXSwgXCIpIG9yIG9wZXJhdG9yIGV4cGVjdGVkXCIsICF0b2tlbnNbZXhwci5sZW5dKX1cclxuXHRcdFx0XHRjYXNlIFwibF9icmFja2V0XCI6XHJcblx0XHRcdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQrMSwgdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmKGV4cHIudHlwZSAhPT0gU1VDQ0VTUykgcmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRpZih0b2tlbnNbZXhwci5sZW5dICYmIHRva2Vuc1tleHByLmxlbl0ubmFtZSA9PT0gXCJyX2JyYWNrZXRcIikge1xyXG5cdFx0XHRcdFx0XHRleHByLmxlbisrO1xyXG5cdFx0XHRcdFx0XHRleHByLnZhbHVlID0gbmV3IFRlcm0oIFwie31cIiwgW2V4cHIudmFsdWVdICk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbZXhwci5sZW5dID8gdG9rZW5zW2V4cHIubGVuXSA6IHRva2Vuc1tleHByLmxlbi0xXSwgXCJ9IG9yIG9wZXJhdG9yIGV4cGVjdGVkXCIsICF0b2tlbnNbZXhwci5sZW5dKX1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBDb21wb3VuZCB0ZXJtXHJcblx0XHRcdHZhciByZXN1bHQgPSBwYXJzZVRlcm0odGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCB0b3BsZXZlbCk7XHJcblx0XHRcdGlmKHJlc3VsdC50eXBlID09PSBTVUNDRVNTIHx8IHJlc3VsdC5kZXJpdmVkKVxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdC8vIExpc3RcclxuXHRcdFx0cmVzdWx0ID0gcGFyc2VMaXN0KHRocmVhZCwgdG9rZW5zLCBzdGFydCk7XHJcblx0XHRcdGlmKHJlc3VsdC50eXBlID09PSBTVUNDRVNTIHx8IHJlc3VsdC5kZXJpdmVkKVxyXG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XHJcblx0XHRcdC8vIFVuZXhwZWN0ZWRcclxuXHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogZmFsc2UsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0XSwgdG9rZW4uZXJyb3IgfHwgXCJ1bmV4cGVjdGVkIHRva2VuXCIpfTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWF4X3ByaW9yaXR5ID0gdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpO1xyXG5cdFx0dmFyIG5leHRfcHJpb3JpdHkgPSB0aHJlYWQuX19nZXRfbmV4dF9wcmlvcml0eShwcmlvcml0eSk7XHJcblx0XHR2YXIgYXV4X3N0YXJ0ID0gc3RhcnQ7XHJcblx0XHRcclxuXHRcdC8vIFByZWZpeCBvcGVyYXRvcnNcclxuXHRcdGlmKHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0KzFdICYmICh0b2tlbnNbc3RhcnRdLnNwYWNlIHx8IHRva2Vuc1tzdGFydCsxXS5uYW1lICE9PSBcImxfcGFyZW5cIikpIHtcclxuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW3N0YXJ0KytdO1xyXG5cdFx0XHR2YXIgY2xhc3NlcyA9IHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCB0b2tlbi52YWx1ZSk7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBBc3NvY2lhdGl2ZSBwcmVmaXggb3BlcmF0b3JcclxuXHRcdFx0aWYoY2xhc3NlcyAmJiBjbGFzc2VzLmluZGV4T2YoXCJmeVwiKSA+IC0xKSB7XHJcblx0XHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCBwcmlvcml0eSwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRcdGlmKGV4cHIudHlwZSAhPT0gRVJST1IpIHtcclxuXHRcdFx0XHRcdGlmKCB0b2tlbi52YWx1ZSA9PT0gXCItXCIgJiYgIXRva2VuLnNwYWNlICYmIHBsLnR5cGUuaXNfbnVtYmVyKCBleHByLnZhbHVlICkgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLk51bSgtZXhwci52YWx1ZS52YWx1ZSwgZXhwci52YWx1ZS5pc19mbG9hdCksXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBleHByLmxlbixcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogZXhwci5sZW4sXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRlcnJvciA9IGV4cHI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHQvLyBOb24tYXNzb2NpYXRpdmUgcHJlZml4IG9wZXJhdG9yXHJcblx0XHRcdH0gZWxzZSBpZihjbGFzc2VzICYmIGNsYXNzZXMuaW5kZXhPZihcImZ4XCIpID4gLTEpIHtcclxuXHRcdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQsIG5leHRfcHJpb3JpdHksIHRvcGxldmVsKTtcclxuXHRcdFx0XHRpZihleHByLnR5cGUgIT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0bGVuOiBleHByLmxlbixcclxuXHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZXJyb3IgPSBleHByO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXJ0ID0gYXV4X3N0YXJ0O1xyXG5cdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0LCBuZXh0X3ByaW9yaXR5LCB0b3BsZXZlbCk7XHJcblx0XHRpZihleHByLnR5cGUgPT09IFNVQ0NFU1MpIHtcclxuXHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0dmFyIHRva2VuID0gdG9rZW5zW3N0YXJ0XTtcclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiAoXHJcblx0XHRcdFx0dG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImF0b21cIiAmJiB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgdG9rZW4udmFsdWUpIHx8XHJcblx0XHRcdFx0dG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImJhclwiICYmIHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCBcInxcIilcclxuXHRcdFx0KSApIHtcclxuXHRcdFx0XHR2YXIgbmV4dF9wcmlvcml0eV9sdCA9IG5leHRfcHJpb3JpdHk7XHJcblx0XHRcdFx0dmFyIG5leHRfcHJpb3JpdHlfZXEgPSBwcmlvcml0eTtcclxuXHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRocmVhZC5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzKHByaW9yaXR5LCB0b2tlbi52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGlmKGNsYXNzZXMuaW5kZXhPZihcInhmXCIpID4gLTEpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZV0pLFxyXG5cdFx0XHRcdFx0XHRsZW46ICsrZXhwci5sZW4sXHJcblx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fSBlbHNlIGlmKGNsYXNzZXMuaW5kZXhPZihcInhmeFwiKSA+IC0xKSB7XHJcblx0XHRcdFx0XHR2YXIgZXhwcjIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0ICsgMSwgbmV4dF9wcmlvcml0eV9sdCwgdG9wbGV2ZWwpO1xyXG5cdFx0XHRcdFx0aWYoZXhwcjIudHlwZSA9PT0gU1VDQ0VTUykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKHRva2VuLnZhbHVlLCBbZXhwci52YWx1ZSwgZXhwcjIudmFsdWVdKSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IGV4cHIyLmxlbixcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRleHByMi5kZXJpdmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHIyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZihjbGFzc2VzLmluZGV4T2YoXCJ4ZnlcIikgPiAtMSkge1xyXG5cdFx0XHRcdFx0dmFyIGV4cHIyID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCArIDEsIG5leHRfcHJpb3JpdHlfZXEsIHRvcGxldmVsKTtcclxuXHRcdFx0XHRcdGlmKGV4cHIyLnR5cGUgPT09IFNVQ0NFU1MpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWUsIGV4cHIyLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBleHByMi5sZW4sXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZXhwcjIuZGVyaXZlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByMjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYoZXhwci50eXBlICE9PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0d2hpbGUodHJ1ZSkge1xyXG5cdFx0XHRcdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHRcdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbc3RhcnRdO1xyXG5cdFx0XHRcdFx0XHRpZih0b2tlbiAmJiB0b2tlbi5uYW1lID09PSBcImF0b21cIiAmJiB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgdG9rZW4udmFsdWUpKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNsYXNzZXMgPSB0aHJlYWQuX19sb29rdXBfb3BlcmF0b3JfY2xhc3Nlcyhwcmlvcml0eSwgdG9rZW4udmFsdWUpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBjbGFzc2VzLmluZGV4T2YoXCJ5ZlwiKSA+IC0xICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZXhwciA9IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFsdWU6IG5ldyBwbC50eXBlLlRlcm0odG9rZW4udmFsdWUsIFtleHByLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGxlbjogKytzdGFydCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoIGNsYXNzZXMuaW5kZXhPZihcInlmeFwiKSA+IC0xICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGV4cHIyID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCArK3N0YXJ0LCBuZXh0X3ByaW9yaXR5X2x0LCB0b3BsZXZlbCk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihleHByMi50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRleHByMi5kZXJpdmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4cHIyO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBleHByMi5sZW47XHJcblx0XHRcdFx0XHRcdFx0XHRleHByID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IHBsLnR5cGUuVGVybSh0b2tlbi52YWx1ZSwgW2V4cHIudmFsdWUsIGV4cHIyLnZhbHVlXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdGxlbjogc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1NcclxuXHRcdFx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHsgYnJlYWs7IH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHsgYnJlYWs7IH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXJyb3IgPSB7dHlwZTogRVJST1IsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW2V4cHIubGVuLTFdLCBcIm9wZXJhdG9yIGV4cGVjdGVkXCIpfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBleHByO1xyXG5cdH1cclxuXHJcblx0Ly8gUGFyc2UgYSBjb21wb3VuZCB0ZXJtXHJcblx0ZnVuY3Rpb24gcGFyc2VUZXJtKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgdG9wbGV2ZWwpIHtcclxuXHRcdGlmKCF0b2tlbnNbc3RhcnRdIHx8ICh0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydF0ucmF3ID09PSBcIi5cIiAmJiAhdG9wbGV2ZWwgJiYgKHRva2Vuc1tzdGFydF0uc3BhY2UgfHwgIXRva2Vuc1tzdGFydCsxXSB8fCB0b2tlbnNbc3RhcnQrMV0ubmFtZSAhPT0gXCJsX3BhcmVuXCIpKSlcclxuXHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogZmFsc2UsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0LTFdLCBcInVuZm91bmRlZCB0b2tlblwiKX07XHJcblx0XHR2YXIgYXRvbSA9IHRva2Vuc1tzdGFydF07XHJcblx0XHR2YXIgZXhwcnMgPSBbXTtcclxuXHRcdGlmKHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0XS5yYXcgIT09IFwiLFwiKSB7XHJcblx0XHRcdHN0YXJ0Kys7XHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydC0xXS5zcGFjZSkgcmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0LCB2YWx1ZTogbmV3IHBsLnR5cGUuVGVybShhdG9tLnZhbHVlLCBleHBycyl9O1xyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJsX3BhcmVuXCIpIHtcclxuXHRcdFx0XHRpZih0b2tlbnNbc3RhcnQrMV0gJiYgdG9rZW5zW3N0YXJ0KzFdLm5hbWUgPT09IFwicl9wYXJlblwiKSBcclxuXHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0KzFdLCBcImFyZ3VtZW50IGV4cGVjdGVkXCIpfTtcclxuXHRcdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2VucywgKytzdGFydCwgXCI5OTlcIiwgdHJ1ZSk7XHJcblx0XHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0aWYoIGV4cHIuZGVyaXZlZCApXHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0gPyB0b2tlbnNbc3RhcnRdIDogdG9rZW5zW3N0YXJ0LTFdLCBcImFyZ3VtZW50IGV4cGVjdGVkXCIsICF0b2tlbnNbc3RhcnRdKX07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGV4cHJzLnB1c2goZXhwci52YWx1ZSk7XHJcblx0XHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0XHR3aGlsZSh0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0XS52YWx1ZSA9PT0gXCIsXCIpIHtcclxuXHRcdFx0XHRcdGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KzEsIFwiOTk5XCIsIHRydWUpO1xyXG5cdFx0XHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0XHRpZiggZXhwci5kZXJpdmVkIClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0KzFdID8gdG9rZW5zW3N0YXJ0KzFdIDogdG9rZW5zW3N0YXJ0XSwgXCJhcmd1bWVudCBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0KzFdKX07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRleHBycy5wdXNoKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBleHByLmxlbjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwicl9wYXJlblwiKSBzdGFydCsrO1xyXG5cdFx0XHRcdGVsc2UgcmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdID8gdG9rZW5zW3N0YXJ0XSA6IHRva2Vuc1tzdGFydC0xXSwgXCIsIG9yICkgZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydF0pfTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4ge3R5cGU6IFNVQ0NFU1MsIGxlbjogc3RhcnQsIHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKGF0b20udmFsdWUsIGV4cHJzKX07XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiBmYWxzZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdLCBcInRlcm0gZXhwZWN0ZWRcIil9O1xyXG5cdH1cclxuXHJcblx0Ly8gUGFyc2UgYSBsaXN0XHJcblx0ZnVuY3Rpb24gcGFyc2VMaXN0KHRocmVhZCwgdG9rZW5zLCBzdGFydCkge1xyXG5cdFx0aWYoIXRva2Vuc1tzdGFydF0pIFxyXG5cdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiBmYWxzZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnQtMV0sIFwiWyBleHBlY3RlZFwiKX07XHJcblx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJsX2JyYWNlXCIpIHtcclxuXHRcdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsICsrc3RhcnQsIFwiOTk5XCIsIHRydWUpO1xyXG5cdFx0XHR2YXIgZXhwcnMgPSBbZXhwci52YWx1ZV07XHJcblx0XHRcdHZhciBjb25zID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcInJfYnJhY2VcIikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHt0eXBlOiBTVUNDRVNTLCBsZW46IHN0YXJ0KzEsIHZhbHVlOiBuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHt0eXBlOiBFUlJPUiwgZGVyaXZlZDogdHJ1ZSwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdLCBcIl0gZXhwZWN0ZWRcIil9O1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cclxuXHRcdFx0d2hpbGUodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tzdGFydF0udmFsdWUgPT09IFwiLFwiKSB7XHJcblx0XHRcdFx0ZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2Vucywgc3RhcnQrMSwgXCI5OTlcIiwgdHJ1ZSk7XHJcblx0XHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdFx0aWYoIGV4cHIuZGVyaXZlZCApXHJcblx0XHRcdFx0XHRcdHJldHVybiBleHByO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydCsxXSA/IHRva2Vuc1tzdGFydCsxXSA6IHRva2Vuc1tzdGFydF0sIFwiYXJndW1lbnQgZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydCsxXSl9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRleHBycy5wdXNoKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGJhciA9IGZhbHNlXHJcblx0XHRcdGlmKHRva2Vuc1tzdGFydF0gJiYgdG9rZW5zW3N0YXJ0XS5uYW1lID09PSBcImJhclwiKSB7XHJcblx0XHRcdFx0YmFyID0gdHJ1ZTtcclxuXHRcdFx0XHRleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCsxLCBcIjk5OVwiLCB0cnVlKTtcclxuXHRcdFx0XHRpZihleHByLnR5cGUgPT09IEVSUk9SKSB7XHJcblx0XHRcdFx0XHRpZiggZXhwci5kZXJpdmVkIClcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGV4cHI7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IHRydWUsIHZhbHVlOiBwbC5lcnJvci5zeW50YXgodG9rZW5zW3N0YXJ0KzFdID8gdG9rZW5zW3N0YXJ0KzFdIDogdG9rZW5zW3N0YXJ0XSwgXCJhcmd1bWVudCBleHBlY3RlZFwiLCAhdG9rZW5zW3N0YXJ0KzFdKX07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNvbnMgPSBleHByLnZhbHVlO1xyXG5cdFx0XHRcdHN0YXJ0ID0gZXhwci5sZW47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodG9rZW5zW3N0YXJ0XSAmJiB0b2tlbnNbc3RhcnRdLm5hbWUgPT09IFwicl9icmFjZVwiKVxyXG5cdFx0XHRcdHJldHVybiB7dHlwZTogU1VDQ0VTUywgbGVuOiBzdGFydCsxLCB2YWx1ZTogYXJyYXlUb0xpc3QoZXhwcnMsIGNvbnMpIH07XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXR1cm4ge3R5cGU6IEVSUk9SLCBkZXJpdmVkOiB0cnVlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0gPyB0b2tlbnNbc3RhcnRdIDogdG9rZW5zW3N0YXJ0LTFdLCBiYXIgPyBcIl0gZXhwZWN0ZWRcIiA6IFwiLCBvciB8IG9yIF0gZXhwZWN0ZWRcIiwgIXRva2Vuc1tzdGFydF0pfTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB7dHlwZTogRVJST1IsIGRlcml2ZWQ6IGZhbHNlLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0sIFwibGlzdCBleHBlY3RlZFwiKX07XHJcblx0fVxyXG5cclxuXHQvLyBQYXJzZSBhIHJ1bGVcclxuXHRmdW5jdGlvbiBwYXJzZVJ1bGUodGhyZWFkLCB0b2tlbnMsIHN0YXJ0KSB7XHJcblx0XHR2YXIgbGluZSA9IHRva2Vuc1tzdGFydF0ubGluZTtcclxuXHRcdHZhciBleHByID0gcGFyc2VFeHByKHRocmVhZCwgdG9rZW5zLCBzdGFydCwgdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpLCBmYWxzZSk7XHJcblx0XHR2YXIgcnVsZSA9IG51bGw7XHJcblx0XHR2YXIgb2JqO1xyXG5cdFx0aWYoZXhwci50eXBlICE9PSBFUlJPUikge1xyXG5cdFx0XHRzdGFydCA9IGV4cHIubGVuO1xyXG5cdFx0XHRpZih0b2tlbnNbc3RhcnRdICYmIHRva2Vuc1tzdGFydF0ubmFtZSA9PT0gXCJhdG9tXCIgJiYgdG9rZW5zW3N0YXJ0XS5yYXcgPT09IFwiLlwiKSB7XHJcblx0XHRcdFx0c3RhcnQrKztcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKGV4cHIudmFsdWUpICkge1xyXG5cdFx0XHRcdFx0aWYoZXhwci52YWx1ZS5pbmRpY2F0b3IgPT09IFwiOi0vMlwiKSB7XHJcblx0XHRcdFx0XHRcdHJ1bGUgPSBuZXcgcGwudHlwZS5SdWxlKGV4cHIudmFsdWUuYXJnc1swXSwgYm9keV9jb252ZXJzaW9uKGV4cHIudmFsdWUuYXJnc1sxXSkpO1xyXG5cdFx0XHRcdFx0XHRvYmogPSB7XHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHJ1bGUsXHJcblx0XHRcdFx0XHRcdFx0bGVuOiBzdGFydCxcclxuXHRcdFx0XHRcdFx0XHR0eXBlOiBTVUNDRVNTXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoZXhwci52YWx1ZS5pbmRpY2F0b3IgPT09IFwiLS0+LzJcIikge1xyXG5cdFx0XHRcdFx0XHRydWxlID0gbmV3IHBsLnR5cGUuUnVsZShleHByLnZhbHVlLmFyZ3NbMF0sIGJvZHlfY29udmVyc2lvbihleHByLnZhbHVlLmFyZ3NbMV0pKTtcclxuXHRcdFx0XHRcdFx0cnVsZSA9IHJ1bGVfdG9fZGNnKHJ1bGUsIHRocmVhZCk7XHJcblx0XHRcdFx0XHRcdHJ1bGUuYm9keSA9IGJvZHlfY29udmVyc2lvbihydWxlLmJvZHkpO1xyXG5cdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc19ydWxlKHJ1bGUpKVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogcnVsZSxcclxuXHRcdFx0XHRcdFx0XHRcdGxlbjogc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBFUlJPUlxyXG5cdFx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdG9iaiA9IHtcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogcnVsZSxcclxuXHRcdFx0XHRcdFx0XHRsZW46IHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IHBsLnR5cGUuaXNfcnVsZSggcnVsZSApID8gU1VDQ0VTUyA6IEVSUk9SXHJcblx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRydWxlID0gbmV3IHBsLnR5cGUuUnVsZShleHByLnZhbHVlLCBudWxsKTtcclxuXHRcdFx0XHRcdFx0b2JqID0ge1xyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBydWxlLFxyXG5cdFx0XHRcdFx0XHRcdGxlbjogc3RhcnQsXHJcblx0XHRcdFx0XHRcdFx0dHlwZTogU1VDQ0VTU1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIHJ1bGUgKSB7XHJcblx0XHRcdFx0XHRcdHZhciBzaW5nbGV0b24gPSBydWxlLnNpbmdsZXRvbl92YXJpYWJsZXMoKTtcclxuXHRcdFx0XHRcdFx0aWYoIHNpbmdsZXRvbi5sZW5ndGggPiAwIClcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwud2FybmluZy5zaW5nbGV0b24oIHNpbmdsZXRvbiwgcnVsZS5oZWFkLmluZGljYXRvciwgbGluZSApICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4geyB0eXBlOiBFUlJPUiwgdmFsdWU6IHBsLmVycm9yLnN5bnRheCh0b2tlbnNbc3RhcnRdLCBcImNhbGxhYmxlIGV4cGVjdGVkXCIpIH07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiB7IHR5cGU6IEVSUk9SLCB2YWx1ZTogcGwuZXJyb3Iuc3ludGF4KHRva2Vuc1tzdGFydF0gPyB0b2tlbnNbc3RhcnRdIDogdG9rZW5zW3N0YXJ0LTFdLCBcIi4gb3Igb3BlcmF0b3IgZXhwZWN0ZWRcIikgfTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV4cHI7XHJcblx0fVxyXG5cclxuXHQvLyBQYXJzZSBhIHByb2dyYW1cclxuXHRmdW5jdGlvbiBwYXJzZVByb2dyYW0odGhyZWFkLCBzdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBvcHRzID0ge307XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcclxuXHRcdG9wdHMuc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcyA/IG9wdGlvbnMuc3VjY2VzcyA6IGZ1bmN0aW9uKCl7fTtcclxuXHRcdG9wdHMuZXJyb3IgPSBvcHRpb25zLmVycm9yID8gb3B0aW9ucy5lcnJvciA6IGZ1bmN0aW9uKCl7fTtcclxuXHRcdG9wdHMuZnJvbSA9IG9wdGlvbnMuZnJvbSA/IG9wdGlvbnMuZnJvbSA6IFwiJHRhdS1qc1wiO1xyXG5cdFx0b3B0cy5yZWNvbnN1bHQgPSBvcHRpb25zLnJlY29uc3VsdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZWNvbnN1bHQgOiB0cnVlO1xyXG5cdFx0b3B0cy5yZWNvbnN1bHRlZCA9IG9wdGlvbnMucmVjb25zdWx0ZWQgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucy5yZWNvbnN1bHRlZDtcclxuXHRcdG9wdHMuY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRvcHRzLmluaXRpYWxpemF0aW9uID0gb3B0aW9ucy5pbml0aWFsaXphdGlvbiA9PT0gdW5kZWZpbmVkID8gW10gOiBvcHRpb25zLmluaXRpYWxpemF0aW9uO1xyXG5cdFx0b3B0cy5jdXJyZW50X3Rva2VuID0gb3B0aW9ucy5jdXJyZW50X3Rva2VuID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jdXJyZW50X3Rva2VuO1xyXG5cdFx0b3B0cy50b2tlbml6ZXIgPSBvcHRpb25zLnRva2VuaXplciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMudG9rZW5pemVyO1xyXG5cdFx0b3B0cy50b2tlbnMgPSBvcHRpb25zLnRva2VucyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMudG9rZW5zO1xyXG5cdFx0b3B0cy5zdHJpbmcgPSBzdHJpbmc7XHJcblx0XHRvcHRzLnRlcm1fZXhwYW5zaW9uID0gZmFsc2U7XHJcblx0XHR2YXIgcmVjb25zdWx0ZWQgPSBvcHRzLnJlY29uc3VsdGVkO1xyXG5cdFx0dmFyIHRva2VuaXplciA9IG9wdHMudG9rZW5pemVyO1xyXG5cdFx0dmFyIHRva2VucyA9IG9wdHMudG9rZW5zO1xyXG5cdFx0aWYodG9rZW5pemVyID09PSBudWxsKSB7XHJcblx0XHRcdHRva2VuaXplciA9IG5ldyBUb2tlbml6ZXIodGhyZWFkKTtcclxuXHRcdFx0dG9rZW5pemVyLm5ld190ZXh0KHN0cmluZyk7XHJcblx0XHRcdG9wdHMudG9rZW5pemVyID0gdG9rZW5pemVyO1xyXG5cdFx0XHR0b2tlbnMgPSB0b2tlbml6ZXIuZ2V0X3Rva2VucygwKTtcclxuXHRcdFx0b3B0cy50b2tlbnMgPSB0b2tlbnM7XHJcblx0XHR9XHJcblx0XHR2YXIgbiA9IG9wdHMuY3VycmVudF90b2tlbjtcclxuXHRcdHdoaWxlKHRva2VucyAhPT0gbnVsbCAmJiB0b2tlbnNbbl0pIHtcclxuXHRcdFx0dmFyIGV4cHIgPSBwYXJzZVJ1bGUodGhyZWFkLCB0b2tlbnMsIG4pO1xyXG5cdFx0XHRvcHRzLmN1cnJlbnRfdG9rZW4gPSBleHByLmxlbjtcclxuXHRcdFx0aWYoZXhwci50eXBlID09PSBFUlJPUikge1xyXG5cdFx0XHRcdGlmKG9wdHMuZXJyb3IgIT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRvcHRzLmVycm9yKG5ldyBUZXJtKFwidGhyb3dcIiwgW2V4cHIudmFsdWVdKSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFRlcm0gZXhwYW5zaW9uXHJcblx0XHRcdFx0dmFyIGNvbnRleHRfbW9kdWxlID0gb3B0cy5jb250ZXh0X21vZHVsZTtcclxuXHRcdFx0XHR2YXIgdGVybV9leHBhbnNpb24gPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXS5ydWxlc1tcInRlcm1fZXhwYW5zaW9uLzJcIl07XHJcblx0XHRcdFx0aWYodGVybV9leHBhbnNpb24gJiYgdGVybV9leHBhbnNpb24ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0b3B0cy50ZXJtX2V4cGFuc2lvbiA9IHRydWU7XHJcblx0XHRcdFx0XHR2YXIgbl90aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdFx0XHRcdHZhciB0ZXJtID0gZXhwci52YWx1ZS5ib2R5ID8gbmV3IFRlcm0oXCI6LVwiLCBbZXhwci52YWx1ZS5oZWFkLCBleHByLnZhbHVlLmJvZHldKSA6IGV4cHIudmFsdWUuaGVhZDtcclxuXHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0XHR0ZXJtID0gdGVybS5yZW5hbWUodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0XHRcdFx0bl90aHJlYWQucXVlcnkoY29udGV4dF9tb2R1bGUgKyBcIjp0ZXJtX2V4cGFuc2lvbihcIiArIHRlcm0udG9TdHJpbmcoe3F1b3RlZDogdHJ1ZX0pICsgXCIsIFgpLlwiKTtcclxuXHRcdFx0XHRcdG5fdGhyZWFkLmFuc3dlcigoZnVuY3Rpb24odGhyZWFkLCBvcHRzLCByZWNvbnN1bHRlZCwgZXhwcikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoYW5zd2VyICYmICFwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikgJiYgcGwudHlwZS5pc190ZXJtKGFuc3dlci5saW5rc1snWCddKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHRlcm0gPSBhbnN3ZXIubGlua3NbJ1gnXTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBydWxlID0gdGVybS5pbmRpY2F0b3IgPT09IFwiOi0vMlwiID8gbmV3IFJ1bGUodGVybS5hcmdzWzBdLCB0ZXJtLmFyZ3NbMV0pIDogbmV3IFJ1bGUodGVybSwgbnVsbCk7XHJcblx0XHRcdFx0XHRcdFx0XHRwYXJzZVByb2dyYW1FeHBhbnNpb24odGhyZWFkLCBvcHRzLCByZWNvbnN1bHRlZCwge3ZhbHVlOiBydWxlLCBsZW46IGV4cHIubGVuLCB0eXBlOiBleHByLnR5cGV9KTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VQcm9ncmFtRXhwYW5zaW9uKHRocmVhZCwgb3B0cywgcmVjb25zdWx0ZWQsIGV4cHIpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSkodGhyZWFkLCBvcHRzLCByZWNvbnN1bHRlZCwgZXhwcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRvcHRzLnRlcm1fZXhwYW5zaW9uID0gZmFsc2U7XHJcblx0XHRcdFx0XHR2YXIgYXN5bmMgPSBwYXJzZVByb2dyYW1FeHBhbnNpb24odGhyZWFkLCBvcHRzLCByZWNvbnN1bHRlZCwgZXhwcik7XHJcblx0XHRcdFx0XHRpZihhc3luYylcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0biA9IGV4cHIubGVuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Ly8gcnVuIGdvYWxzIGZyb20gaW5pdGlhbGl6YXRpb24vMSBkaXJlY3RpdmVcclxuXHRcdHZhciBjYWxsYmFjayA9IG9wdHMuc3VjY2VzcztcclxuXHRcdHZhciBudGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRmb3IodmFyIGkgPSBvcHRzLmluaXRpYWxpemF0aW9uLmxlbmd0aC0xOyBpID4gMDsgaS0tKSB7XHJcblx0XHRcdHZhciBuZXh0X2NhbGxiYWNrID0gKGZ1bmN0aW9uKGluaXQsIGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRcdFx0aWYoYW5zd2VyID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdG50aHJlYWQuYW5zd2VyKCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19lcnJvcihhbnN3ZXIpKSB7XHJcblx0XHRcdFx0XHRcdG9wdHMuZXJyb3IoYW5zd2VyKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdG50aHJlYWQuYWRkX2dvYWwoaW5pdCk7XHJcblx0XHRcdFx0XHRcdG50aHJlYWQuYW5zd2VyKGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KShvcHRzLmluaXRpYWxpemF0aW9uW2ldLCBjYWxsYmFjayk7XHJcblx0XHRcdGNhbGxiYWNrID0gbmV4dF9jYWxsYmFjaztcclxuXHRcdH1cclxuXHRcdGlmKG9wdHMuaW5pdGlhbGl6YXRpb24ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRudGhyZWFkLmFkZF9nb2FsKG9wdHMuaW5pdGlhbGl6YXRpb25bMF0pO1xyXG5cdFx0XHRudGhyZWFkLmFuc3dlcihjYWxsYmFjayk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VHb2FsRXhwYW5zaW9uKHRocmVhZCwgb3B0aW9ucywgZXhwcikge1xyXG5cdFx0dmFyIG5fdGhyZWFkID0gbmV3IFRocmVhZCggdGhyZWFkLnNlc3Npb24gKTtcclxuXHRcdG5fdGhyZWFkLl9fZ29hbF9leHBhbnNpb24gPSB0cnVlO1xyXG5cdFx0dmFyIHZhcnRlcm0gPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHR2YXIgdmFyaGVhZCA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdHZhciBnb2FsID0gdmFyaGVhZCArIFwiID0gXCIgKyBleHByLnZhbHVlLmhlYWQgKyBcIiwgZ29hbF9leHBhbnNpb24oXCIgKyBleHByLnZhbHVlLmJvZHkudG9TdHJpbmcoe1xyXG5cdFx0XHRxdW90ZWQ6IHRydWVcclxuXHRcdH0pICsgXCIsIFwiICsgdmFydGVybS50b1N0cmluZyh7XHJcblx0XHRcdHF1b3RlZDogdHJ1ZVxyXG5cdFx0fSkgKyBcIikuXCI7XHJcblx0XHRuX3RocmVhZC5xdWVyeShnb2FsKTtcclxuXHRcdG5fdGhyZWFkLmFuc3dlcihmdW5jdGlvbihhbnN3ZXIpIHtcclxuXHRcdFx0aWYoYW5zd2VyICYmICFwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikgJiYgYW5zd2VyLmxpbmtzW3ZhcnRlcm1dKSB7XHJcblx0XHRcdFx0ZXhwci52YWx1ZS5oZWFkID0gYW5zd2VyLmxpbmtzW3ZhcmhlYWRdO1xyXG5cdFx0XHRcdGV4cHIudmFsdWUuYm9keSA9IGJvZHlfY29udmVyc2lvbihhbnN3ZXIubGlua3NbdmFydGVybV0pO1xyXG5cdFx0XHRcdHBhcnNlR29hbEV4cGFuc2lvbih0aHJlYWQsIG9wdGlvbnMsIGV4cHIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5hZGRfcnVsZShleHByLnZhbHVlLCBvcHRpb25zKTtcclxuXHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VRdWVyeUV4cGFuc2lvbih0aHJlYWQsIHRlcm0sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBuX3RocmVhZCA9IG5ldyBUaHJlYWQodGhyZWFkLnNlc3Npb24pO1xyXG5cdFx0bl90aHJlYWQuX19nb2FsX2V4cGFuc2lvbiA9IHRydWU7XHJcblx0XHR2YXIgdmFydGVybSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdHZhciBnb2FsID0gXCJnb2FsX2V4cGFuc2lvbihcIiArIHRlcm0udG9TdHJpbmcoe1xyXG5cdFx0XHRxdW90ZWQ6IHRydWVcclxuXHRcdH0pICsgXCIsIFwiICsgdmFydGVybS50b1N0cmluZyh7XHJcblx0XHRcdHF1b3RlZDogdHJ1ZVxyXG5cdFx0fSkgKyBcIikuXCI7XHJcblx0XHRuX3RocmVhZC5xdWVyeShnb2FsKTtcclxuXHRcdHZhciB2YXJpYWJsZXMgPSBuX3RocmVhZC5oZWFkX3BvaW50KCkuc3Vic3RpdHV0aW9uLmRvbWFpbigpO1xyXG5cdFx0bl90aHJlYWQuYW5zd2VyKGZ1bmN0aW9uKGFuc3dlcikge1xyXG5cdFx0XHRpZihhbnN3ZXIgJiYgIXBsLnR5cGUuaXNfZXJyb3IoYW5zd2VyKSAmJiBhbnN3ZXIubGlua3NbdmFydGVybV0pIHtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdmFyaWFibGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZih2YXJpYWJsZXNbaV0gIT09IHZhcnRlcm0uaWQgJiYgYW5zd2VyLmxpbmtzW3ZhcmlhYmxlc1tpXV0pIHtcclxuXHRcdFx0XHRcdFx0dmFyIHN1YnMgPSBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRcdFx0XHRcdHN1YnMubGlua3NbYW5zd2VyLmxpbmtzW3ZhcmlhYmxlc1tpXV1dID0gdmFyaWFibGVzW2ldO1xyXG5cdFx0XHRcdFx0XHRhbnN3ZXIubGlua3NbdmFydGVybV0gPSBhbnN3ZXIubGlua3NbdmFydGVybV0uYXBwbHkoIHN1YnMgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cGFyc2VRdWVyeUV4cGFuc2lvbih0aHJlYWQsIGJvZHlfY29udmVyc2lvbihhbnN3ZXIubGlua3NbdmFydGVybV0pLCBvcHRpb25zKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQuYWRkX2dvYWwodGVybSk7XHJcblx0XHRcdFx0b3B0aW9ucy5zdWNjZXNzKHRlcm0pO1xyXG5cdFx0XHRcdHBhcnNlUXVlcnkodGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VQcm9ncmFtRXhwYW5zaW9uKHRocmVhZCwgb3B0aW9ucywgcmVjb25zdWx0ZWQsIGV4cHIpIHtcclxuXHRcdHZhciBhc3luYyA9IG9wdGlvbnMudGVybV9leHBhbnNpb24gPT09IHRydWU7XHJcblx0XHRpZihleHByLnZhbHVlLmJvZHkgPT09IG51bGwgJiYgZXhwci52YWx1ZS5oZWFkLmluZGljYXRvciA9PT0gXCI/LS8xXCIpIHtcclxuXHRcdFx0YXN5bmMgPSB0cnVlO1xyXG5cdFx0XHR2YXIgbl90aHJlYWQgPSBuZXcgVGhyZWFkKHRocmVhZC5zZXNzaW9uKTtcclxuXHRcdFx0bl90aHJlYWQuYWRkX2dvYWwoZXhwci52YWx1ZS5oZWFkLmFyZ3NbMF0pO1xyXG5cdFx0XHRuX3RocmVhZC5hbnN3ZXIoZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19lcnJvcihhbnN3ZXIpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhhbnN3ZXIuYXJnc1swXSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGFuc3dlciA9PT0gZmFsc2UgfHwgYW5zd2VyID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC53YXJuaW5nLmZhaWxlZF9nb2FsKGV4cHIudmFsdWUuaGVhZC5hcmdzWzBdLCBleHByLmxlbikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmKGV4cHIudmFsdWUuYm9keSA9PT0gbnVsbCAmJiBleHByLnZhbHVlLmhlYWQuaW5kaWNhdG9yID09PSBcIjotLzFcIikge1xyXG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhyZWFkLnJ1bl9kaXJlY3RpdmUoZXhwci52YWx1ZS5oZWFkLmFyZ3NbMF0sIG9wdGlvbnMpO1xyXG5cdFx0XHRhc3luYyA9IGFzeW5jIHx8IChyZXN1bHQgPT09IHRydWUpO1xyXG5cdFx0XHRpZihhc3luYylcclxuXHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBvcHRpb25zLnN0cmluZywgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHR2YXIgaW5kaWNhdG9yID0gZXhwci52YWx1ZS5oZWFkLmluZGljYXRvcjtcclxuXHRcdFx0aWYoZXhwci52YWx1ZS5oZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gZXhwci52YWx1ZS5oZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aW5kaWNhdG9yID0gZXhwci52YWx1ZS5oZWFkLmFyZ3NbMV0uaW5kaWNhdG9yO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFyZWNvbnN1bHRlZC5oYXNPd25Qcm9wZXJ0eShjb250ZXh0X21vZHVsZSkpXHJcblx0XHRcdFx0cmVjb25zdWx0ZWRbY29udGV4dF9tb2R1bGVdID0ge307XHJcblx0XHRcdGlmKG9wdGlvbnMucmVjb25zdWx0ICE9PSBmYWxzZSAmJiByZWNvbnN1bHRlZFtjb250ZXh0X21vZHVsZV1baW5kaWNhdG9yXSAhPT0gdHJ1ZSAmJiAhdGhyZWFkLmlzX211bHRpZmlsZV9wcmVkaWNhdGUoaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tjb250ZXh0X21vZHVsZV07XHJcblx0XHRcdFx0aWYoY29udGV4dF9tb2R1bGUgIT09IFwic3lzdGVtXCIgJiYgZ2V0X21vZHVsZSAmJiBnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0pIHtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXSA9IGZpbHRlcihnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0sIGZ1bmN0aW9uKHJ1bGUpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJ1bGUuZHluYW1pYztcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmVjb25zdWx0ZWRbY29udGV4dF9tb2R1bGVdW2luZGljYXRvcl0gPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBnb2FsX2V4cGFuc2lvbiA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXMudXNlci5ydWxlc1tcImdvYWxfZXhwYW5zaW9uLzJcIl07XHJcblx0XHRcdGlmKGV4cHIudmFsdWUuYm9keSAhPT0gbnVsbCAmJiBnb2FsX2V4cGFuc2lvbiAmJiBnb2FsX2V4cGFuc2lvbi5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0YXN5bmMgPSB0cnVlO1xyXG5cdFx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0dmFyIG9yaWdpbiA9IHtcclxuXHRcdFx0XHRcdGhlYWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZXhwci52YWx1ZS5oZWFkOyB9LFxyXG5cdFx0XHRcdFx0dGVybTogZnVuY3Rpb24oKSB7IHJldHVybiBleHByLnZhbHVlLmJvZHk7IH0sXHJcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKGgsIHApe1xyXG5cdFx0XHRcdFx0XHRleHByLnZhbHVlLmhlYWQgPSBoO1xyXG5cdFx0XHRcdFx0XHRleHByLnZhbHVlLmJvZHkgPSBwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0cGFyc2VHb2FsRXhwYW5zaW9uKHRocmVhZCwgb3B0aW9ucywgZXhwciwgYm9keV9jb252ZXJzaW9uKGV4cHIudmFsdWUuYm9keSksIG9yaWdpbi5zZXQsIG9yaWdpbik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLmFkZF9ydWxlKGV4cHIudmFsdWUsIG9wdGlvbnMpO1xyXG5cdFx0XHRcdGlmKGFzeW5jKVxyXG5cdFx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXN5bmM7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFBhcnNlIGEgcXVlcnlcclxuXHRmdW5jdGlvbiBwYXJzZVF1ZXJ5KHRocmVhZCwgc3RyaW5nLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgb3B0cyA9IHt9O1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMgOiBmdW5jdGlvbigpe307XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRvcHRzLnN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrIDogb3B0aW9ucy5zdWNjZXNzO1xyXG5cdFx0b3B0cy5lcnJvciA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IGNhbGxiYWNrIDogb3B0aW9ucy5lcnJvcjtcclxuXHRcdG9wdHMudG9rZW5pemVyID0gb3B0aW9ucy50b2tlbml6ZXIgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLnRva2VuaXplcjtcclxuXHRcdG9wdHMuY3VycmVudF90b2tlbiA9IG9wdGlvbnMuY3VycmVudF90b2tlbiA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY3VycmVudF90b2tlbjtcclxuXHRcdG9wdHMuc3RyaW5nID0gc3RyaW5nO1xyXG5cdFx0dmFyIHRva2VuaXplciA9IG9wdHMudG9rZW5pemVyO1xyXG5cdFx0dmFyIG4gPSBvcHRzLmN1cnJlbnRfdG9rZW47XHJcblx0XHRpZih0b2tlbml6ZXIgPT09IG51bGwpIHtcclxuXHRcdFx0dG9rZW5pemVyID0gbmV3IFRva2VuaXplcih0aHJlYWQpO1xyXG5cdFx0XHRvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcclxuXHRcdFx0dG9rZW5pemVyLm5ld190ZXh0KHN0cmluZyk7XHJcblx0XHR9XHJcblx0XHRkbyB7XHJcblx0XHRcdHZhciB0b2tlbnMgPSB0b2tlbml6ZXIuZ2V0X3Rva2VucyhuKTtcclxuXHRcdFx0aWYodG9rZW5zID09PSBudWxsKVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR2YXIgZXhwciA9IHBhcnNlRXhwcih0aHJlYWQsIHRva2VucywgMCwgdGhyZWFkLl9fZ2V0X21heF9wcmlvcml0eSgpLCBmYWxzZSk7XHJcblx0XHRcdGlmKGV4cHIudHlwZSAhPT0gRVJST1IpIHtcclxuXHRcdFx0XHR2YXIgZXhwcl9wb3NpdGlvbiA9IGV4cHIubGVuO1xyXG5cdFx0XHRcdG4gPSBleHByLmxlbiArIDE7XHJcblx0XHRcdFx0b3B0cy5jdXJyZW50X3Rva2VuID0gbjtcclxuXHRcdFx0XHRpZih0b2tlbnNbZXhwcl9wb3NpdGlvbl0gJiYgdG9rZW5zW2V4cHJfcG9zaXRpb25dLm5hbWUgPT09IFwiYXRvbVwiICYmIHRva2Vuc1tleHByX3Bvc2l0aW9uXS5yYXcgPT09IFwiLlwiKSB7XHJcblx0XHRcdFx0XHRleHByLnZhbHVlID0gYm9keV9jb252ZXJzaW9uKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdFx0Ly8gR29hbCBleHBhbnNpb25cclxuXHRcdFx0XHRcdHZhciBnb2FsX2V4cGFuc2lvbiA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXMudXNlci5ydWxlc1tcImdvYWxfZXhwYW5zaW9uLzJcIl07XHJcblx0XHRcdFx0XHRpZighdGhyZWFkLl9fZ29hbF9leHBhbnNpb24gJiYgZ29hbF9leHBhbnNpb24gJiYgZ29hbF9leHBhbnNpb24ubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdFx0XHRwYXJzZVF1ZXJ5RXhwYW5zaW9uKHRocmVhZCwgZXhwci52YWx1ZSwgb3B0cyk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5hZGRfZ29hbChleHByLnZhbHVlKTtcclxuXHRcdFx0XHRcdFx0b3B0cy5zdWNjZXNzKGV4cHIudmFsdWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgdG9rZW4gPSB0b2tlbnNbZXhwcl9wb3NpdGlvbl07XHJcblx0XHRcdFx0XHRvcHRzLmVycm9yKFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcInRocm93XCIsIFtcclxuXHRcdFx0XHRcdFx0XHRwbC5lcnJvci5zeW50YXgoXHJcblx0XHRcdFx0XHRcdFx0XHR0b2tlbiA/IHRva2VuIDogdG9rZW5zW2V4cHJfcG9zaXRpb24tMV0sXHJcblx0XHRcdFx0XHRcdFx0XHR0b2tlbiAmJiB0b2tlbi5lcnJvciA/IHRva2VuLmVycm9yIDogXCIuIG9yIG9wZXJhdG9yIGV4cGVjdGVkXCIsXHJcblx0XHRcdFx0XHRcdFx0XHQhdG9rZW5cclxuXHRcdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvcHRzLmVycm9yKG5ldyBUZXJtKFwidGhyb3dcIiwgW2V4cHIudmFsdWVdKSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9IHdoaWxlKHRydWUpO1xyXG5cdH1cclxuXHJcblxyXG5cdFxyXG5cdC8vIFVUSUxTXHJcblxyXG5cdC8vIFJ1bGUgdG8gRENHXHJcblx0ZnVuY3Rpb24gcnVsZV90b19kY2cocnVsZSwgdGhyZWFkKSB7XHJcblx0XHR0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0cnVsZSA9IHJ1bGUucmVuYW1lKHRocmVhZCk7XHJcblx0XHR2YXIgYmVnaW4gPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHR2YXIgZGNnID0gYm9keV90b19kY2coIHJ1bGUuYm9keSwgYmVnaW4sIHRocmVhZCApO1xyXG5cdFx0aWYoIGRjZy5lcnJvciApXHJcblx0XHRcdHJldHVybiBkY2cudmFsdWU7XHJcblx0XHRydWxlLmJvZHkgPSBkY2cudmFsdWU7XHJcblx0XHQvLyBwdXNoLWJhY2sgbGlzdHNcclxuXHRcdGlmKHJ1bGUuaGVhZC5pbmRpY2F0b3IgPT09IFwiLC8yXCIpIHtcclxuXHRcdFx0dmFyIHRlcm1pbmFscyA9IHJ1bGUuaGVhZC5hcmdzWzFdO1xyXG5cdFx0XHRydWxlLmhlYWQgPSBydWxlLmhlYWQuYXJnc1swXTtcclxuXHRcdFx0dmFyIGxhc3QgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHZhciBwb2ludGVyID0gdGVybWluYWxzO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc19saXN0KHBvaW50ZXIpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIHBvaW50ZXIsIFwiRENHLzBcIik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocG9pbnRlci5pbmRpY2F0b3IgPT09IFwiW10vMFwiKSB7XHJcblx0XHRcdFx0dGVybWluYWxzID0gZGNnLnZhcmlhYmxlO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHdoaWxlKHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICYmIHBsLnR5cGUuaXNfbGlzdChwb2ludGVyKSAmJiBwb2ludGVyLmFyZ3NbMV0uaW5kaWNhdG9yICE9PSBcIltdLzBcIikge1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSlcclxuXHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci5pbnN0YW50aWF0aW9uKFwiRENHLzBcIik7XHJcblx0XHRcdFx0ZWxzZSBpZighcGwudHlwZS5pc19saXN0KHBvaW50ZXIpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIHRlcm1pbmFscywgXCJEQ0cvMFwiKTtcclxuXHRcdFx0XHRwb2ludGVyLmFyZ3NbMV0gPSBkY2cudmFyaWFibGU7XHJcblx0XHRcdH1cclxuXHRcdFx0cnVsZS5ib2R5ID0gbmV3IFRlcm0oXCIsXCIsIFtydWxlLmJvZHksIG5ldyBUZXJtKFwiPVwiLCBbbGFzdCwgdGVybWluYWxzXSldKTtcclxuXHRcdFx0cnVsZS5oZWFkID0gbmV3IFRlcm0ocnVsZS5oZWFkLmlkLCBydWxlLmhlYWQuYXJncy5jb25jYXQoW2JlZ2luLCBsYXN0XSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gcmVwbGFjZSBmaXJzdCBhc3NpZ25tZW50XHJcblx0XHRcdHZhciBmaXJzdF9hc3NpZ24gPSBydWxlLmJvZHk7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShmaXJzdF9hc3NpZ24pICYmIGZpcnN0X2Fzc2lnbi5pbmRpY2F0b3IgPT09IFwiLC8yXCIpXHJcblx0XHRcdFx0Zmlyc3RfYXNzaWduID0gZmlyc3RfYXNzaWduLmFyZ3NbMF07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShmaXJzdF9hc3NpZ24pICYmIGZpcnN0X2Fzc2lnbi5pbmRpY2F0b3IgPT09IFwiPS8yXCIgJiZcclxuXHRcdFx0ICAgcGwudHlwZS5pc192YXJpYWJsZShmaXJzdF9hc3NpZ24uYXJnc1swXSkgJiYgZmlyc3RfYXNzaWduLmFyZ3NbMF0gPT09IGJlZ2luKSB7XHJcblx0XHRcdFx0YmVnaW4gPSBmaXJzdF9hc3NpZ24uYXJnc1sxXTtcclxuXHRcdFx0XHRydWxlLmJvZHkgPSBydWxlLmJvZHkucmVwbGFjZShudWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBhZGQgZmlyc3QgYW5kIGxhc3QgdmFyaWFibGVzIHRvIHRoZSBoZWFkXHJcblx0XHRcdGlmKHJ1bGUuaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpXHJcblx0XHRcdFx0cnVsZS5oZWFkID0gbmV3IFRlcm0oXCI6XCIsIFtcclxuXHRcdFx0XHRcdG5ldyBUZXJtKHJ1bGUuaGVhZC5hcmdzWzBdLmlkLCBbXSksXHJcblx0XHRcdFx0XHRuZXcgVGVybShydWxlLmhlYWQuYXJnc1sxXS5pZCwgcnVsZS5oZWFkLmFyZ3NbMV0uYXJncy5jb25jYXQoW2JlZ2luLCBkY2cudmFyaWFibGVdKSlcclxuXHRcdFx0XHRdKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJ1bGUuaGVhZCA9IG5ldyBUZXJtKHJ1bGUuaGVhZC5pZCwgcnVsZS5oZWFkLmFyZ3MuY29uY2F0KFtiZWdpbiwgZGNnLnZhcmlhYmxlXSkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJ1bGU7XHJcblx0fVxyXG5cclxuXHQvLyBCb2R5IHRvIERDR1xyXG5cdGZ1bmN0aW9uIGJvZHlfdG9fZGNnKGV4cHIsIGxhc3QsIHRocmVhZCkge1xyXG5cdFx0dmFyIGZyZWU7XHJcblx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwiIS8wXCIgKSB7XHJcblx0XHRcdGZyZWUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiLFwiLCBbZXhwciwgbmV3IFRlcm0oXCI9XCIsIFtsYXN0LCBmcmVlXSldKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogZnJlZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwiOi8yXCIgKSB7XHJcblx0XHRcdHZhciByaWdodCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1sxXSwgbGFzdCwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIHJpZ2h0LmVycm9yICkgcmV0dXJuIHJpZ2h0O1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIjpcIiwgW2V4cHIuYXJnc1swXSwgcmlnaHQudmFsdWVdKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogcmlnaHQudmFyaWFibGUsXHJcblx0XHRcdFx0ZXJyb3I6IGZhbHNlXHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdGVybSggZXhwciApICYmIGV4cHIuaW5kaWNhdG9yID09PSBcIlxcXFwrLzFcIiApIHtcclxuXHRcdFx0dmFyIGxlZnQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMF0sIGxhc3QsIHRocmVhZCk7XHJcblx0XHRcdGlmKCBsZWZ0LmVycm9yICkgcmV0dXJuIGxlZnQ7XHJcblx0XHRcdGZyZWUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oZXhwci5pZCwgW2xlZnQudmFsdWVdKSwgbmV3IFRlcm0oXCI9XCIsIFtsYXN0LCBmcmVlXSldKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogZnJlZSxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc190ZXJtKCBleHByICkgJiYgKGV4cHIuaW5kaWNhdG9yID09PSBcIiwvMlwiIHx8IGV4cHIuaW5kaWNhdG9yID09PSBcIi0+LzJcIikgKSB7XHJcblx0XHRcdHZhciBsZWZ0ID0gYm9keV90b19kY2coZXhwci5hcmdzWzBdLCBsYXN0LCB0aHJlYWQpO1xyXG5cdFx0XHRpZiggbGVmdC5lcnJvciApIHJldHVybiBsZWZ0O1xyXG5cdFx0XHR2YXIgcmlnaHQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMV0sIGxlZnQudmFyaWFibGUsIHRocmVhZCk7XHJcblx0XHRcdGlmKCByaWdodC5lcnJvciApIHJldHVybiByaWdodDtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oZXhwci5pZCwgW2xlZnQudmFsdWUsIHJpZ2h0LnZhbHVlXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IHJpZ2h0LnZhcmlhYmxlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBleHByLmluZGljYXRvciA9PT0gXCI7LzJcIiApIHtcclxuXHRcdFx0dmFyIGxlZnQgPSBib2R5X3RvX2RjZyhleHByLmFyZ3NbMF0sIGxhc3QsIHRocmVhZCk7XHJcblx0XHRcdGlmKCBsZWZ0LmVycm9yICkgcmV0dXJuIGxlZnQ7XHJcblx0XHRcdHZhciByaWdodCA9IGJvZHlfdG9fZGNnKGV4cHIuYXJnc1sxXSwgbGFzdCwgdGhyZWFkKTtcclxuXHRcdFx0aWYoIHJpZ2h0LmVycm9yICkgcmV0dXJuIHJpZ2h0O1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiO1wiLCBbbGVmdC52YWx1ZSwgcmlnaHQudmFsdWVdKSwgbmV3IFRlcm0oXCI9XCIsIFtsZWZ0LnZhcmlhYmxlLCByaWdodC52YXJpYWJsZV0pXSksXHJcblx0XHRcdFx0dmFyaWFibGU6IHJpZ2h0LnZhcmlhYmxlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBleHByLmluZGljYXRvciA9PT0gXCJ7fS8xXCIgKSB7XHJcblx0XHRcdGZyZWUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiLFwiLCBbZXhwci5hcmdzWzBdLCBuZXcgVGVybShcIj1cIiwgW2xhc3QsIGZyZWVdKV0pLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmcmVlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIGV4cHIgKSApIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCJ0cnVlXCIsIFtdKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogbGFzdCxcclxuXHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19saXN0KCBleHByICkgKSB7XHJcblx0XHRcdGZyZWUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHZhciBwb2ludGVyID0gZXhwcjtcclxuXHRcdFx0dmFyIHByZXY7XHJcblx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRwcmV2ID0gcG9pbnRlcjtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHZhbHVlOiBwbC5lcnJvci5pbnN0YW50aWF0aW9uKFwiRENHLzBcIiksXHJcblx0XHRcdFx0XHR2YXJpYWJsZTogbGFzdCxcclxuXHRcdFx0XHRcdGVycm9yOiB0cnVlXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19lbXB0eV9saXN0KCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdHZhbHVlOiBwbC5lcnJvci50eXBlKFwibGlzdFwiLCBleHByLCBcIkRDRy8wXCIpLFxyXG5cdFx0XHRcdFx0dmFyaWFibGU6IGxhc3QsXHJcblx0XHRcdFx0XHRlcnJvcjogdHJ1ZVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldi5hcmdzWzFdID0gZnJlZTtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiPVwiLCBbbGFzdCwgZXhwcl0pLFxyXG5cdFx0XHRcdFx0dmFyaWFibGU6IGZyZWUsXHJcblx0XHRcdFx0XHRlcnJvcjogZmFsc2VcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfY2FsbGFibGUoIGV4cHIgKSApIHtcclxuXHRcdFx0ZnJlZSA9IHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKTtcclxuXHRcdFx0ZXhwciA9IG5ldyBUZXJtKCBleHByLmlkLCBleHByLmFyZ3MuY29uY2F0KFtsYXN0LGZyZWVdKSApO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHZhbHVlOiBleHByLFxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmcmVlLFxyXG5cdFx0XHRcdGVycm9yOiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR2YWx1ZTogcGwuZXJyb3IudHlwZSggXCJjYWxsYWJsZVwiLCBleHByLCBcIkRDRy8wXCIgKSxcclxuXHRcdFx0XHR2YXJpYWJsZTogbGFzdCxcclxuXHRcdFx0XHRlcnJvcjogdHJ1ZVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHRcclxuXHQvLyBCb2R5IGNvbnZlcnNpb25cclxuXHRmdW5jdGlvbiBib2R5X2NvbnZlcnNpb24oIGV4cHIgKSB7XHJcblx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZXhwciApIClcclxuXHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImNhbGxcIiwgW2V4cHJdICk7XHJcblx0XHRlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oIGV4cHIgKSAmJiBbXCIsLzJcIiwgXCI7LzJcIiwgXCItPi8yXCJdLmluZGV4T2YoZXhwci5pbmRpY2F0b3IpICE9PSAtMSApXHJcblx0XHRcdHJldHVybiBuZXcgVGVybSggZXhwci5pZCwgW2JvZHlfY29udmVyc2lvbiggZXhwci5hcmdzWzBdICksIGJvZHlfY29udmVyc2lvbiggZXhwci5hcmdzWzFdICldICk7XHJcblx0XHRlbHNlIGlmKCBwbC50eXBlLmlzX3Rlcm0oZXhwcikgJiYgZXhwci5pbmRpY2F0b3IgPT09IFwiOi8yXCIgKSB7XHJcblx0XHRcdHZhciBib2R5ID0gYm9keV9jb252ZXJzaW9uKGV4cHIuYXJnc1sxXSk7XHJcblx0XHRcdHJldHVybiBuZXcgVGVybShcIjpcIiwgW2V4cHIuYXJnc1swXSwgYm9keV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGV4cHI7XHJcblx0fVxyXG5cdFxyXG5cdC8vIExpc3QgdG8gUHJvbG9nIGxpc3RcclxuXHRmdW5jdGlvbiBhcnJheVRvTGlzdCggYXJyYXksIGNvbnMgKSB7XHJcblx0XHR2YXIgbGlzdCA9IGNvbnMgPyBjb25zIDogbmV3IFRlcm0oIFwiW11cIiwgW10gKTtcclxuXHRcdGZvcih2YXIgaSA9IGFycmF5Lmxlbmd0aC0xOyBpID49IDA7IGktLSApXHJcblx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCIuXCIsIFthcnJheVtpXSwgbGlzdF0gKTtcclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH1cclxuXHJcblx0Ly8gQXJyYXkgZGlmZmVyZW5jZVxyXG5cdGZ1bmN0aW9uIGRpZmZlcmVuY2UoeHMsIHlzKSB7XHJcblx0XHR2YXIgenMgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihpbmRleE9mKHpzLCB4c1tpXSkgPT09IC0xICYmIGluZGV4T2YoeXMsIHhzW2ldKSA9PT0gLTEpXHJcblx0XHRcdFx0enMucHVzaCh4c1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4genM7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFJlbW92ZSBlbGVtZW50IGZyb20gYXJyYXlcclxuXHRmdW5jdGlvbiByZW1vdmUoIGFycmF5LCBlbGVtZW50ICkge1xyXG5cdFx0Zm9yKCB2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRpZiggYXJyYXlbaV0gPT09IGVsZW1lbnQgKSB7XHJcblx0XHRcdFx0YXJyYXkuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdC8vIFJlbW92ZSBkdXBsaWNhdGUgZWxlbWVudHNcclxuXHRmdW5jdGlvbiBudWIoIGFycmF5ICkge1xyXG5cdFx0dmFyIHNlZW4gPSB7fTtcclxuXHRcdHZhciB1bmlxdWUgPSBbXTtcclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdGlmKCAhKGFycmF5W2ldIGluIHNlZW4pICkge1xyXG5cdFx0XHRcdHVuaXF1ZS5wdXNoKCBhcnJheVtpXSApO1xyXG5cdFx0XHRcdHNlZW5bYXJyYXlbaV1dID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHVuaXF1ZTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHJhY3QgYSBydWxlXHJcblx0ZnVuY3Rpb24gcmV0cmFjdCh0aHJlYWQsIHBvaW50LCBpbmRpY2F0b3IsIHJ1bGUsIGdldF9tb2R1bGUpIHtcclxuXHRcdGlmKGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXSkge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1tpbmRpY2F0b3JdW2ldID09PSBydWxlKSB7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2luZGljYXRvcl0uc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdC8vIGNhbGwvblxyXG5cdGZ1bmN0aW9uIGNhbGxOKG4pIHtcclxuXHRcdHJldHVybiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjbG9zdXJlID0gYXRvbS5hcmdzWzBdLCBhcmdzID0gYXRvbS5hcmdzLnNsaWNlKDEsIG4pO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2F0b207XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShjbG9zdXJlKSAmJiBjbG9zdXJlLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20oY2xvc3VyZS5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgY2xvc3VyZS5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfYXRvbSA9IGNsb3N1cmUuYXJnc1swXTtcclxuXHRcdFx0XHRjbG9zdXJlID0gY2xvc3VyZS5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoY2xvc3VyZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xvc3VyZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsb3N1cmUsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdvYWwgPSBib2R5X2NvbnZlcnNpb24obmV3IFRlcm0oY2xvc3VyZS5pZCwgY2xvc3VyZS5hcmdzLmNvbmNhdChhcmdzKSkpO1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGdvYWwpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGdvYWwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKG1vZHVsZV9hdG9tKVxyXG5cdFx0XHRcdFx0Z29hbCA9IG5ldyBUZXJtKFwiOlwiLCBbbW9kdWxlX2F0b20sIGdvYWxdKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShnb2FsKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcblx0XHJcblx0Ly8gU3RyaW5nIHRvIGluZGljYXRvclxyXG5cdGZ1bmN0aW9uIHN0cl9pbmRpY2F0b3IoIHN0ciApIHtcclxuXHRcdGZvciggdmFyIGkgPSBzdHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKVxyXG5cdFx0XHRpZiggc3RyLmNoYXJBdChpKSA9PT0gXCIvXCIgKVxyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCIvXCIsIFtuZXcgVGVybSggc3RyLnN1YnN0cmluZygwLCBpKSApLCBuZXcgTnVtKCBwYXJzZUludChzdHIuc3Vic3RyaW5nKGkrMSkpLCBmYWxzZSApXSApO1xyXG5cdH1cclxuXHJcblx0Ly8gR3JlYXRlc3QgY29tbW9uIGRpdmlzb3JcclxuXHRmdW5jdGlvbiBnY2QoYSwgYikge1xyXG5cdFx0aWYoYiA9PT0gMClcclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoZ2NkKGIsIGEgJSBiKSk7XHJcblx0fVxyXG5cdFxyXG5cdFxyXG5cclxuXHQvLyBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdGZ1bmN0aW9uIFZhciggaWQgKSB7XHJcblx0XHR0aGlzLmlkID0gaWQ7XHJcblx0XHR0aGlzLmdyb3VuZCA9IGZhbHNlO1xyXG5cdH1cclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0ZnVuY3Rpb24gTnVtKCB2YWx1ZSwgaXNfZmxvYXQgKSB7XHJcblx0XHR0aGlzLmlzX2Zsb2F0ID0gaXNfZmxvYXQgIT09IHVuZGVmaW5lZCA/IGlzX2Zsb2F0IDogTWF0aC50cnVuYyh2YWx1ZSkgIT09IHZhbHVlO1xyXG5cdFx0dGhpcy52YWx1ZSA9IHRoaXMuaXNfZmxvYXQgPyB2YWx1ZSA6IE1hdGgudHJ1bmModmFsdWUpO1xyXG5cdFx0dGhpcy5pbmRleCA9IHRoaXMudmFsdWU7XHJcblx0XHR0aGlzLmdyb3VuZCA9IHRydWU7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0dmFyIHRlcm1fcmVmID0gMDtcclxuXHRmdW5jdGlvbiBUZXJtKCBpZCwgYXJncywgcmVmICkge1xyXG5cdFx0dGVybV9yZWYrKztcclxuXHRcdHRoaXMucmVmID0gcmVmIHx8IHRlcm1fcmVmO1xyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy5hcmdzID0gYXJncyB8fCBbXTtcclxuXHRcdHRoaXMuaW5kaWNhdG9yID0gaWQgKyBcIi9cIiArIHRoaXMuYXJncy5sZW5ndGg7XHJcblx0XHR0aGlzLmluZGV4ID0gdGhpcy5pbmRpY2F0b3I7XHJcblx0XHR0aGlzLmdyb3VuZCA9IHRydWU7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmKHRoaXMuYXJnc1tpXS5oYXNPd25Qcm9wZXJ0eShcImdyb3VuZFwiKSAmJiB0aGlzLmFyZ3NbaV0uZ3JvdW5kID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdHRoaXMuZ3JvdW5kID0gZmFsc2U7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHR2YXIgc3RyZWFtX3JlZiA9IDA7XHJcblx0ZnVuY3Rpb24gU3RyZWFtKCBzdHJlYW0sIG1vZGUsIGFsaWFzLCB0eXBlLCByZXBvc2l0aW9uLCBlb2ZfYWN0aW9uICkge1xyXG5cdFx0dGhpcy5pZCA9IHN0cmVhbV9yZWYrKztcclxuXHRcdHRoaXMuc3RyZWFtID0gc3RyZWFtO1xyXG5cdFx0dGhpcy5tb2RlID0gbW9kZTsgLy8gXCJyZWFkXCIgb3IgXCJ3cml0ZVwiIG9yIFwiYXBwZW5kXCJcclxuXHRcdHRoaXMuYWxpYXMgPSBhbGlhcztcclxuXHRcdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBcInRleHRcIjsgLy8gXCJ0ZXh0XCIgb3IgXCJiaW5hcnlcIlxyXG5cdFx0dGhpcy5yZXBvc2l0aW9uID0gcmVwb3NpdGlvbiAhPT0gdW5kZWZpbmVkID8gcmVwb3NpdGlvbiA6IHRydWU7IC8vIHRydWUgb3IgZmFsc2VcclxuXHRcdHRoaXMuZW9mX2FjdGlvbiA9IGVvZl9hY3Rpb24gIT09IHVuZGVmaW5lZCA/IGVvZl9hY3Rpb24gOiBcImVvZl9jb2RlXCI7IC8vIFwiZXJyb3JcIiBvciBcImVvZl9jb2RlXCIgb3IgXCJyZXNldFwiXHJcblx0XHR0aGlzLnBvc2l0aW9uID0gdGhpcy5tb2RlID09PSBcImFwcGVuZFwiID8gXCJlbmRfb2Zfc3RyZWFtXCIgOiAwO1xyXG5cdFx0dGhpcy5vdXRwdXQgPSB0aGlzLm1vZGUgPT09IFwid3JpdGVcIiB8fCB0aGlzLm1vZGUgPT09IFwiYXBwZW5kXCI7XHJcblx0XHR0aGlzLmlucHV0ID0gdGhpcy5tb2RlID09PSBcInJlYWRcIjtcclxuXHRcdHRoaXMubGluZV9wb3NpdGlvbiA9IDA7XHJcblx0XHR0aGlzLmxpbmVfY291bnQgPSAxO1xyXG5cdFx0dGhpcy5jaGFyX2NvdW50ID0gMDtcclxuXHR9XHJcblx0XHJcblx0Ly8gU3Vic3RpdHV0aW9uc1xyXG5cdGZ1bmN0aW9uIFN1YnN0aXR1dGlvbiggbGlua3MsIGF0dHJzICkge1xyXG5cdFx0bGlua3MgPSBsaW5rcyB8fCB7fTtcclxuXHRcdGF0dHJzID0gYXR0cnMgfHwge307XHJcblx0XHR0aGlzLmxpbmtzID0gbGlua3M7XHJcblx0XHR0aGlzLmF0dHJzID0gYXR0cnM7XHJcblx0fVxyXG5cdFxyXG5cdC8vIFN0YXRlc1xyXG5cdGZ1bmN0aW9uIFN0YXRlKCBnb2FsLCBzdWJzLCBwYXJlbnQgKSB7XHJcblx0XHRzdWJzID0gc3VicyB8fCBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRwYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcclxuXHRcdHRoaXMuZ29hbCA9IGdvYWw7XHJcblx0XHR0aGlzLnN1YnN0aXR1dGlvbiA9IHN1YnM7XHJcblx0XHR0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuXHR9XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRmdW5jdGlvbiBSdWxlKCBoZWFkLCBib2R5LCBkeW5hbWljICkge1xyXG5cdFx0dGhpcy5oZWFkID0gaGVhZDtcclxuXHRcdHRoaXMuYm9keSA9IGJvZHk7XHJcblx0XHR0aGlzLmR5bmFtaWMgPSBkeW5hbWljID8gZHluYW1pYyA6IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0Ly8gU2Vzc2lvblxyXG5cdGZ1bmN0aW9uIFNlc3Npb24oIGxpbWl0ICkge1xyXG5cdFx0bGltaXQgPSB0eXBlb2YgbGltaXQgPT09IFwibnVtYmVyXCIgJiYgbGltaXQgPiAwID8gbGltaXQgOiBudWxsO1xyXG5cdFx0dGhpcy5yZW5hbWUgPSAwO1xyXG5cdFx0dGhpcy5tb2R1bGVzID0ge307XHJcblx0XHR0aGlzLm1vZHVsZXMudXNlciA9IG5ldyBNb2R1bGUoXCJ1c2VyXCIsIHt9LCBcImFsbFwiLCB7XHJcblx0XHRcdHNlc3Npb246IHRoaXMsXHJcblx0XHRcdGRlcGVuZGVuY2llczogW1wic3lzdGVtXCJdXHJcblx0XHR9KTtcclxuXHRcdHRoaXMubW9kdWxlcy5zeXN0ZW0gPSBwbC5tb2R1bGVzLnN5c3RlbTtcclxuXHRcdHRoaXMucnVsZXMgPSB0aGlzLm1vZHVsZXMudXNlci5ydWxlcztcclxuXHRcdHRoaXMudG90YWxfdGhyZWFkcyA9IDA7XHJcblx0XHR0aGlzLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHR0aGlzLnB1YmxpY19wcmVkaWNhdGVzID0gdGhpcy5tb2R1bGVzLnVzZXIucHVibGljX3ByZWRpY2F0ZXM7XHJcblx0XHR0aGlzLm11bHRpZmlsZV9wcmVkaWNhdGVzID0gdGhpcy5tb2R1bGVzLnVzZXIubXVsdGlmaWxlX3ByZWRpY2F0ZXM7XHJcblx0XHR0aGlzLmxpbWl0ID0gbGltaXQ7XHJcblx0XHR0aGlzLnN0cmVhbXMgPSB7XHJcblx0XHRcdFwidXNlcl9pbnB1dFwiOiBuZXcgU3RyZWFtKFxyXG5cdFx0XHRcdG5vZGVqc19mbGFnID8gbm9kZWpzX3VzZXJfaW5wdXQgOiB0YXVfdXNlcl9pbnB1dCxcclxuXHRcdFx0XHRcInJlYWRcIiwgXCJ1c2VyX2lucHV0XCIsIFwidGV4dFwiLCBmYWxzZSwgXCJyZXNldFwiICksXHJcblx0XHRcdFwidXNlcl9vdXRwdXRcIjogbmV3IFN0cmVhbShcclxuXHRcdFx0XHRub2RlanNfZmxhZyA/IG5vZGVqc191c2VyX291dHB1dCA6IHRhdV91c2VyX291dHB1dCxcclxuXHRcdFx0XHRcImFwcGVuZFwiLCBcInVzZXJfb3V0cHV0XCIsIFwidGV4dFwiLCBmYWxzZSwgXCJyZXNldFwiICksXHJcblx0XHRcdFwidXNlcl9lcnJvclwiOiBuZXcgU3RyZWFtKFxyXG5cdFx0XHRcdG5vZGVqc19mbGFnID8gbm9kZWpzX3VzZXJfZXJyb3IgOiB0YXVfdXNlcl9lcnJvcixcclxuXHRcdFx0XHRcImFwcGVuZFwiLCBcInVzZXJfZXJyb3JcIiwgXCJ0ZXh0XCIsIGZhbHNlLCBcInJlc2V0XCIgKSxcclxuXHRcdH07XHJcblx0XHR0aGlzLmZpbGVfc3lzdGVtID0gbm9kZWpzX2ZsYWcgPyBub2RlanNfZmlsZV9zeXN0ZW0gOiB0YXVfZmlsZV9zeXN0ZW07XHJcblx0XHR0aGlzLnN0YW5kYXJkX2lucHV0ID0gdGhpcy5zdHJlYW1zW1widXNlcl9pbnB1dFwiXTtcclxuXHRcdHRoaXMuc3RhbmRhcmRfb3V0cHV0ID0gdGhpcy5zdHJlYW1zW1widXNlcl9vdXRwdXRcIl07XHJcblx0XHR0aGlzLnN0YW5kYXJkX2Vycm9yID0gdGhpcy5zdHJlYW1zW1widXNlcl9lcnJvclwiXTtcclxuXHRcdHRoaXMuY3VycmVudF9pbnB1dCA9IHRoaXMuc3RyZWFtc1tcInVzZXJfaW5wdXRcIl07XHJcblx0XHR0aGlzLmN1cnJlbnRfb3V0cHV0ID0gdGhpcy5zdHJlYW1zW1widXNlcl9vdXRwdXRcIl07XHJcblx0XHR0aGlzLndvcmtpbmdfZGlyZWN0b3J5ID0gXCIvXCI7IC8vIG9ubHkgZm9yIGJyb3dzZXJcclxuXHRcdHRoaXMuZm9ybWF0X3N1Y2Nlc3MgPSBmdW5jdGlvbiggc3RhdGUgKSB7IHJldHVybiBzdGF0ZS5zdWJzdGl0dXRpb247IH07XHJcblx0XHR0aGlzLmZvcm1hdF9lcnJvciA9IGZ1bmN0aW9uKCBzdGF0ZSApIHsgcmV0dXJuIHN0YXRlLmdvYWw7IH07XHJcblx0XHR0aGlzLmZsYWcgPSB7XHRcclxuXHRcdFx0Ym91bmRlZDogcGwuZmxhZy5ib3VuZGVkLnZhbHVlLFxyXG5cdFx0XHRtYXhfaW50ZWdlcjogcGwuZmxhZy5tYXhfaW50ZWdlci52YWx1ZSxcclxuXHRcdFx0bWluX2ludGVnZXI6IHBsLmZsYWcubWluX2ludGVnZXIudmFsdWUsXHJcblx0XHRcdGludGVnZXJfcm91bmRpbmdfZnVuY3Rpb246IHBsLmZsYWcuaW50ZWdlcl9yb3VuZGluZ19mdW5jdGlvbi52YWx1ZSxcclxuXHRcdFx0Y2hhcl9jb252ZXJzaW9uOiBwbC5mbGFnLmNoYXJfY29udmVyc2lvbi52YWx1ZSxcclxuXHRcdFx0ZGVidWc6IHBsLmZsYWcuZGVidWcudmFsdWUsXHJcblx0XHRcdG1heF9hcml0eTogcGwuZmxhZy5tYXhfYXJpdHkudmFsdWUsXHJcblx0XHRcdHVua25vd246IHBsLmZsYWcudW5rbm93bi52YWx1ZSxcclxuXHRcdFx0ZG91YmxlX3F1b3RlczogcGwuZmxhZy5kb3VibGVfcXVvdGVzLnZhbHVlLFxyXG5cdFx0XHRvY2N1cnNfY2hlY2s6IHBsLmZsYWcub2NjdXJzX2NoZWNrLnZhbHVlLFxyXG5cdFx0XHRkaWFsZWN0OiBwbC5mbGFnLmRpYWxlY3QudmFsdWUsXHJcblx0XHRcdHZlcnNpb25fZGF0YTogcGwuZmxhZy52ZXJzaW9uX2RhdGEudmFsdWUsXHJcblx0XHRcdG5vZGVqczogcGwuZmxhZy5ub2RlanMudmFsdWUsXHJcblx0XHRcdGFyZ3Y6IHBsLmZsYWcuYXJndi52YWx1ZVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuX19sb2FkZWRfbW9kdWxlcyA9IFtdO1xyXG5cdFx0dGhpcy5fX2NoYXJfY29udmVyc2lvbiA9IHt9O1xyXG5cdFx0dGhpcy5fX29wZXJhdG9ycyA9IHtcclxuXHRcdFx0MTIwMDogeyBcIjotXCI6IFtcImZ4XCIsIFwieGZ4XCJdLCAgXCItLT5cIjogW1wieGZ4XCJdLCBcIj8tXCI6IFtcImZ4XCJdIH0sXHJcblx0XHRcdDExNTA6IHsgXCJtZXRhX3ByZWRpY2F0ZVwiOiBbXCJmeFwiXSB9LFxyXG5cdFx0XHQxMTAwOiB7IFwiO1wiOiBbXCJ4ZnlcIl0gfSxcclxuXHRcdFx0MTA1MDogeyBcIi0+XCI6IFtcInhmeVwiXSwgXCIqLT5cIjogW1wieGZ5XCJdIH0sXHJcblx0XHRcdDEwMDA6IHsgXCIsXCI6IFtcInhmeVwiXSB9LFxyXG5cdFx0XHQ5MDA6IHsgXCJcXFxcK1wiOiBbXCJmeVwiXSB9LFxyXG5cdFx0XHQ3MDA6IHtcclxuXHRcdFx0XHRcIj1cIjogW1wieGZ4XCJdLCBcIlxcXFw9XCI6IFtcInhmeFwiXSwgXCI9PVwiOiBbXCJ4ZnhcIl0sIFwiXFxcXD09XCI6IFtcInhmeFwiXSxcclxuXHRcdFx0XHRcIkA8XCI6IFtcInhmeFwiXSwgXCJAPTxcIjogW1wieGZ4XCJdLCBcIkA+XCI6IFtcInhmeFwiXSwgXCJAPj1cIjogW1wieGZ4XCJdLFxyXG5cdFx0XHRcdFwiPS4uXCI6IFtcInhmeFwiXSwgXCJpc1wiOiBbXCJ4ZnhcIl0sIFwiPTo9XCI6IFtcInhmeFwiXSwgXCI9XFxcXD1cIjogW1wieGZ4XCJdLFxyXG5cdFx0XHRcdFwiPFwiOiBbXCJ4ZnhcIl0sIFwiPTxcIjogW1wieGZ4XCJdLCBcIj5cIjogW1wieGZ4XCJdLCBcIj49XCI6IFtcInhmeFwiXVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQ2MDA6IHsgXCI6XCI6IFtcInhmeVwiXSB9LFxyXG5cdFx0XHQ1MDA6IHsgXCIrXCI6IFtcInlmeFwiXSwgXCItXCI6IFtcInlmeFwiXSwgXCIvXFxcXFwiOiBbXCJ5ZnhcIl0sIFwiXFxcXC9cIjogW1wieWZ4XCJdIH0sXHJcblx0XHRcdDQwMDoge1xyXG5cdFx0XHRcdFwiKlwiOiBbXCJ5ZnhcIl0sIFwiL1wiOiBbXCJ5ZnhcIl0sIFwiLy9cIjogW1wieWZ4XCJdLCBcInJlbVwiOiBbXCJ5ZnhcIl0sXHJcblx0XHRcdFx0XCJtb2RcIjogW1wieWZ4XCJdLCBcIjw8XCI6IFtcInlmeFwiXSwgXCI+PlwiOiBbXCJ5ZnhcIl0sIFwiZGl2XCI6IFtcInlmeFwiXVxyXG5cdFx0XHR9LFxyXG5cdFx0XHQyMDA6IHsgXCIqKlwiOiBbXCJ4ZnhcIl0sIFwiXlwiOiBbXCJ4ZnlcIl0sIFwiLVwiOiBbXCJmeVwiXSwgXCIrXCI6IFtcImZ5XCJdLCBcIlxcXFxcIjogW1wiZnlcIl0gfVxyXG5cdFx0fTtcclxuXHRcdHRoaXMudGhyZWFkID0gbmV3IFRocmVhZCggdGhpcyApO1xyXG5cdH1cclxuXHRcclxuXHQvLyBUaHJlYWRzXHJcblx0ZnVuY3Rpb24gVGhyZWFkKCBzZXNzaW9uICkge1xyXG5cdFx0dGhpcy5lcG9jaCA9IERhdGUubm93KCk7XHJcblx0XHR0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xyXG5cdFx0dGhpcy5zZXNzaW9uLnRvdGFsX3RocmVhZHMrKztcclxuXHRcdHRoaXMuZm9ybWF0X3N1Y2Nlc3MgPSBzZXNzaW9uLmZvcm1hdF9zdWNjZXNzO1xyXG5cdFx0dGhpcy5mb3JtYXRfZXJyb3IgPSBzZXNzaW9uLmZvcm1hdF9lcnJvcjtcclxuXHRcdHRoaXMudG90YWxfc3RlcHMgPSAwO1xyXG5cdFx0dGhpcy5jcHVfdGltZSA9IDA7XHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdFx0dGhpcy5kZWJ1Z2dlciA9IGZhbHNlO1xyXG5cdFx0dGhpcy5kZWJ1Z2dlcl9zdGF0ZXMgPSBbXTtcclxuXHRcdHRoaXMubGV2ZWwgPSBuZXcgVGVybShcInRvcF9sZXZlbFwiKTtcclxuXHRcdHRoaXMuY3VycmVudF9saW1pdCA9IHRoaXMuc2Vzc2lvbi5saW1pdDtcclxuXHRcdHRoaXMuaGFzX2xpbWl0ID0gdGhpcy5zZXNzaW9uLmxpbWl0ICE9PSBudWxsO1xyXG5cdFx0dGhpcy53YXJuaW5ncyA9IFtdO1xyXG5cdFx0dGhpcy5fX2NhbGxzID0gW107XHJcblx0XHR0aGlzLl9fZ29hbF9leHBhbnNpb24gPSBmYWxzZTtcclxuXHRcdHRoaXMuX19zdGFja3MgPSB7fTtcclxuXHR9XHJcblx0XHJcblx0Ly8gTW9kdWxlc1xyXG5cdGZ1bmN0aW9uIE1vZHVsZShpZCwgcnVsZXMsIGV4cG9ydHMsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID09PSB1bmRlZmluZWQgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzID0gb3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlcyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zLnB1YmxpY19wcmVkaWNhdGVzO1xyXG5cdFx0b3B0aW9ucy5tdWx0aWZpbGVfcHJlZGljYXRlcyA9IG9wdGlvbnMubXVsdGlmaWxlX3ByZWRpY2F0ZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucy5tdWx0aWZpbGVfcHJlZGljYXRlcztcclxuXHRcdG9wdGlvbnMubWV0YV9wcmVkaWNhdGVzID0gb3B0aW9ucy5tZXRhX3ByZWRpY2F0ZXMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucy5tZXRhX3ByZWRpY2F0ZXM7XHJcblx0XHRvcHRpb25zLnNlc3Npb24gPSBvcHRpb25zLnNlc3Npb24gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLnNlc3Npb247XHJcblx0XHRvcHRpb25zLmRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzID09PSB1bmRlZmluZWQgPyBbXSA6IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy5ydWxlcyA9IHJ1bGVzO1xyXG5cdFx0dGhpcy5pbmRleGVkX2NsYXVzZXMgPSB7fTtcclxuXHRcdHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzID0ge307XHJcblx0XHR0aGlzLnB1YmxpY19wcmVkaWNhdGVzID0gb3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlcztcclxuXHRcdHRoaXMubXVsdGlmaWxlX3ByZWRpY2F0ZXMgPSBvcHRpb25zLm11bHRpZmlsZV9wcmVkaWNhdGVzO1xyXG5cdFx0dGhpcy5tZXRhX3ByZWRpY2F0ZXMgPSBvcHRpb25zLm1ldGFfcHJlZGljYXRlcztcclxuXHRcdHRoaXMuc3JjX3ByZWRpY2F0ZXMgPSB7fTtcclxuXHRcdHRoaXMuZGVwZW5kZW5jaWVzID0gb3B0aW9ucy5kZXBlbmRlbmNpZXM7XHJcblx0XHR0aGlzLmV4cG9ydHMgPSBleHBvcnRzO1xyXG5cdFx0dGhpcy5pc19saWJyYXJ5ID0gb3B0aW9ucy5zZXNzaW9uID09PSBudWxsO1xyXG5cdFx0dGhpcy5tb2R1bGVzID0ge307XHJcblx0XHRpZihvcHRpb25zLnNlc3Npb24pIHtcclxuXHRcdFx0b3B0aW9ucy5zZXNzaW9uLm1vZHVsZXNbaWRdID0gdGhpcztcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG9wdGlvbnMuZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIGxpYiA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzW2ldO1xyXG5cdFx0XHRcdGlmKCFvcHRpb25zLnNlc3Npb24ubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShsaWIpKVxyXG5cdFx0XHRcdFx0b3B0aW9ucy5zZXNzaW9uLm1vZHVsZXNbbGliXSA9IHBsLm1vZHVsZXNbbGliXTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGwubW9kdWxlc1tpZF0gPSB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYoZXhwb3J0cyAhPT0gXCJhbGxcIikge1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZXhwb3J0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHRoaXMucHVibGljX3ByZWRpY2F0ZXNbZXhwb3J0c1tpXV0gPVxyXG5cdFx0XHRcdFx0b3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShleHBvcnRzW2ldKSAmJlxyXG5cdFx0XHRcdFx0b3B0aW9ucy5wdWJsaWNfcHJlZGljYXRlc1tleHBvcnRzW2ldXSA9PT0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy51cGRhdGVfaW5kaWNlc19jbGF1c2VzKCk7XHJcblx0fVxyXG5cdFxyXG5cdC8vIENoZWNrIGlmIGEgcHJlZGljYXRlIGlzIGV4cG9ydGVkXHJcblx0TW9kdWxlLnByb3RvdHlwZS5leHBvcnRzX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvcikge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXhwb3J0cyA9PT0gXCJhbGxcIiB8fCBpbmRleE9mKHRoaXMuZXhwb3J0cywgaW5kaWNhdG9yKSAhPT0gLTE7XHJcblx0fTtcclxuXHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgcHVibGljXHJcblx0TW9kdWxlLnByb3RvdHlwZS5pc19wdWJsaWNfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMucHVibGljX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSB8fCB0aGlzLnB1YmxpY19wcmVkaWNhdGVzW2luZGljYXRvcl0gPT09IHRydWU7XHJcblx0fTtcclxuXHRcclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBtdWx0aWZpbGVcclxuXHRNb2R1bGUucHJvdG90eXBlLmlzX211bHRpZmlsZV9wcmVkaWNhdGUgPSBmdW5jdGlvbiggaW5kaWNhdG9yICkge1xyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlmaWxlX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSAmJiB0aGlzLm11bHRpZmlsZV9wcmVkaWNhdGVzW2luZGljYXRvcl0gPT09IHRydWU7XHJcblx0fTtcclxuXHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgYSBtZXRhLXByZWRpY2F0ZVxyXG5cdE1vZHVsZS5wcm90b3R5cGUuaXNfbWV0YV9wcmVkaWNhdGUgPSBmdW5jdGlvbiggaW5kaWNhdG9yICkge1xyXG5cdFx0aWYodGhpcy5tZXRhX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkoaW5kaWNhdG9yKSlcclxuXHRcdFx0cmV0dXJuIHRoaXMubWV0YV9wcmVkaWNhdGVzW2luZGljYXRvcl07XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvLyBVcGRhdGUgaW5kaWNlcyBvZiBhbGwgcHJlZGljYXRlc1xyXG5cdE1vZHVsZS5wcm90b3R5cGUudXBkYXRlX2luZGljZXNfY2xhdXNlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5pbmRleGVkX2NsYXVzZXMgPSB7fTtcclxuXHRcdHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzID0ge307XHJcblx0XHRmb3IodmFyIGluZGljYXRvciBpbiB0aGlzLnJ1bGVzKVxyXG5cdFx0XHR0aGlzLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZShpbmRpY2F0b3IpO1xyXG5cdH07XHJcblxyXG5cdC8vIFVwZGF0ZSBpbmRpY2VzIG9mIGEgcHJlZGljYXRlXHJcblx0TW9kdWxlLnByb3RvdHlwZS51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IpIHtcclxuXHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl0gPSB7fTtcclxuXHRcdHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl0gPSBbXTtcclxuXHRcdGlmKCFBcnJheS5pc0FycmF5KHRoaXMucnVsZXNbaW5kaWNhdG9yXSkpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnJ1bGVzW2luZGljYXRvcl0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGNsYXVzZSA9IHRoaXMucnVsZXNbaW5kaWNhdG9yXVtpXTtcclxuXHRcdFx0dGhpcy5hZGRfaW5kZXhfcHJlZGljYXRlKGNsYXVzZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Ly8gQWRkIGluZGV4ZWQgY2x1dXNlIHRvIGEgcHJlZGljYXRlXHJcblx0TW9kdWxlLnByb3RvdHlwZS5hZGRfaW5kZXhfcHJlZGljYXRlID0gZnVuY3Rpb24oY2xhdXNlKSB7XHJcblx0XHR2YXIgaW5kaWNhdG9yID0gY2xhdXNlLmhlYWQuaW5kaWNhdG9yO1xyXG5cdFx0dmFyIGluZGV4ID0gY2xhdXNlLmhlYWQuYXJncy5sZW5ndGggPiAwID8gY2xhdXNlLmhlYWQuYXJnc1swXS5pbmRleCA6IHVuZGVmaW5lZDtcclxuXHRcdGlmKGluZGV4KSB7XHJcblx0XHRcdGlmKCF0aGlzLmluZGV4ZWRfY2xhdXNlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKVxyXG5cdFx0XHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl0gPSB7fTtcclxuXHRcdFx0aWYoIXRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl0uaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XHJcblx0XHRcdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXVtpbmRleF0gPSBbXTtcclxuXHRcdFx0XHRpZih0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKVxyXG5cdFx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IHRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzW2luZGljYXRvcl0ubGVuZ3RoOyBqKyspXHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl1baW5kZXhdLnB1c2godGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXVtqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5pbmRleGVkX2NsYXVzZXNbaW5kaWNhdG9yXVtpbmRleF0ucHVzaChjbGF1c2UpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYoIXRoaXMubm9uX2luZGV4YWJsZV9jbGF1c2VzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpXHJcblx0XHRcdFx0dGhpcy5ub25faW5kZXhhYmxlX2NsYXVzZXNbaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0XHR0aGlzLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdLnB1c2goY2xhdXNlKTtcclxuXHRcdFx0Zm9yKHZhciBpbmRleCBpbiB0aGlzLmluZGV4ZWRfY2xhdXNlc1tpbmRpY2F0b3JdKVxyXG5cdFx0XHRcdHRoaXMuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl1baW5kZXhdLnB1c2goY2xhdXNlKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIFVOSUZZIFBST0xPRyBPQkpFQ1RTXHJcblxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbihvYmosIG9jY3Vyc19jaGVjaykge1xyXG5cdFx0aWYob2NjdXJzX2NoZWNrICYmIGluZGV4T2Yob2JqLnZhcmlhYmxlcygpLCB0aGlzLmlkKSAhPT0gLTEgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUob2JqKSlcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdGxpbmtzW3RoaXMuaWRdID0gb2JqO1xyXG5cdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24obGlua3MpO1xyXG5cdH07XHJcblxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLnVuaWZ5ID0gZnVuY3Rpb24ob2JqLCBvY2N1cnNfY2hlY2spIHtcclxuXHRcdGlmKHBsLnR5cGUuaXNfbnVtYmVyKG9iaikgJiYgdGhpcy52YWx1ZSA9PT0gb2JqLnZhbHVlICYmIHRoaXMuaXNfZmxvYXQgPT09IG9iai5pc19mbG9hdClcclxuXHRcdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUudW5pZnkgPSBmdW5jdGlvbihvYmosIG9jY3Vyc19jaGVjaykge1xyXG5cdFx0aWYoIXBsLnR5cGUuaXNfdGVybShvYmopICYmIG9iai51bmlmeSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBvYmoudW5pZnkodGhpcywgb2NjdXJzX2NoZWNrKTtcclxuXHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX3Rlcm0ob2JqKSAmJiB0aGlzLmluZGljYXRvciA9PT0gb2JqLmluZGljYXRvcikge1xyXG5cdFx0XHR2YXIgc3VicyA9IG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeSh0aGlzLmFyZ3NbaV0uYXBwbHkoc3VicyksIG9iai5hcmdzW2ldLmFwcGx5KHN1YnMpLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0XHRcdGlmKG1ndSA9PT0gbnVsbClcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdGZvcih2YXIgeCBpbiBtZ3UubGlua3MpXHJcblx0XHRcdFx0XHRzdWJzLmxpbmtzW3hdID0gbWd1LmxpbmtzW3hdO1xyXG5cdFx0XHRcdHN1YnMgPSBzdWJzLmFwcGx5KG1ndSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHN1YnM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS51bmlmeSA9IGZ1bmN0aW9uKG9iaiwgX29jY3Vyc19jaGVjaykge1xyXG5cdFx0aWYocGwudHlwZS5pc19zdHJlYW0ob2JqKSAmJiB0aGlzLmlkID09PSBvYmouaWQpXHJcblx0XHRcdHJldHVybiBuZXcgU3Vic3RpdHV0aW9uKCk7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHRTdHJlYW0ucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbihvYmopIHtcclxuXHRcdGlmKHRoaXMuaWQgPCBvYmouaWQpXHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdGVsc2UgaWYodGhpcy5pZCA9PT0gb2JqLmlkKVxyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdGVsc2VcclxuXHRcdFx0cmV0dXJuIDE7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHJcblx0Ly8gUFJPTE9HIE9CSkVDVFMgVE8gU1RSSU5HXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdGlmKG9wdGlvbnMudmFyaWFibGVfbmFtZXMpIHtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSBvcHRpb25zLnZhcmlhYmxlX25hbWVzO1xyXG5cdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHR2YXIgaGVhZCA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oaGVhZCkgJiYgaGVhZC5pbmRpY2F0b3IgPT09IFwiPS8yXCJcclxuXHRcdFx0XHQmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQuYXJnc1sxXSkgJiYgaGVhZC5hcmdzWzFdLmlkID09PSB0aGlzLmlkXHJcblx0XHRcdFx0JiYgcGwudHlwZS5pc19hdG9tKGhlYWQuYXJnc1swXSkpXHJcblx0XHRcdFx0XHRyZXR1cm4gaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmlkO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggXyApIHtcclxuXHRcdHZhciBzdHIgPSB0aGlzLnZhbHVlLnRvU3RyaW5nKCk7XHJcblx0XHR2YXIgZSA9IHN0ci5pbmRleE9mKFwiZVwiKTtcclxuXHRcdGlmKGUgIT09IC0xKSB7XHJcblx0XHRcdGlmKHN0ci5pbmRleE9mKFwiLlwiKSAhPT0gLTEpXHJcblx0XHRcdFx0cmV0dXJuIHN0cjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBzdHIucmVwbGFjZShcImVcIiwgXCIuMGVcIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5pc19mbG9hdCAmJiBpbmRleE9mKHN0ciwgXCIuXCIpID09PSAtMSA/IHRoaXMudmFsdWUgKyBcIi4wXCIgOiBzdHI7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMsIHByaW9yaXR5LCBmcm9tICkge1xyXG5cdFx0b3B0aW9ucyA9ICFvcHRpb25zID8ge30gOiBvcHRpb25zO1xyXG5cdFx0b3B0aW9ucy5xdW90ZWQgPSBvcHRpb25zLnF1b3RlZCA9PT0gdW5kZWZpbmVkID8gZmFsc2U6IG9wdGlvbnMucXVvdGVkO1xyXG5cdFx0b3B0aW9ucy5pZ25vcmVfb3BzID0gb3B0aW9ucy5pZ25vcmVfb3BzID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMuaWdub3JlX29wcztcclxuXHRcdG9wdGlvbnMubnVtYmVydmFycyA9IG9wdGlvbnMubnVtYmVydmFycyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLm51bWJlcnZhcnM7XHJcblx0XHRvcHRpb25zLnZhcmlhYmxlX25hbWVzID0gb3B0aW9ucy52YXJpYWJsZV9uYW1lcyA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLnZhcmlhYmxlX25hbWVzO1xyXG5cdFx0cHJpb3JpdHkgPSBwcmlvcml0eSA9PT0gdW5kZWZpbmVkID8ge3ByaW9yaXR5OiAxMjAwLCBjbGFzczogXCJcIiwgaW5kaWNhdG9yOiBcIlwifSA6IHByaW9yaXR5O1xyXG5cdFx0ZnJvbSA9IGZyb20gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBmcm9tO1xyXG5cdFx0dmFyIGFyZ19wcmlvcml0eSA9IHtwcmlvcml0eTogOTk5LCBjbGFzczogXCJcIiwgaW5kaWNhdG9yOiBcIlwifTtcclxuXHRcdGlmKCBvcHRpb25zLm51bWJlcnZhcnMgJiYgdGhpcy5pbmRpY2F0b3IgPT09IFwiJFZBUi8xXCIgJiYgcGwudHlwZS5pc19pbnRlZ2VyKCB0aGlzLmFyZ3NbMF0gKSAmJiB0aGlzLmFyZ3NbMF0udmFsdWUgPj0gMCApIHtcclxuXHRcdFx0dmFyIGkgPSB0aGlzLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdHZhciBudW1iZXIgPSBNYXRoLmZsb29yKCBpLzI2ICk7XHJcblx0XHRcdHZhciBsZXR0ZXIgPSAgaSAlIDI2O1xyXG5cdFx0XHRyZXR1cm4gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiW2xldHRlcl0gKyAobnVtYmVyICE9PSAwID8gbnVtYmVyIDogXCJcIik7XHJcblx0XHR9XHJcblx0XHRzd2l0Y2goIHRoaXMuaW5kaWNhdG9yICl7XHJcblx0XHRcdGNhc2UgXCJbXS8wXCI6XHJcblx0XHRcdGNhc2UgXCJ7fS8wXCI6XHJcblx0XHRcdGNhc2UgXCIhLzBcIjpcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5pZDtcclxuXHRcdFx0Y2FzZSBcInt9LzFcIjpcclxuXHRcdFx0XHRpZiggb3B0aW9ucy5pZ25vcmVfb3BzID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBcIntcIiArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucyApICsgXCJ9XCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBcInt9KFwiICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdGNhc2UgXCIuLzJcIjpcclxuXHRcdFx0XHRpZiggb3B0aW9ucy5pZ25vcmVfb3BzID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdHZhciBsaXN0ID0gXCJbXCIgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMsIGFyZ19wcmlvcml0eSApO1xyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QgKz0gXCIsXCIgKyBwb2ludGVyLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMsIGFyZ19wcmlvcml0eSApO1xyXG5cdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdFx0bGlzdCArPSBcInxcIiArIHBvaW50ZXIudG9TdHJpbmcoIG9wdGlvbnMsIGFyZ19wcmlvcml0eSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bGlzdCArPSBcIl1cIjtcclxuXHRcdFx0XHRcdHJldHVybiBsaXN0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR2YXIgaWQgPSB0aGlzLmlkO1xyXG5cdFx0XHRcdHZhciBvcGVyYXRvciA9IG9wdGlvbnMuc2Vzc2lvbiA/IG9wdGlvbnMuc2Vzc2lvbi5sb29rdXBfb3BlcmF0b3IoIHRoaXMuaWQsIHRoaXMuYXJncy5sZW5ndGggKSA6IG51bGw7XHJcblx0XHRcdFx0aWYoIG9wdGlvbnMuc2Vzc2lvbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlX29wcyB8fCBvcGVyYXRvciA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdGlmKCBvcHRpb25zLnF1b3RlZCAmJiAoISAvXighfFthLXpdWzAtOWEtekEtWl9dKnxbI1xcJFxcJlxcKlxcK1xcLVxcLlxcL1xcOlxcPFxcPVxcPlxcP1xcQFxcXlxcflxcXFxdKykkLy50ZXN0KCBpZCApICYmIGlkICE9PSBcInt9XCIgJiYgaWQgIT09IFwiW11cIiB8fCBpbmRleE9mKFtcIi5cIixcIixcIixcIjtcIl0sIGlkKSAhPT0gLTEgfHwgaWQuc3Vic3RyaW5nKDAsMikgPT09IFwiLypcIikgKVxyXG5cdFx0XHRcdFx0XHRpZCA9IFwiJ1wiICsgcmVkb0VzY2FwZShpZCkgKyBcIidcIjtcclxuXHRcdFx0XHRcdGlmKCB0aGlzLmFyZ3MubGVuZ3RoID09PSAwICYmIGlzX2dyYXBoaWNfdG9rZW4odGhpcy5pZCkgJiYgcHJpb3JpdHkuaW5kaWNhdG9yICE9PSBcIlwiKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gXCIoXCIgKyBpZCArIFwiKVwiO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGlkICsgKHRoaXMuYXJncy5sZW5ndGggPiAwID8gXCIoXCIgKyBtYXAoIHRoaXMuYXJncyxcclxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24oeCkgeyByZXR1cm4geC50b1N0cmluZyhvcHRpb25zLCBhcmdfcHJpb3JpdHkpOyB9XHJcblx0XHRcdFx0XHQpLmpvaW4oXCIsXCIpICsgXCIpXCIgOiBcIlwiKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIHByaW9yaXR5X29wID0gcGFyc2VJbnQob3BlcmF0b3IucHJpb3JpdHkpO1xyXG5cdFx0XHRcdFx0dmFyIHByaW9yaXR5X2FyZyA9IHBhcnNlSW50KHByaW9yaXR5LnByaW9yaXR5KTtcclxuXHRcdFx0XHRcdHZhciBjb25kID0gcHJpb3JpdHlfb3AgPiBwcmlvcml0eV9hcmcgfHwgcHJpb3JpdHlfb3AgPT09IHByaW9yaXR5X2FyZyAmJiAoXHJcblx0XHRcdFx0XHRcdG9wZXJhdG9yLmNsYXNzID09PSBcInhmeFwiIHx8XHJcblx0XHRcdFx0XHRcdG9wZXJhdG9yLmNsYXNzID09PSBcInhmeVwiICYmIHRoaXMuaW5kaWNhdG9yICE9PSBwcmlvcml0eS5pbmRpY2F0b3IgfHxcclxuXHRcdFx0XHRcdFx0b3BlcmF0b3IuY2xhc3MgPT09IFwieWZ4XCIgJiYgdGhpcy5pbmRpY2F0b3IgIT09IHByaW9yaXR5LmluZGljYXRvciB8fFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGljYXRvciA9PT0gcHJpb3JpdHkuaW5kaWNhdG9yICYmIG9wZXJhdG9yLmNsYXNzID09PSBcInlmeFwiICYmIGZyb20gPT09IFwicmlnaHRcIiB8fFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGljYXRvciA9PT0gcHJpb3JpdHkuaW5kaWNhdG9yICYmIG9wZXJhdG9yLmNsYXNzID09PSBcInhmeVwiICYmIGZyb20gPT09IFwibGVmdFwiIHx8XHJcblx0XHRcdFx0XHRcdHRoaXMuaW5kaWNhdG9yID09PSBwcmlvcml0eS5pbmRpY2F0b3IgJiYgb3BlcmF0b3IuY2xhc3MgPT09IFwieGZcIiAmJiBmcm9tID09PSBcImxlZnRcIiB8fFxyXG5cdFx0XHRcdFx0XHR0aGlzLmluZGljYXRvciA9PT0gcHJpb3JpdHkuaW5kaWNhdG9yICYmIG9wZXJhdG9yLmNsYXNzID09PSBcImZ4XCIgJiYgZnJvbSA9PT0gXCJyaWdodFwiKTtcclxuXHRcdFx0XHRcdG9wZXJhdG9yLmluZGljYXRvciA9IHRoaXMuaW5kaWNhdG9yO1xyXG5cdFx0XHRcdFx0dmFyIGxwYXIgPSBjb25kID8gXCIoXCIgOiBcIlwiO1xyXG5cdFx0XHRcdFx0dmFyIHJwYXIgPSBjb25kID8gXCIpXCIgOiBcIlwiO1xyXG5cdFx0XHRcdFx0dmFyIHNwYWNlID0gIShpc19ncmFwaGljX3Rva2VuKHRoaXMuaWQpIHx8IHRoaXMuaWQgPT09IFwiLFwiIHx8IHRoaXMuaWQgPT09IFwiO1wiKVxyXG5cdFx0XHRcdFx0XHR8fCBvcGVyYXRvci5jbGFzcy5sZW5ndGggPT09IDJcclxuXHRcdFx0XHRcdFx0fHwgb3BlcmF0b3IuY2xhc3MubGVuZ3RoID09PSAzICYmIHBsLnR5cGUuaXNfbnVtYmVyKHRoaXMuYXJnc1sxXSkgJiYgdGhpcy5hcmdzWzFdLnZhbHVlIDwgMCA/IFwiIFwiIDogXCJcIjtcclxuXHRcdFx0XHRcdGlmKCB0aGlzLmFyZ3MubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbHBhciArIHRoaXMuaWQgKyBycGFyO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBbXCJmeVwiLFwiZnhcIl0uaW5kZXhPZiggb3BlcmF0b3IuY2xhc3MpICE9PSAtMSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGxwYXIgKyBpZCArIHNwYWNlICsgdGhpcy5hcmdzWzBdLnRvU3RyaW5nKCBvcHRpb25zLCBvcGVyYXRvciwgXCJyaWdodFwiICkgKyBycGFyO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBbXCJ5ZlwiLFwieGZcIl0uaW5kZXhPZiggb3BlcmF0b3IuY2xhc3MpICE9PSAtMSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGxwYXIgKyB0aGlzLmFyZ3NbMF0udG9TdHJpbmcoIG9wdGlvbnMsIG9wZXJhdG9yLCBcImxlZnRcIiApICsgc3BhY2UgKyBpZCArIHJwYXI7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbHBhciArIHRoaXMuYXJnc1swXS50b1N0cmluZyggb3B0aW9ucywgb3BlcmF0b3IsIFwibGVmdFwiICkgKyBzcGFjZSArIHRoaXMuaWQgKyBzcGFjZSArIHRoaXMuYXJnc1sxXS50b1N0cmluZyggb3B0aW9ucywgb3BlcmF0b3IsIFwicmlnaHRcIiApICsgIHJwYXI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIF8gKSB7XHJcblx0XHRyZXR1cm4gXCI8c3RyZWFtPihcIiArIHRoaXMuaWQgKyBcIilcIjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN1YnN0aXR1dGlvbnNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHR2YXIgc3RyID0gXCJ7XCI7XHJcblx0XHRmb3IoIHZhciBsaW5rIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKSBjb250aW51ZTtcclxuXHRcdFx0aWYoIHN0ciAhPT0gXCJ7XCIgKSB7XHJcblx0XHRcdFx0c3RyICs9IFwiLCBcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHIgKz0gbGluayArIFwiL1wiICsgdGhpcy5saW5rc1tsaW5rXS50b1N0cmluZyggb3B0aW9ucyApO1xyXG5cdFx0fVxyXG5cdFx0c3RyICs9IFwifVwiO1xyXG5cdFx0cmV0dXJuIHN0cjtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFN0YXRlc1xyXG5cdFN0YXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0aWYoIHRoaXMuZ29hbCA9PT0gbnVsbCApIHtcclxuXHRcdFx0cmV0dXJuIFwiPFwiICsgdGhpcy5zdWJzdGl0dXRpb24udG9TdHJpbmcoIG9wdGlvbnMgKSArIFwiPlwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFwiPFwiICsgdGhpcy5nb2FsLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIiwgXCIgKyB0aGlzLnN1YnN0aXR1dGlvbi50b1N0cmluZyggb3B0aW9ucyApICsgXCI+XCI7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0XHRpZiggIXRoaXMuYm9keSApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC50b1N0cmluZyggb3B0aW9ucyApICsgXCIuXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLnRvU3RyaW5nKCBvcHRpb25zLCAxMjAwLCBcImxlZnRcIiApICsgXCIgOi0gXCIgKyB0aGlzLmJvZHkudG9TdHJpbmcoIG9wdGlvbnMsIDEyMDAsIFwicmlnaHRcIiApICsgXCIuXCI7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBTZXNzaW9uXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIHRoaXMubW9kdWxlcykge1xyXG5cdFx0XHRpZih0aGlzLm1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgdGhpcy5tb2R1bGVzW3Byb3BdLmlzX2xpYnJhcnkpXHJcblx0XHRcdFx0c3RyICs9IFwiOi0gdXNlX21vZHVsZShsaWJyYXJ5KFwiICsgdGhpcy5tb2R1bGVzW3Byb3BdICsgXCIpKS5cXG5cIjtcclxuXHRcdH1cclxuXHRcdHN0ciArPSBcIlxcblwiO1xyXG5cdFx0Zm9yKHZhciBrZXkgaW4gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXMpIHtcclxuXHRcdFx0aWYoIXRoaXMubW9kdWxlcy51c2VyLnJ1bGVzLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRmb3IoaSA9IDA7IGkgPCB0aGlzLm1vZHVsZXMudXNlci5ydWxlc1trZXldLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0c3RyICs9IHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzW2tleV1baV0udG9TdHJpbmcob3B0aW9ucyk7XHJcblx0XHRcdFx0c3RyICs9IFwiXFxuXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHI7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBDTE9ORSBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgVmFyKCB0aGlzLmlkICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBOdW0oIHRoaXMudmFsdWUsIHRoaXMuaXNfZmxvYXQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciB0ZXJtID0gbmV3IFRlcm0oIHRoaXMuaWQsIG1hcCggdGhpcy5hcmdzLCBmdW5jdGlvbiggYXJnICkge1xyXG5cdFx0XHRyZXR1cm4gYXJnLmNsb25lKCk7XHJcblx0XHR9ICkgKTtcclxuXHRcdGlmKHRoaXMuZGVmaW5pdGlvbl9tb2R1bGUpXHJcblx0XHRcdHRlcm0uZGVmaW5pdGlvbl9tb2R1bGUgPSB0aGlzLmRlZmluaXRpb25fbW9kdWxlO1xyXG5cdFx0cmV0dXJuIHRlcm07XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgU3RyZWFtKCB0aGlzLnN0cmVhbSwgdGhpcy5tb2RlLCB0aGlzLmFsaWFzLCB0aGlzLnR5cGUsIHRoaXMucmVwb3NpdGlvbiwgdGhpcy5lb2ZfYWN0aW9uICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBTdWJzdGl0dXRpb25zXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGxpbmtzID0ge307XHJcblx0XHR2YXIgYXR0cnMgPSB7fTtcclxuXHRcdGZvciggdmFyIGxpbmsgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpIGNvbnRpbnVlO1xyXG5cdFx0XHRsaW5rc1tsaW5rXSA9IHRoaXMubGlua3NbbGlua10uY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdGZvciggdmFyIGF0dHIgaW4gdGhpcy5hdHRycyApIHtcclxuXHRcdFx0aWYoIXRoaXMuYXR0cnMuaGFzT3duUHJvcGVydHkoYXR0cnMpKSBjb250aW51ZTtcclxuXHRcdFx0YXR0cnNbYXR0cl0gPSB7fTtcclxuXHRcdFx0Zm9yKCB2YXIgbSBpbiB0aGlzLmF0dHJzW2F0dHJdICkge1xyXG5cdFx0XHRcdGlmKCF0aGlzLmF0dHJzW2F0dHJdLmhhc093blByb3BlcnR5KG0pKSBjb250aW51ZTtcclxuXHRcdFx0XHRhdHRyc1thdHRyXVttXSA9IHRoaXMuYXR0cnNbYXR0cl1bbV0uY2xvbmUoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oIGxpbmtzLCBhdHRycyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3RhdGVzXHJcblx0U3RhdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0YXRlKCB0aGlzLmdvYWwuY2xvbmUoKSwgdGhpcy5zdWJzdGl0dXRpb24uY2xvbmUoKSwgdGhpcy5wYXJlbnQgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBuZXcgUnVsZSggdGhpcy5oZWFkLmNsb25lKCksIHRoaXMuYm9keSAhPT0gbnVsbCA/IHRoaXMuYm9keS5jbG9uZSgpIDogbnVsbCApO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQ09NUEFSRSBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmogKSAmJiB0aGlzLmlkID09PSBvYmouaWQ7XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfbnVtYmVyKCBvYmogKSAmJiB0aGlzLnZhbHVlID09PSBvYmoudmFsdWUgJiYgdGhpcy5pc19mbG9hdCA9PT0gb2JqLmlzX2Zsb2F0O1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0aWYoICFwbC50eXBlLmlzX3Rlcm0oIG9iaiApIHx8IHRoaXMuaW5kaWNhdG9yICE9PSBvYmouaW5kaWNhdG9yICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0aWYoICF0aGlzLmFyZ3NbaV0uZXF1YWxzKCBvYmouYXJnc1tpXSApICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0Ly8gU3RyZWFtc1xyXG5cdFN0cmVhbS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX3N0cmVhbSggb2JqICkgJiYgdGhpcy5pZCA9PT0gb2JqLmlkO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3Vic3RpdHV0aW9uc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHR2YXIgbGluaztcclxuXHRcdGlmKCAhcGwudHlwZS5pc19zdWJzdGl0dXRpb24oIG9iaiApICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRmb3IoIGxpbmsgaW4gdGhpcy5saW5rcyApIHtcclxuXHRcdFx0aWYoIXRoaXMubGlua3MuaGFzT3duUHJvcGVydHkobGluaykpIGNvbnRpbnVlO1xyXG5cdFx0XHRpZiggIW9iai5saW5rc1tsaW5rXSB8fCAhdGhpcy5saW5rc1tsaW5rXS5lcXVhbHMoIG9iai5saW5rc1tsaW5rXSApICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Zm9yKCBsaW5rIGluIG9iai5saW5rcyApIHtcclxuXHRcdFx0aWYoIW9iai5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSkgY29udGludWU7XHJcblx0XHRcdGlmKCAhdGhpcy5saW5rc1tsaW5rXSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3RhdGVzXHJcblx0U3RhdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19zdGF0ZSggb2JqICkgJiYgdGhpcy5nb2FsLmVxdWFscyggb2JqLmdvYWwgKSAmJiB0aGlzLnN1YnN0aXR1dGlvbi5lcXVhbHMoIG9iai5zdWJzdGl0dXRpb24gKSAmJiB0aGlzLnBhcmVudCA9PT0gb2JqLnBhcmVudDtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdHJldHVybiBwbC50eXBlLmlzX3J1bGUoIG9iaiApICYmIHRoaXMuaGVhZC5lcXVhbHMoIG9iai5oZWFkICkgJiYgKHRoaXMuYm9keSA9PT0gbnVsbCAmJiBvYmouYm9keSA9PT0gbnVsbCB8fCB0aGlzLmJvZHkgIT09IG51bGwgJiYgdGhpcy5ib2R5LmVxdWFscyggb2JqLmJvZHkgKSk7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBSRU5BTUUgVkFSSUFCTEVTIE9GIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0cmV0dXJuIHRocmVhZC5nZXRfZnJlZV92YXJpYWJsZSggdGhpcyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24oIF8gKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdC8vIGdyb3VuZFxyXG5cdFx0aWYodGhpcy5ncm91bmQpXHJcblx0XHRcdHJldHVybiBuZXcgVGVybSh0aGlzLmlkLCB0aGlzLmFyZ3MpO1xyXG5cdFx0Ly8gbGlzdFxyXG5cdFx0aWYodGhpcy5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXM7XHJcblx0XHRcdHdoaWxlKHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICYmICFwb2ludGVyLmdyb3VuZCkge1xyXG5cdFx0XHRcdHZhciBhcHAgPSBwb2ludGVyLmFyZ3NbMF0ucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdFx0YXJyLnB1c2goYXBwKTtcclxuXHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsaXN0ID0gcG9pbnRlci5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0Zm9yKHZhciBpID0gYXJyLmxlbmd0aC0xOyBpID49IDA7IGktLSlcclxuXHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oXCIuXCIsIFthcnJbaV0sIGxpc3RdKTtcclxuXHRcdFx0cmV0dXJuIGxpc3Q7XHJcblx0XHR9XHJcblx0XHQvLyBjb21wb3VuZCB0ZXJtXHJcblx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgYXBwID0gdGhpcy5hcmdzW2ldLnJlbmFtZSh0aHJlYWQpO1xyXG5cdFx0XHRhcmdzLnB1c2goYXBwKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVGVybSh0aGlzLmlkLCBhcmdzKTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS5yZW5hbWUgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHRcclxuXHQvLyBSdWxlc1xyXG5cdFJ1bGUucHJvdG90eXBlLnJlbmFtZSA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRyZXR1cm4gbmV3IFJ1bGUoIHRoaXMuaGVhZC5yZW5hbWUoIHRocmVhZCApLCB0aGlzLmJvZHkgIT09IG51bGwgPyB0aGlzLmJvZHkucmVuYW1lKCB0aHJlYWQgKSA6IG51bGwgKTtcclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIENIRUNLIElGIFJFTkFNRVxyXG5cclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmlzX3JlbmFtZSA9IGZ1bmN0aW9uKG9iaiwgbGlua3MpIHtcclxuXHRcdGxpbmtzID0gbGlua3MgfHwge307XHJcblx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShvYmopXHJcblx0XHR8fCBsaW5rcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmlkKSAmJiBsaW5rc1t0aGlzLmlkXSAhPT0gb2JqLmlkXHJcblx0XHR8fCBsaW5rcy5oYXNPd25Qcm9wZXJ0eShvYmouaWQpICYmIGxpbmtzW29iai5pZF0gIT09IHRoaXMuaWQpXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdGxpbmtzW3RoaXMuaWRdID0gb2JqLmlkO1xyXG5cdFx0bGlua3Nbb2JqLmlkXSA9IHRoaXMuaWQ7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmlzX3JlbmFtZSA9IGZ1bmN0aW9uKG9iaiwgX2xpbmtzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcXVhbHMob2JqKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuaXNfcmVuYW1lID0gZnVuY3Rpb24ob2JqLCBsaW5rcykge1xyXG5cdFx0bGlua3MgPSBsaW5rcyB8fCB7fTtcclxuXHRcdGlmKCFwbC50eXBlLmlzX3Rlcm0ob2JqKSB8fCB0aGlzLmluZGljYXRvciAhPT0gb2JqLmluZGljYXRvcilcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZighcGwuaXNfcmVuYW1lKHRoaXMuYXJnc1tpXSwgb2JqLmFyZ3NbaV0sIGxpbmtzKSlcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS5pc19yZW5hbWUgPSBmdW5jdGlvbihvYmosIF9saW5rcykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXF1YWxzKG9iaik7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBHRVQgSUQgT0YgVkFSSUFCTEVTIEZST00gUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFt0aGlzLmlkXTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLnZhcmlhYmxlcyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFtdO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMuZ3JvdW5kKVxyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHRyZXR1cm4gW10uY29uY2F0LmFwcGx5KCBbXSwgbWFwKCB0aGlzLmFyZ3MsIGZ1bmN0aW9uKCBhcmcgKSB7XHJcblx0XHRcdHJldHVybiBhcmcudmFyaWFibGVzKCk7XHJcblx0XHR9ICkgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBTdHJlYW1zXHJcblx0U3RyZWFtLnByb3RvdHlwZS52YXJpYWJsZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBbXTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUudmFyaWFibGVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiggdGhpcy5ib2R5ID09PSBudWxsICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWFkLnZhcmlhYmxlcygpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVhZC52YXJpYWJsZXMoKS5jb25jYXQoIHRoaXMuYm9keS52YXJpYWJsZXMoKSApO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gQVBQTFkgU1VCU1RJVFVUSU9OUyBUTyBQUk9MT0cgT0JKRUNUU1xyXG5cdFxyXG5cdC8vIFZhcmlhYmxlc1xyXG5cdFZhci5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggc3VicyApIHtcclxuXHRcdGlmKCBzdWJzLmxvb2t1cCggdGhpcy5pZCApICkge1xyXG5cdFx0XHRyZXR1cm4gc3Vicy5sb29rdXAoIHRoaXMuaWQgKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggXyApIHtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uKCBzdWJzICkge1xyXG5cdFx0Ly8gZ3JvdW5kIGF0b21cclxuXHRcdGlmKHRoaXMuZ3JvdW5kKVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdC8vIGxpc3RcclxuXHRcdGlmKHRoaXMuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0dmFyIHBvaW50ZXIgPSB0aGlzO1xyXG5cdFx0XHR3aGlsZShwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiAmJiAhcG9pbnRlci5ncm91bmQpIHtcclxuXHRcdFx0XHR2YXIgYXBwID0gcG9pbnRlci5hcmdzWzBdLmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRcdGFyci5wdXNoKGFwcCk7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbGlzdCA9IHBvaW50ZXIuYXBwbHkoc3Vicyk7XHJcblx0XHRcdGZvcih2YXIgaSA9IGFyci5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pXHJcblx0XHRcdFx0bGlzdCA9IG5ldyBUZXJtKFwiLlwiLCBbYXJyW2ldLCBsaXN0XSk7XHJcblx0XHRcdHJldHVybiBsaXN0O1xyXG5cdFx0fVxyXG5cdFx0Ly8gY29tcG91bmQgdGVybVxyXG5cdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGFwcCA9IHRoaXMuYXJnc1tpXS5hcHBseShzdWJzKTtcclxuXHRcdFx0YXJncy5wdXNoKGFwcCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFRlcm0odGhpcy5pZCwgYXJncywgdGhpcy5yZWYpO1xyXG5cdH07XHJcblxyXG5cdC8vIFN0cmVhbXNcclxuXHRTdHJlYW0ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24oIF8gKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJ1bGVzXHJcblx0UnVsZS5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggc3VicyApIHtcclxuXHRcdHJldHVybiBuZXcgUnVsZSggdGhpcy5oZWFkLmFwcGx5KCBzdWJzICksIHRoaXMuYm9keSAhPT0gbnVsbCA/IHRoaXMuYm9keS5hcHBseSggc3VicyApIDogbnVsbCApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU3Vic3RpdHV0aW9uc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiggc3VicyApIHtcclxuXHRcdHZhciBsaW5rLCBsaW5rcyA9IHt9LCBhdHRyLCBhdHRycyA9IHt9LCBtO1xyXG5cdFx0Zm9yKCBsaW5rIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGxpbmspKSBjb250aW51ZTtcclxuXHRcdFx0bGlua3NbbGlua10gPSB0aGlzLmxpbmtzW2xpbmtdLmFwcGx5KHN1YnMpO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKCBhdHRyIGluIHRoaXMuYXR0cnMgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmF0dHJzLmhhc093blByb3BlcnR5KGF0dHIpKSBjb250aW51ZTtcclxuXHRcdFx0YXR0cnNbYXR0cl0gPSB7fTtcclxuXHRcdFx0Zm9yKCBtIGluIHRoaXMuYXR0cnNbYXR0cl0gKSB7XHJcblx0XHRcdFx0aWYoIXRoaXMuYXR0cnNbYXR0cl0uaGFzT3duUHJvcGVydHkobSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGF0dHJzW2F0dHJdW21dID0gdGhpcy5hdHRyc1thdHRyXVttXS5hcHBseShzdWJzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oIGxpbmtzLCBhdHRycyApO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gU0VMRUNUSU9OIEZVTkNUSU9OXHJcblx0XHJcblx0Ly8gU2VsZWN0IHRlcm1cclxuXHRUZXJtLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBwb2ludGVyID0gdGhpcztcclxuXHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIsLzJcIilcclxuXHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdHJldHVybiBwb2ludGVyO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUmVwbGFjZSB0ZXJtXHJcblx0VGVybS5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uKCBleHByICkge1xyXG5cdFx0aWYoIHRoaXMuaW5kaWNhdG9yID09PSBcIiwvMlwiICkge1xyXG5cdFx0XHRpZiggdGhpcy5hcmdzWzBdLmluZGljYXRvciA9PT0gXCIsLzJcIiApIHtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiLFwiLCBbdGhpcy5hcmdzWzBdLnJlcGxhY2UoIGV4cHIgKSwgdGhpcy5hcmdzWzFdXSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBleHByID09PSBudWxsID8gdGhpcy5hcmdzWzFdIDogbmV3IFRlcm0oIFwiLFwiLCBbZXhwciwgdGhpcy5hcmdzWzFdXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gZXhwcjtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBTZWFyY2ggdGVybVxyXG5cdFRlcm0ucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKCBleHByICkge1xyXG5cdFx0aWYodGhpcyA9PSBleHByIHx8IHRoaXMucmVmID09PSBleHByLnJlZilcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7IGkrKyApXHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIHRoaXMuYXJnc1tpXSApICYmIHRoaXMuYXJnc1tpXS5zZWFyY2goIGV4cHIgKSApXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBQUk9MT0cgU0VTU0lPTlMgQU5EIFRIUkVBRFNcclxuXHJcblx0Ly8gUHVzaCB0byBhIGdsb2JhbCBzdGFja1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLnB1c2hfZ2xvYmFsX3N0YWNrID0gZnVuY3Rpb24oc3RhY2ssIHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHVzaF9nbG9iYWxfc3RhY2soc3RhY2ssIHZhbHVlKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUucHVzaF9nbG9iYWxfc3RhY2sgPSBmdW5jdGlvbihzdGFjaywgdmFsdWUpIHtcclxuXHRcdGlmKCF0aGlzLl9fc3RhY2tzLmhhc093blByb3BlcnR5KHN0YWNrKSlcclxuXHRcdFx0dGhpcy5fX3N0YWNrc1tzdGFja10gPSBbXTtcclxuXHRcdHRoaXMuX19zdGFja3Nbc3RhY2tdLnB1c2godmFsdWUpO1xyXG5cdH07XHJcblxyXG5cdC8vIFBvcCBhbGwgZnJvbSBhIGdsb2JhbCBzdGFja1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmZsdXNoX2dsb2JhbF9zdGFjayA9IGZ1bmN0aW9uKHN0YWNrLCB0YWlsKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHVzaF9nbG9iYWxfc3RhY2soc3RhY2ssIHRhaWwpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5mbHVzaF9nbG9iYWxfc3RhY2sgPSBmdW5jdGlvbihzdGFjaywgdGFpbCkge1xyXG5cdFx0dmFyIGxpc3QgPSB0YWlsIHx8IG5ldyBUZXJtKFwiW11cIiwgW10pO1xyXG5cdFx0aWYodGhpcy5fX3N0YWNrcy5oYXNPd25Qcm9wZXJ0eShzdGFjaykpIHtcclxuXHRcdFx0d2hpbGUodGhpcy5fX3N0YWNrc1tzdGFja10ubGVuZ3RoID4gMClcclxuXHRcdFx0XHRsaXN0ID0gbmV3IFRlcm0oXCIuXCIsIFt0aGlzLl9fc3RhY2tzW3N0YWNrXS5wb3AoKSwgbGlzdF0pO1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fX3N0YWNrc1tzdGFja107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHR9O1xyXG5cclxuXHQvLyBTZXQgbWF4IGluZmVyZW5jZXNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5zZXRNYXhJbmZlcmVuY2VzID0gZnVuY3Rpb24obWF4KSB7XHJcblx0XHR0aGlzLmxpbWl0ID0gdHlwZW9mIG1heCA9PT0gXCJudW1iZXJcIiAmJiBtYXggPiAwID8gbWF4IDogbnVsbDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuc2V0TWF4SW5mZXJlbmNlcyA9IGZ1bmN0aW9uKG1heCkge1xyXG5cdFx0dGhpcy5zZXNzaW9uLnNldE1heEluZmVyZW5jZXMobWF4KTtcclxuXHRcdHRoaXMuY3VycmVudF9saW1pdCA9IHRoaXMuc2Vzc2lvbi5saW1pdDtcclxuXHRcdHRoaXMuaGFzX2xpbWl0ID0gdGhpcy5zZXNzaW9uLmxpbWl0ICE9PSBudWxsO1xyXG5cdH07XHJcblxyXG5cdC8vIEZvcm1hdCBhbnN3ZXJcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5mb3JtYXRfYW5zd2VyID0gZnVuY3Rpb24oYW5zd2VyLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuZm9ybWF0X2Fuc3dlcihhbnN3ZXIsIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5mb3JtYXRfYW5zd2VyID0gZnVuY3Rpb24oYW5zd2VyLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gcGwuZm9ybWF0X2Fuc3dlcihhbnN3ZXIsIHRoaXMsIG9wdGlvbnMpO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBjdXJyZW50IGlucHV0XHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2N1cnJlbnRfaW5wdXQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmN1cnJlbnRfaW5wdXQ7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9jdXJyZW50X2lucHV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmdldF9jdXJyZW50X2lucHV0KCk7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IGN1cnJlbnQgb3V0cHV0XHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2N1cnJlbnRfb3V0cHV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jdXJyZW50X291dHB1dDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X2N1cnJlbnRfb3V0cHV0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmdldF9jdXJyZW50X291dHB1dCgpO1xyXG5cdH07XHJcblxyXG5cdC8vIFNldCBjdXJyZW50IGlucHV0XHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuc2V0X2N1cnJlbnRfaW5wdXQgPSBmdW5jdGlvbiggaW5wdXQgKSB7XHJcblx0XHR0aGlzLmN1cnJlbnRfaW5wdXQgPSBpbnB1dDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuc2V0X2N1cnJlbnRfaW5wdXQgPSBmdW5jdGlvbiggaW5wdXQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLnNldF9jdXJyZW50X2lucHV0KCBpbnB1dCApO1xyXG5cdH07XHJcblxyXG5cdC8vIFNldCBjdXJyZW50IG91dHB1dFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnNldF9jdXJyZW50X291dHB1dCA9IGZ1bmN0aW9uKCBvdXRwdXQgKSB7XHJcblx0XHR0aGlzLmN1cnJlbnRfb3V0cHV0ID0gb3V0cHV0O1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5zZXRfY3VycmVudF9vdXRwdXQgPSBmdW5jdGlvbiggb3V0cHV0ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5zZXRfY3VycmVudF9vdXRwdXQoIG91dHB1dCk7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IHN0cmVhbSBieSBhbGlhc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9zdHJlYW1fYnlfYWxpYXMgPSBmdW5jdGlvbiggYWxpYXMgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdHJlYW1zW2FsaWFzXTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X3N0cmVhbV9ieV9hbGlhcyA9IGZ1bmN0aW9uKCBhbGlhcyApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZ2V0X3N0cmVhbV9ieV9hbGlhcyggYWxpYXMgKTtcclxuXHR9O1xyXG5cclxuXHQvLyBPcGVuIGZpbGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5maWxlX3N5c3RlbV9vcGVuID0gZnVuY3Rpb24oIHBhdGgsIHR5cGUsIG1vZGUgKSB7XHJcblx0XHRpZih0aGlzLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJmYWxzZS8wXCIpXHJcblx0XHRcdHBhdGggPSB0aGlzLmFic29sdXRlX2ZpbGVfbmFtZShwYXRoKTtcclxuXHRcdHJldHVybiB0aGlzLmZpbGVfc3lzdGVtLm9wZW4oIHBhdGgsIHR5cGUsIG1vZGUgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZmlsZV9zeXN0ZW1fb3BlbiA9IGZ1bmN0aW9uKCBwYXRoLCB0eXBlLCBtb2RlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5maWxlX3N5c3RlbV9vcGVuKCBwYXRoLCB0eXBlLCBtb2RlICk7XHJcblx0fTtcclxuXHJcblx0Ly8gQWJzb2x1dGUgZmlsZSBuYW1lXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuYWJzb2x1dGVfZmlsZV9uYW1lID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcclxuXHRcdHZhciBhYnNvbHV0ZTtcclxuXHRcdC8vIG5vZGUuanNcclxuXHRcdGlmKHRoaXMuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiKSB7XHJcblx0XHRcdHZhciBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XHJcblx0XHRcdGFic29sdXRlID0gZmlsZW5hbWU7XHJcblx0XHRcdGZvcih2YXIgcHJvcCBpbiBwcm9jZXNzLmVudikge1xyXG5cdFx0XHRcdGlmKCFwcm9jZXNzLmVudi5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdGFic29sdXRlID0gYWJzb2x1dGUucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXCRcIiArIHByb3AsIFwiZ1wiKSwgcHJvY2Vzcy5lbnZbcHJvcF0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXRoLnJlc29sdmUoYWJzb2x1dGUpO1xyXG5cdFx0Ly8gYnJvd3NlclxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGN3ZCA9IHRoaXMud29ya2luZ19kaXJlY3Rvcnk7XHJcblx0XHRcdGlmKGZpbGVuYW1lWzBdID09PSBcIi9cIilcclxuXHRcdFx0XHRhYnNvbHV0ZSA9IGZpbGVuYW1lO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0YWJzb2x1dGUgPSBjd2QgKyAoY3dkW2N3ZC5sZW5ndGgtMV0gPT09IFwiL1wiID8gZmlsZW5hbWUgOiBcIi9cIiArIGZpbGVuYW1lKTtcclxuXHRcdFx0YWJzb2x1dGUgPSBhYnNvbHV0ZS5yZXBsYWNlKC9cXC9cXC5cXC8vZywgXCIvXCIpO1xyXG5cdFx0XHR2YXIgZGlycyA9IGFic29sdXRlLnNwbGl0KFwiL1wiKTtcclxuXHRcdFx0dmFyIGRpcnMyID0gW107XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYoZGlyc1tpXSAhPT0gXCIuLlwiKSB7XHJcblx0XHRcdFx0XHRkaXJzMi5wdXNoKGRpcnNbaV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZihkaXJzMi5sZW5ndGggIT09IDApXHJcblx0XHRcdFx0XHRcdGRpcnMyLnBvcCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRhYnNvbHV0ZSA9IGRpcnMyLmpvaW4oXCIvXCIpLnJlcGxhY2UoL1xcL1xcLiQvLCBcIi9cIik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYWJzb2x1dGU7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmFic29sdXRlX2ZpbGVfbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGN3ZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5hYnNvbHV0ZV9maWxlX25hbWUocGF0aCwgY3dkKTtcclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgY29udmVyc2lvbiBvZiB0aGUgY2hhclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmdldF9jaGFyX2NvbnZlcnNpb24gPSBmdW5jdGlvbiggY2hhciApIHtcclxuXHRcdHJldHVybiB0aGlzLl9fY2hhcl9jb252ZXJzaW9uW2NoYXJdIHx8IGNoYXI7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9jaGFyX2NvbnZlcnNpb24gPSBmdW5jdGlvbiggY2hhciApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uZ2V0X2NoYXJfY29udmVyc2lvbiggY2hhciApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUGFyc2UgYW4gZXhwcmVzc2lvblxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIHN0cmluZyApIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5wYXJzZSggc3RyaW5nICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oIHN0cmluZyApIHtcclxuXHRcdHZhciB0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKCB0aGlzICk7XHJcblx0XHR0b2tlbml6ZXIubmV3X3RleHQoIHN0cmluZyApO1xyXG5cdFx0dmFyIHRva2VucyA9IHRva2VuaXplci5nZXRfdG9rZW5zKCk7XHJcblx0XHRpZiggdG9rZW5zID09PSBudWxsIClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0dmFyIGV4cHIgPSBwYXJzZUV4cHIodGhpcywgdG9rZW5zLCAwLCB0aGlzLl9fZ2V0X21heF9wcmlvcml0eSgpLCBmYWxzZSk7XHJcblx0XHRpZiggZXhwci5sZW4gIT09IHRva2Vucy5sZW5ndGggKVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRyZXR1cm4geyB2YWx1ZTogZXhwci52YWx1ZSwgZXhwcjogZXhwciwgdG9rZW5zOiB0b2tlbnMgfTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBmbGFnIHZhbHVlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X2ZsYWcgPSBmdW5jdGlvbiggZmxhZyApIHtcclxuXHRcdHJldHVybiB0aGlzLmZsYWdbZmxhZ107XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF9mbGFnID0gZnVuY3Rpb24oIGZsYWcgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmdldF9mbGFnKCBmbGFnICk7XHJcblx0fTtcclxuXHJcblx0Ly8gQWRkIGEgcnVsZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFkZF9ydWxlID0gZnVuY3Rpb24ocnVsZSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmFkZF9ydWxlKHJ1bGUsIG9wdGlvbnMpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hZGRfcnVsZSA9IGZ1bmN0aW9uKHJ1bGUsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xyXG5cdFx0b3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tID8gb3B0aW9ucy5mcm9tIDogXCIkdGF1LWpzXCI7XHJcblx0XHR2YXIgbW9kdWxlX2lkLCBnZXRfbW9kdWxlO1xyXG5cdFx0aWYocGwudHlwZS5pc190ZXJtKHJ1bGUuaGVhZCkgJiYgcnVsZS5oZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRpZighcGwudHlwZS5pc19hdG9tKHJ1bGUuaGVhZC5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdHRoaXMudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIHJ1bGUuaGVhZC5hcmdzWzBdLCBcInRvcF9sZXZlbC8wXCIpKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0bW9kdWxlX2lkID0gcnVsZS5oZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdHJ1bGUuaGVhZCA9IHJ1bGUuaGVhZC5hcmdzWzFdO1xyXG5cdFx0fVxyXG5cdFx0aWYobW9kdWxlX2lkKSB7XHJcblx0XHRcdGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRnZXRfbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVfaWQsIHt9LCBcImFsbFwiLCB7c2Vzc2lvbjogdGhpcy5zZXNzaW9ufSk7XHJcblx0XHRcdFx0dGhpcy5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSA9IGdldF9tb2R1bGU7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdldF9tb2R1bGUgPSB0aGlzLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXTtcclxuXHRcdH1cclxuXHRcdGdldF9tb2R1bGUuc3JjX3ByZWRpY2F0ZXNbcnVsZS5oZWFkLmluZGljYXRvcl0gPSBvcHRpb25zLmZyb207XHJcblx0XHRpZighZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShydWxlLmhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW3J1bGUuaGVhZC5pbmRpY2F0b3JdID0gW107XHJcblx0XHR9XHJcblx0XHRnZXRfbW9kdWxlLnJ1bGVzW3J1bGUuaGVhZC5pbmRpY2F0b3JdLnB1c2gocnVsZSk7XHJcblx0XHRpZighZ2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShydWxlLmhlYWQuaW5kaWNhdG9yKSlcclxuXHRcdFx0Z2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1tydWxlLmhlYWQuaW5kaWNhdG9yXSA9IGZhbHNlO1xyXG5cdFx0Ly8gdXBkYXRlIHRlcm0gaW5kZXhpbmdcclxuXHRcdGdldF9tb2R1bGUuYWRkX2luZGV4X3ByZWRpY2F0ZShydWxlKTtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdC8vIFJ1biBhIGRpcmVjdGl2ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnJ1bl9kaXJlY3RpdmUgPSBmdW5jdGlvbihkaXJlY3RpdmUsIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5ydW5fZGlyZWN0aXZlKGRpcmVjdGl2ZSwgb3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnJ1bl9kaXJlY3RpdmUgPSBmdW5jdGlvbihkaXJlY3RpdmUsIG9wdGlvbnMpIHtcclxuXHRcdGlmKHBsLnR5cGUuaXNfZGlyZWN0aXZlKGRpcmVjdGl2ZSkpIHtcclxuXHRcdFx0aWYocGwuZGlyZWN0aXZlW2RpcmVjdGl2ZS5pbmRpY2F0b3JdKVxyXG5cdFx0XHRcdHJldHVybiBwbC5kaXJlY3RpdmVbZGlyZWN0aXZlLmluZGljYXRvcl0odGhpcywgZGlyZWN0aXZlLCBvcHRpb25zKTtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHJldHVybiBwbC5kaXJlY3RpdmVbZGlyZWN0aXZlLmlkICsgXCIvKlwiXSh0aGlzLCBkaXJlY3RpdmUsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IG1heGltdW0gcHJpb3JpdHkgb2YgdGhlIG9wZXJhdG9yc1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLl9fZ2V0X21heF9wcmlvcml0eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFwiMTIwMFwiO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5fX2dldF9tYXhfcHJpb3JpdHkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uX19nZXRfbWF4X3ByaW9yaXR5KCk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgbmV4dCBwcmlvcml0eSBvZiB0aGUgb3BlcmF0b3JzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuX19nZXRfbmV4dF9wcmlvcml0eSA9IGZ1bmN0aW9uKCBwcmlvcml0eSApIHtcclxuXHRcdHZhciBtYXggPSAwO1xyXG5cdFx0cHJpb3JpdHkgPSBwYXJzZUludCggcHJpb3JpdHkgKTtcclxuXHRcdGZvciggdmFyIGtleSBpbiB0aGlzLl9fb3BlcmF0b3JzICkge1xyXG5cdFx0XHRpZiggIXRoaXMuX19vcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoa2V5KSApIGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgbiA9IHBhcnNlSW50KGtleSk7XHJcblx0XHRcdGlmKCBuID4gbWF4ICYmIG4gPCBwcmlvcml0eSApIG1heCA9IG47XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbWF4LnRvU3RyaW5nKCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLl9fZ2V0X25leHRfcHJpb3JpdHkgPSBmdW5jdGlvbiggcHJpb3JpdHkgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLl9fZ2V0X25leHRfcHJpb3JpdHkoIHByaW9yaXR5ICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgY2xhc3NlcyBvZiBhbiBvcGVyYXRvclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLl9fbG9va3VwX29wZXJhdG9yX2NsYXNzZXMgPSBmdW5jdGlvbiggcHJpb3JpdHksIG9wZXJhdG9yICkge1xyXG5cdFx0aWYoIHRoaXMuX19vcGVyYXRvcnMuaGFzT3duUHJvcGVydHkoIHByaW9yaXR5ICkgJiYgdGhpcy5fX29wZXJhdG9yc1twcmlvcml0eV1bb3BlcmF0b3JdIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLl9fb3BlcmF0b3JzW3ByaW9yaXR5XVtvcGVyYXRvcl0gIHx8IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5fX2xvb2t1cF9vcGVyYXRvcl9jbGFzc2VzID0gZnVuY3Rpb24oIHByaW9yaXR5LCBvcGVyYXRvciApIHtcclxuXHRcdHJldHVybiB0aGlzLnNlc3Npb24uX19sb29rdXBfb3BlcmF0b3JfY2xhc3NlcyggcHJpb3JpdHksIG9wZXJhdG9yICk7XHJcblx0fTtcclxuXHJcblx0Ly8gR2V0IG9wZXJhdG9yXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUubG9va3VwX29wZXJhdG9yID0gZnVuY3Rpb24oIG5hbWUsIGFyaXR5ICkge1xyXG5cdFx0Zm9yKHZhciBwIGluIHRoaXMuX19vcGVyYXRvcnMpXHJcblx0XHRcdGlmKHRoaXMuX19vcGVyYXRvcnNbcF1bbmFtZV0pXHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX19vcGVyYXRvcnNbcF1bbmFtZV0ubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHRpZiggdGhpcy5fX29wZXJhdG9yc1twXVtuYW1lXVtpXS5sZW5ndGggPT09IGFyaXR5KzEgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4ge3ByaW9yaXR5OiBwLCBjbGFzczogdGhpcy5fX29wZXJhdG9yc1twXVtuYW1lXVtpXX07XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUubG9va3VwX29wZXJhdG9yID0gZnVuY3Rpb24oIG5hbWUsIGFyaXR5ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5sb29rdXBfb3BlcmF0b3IoIG5hbWUsIGFyaXR5ICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUaHJvdyBhIHdhcm5pbmdcclxuXHRTZXNzaW9uLnByb3RvdHlwZS50aHJvd193YXJuaW5nID0gZnVuY3Rpb24oIHdhcm5pbmcgKSB7XHJcblx0XHR0aGlzLnRocmVhZC50aHJvd193YXJuaW5nKCB3YXJuaW5nICk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLnRocm93X3dhcm5pbmcgPSBmdW5jdGlvbiggd2FybmluZyApIHtcclxuXHRcdHRoaXMud2FybmluZ3MucHVzaCggd2FybmluZyApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IHdhcm5pbmdzXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuZ2V0X3dhcm5pbmdzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuZ2V0X3dhcm5pbmdzKCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmdldF93YXJuaW5ncyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMud2FybmluZ3M7XHJcblx0fTtcclxuXHJcblx0Ly8gQWRkIGEgZ29hbFxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFkZF9nb2FsID0gZnVuY3Rpb24oIGdvYWwsIHVuaXF1ZSApIHtcclxuXHRcdHRoaXMudGhyZWFkLmFkZF9nb2FsKCBnb2FsLCB1bmlxdWUgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuYWRkX2dvYWwgPSBmdW5jdGlvbiggZ29hbCwgdW5pcXVlLCBwYXJlbnQgKSB7XHJcblx0XHRwYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnQgOiBudWxsO1xyXG5cdFx0aWYoIHVuaXF1ZSA9PT0gdHJ1ZSApXHJcblx0XHRcdHRoaXMucG9pbnRzID0gW107XHJcblx0XHR2YXIgdmFycyA9IGdvYWwudmFyaWFibGVzKCk7XHJcblx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKyApXHJcblx0XHRcdGxpbmtzW3ZhcnNbaV1dID0gbmV3IFZhcih2YXJzW2ldKTtcclxuXHRcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBTdGF0ZSggZ29hbCwgbmV3IFN1YnN0aXR1dGlvbihsaW5rcyksIHBhcmVudCApICk7XHJcblx0fTtcclxuXHJcblx0Ly8gQ29uc3VsdCBhIHByb2dyYW0gZnJvbSBhIHN0cmluZ1xyXG5cdFNlc3Npb24ucHJvdG90eXBlLmNvbnN1bHQgPSBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuY29uc3VsdChwcm9ncmFtLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuY29uc3VsdCA9IGZ1bmN0aW9uKHByb2dyYW0sIG9wdGlvbnMpIHtcclxuXHRcdHZhciBzdHJpbmcgPSBcIlwiLCBzdWNjZXNzID0gZmFsc2U7XHJcblx0XHR2YXIgb3B0cyA9IHt9O1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gdHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMgOiBmdW5jdGlvbigpe307XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnM7XHJcblx0XHRvcHRzLmNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZSA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0b3B0cy50ZXh0ID0gb3B0aW9ucy50ZXh0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy50ZXh0O1xyXG5cdFx0b3B0cy5odG1sID0gb3B0aW9ucy5odG1sID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5odG1sO1xyXG5cdFx0b3B0cy51cmwgPSBvcHRpb25zLnVybCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMudXJsO1xyXG5cdFx0b3B0cy5maWxlID0gb3B0aW9ucy5maWxlID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5maWxlO1xyXG5cdFx0b3B0cy5zY3JpcHQgPSBvcHRpb25zLnNjcmlwdCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuc2NyaXB0O1xyXG5cdFx0b3B0cy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzID09PSB1bmRlZmluZWQgPyBjYWxsYmFjayA6IG9wdGlvbnMuc3VjY2VzcztcclxuXHRcdG9wdHMuZXJyb3IgPSBvcHRpb25zLmVycm9yID09PSB1bmRlZmluZWQgPyBjYWxsYmFjayA6IG9wdGlvbnMuZXJyb3I7XHJcblx0XHQvLyBzdHJpbmdcclxuXHRcdGlmKHR5cGVvZiBwcm9ncmFtID09PSBcInN0cmluZ1wiKSB7XHJcblx0XHRcdHN0cmluZyA9IHByb2dyYW07XHJcblx0XHRcdC8vIHNjcmlwdCBpZFxyXG5cdFx0XHRpZihvcHRzLnNjcmlwdCAmJiB0aGlzLmdldF9mbGFnKFwibm9kZWpzXCIpLmluZGljYXRvciA9PT0gXCJmYWxzZS8wXCIgJiYgcHJvZ3JhbSAhPSBcIlwiICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cmluZykpIHtcclxuXHRcdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3RyaW5nKTtcclxuXHRcdFx0XHR2YXIgdHlwZSA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xyXG5cdFx0XHRcdGlmKHR5cGUgIT09IG51bGwgJiYgdHlwZS5yZXBsYWNlKC8gL2csIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwidGV4dC9wcm9sb2dcIikge1xyXG5cdFx0XHRcdFx0c3RyaW5nID0gc2NyaXB0LnRleHQ7XHJcblx0XHRcdFx0XHRzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gZmlsZSAobm9kZS5qcylcclxuXHRcdFx0aWYoIXN1Y2Nlc3MgJiYgb3B0cy5maWxlICYmIHRoaXMuZ2V0X2ZsYWcoXCJub2RlanNcIikuaW5kaWNhdG9yID09PSBcInRydWUvMFwiKSB7XHJcblx0XHRcdFx0dmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xyXG5cdFx0XHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0XHRcdGZzLnJlYWRGaWxlKHByb2dyYW0sIGZ1bmN0aW9uKGVycm9yLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRpZihlcnJvcikge1xyXG5cdFx0XHRcdFx0XHRvcHRzLmZpbGUgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmNvbnN1bHQocHJvZ3JhbSwgb3B0cyk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwYXJzZVByb2dyYW0odGhyZWFkLCBkYXRhLnRvU3RyaW5nKCksIG9wdHMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBodHRwIHJlcXVlc3RcclxuXHRcdFx0aWYoIXN1Y2Nlc3MgJiYgdGhpcy5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwiZmFsc2UvMFwiICYmIG9wdHMudXJsICYmIHByb2dyYW0gIT09IFwiXCIgJiYgISgvXFxzLy50ZXN0KHByb2dyYW0pKSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR2YXIgeGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHRcdFx0XHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0XHRcdFx0eGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMucmVhZHlTdGF0ZSA9PSA0KSB7XHJcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5zdGF0dXMgPT0gMjAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzdHJpbmcgPSB4aHR0cC5yZXNwb25zZVRleHQ7XHJcblx0XHRcdFx0XHRcdFx0XHRzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlUHJvZ3JhbSh0aHJlYWQsIHN0cmluZywgb3B0cyk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdG9wdHMudXJsID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuY29uc3VsdChwcm9ncmFtLCBvcHRzKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHhodHRwLm9wZW4oXCJHRVRcIiwgcHJvZ3JhbSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR4aHR0cC5zZW5kKCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBjYXRjaChleCkge1xyXG5cdFx0XHRcdFx0b3B0cy5lcnJvcihleCk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHRleHRcclxuXHRcdFx0aWYoIXN1Y2Nlc3MgJiYgb3B0cy50ZXh0KSB7XHJcblx0XHRcdFx0c3VjY2VzcyA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdC8vIGh0bWxcclxuXHRcdH0gZWxzZSBpZihvcHRzLmh0bWwgJiYgcHJvZ3JhbS5ub2RlTmFtZSkge1xyXG5cdFx0XHRzd2l0Y2gocHJvZ3JhbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcblx0XHRcdFx0Y2FzZSBcImlucHV0XCI6XHJcblx0XHRcdFx0Y2FzZSBcInRleHRhcmVhXCI6XHJcblx0XHRcdFx0XHRzdHJpbmcgPSBwcm9ncmFtLnZhbHVlO1xyXG5cdFx0XHRcdFx0c3VjY2VzcyA9IHRydWU7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0c3RyaW5nID0gcHJvZ3JhbS5pbm5lckhUTUw7XHJcblx0XHRcdFx0XHRzdWNjZXNzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvcHRzLmVycm9yKHBsLmVycm9yLmV4aXN0ZW5jZShcInNvdXJjZV9zaW5rXCIsIG5ldyBUZXJtKHN0cmluZyksIFwidG9wX2xldmVsLzBcIikpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy53YXJuaW5ncyA9IFtdO1xyXG5cdFx0cGFyc2VQcm9ncmFtKHRoaXMsIHN0cmluZywgb3B0cyk7XHJcblx0fTtcclxuXHJcblx0Ly8gUXVlcnkgZ29hbCBmcm9tIGEgc3RyaW5nICh3aXRob3V0ID8tKVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQucXVlcnkoc3RyaW5nLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcclxuXHRcdHRoaXMucG9pbnRzID0gW107XHJcblx0XHR0aGlzLmRlYnVnZ2VyX3N0YXRlcyA9IFtdO1xyXG5cdFx0dGhpcy5sZXZlbCA9IG5ldyBUZXJtKFwidG9wX2xldmVsXCIpO1xyXG5cdFx0cmV0dXJuIHBhcnNlUXVlcnkodGhpcywgc3RyaW5nLCBvcHRpb25zKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBmaXJzdCBjaG9pY2UgcG9pbnRcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5oZWFkX3BvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuaGVhZF9wb2ludCgpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5oZWFkX3BvaW50ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoLTFdO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IGZyZWUgdmFyaWFibGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5nZXRfZnJlZV92YXJpYWJsZSA9IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5nZXRfZnJlZV92YXJpYWJsZSggdmFyaWFibGUgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuZ2V0X2ZyZWVfdmFyaWFibGUgPSBmdW5jdGlvbiggdmFyaWFibGUgKSB7XHJcblx0XHR2YXIgdmFyaWFibGVzID0gW107XHJcblx0XHRpZiggdmFyaWFibGUuaWQgPT09IFwiX1wiIHx8IHRoaXMuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlc1t2YXJpYWJsZS5pZF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0dGhpcy5zZXNzaW9uLnJlbmFtZSsrO1xyXG5cdFx0XHRpZiggdGhpcy5jdXJyZW50X3BvaW50IClcclxuXHRcdFx0XHR2YXJpYWJsZXMgPSB0aGlzLmN1cnJlbnRfcG9pbnQuc3Vic3RpdHV0aW9uLmRvbWFpbigpO1xyXG5cdFx0XHR3aGlsZSggaW5kZXhPZiggdmFyaWFibGVzLCBwbC5mb3JtYXRfdmFyaWFibGUoIHRoaXMuc2Vzc2lvbi5yZW5hbWUsIHZhcmlhYmxlLmlkICkgKSAhPT0gLTEgKSB7XHJcblx0XHRcdFx0dGhpcy5zZXNzaW9uLnJlbmFtZSsrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCB2YXJpYWJsZS5pZCA9PT0gXCJfXCIgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBWYXIoIHBsLmZvcm1hdF92YXJpYWJsZSggdGhpcy5zZXNzaW9uLnJlbmFtZSwgdmFyaWFibGUuaWQgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlc1t2YXJpYWJsZS5pZF0gPSBwbC5mb3JtYXRfdmFyaWFibGUoIHRoaXMuc2Vzc2lvbi5yZW5hbWUsIHZhcmlhYmxlLmlkICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBuZXcgVmFyKCB0aGlzLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXNbdmFyaWFibGUuaWRdICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBHZXQgbmV4dCBmcmVlIHZhcmlhYmxlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUubmV4dF9mcmVlX3ZhcmlhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLm5leHRfZnJlZV92YXJpYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5zZXNzaW9uLnJlbmFtZSsrO1xyXG5cdFx0dmFyIHZhcmlhYmxlcyA9IFtdO1xyXG5cdFx0aWYoIHRoaXMuY3VycmVudF9wb2ludCApXHJcblx0XHRcdHZhcmlhYmxlcyA9IHRoaXMuY3VycmVudF9wb2ludC5zdWJzdGl0dXRpb24uZG9tYWluKCk7XHJcblx0XHR3aGlsZSggaW5kZXhPZiggdmFyaWFibGVzLCBwbC5mb3JtYXRfdmFyaWFibGUoIHRoaXMuc2Vzc2lvbi5yZW5hbWUgKSApICE9PSAtMSApIHtcclxuXHRcdFx0dGhpcy5zZXNzaW9uLnJlbmFtZSsrO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBWYXIoIHBsLmZvcm1hdF92YXJpYWJsZSggdGhpcy5zZXNzaW9uLnJlbmFtZSApICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBwdWJsaWNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5pc19wdWJsaWNfcHJlZGljYXRlID0gZnVuY3Rpb24oaW5kaWNhdG9yLCBtb2R1bGVfaWQpIHtcclxuXHRcdG1vZHVsZV9pZCA9IG1vZHVsZV9pZCA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBtb2R1bGVfaWQ7XHJcblx0XHRyZXR1cm4gcGwudHlwZS5pc19tb2R1bGUodGhpcy5tb2R1bGVzW21vZHVsZV9pZF0pICYmIHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdLmlzX3B1YmxpY19wcmVkaWNhdGUoaW5kaWNhdG9yKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuaXNfcHVibGljX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXNzaW9uLmlzX3B1YmxpY19wcmVkaWNhdGUoaW5kaWNhdG9yLCBtb2R1bGVfaWQpO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gQ2hlY2sgaWYgYSBwcmVkaWNhdGUgaXMgbXVsdGlmaWxlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuaXNfbXVsdGlmaWxlX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGluZGljYXRvciwgbW9kdWxlX2lkKSB7XHJcblx0XHRtb2R1bGVfaWQgPSBtb2R1bGVfaWQgPT09IHVuZGVmaW5lZCA/IFwidXNlclwiIDogbW9kdWxlX2lkO1xyXG5cdFx0cmV0dXJuIHBsLnR5cGUuaXNfbW9kdWxlKHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdKSAmJiB0aGlzLm1vZHVsZXNbbW9kdWxlX2lkXS5pc19tdWx0aWZpbGVfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmlzX211bHRpZmlsZV9wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5pc19tdWx0aWZpbGVfcHJlZGljYXRlKGluZGljYXRvciwgbW9kdWxlX2lkKTtcclxuXHR9O1xyXG5cclxuXHQvLyBDaGVjayBpZiBhIHByZWRpY2F0ZSBpcyBhIG1ldGEtcHJlZGljYXRlXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuaXNfbWV0YV9wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0bW9kdWxlX2lkID0gbW9kdWxlX2lkID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG1vZHVsZV9pZDtcclxuXHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdKSlcclxuXHRcdFx0cmV0dXJuIHRoaXMubW9kdWxlc1ttb2R1bGVfaWRdLmlzX21ldGFfcHJlZGljYXRlKGluZGljYXRvcik7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUuaXNfbWV0YV9wcmVkaWNhdGUgPSBmdW5jdGlvbihpbmRpY2F0b3IsIG1vZHVsZV9pZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi5pc19tZXRhX3ByZWRpY2F0ZShpbmRpY2F0b3IsIG1vZHVsZV9pZCk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBJbnNlcnQgc3RhdGVzIGF0IHRoZSBiZWdpbm5pbmdcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24oIHN0YXRlcyApIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKCBzdGF0ZXMgKSB7XHJcblx0XHRmb3IodmFyIGkgPSBzdGF0ZXMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tKVxyXG5cdFx0XHR0aGlzLnBvaW50cy5wdXNoKCBzdGF0ZXNbaV0gKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFJlbW92ZSB0aGUgc2VsZWN0ZWQgdGVybSBhbmQgcHJlcGVuZCB0aGUgY3VycmVudCBzdGF0ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLnN1Y2Nlc3MgPSBmdW5jdGlvbiggcG9pbnQsIHBhcmVudCApIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5zdWNjZXNzKCBwb2ludCwgcGFyZW50ICk7XHJcblx0fVxyXG5cdFRocmVhZC5wcm90b3R5cGUuc3VjY2VzcyA9IGZ1bmN0aW9uKCBwb2ludCwgcGFyZW50ICkge1xyXG5cdFx0dmFyIHBhcmVudCA9IHR5cGVvZiBwYXJlbnQgPT09IFwidW5kZWZpbmVkXCIgPyBwb2ludCA6IHBhcmVudDtcclxuXHRcdHRoaXMucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBudWxsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcGFyZW50ICkgXSApO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gVGhyb3cgZXJyb3JcclxuXHRTZXNzaW9uLnByb3RvdHlwZS50aHJvd19lcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQudGhyb3dfZXJyb3IoZXJyb3IpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS50aHJvd19lcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGVycm9yKSlcclxuXHRcdFx0ZXJyb3IgPSBwbC5lcnJvci5pbnN0YW50aWF0aW9uKHRoaXMubGV2ZWwuaW5kaWNhdG9yKTtcclxuXHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0bmV3IFRlcm0oXCJ0aHJvd1wiLCBbZXJyb3JdKSxcclxuXHRcdFx0bmV3IFN1YnN0aXR1dGlvbigpLFxyXG5cdFx0XHRudWxsXHJcblx0XHQpO1xyXG5cdFx0c3RhdGUuZXJyb3IgPSB0cnVlO1xyXG5cdFx0dGhpcy5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gR2V0IHRoZSBtb2R1bGUgb2YgYSBwcmVkaWNhdGVcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5sb29rdXBfbW9kdWxlID0gZnVuY3Rpb24oYXRvbSwgY29udGV4dF9tb2R1bGUpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5sb29rdXBfbW9kdWxlKGF0b20sIGNvbnRleHRfbW9kdWxlKTtcclxuXHR9XHJcblx0VGhyZWFkLnByb3RvdHlwZS5sb29rdXBfbW9kdWxlID0gZnVuY3Rpb24oYXRvbSwgY29udGV4dF9tb2R1bGUpIHtcclxuXHRcdHZhciBnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdO1xyXG5cdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKVxyXG5cdFx0XHRnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXMudXNlcjtcclxuXHRcdGlmKGdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkoYXRvbS5pbmRpY2F0b3IpICYmIChcclxuXHRcdFx0Z2V0X21vZHVsZS5leHBvcnRzX3ByZWRpY2F0ZShhdG9tLmluZGljYXRvcikgfHxcclxuXHRcdFx0Z2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmxldmVsLmluZGljYXRvcikgfHxcclxuXHRcdFx0Y29udGV4dF9tb2R1bGUgPT09IGdldF9tb2R1bGUuaWQpKVxyXG5cdFx0XHRcdHJldHVybiBnZXRfbW9kdWxlO1xyXG5cdFx0Z2V0X21vZHVsZS5tb2R1bGVzLnN5c3RlbSA9IHBsLm1vZHVsZXMuc3lzdGVtO1xyXG5cdFx0Z2V0X21vZHVsZS5tb2R1bGVzLnVzZXIgPSB0aGlzLnNlc3Npb24ubW9kdWxlcy51c2VyO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIGdldF9tb2R1bGUubW9kdWxlcykge1xyXG5cdFx0XHRpZighdGhpcy5zZXNzaW9uLm1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXNbcHJvcF07XHJcblx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkoYXRvbS5pbmRpY2F0b3IpICYmIChcclxuXHRcdFx0XHRnZXRfbW9kdWxlLmV4cG9ydHNfcHJlZGljYXRlKGF0b20uaW5kaWNhdG9yKSB8fFxyXG5cdFx0XHRcdGdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkodGhpcy5sZXZlbC5pbmRpY2F0b3IpIHx8XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPT09IGdldF9tb2R1bGUuaWQpKVxyXG5cdFx0XHRcdFx0cmV0dXJuIGdldF9tb2R1bGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvLyBFeHBhbmQgYSBtZXRhLXByZWRpY2F0ZVxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmV4cGFuZF9tZXRhX3ByZWRpY2F0ZSA9IGZ1bmN0aW9uKGF0b20sIGRlZmluaXRpb25fbW9kdWxlLCBjb250ZXh0X21vZHVsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmV4cGFuZF9tZXRhX3ByZWRpY2F0ZShhdG9tLCBkZWZpbml0aW9uX21vZHVsZSwgY29udGV4dF9tb2R1bGUpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5leHBhbmRfbWV0YV9wcmVkaWNhdGUgPSBmdW5jdGlvbihhdG9tLCBkZWZpbml0aW9uX21vZHVsZSwgY29udGV4dF9tb2R1bGUpIHtcclxuXHRcdHZhciBnZXRfbW9kdWxlID0gdGhpcy5zZXNzaW9uLm1vZHVsZXNbZGVmaW5pdGlvbl9tb2R1bGVdO1xyXG5cdFx0aWYoIWdldF9tb2R1bGUpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHZhciBtZXRhID0gZ2V0X21vZHVsZS5pc19tZXRhX3ByZWRpY2F0ZShhdG9tLmluZGljYXRvcik7XHJcblx0XHRpZighbWV0YSlcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1ldGEuYXJncy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX2ludGVnZXIobWV0YS5hcmdzW2ldKSB8fCBwbC50eXBlLmlzX2F0b20obWV0YS5hcmdzW2ldKSAmJiBpbmRleE9mKFtcIjpcIl0sIG1ldGEuYXJnc1tpXS5pZCkgIT09IC0xKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdGVybShhdG9tLmFyZ3NbaV0pIHx8IGF0b20uYXJnc1tpXS5pbmRpY2F0b3IgIT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRcdGF0b20uYXJnc1tpXSA9IG5ldyBUZXJtKFwiOlwiLCBbbmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLCBhdG9tLmFyZ3NbaV1dKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX2F0b20obWV0YS5hcmdzW2ldKSAmJiBtZXRhLmFyZ3NbaV0uaWQgPT09IFwiXlwiKSB7XHJcblx0XHRcdFx0dmFyIHBvaW50ZXJfbGFzdCA9IGF0b207XHJcblx0XHRcdFx0dmFyIHBvaW50ZXJfaW5kZXggPSBpO1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gYXRvbS5hcmdzW2ldO1xyXG5cdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCJeLzJcIikge1xyXG5cdFx0XHRcdFx0cG9pbnRlcl9sYXN0ID0gcG9pbnRlcjtcclxuXHRcdFx0XHRcdHBvaW50ZXJfaW5kZXggPSAxO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdGVybShwb2ludGVyKSB8fCBwb2ludGVyLmluZGljYXRvciAhPT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdFx0cG9pbnRlcl9sYXN0LmFyZ3NbcG9pbnRlcl9pbmRleF0gPSBuZXcgVGVybShcIjpcIiwgW25ldyBUZXJtKGNvbnRleHRfbW9kdWxlKSwgcG9pbnRlcl0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gUmVzb2x1dGlvbiBzdGVwXHJcblx0U2Vzc2lvbi5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLnN0ZXAoKTtcclxuXHR9XHJcblx0VGhyZWFkLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLnBvaW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGFzeW4gPSBmYWxzZTtcclxuXHRcdHZhciBwb2ludCA9IHRoaXMucG9pbnRzLnBvcCgpO1xyXG5cdFx0dGhpcy5jdXJyZW50X3BvaW50ID0gcG9pbnQ7XHJcblx0XHRpZih0aGlzLmRlYnVnZ2VyKVxyXG5cdFx0XHR0aGlzLmRlYnVnZ2VyX3N0YXRlcy5wdXNoKHBvaW50KTtcclxuXHRcdHZhciBhdG9tID0gcGwudHlwZS5pc190ZXJtKHBvaW50LmdvYWwpID8gcG9pbnQuZ29hbC5zZWxlY3QoKSA6IHBvaW50LmdvYWw7XHJcblx0XHRpZihwbC50eXBlLmlzX3Rlcm0oYXRvbSkgJiYgKGF0b20uaW5kaWNhdG9yICE9PSBcIjovMlwiIHx8IHBsLnR5cGUuaXNfdGVybShhdG9tLmFyZ3NbMV0pKSkge1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBudWxsO1xyXG5cdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdGlmKGF0b20gIT09IG51bGwpIHtcclxuXHRcdFx0XHR0aGlzLnRvdGFsX3N0ZXBzKys7XHJcblx0XHRcdFx0dmFyIGxldmVsID0gcG9pbnQ7XHJcblx0XHRcdFx0d2hpbGUobGV2ZWwucGFyZW50ICE9PSBudWxsICYmIGxldmVsLnBhcmVudC5nb2FsLnNlYXJjaChhdG9tKSlcclxuXHRcdFx0XHRcdGxldmVsID0gbGV2ZWwucGFyZW50O1xyXG5cdFx0XHRcdGlmKGxldmVsLnBhcmVudCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhpcy5sZXZlbCA9IG5ldyBUZXJtKFwidG9wX2xldmVsXCIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aGlzLmxldmVsID0gbGV2ZWwucGFyZW50LmdvYWwuc2VsZWN0KCk7XHJcblx0XHRcdFx0XHRpZih0aGlzLmxldmVsLmluZGljYXRvciA9PT0gXCI6LzJcIilcclxuXHRcdFx0XHRcdFx0dGhpcy5sZXZlbCA9IHRoaXMubGV2ZWwuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGF0b20pICYmIGF0b20uaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0XHRjb250ZXh0X21vZHVsZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRcdGF0b20gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKGNvbnRleHRfbW9kdWxlKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgY29udGV4dF9tb2R1bGUsIHRoaXMubGV2ZWwuaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gY29udGV4dF9tb2R1bGUuaWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKHRoaXMubGV2ZWwuZGVmaW5pdGlvbl9tb2R1bGUpIHtcclxuXHRcdFx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSB0aGlzLmxldmVsLmRlZmluaXRpb25fbW9kdWxlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBcInVzZXJcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YXRvbS5jb250ZXh0X21vZHVsZSA9IGNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHRcdGlmKGF0b20uaW5kaWNhdG9yID09PSBcIiwvMlwiKSB7XHJcblx0XHRcdFx0XHR0aGlzLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI6XCIsIFtuZXcgVGVybShjb250ZXh0X21vZHVsZSksIGF0b20uYXJnc1swXV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiOlwiLCBbbmV3IFRlcm0oY29udGV4dF9tb2R1bGUpLCBhdG9tLmFyZ3NbMV1dKV0pKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KV0pO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9fY2FsbF9pbmRpY2F0b3IgPSBhdG9tLmluZGljYXRvcjtcclxuXHRcdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRoaXMubG9va3VwX21vZHVsZShhdG9tLCBjb250ZXh0X21vZHVsZSk7XHJcblx0XHRcdFx0YXRvbS5kZWZpbml0aW9uX21vZHVsZSA9IHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpID8gZ2V0X21vZHVsZS5pZCA6IFwidXNlclwiO1xyXG5cdFx0XHRcdHRoaXMuZXhwYW5kX21ldGFfcHJlZGljYXRlKGF0b20sIGF0b20uZGVmaW5pdGlvbl9tb2R1bGUsIGNvbnRleHRfbW9kdWxlKTtcclxuXHRcdFx0XHR2YXIgY2xhdXNlcyA9IG51bGw7XHJcblx0XHRcdFx0aWYoZ2V0X21vZHVsZSAmJiBhdG9tLmFyZ3MubGVuZ3RoID4gMCAmJiBhdG9tLmFyZ3NbMF0uaW5kZXggJiYgZ2V0X21vZHVsZS5pbmRleGVkX2NsYXVzZXMuaGFzT3duUHJvcGVydHkoYXRvbS5pbmRpY2F0b3IpICYmIGdldF9tb2R1bGUuaW5kZXhlZF9jbGF1c2VzW2F0b20uaW5kaWNhdG9yXS5oYXNPd25Qcm9wZXJ0eShhdG9tLmFyZ3NbMF0uaW5kZXgpKVxyXG5cdFx0XHRcdFx0Y2xhdXNlcyA9IGdldF9tb2R1bGUuaW5kZXhlZF9jbGF1c2VzW2F0b20uaW5kaWNhdG9yXVthdG9tLmFyZ3NbMF0uaW5kZXhdO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdGNsYXVzZXMgPSBnZXRfbW9kdWxlID09PSBudWxsID8gbnVsbCA6IGdldF9tb2R1bGUucnVsZXNbYXRvbS5pbmRpY2F0b3JdO1xyXG5cdFx0XHRcdGlmKGNsYXVzZXMgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGlmKCF0aGlzLnNlc3Npb24ubW9kdWxlcy51c2VyLnJ1bGVzLmhhc093blByb3BlcnR5KGF0b20uaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0XHRpZih0aGlzLmdldF9mbGFnKFwidW5rbm93blwiKS5pZCA9PT0gXCJlcnJvclwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInByb2NlZHVyZVwiLCBhdG9tLmluZGljYXRvciwgdGhpcy5sZXZlbC5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKHRoaXMuZ2V0X2ZsYWcoXCJ1bmtub3duXCIpLmlkID09PSBcIndhcm5pbmdcIikge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMudGhyb3dfd2FybmluZyhcInVua25vd24gcHJvY2VkdXJlIFwiICsgYXRvbS5pbmRpY2F0b3IgKyBcIiAoZnJvbSBcIiArIHRoaXMubGV2ZWwuaW5kaWNhdG9yICsgXCIpXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKGNsYXVzZXMgaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG5cdFx0XHRcdFx0YXN5biA9IGNsYXVzZXModGhpcywgcG9pbnQsIGF0b20pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvLyBHb2FsIGV4cGFuc2lvblxyXG5cdFx0XHRcdFx0aWYodGhpcy5fX2dvYWxfZXhwYW5zaW9uICYmIGF0b20uaW5kaWNhdG9yID09PSBcImdvYWxfZXhwYW5zaW9uLzJcIilcclxuXHRcdFx0XHRcdFx0Y2xhdXNlcyA9IGNsYXVzZXMuY29uY2F0KHBsLmJ1aWx0aW4ucnVsZXNbXCJnb2FsX2V4cGFuc2lvbi8yXCJdKTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjbGF1c2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcyA9IHt9O1xyXG5cdFx0XHRcdFx0XHR2YXIgY2xhdXNlID0gY2xhdXNlc1tpXS5yZW5hbWUodGhpcyk7XHJcblx0XHRcdFx0XHRcdHZhciBvY2N1cnNfY2hlY2sgPSB0aGlzLmdldF9mbGFnKFwib2NjdXJzX2NoZWNrXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIjtcclxuXHRcdFx0XHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KGF0b20sIGNsYXVzZS5oZWFkLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0XHRcdFx0XHRpZihtZ3UgIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5nb2FsID0gcG9pbnQuZ29hbC5yZXBsYWNlKGNsYXVzZS5ib2R5KTtcclxuXHRcdFx0XHRcdFx0XHRpZihzdGF0ZS5nb2FsICE9PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhdGUuZ29hbCA9IHN0YXRlLmdvYWwuYXBwbHkobWd1KTtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5zdWJzdGl0dXRpb24gPSBwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkobWd1KTtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5wYXJlbnQgPSBwb2ludDtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChzdGF0ZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRoaXMucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHRlcm0gPSBwbC50eXBlLmlzX3Rlcm0oYXRvbSkgJiYgYXRvbS5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBhdG9tLmFyZ3NbMV0gOiBhdG9tO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHRlcm0pKVxyXG5cdFx0XHRcdHRoaXMudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbih0aGlzLmxldmVsLmluZGljYXRvcikpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhpcy50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgdGVybSwgdGhpcy5sZXZlbC5pbmRpY2F0b3IpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhc3luO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gRmluZCBuZXh0IGNvbXB1dGVkIGFuc3dlclxyXG5cdFNlc3Npb24ucHJvdG90eXBlLmFuc3dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiB0aGlzLnRocmVhZC5hbnN3ZXIob3B0aW9ucyk7XHJcblx0fTtcclxuXHRUaHJlYWQucHJvdG90eXBlLmFuc3dlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHZhciBvcHRzID0ge307XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCBmdW5jdGlvbigpIHt9O1xyXG5cdFx0aWYodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRvcHRzID0ge1xyXG5cdFx0XHRcdHN1Y2Nlc3M6IG9wdGlvbnMsXHJcblx0XHRcdFx0ZXJyb3I6IG9wdGlvbnMsXHJcblx0XHRcdFx0ZmFpbDogb3B0aW9ucyxcclxuXHRcdFx0XHRsaW1pdDogb3B0aW9uc1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3B0cy5zdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbigpIHt9IDogb3B0aW9ucy5zdWNjZXNzO1xyXG5cdFx0XHRvcHRzLmVycm9yID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24oKSB7fSA6IG9wdGlvbnMuZXJyb3I7XHJcblx0XHRcdG9wdHMuZmFpbCA9IG9wdGlvbnMuZmFpbCA9PT0gdW5kZWZpbmVkID8gZnVuY3Rpb24oKSB7fSA6IG9wdGlvbnMuZmFpbDtcclxuXHRcdFx0b3B0cy5saW1pdCA9IG9wdGlvbnMubGltaXQgPT09IHVuZGVmaW5lZCA/IGZ1bmN0aW9uKCkge30gOiBvcHRpb25zLmxpbWl0O1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fX2NhbGxzLnB1c2gob3B0cyk7XHJcblx0XHRpZiggdGhpcy5fX2NhbGxzLmxlbmd0aCA+IDEgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRoaXMuYWdhaW4oKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEZpbmQgYWxsIGNvbXB1dGVkIGFuc3dlcnNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hbnN3ZXJzID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBtYXgsIGFmdGVyICkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGhyZWFkLmFuc3dlcnMoIGNhbGxiYWNrLCBtYXgsIGFmdGVyICk7XHJcblx0fVxyXG5cdFRocmVhZC5wcm90b3R5cGUuYW5zd2VycyA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgbWF4LCBhZnRlciApIHtcclxuXHRcdHZhciBhbnN3ZXJzID0gbWF4ID09PSB1bmRlZmluZWQgPyAxMDAwIDogbWF4O1xyXG5cdFx0dmFyIHRocmVhZCA9IHRoaXM7XHJcblx0XHRpZiggYW5zd2VycyA8PSAwICkge1xyXG5cdFx0XHRpZihhZnRlcilcclxuXHRcdFx0XHRhZnRlcigpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLmFuc3dlciggZnVuY3Rpb24oIGFuc3dlciApIHtcclxuXHRcdFx0Y2FsbGJhY2soIGFuc3dlciApO1xyXG5cdFx0XHRpZiggYW5zd2VyICE9PSBmYWxzZSApIHtcclxuXHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHRocmVhZC5hbnN3ZXJzKCBjYWxsYmFjaywgYW5zd2Vycy0xLCBhZnRlciApO1xyXG5cdFx0XHRcdH0sIDAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKGFmdGVyKSB7XHJcblx0XHRcdFx0YWZ0ZXIoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSApO1xyXG5cdH07XHJcblxyXG5cdC8vIEFnYWluIGZpbmRpbmcgbmV4dCBjb21wdXRlZCBhbnN3ZXJcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5hZ2FpbiA9IGZ1bmN0aW9uKHJlc2V0X2xpbWl0KSB7XHJcblx0XHRyZXR1cm4gdGhpcy50aHJlYWQuYWdhaW4ocmVzZXRfbGltaXQpO1xyXG5cdH07XHJcblx0VGhyZWFkLnByb3RvdHlwZS5hZ2FpbiA9IGZ1bmN0aW9uKHJlc2V0X2xpbWl0KSB7XHJcblx0XHR3aGlsZSh0aGlzLl9fY2FsbHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHR0aGlzLndhcm5pbmdzID0gW107XHJcblx0XHRcdGlmKHJlc2V0X2xpbWl0ICE9PSBmYWxzZSlcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnRfbGltaXQgPSB0aGlzLnNlc3Npb24ubGltaXQ7XHJcblx0XHRcdHdoaWxlKCghdGhpcy5oYXNfbGltaXQgfHwgdGhpcy5jdXJyZW50X2xpbWl0ID4gMCkgJiYgdGhpcy5wb2ludHMubGVuZ3RoID4gMCAmJiB0aGlzLmhlYWRfcG9pbnQoKS5nb2FsICE9PSBudWxsICYmICFwbC50eXBlLmlzX2Vycm9yX3N0YXRlKHRoaXMuaGVhZF9wb2ludCgpKSkge1xyXG5cdFx0XHRcdGlmKHRoaXMuaGFzX2xpbWl0KVxyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50X2xpbWl0LS07XHJcblx0XHRcdFx0dmFyIHQwID0gRGF0ZS5ub3coKTtcclxuXHRcdFx0XHR2YXIgYXN5biA9IHRoaXMuc3RlcCgpO1xyXG5cdFx0XHRcdHZhciB0MSA9IERhdGUubm93KCk7XHJcblx0XHRcdFx0dGhpcy5jcHVfdGltZSArPSB0MS10MDtcclxuXHRcdFx0XHRpZihhc3luID09PSB0cnVlKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjYWxsID0gdGhpcy5fX2NhbGxzLnNoaWZ0KCk7XHJcblx0XHRcdC8vIGxpbWl0IG9mIGluZmVyZW5jZXNcclxuXHRcdFx0aWYodGhpcy5oYXNfbGltaXQgJiYgdGhpcy5jdXJyZW50X2xpbWl0IDw9IDApIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oY2FsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGNhbGwubGltaXQobnVsbCk7XHJcblx0XHRcdFx0XHR9LCAwKTtcclxuXHRcdFx0XHR9KShjYWxsKTtcclxuXHRcdFx0Ly8gbm8gYW5zd2VyXHJcblx0XHRcdH0gZWxzZSBpZih0aGlzLnBvaW50cy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHQoZnVuY3Rpb24oY2FsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGNhbGwuZmFpbChmYWxzZSk7XHJcblx0XHRcdFx0XHR9LCAwKTtcclxuXHRcdFx0XHR9KShjYWxsKTtcclxuXHRcdFx0Ly8gZXJyb3JcclxuXHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfZXJyb3IodGhpcy5oZWFkX3BvaW50KCkuZ29hbCkpIHtcclxuXHRcdFx0XHR2YXIgZXJyb3IgPSB0aGlzLmZvcm1hdF9lcnJvcih0aGlzLnBvaW50cy5wb3AoKSk7XHJcblx0XHRcdFx0dGhpcy5wb2ludHMgPSBbXTtcclxuXHRcdFx0XHQoZnVuY3Rpb24oZXJyb3IsIGNhbGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRjYWxsLmVycm9yKGVycm9yKTtcclxuXHRcdFx0XHRcdH0sIDApO1xyXG5cdFx0XHRcdH0pKGVycm9yLCBjYWxsKTtcclxuXHRcdFx0Ly8gY29tcHV0ZWQgYW5zd2VyXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYodGhpcy5kZWJ1Z2dlcilcclxuXHRcdFx0XHRcdHRoaXMuZGVidWdnZXJfc3RhdGVzLnB1c2godGhpcy5oZWFkX3BvaW50KCkpO1xyXG5cdFx0XHRcdHZhciBhbnN3ZXIgPSB0aGlzLmZvcm1hdF9zdWNjZXNzKHRoaXMucG9pbnRzLnBvcCgpKTtcclxuXHRcdFx0XHQoZnVuY3Rpb24oYW5zd2VyLCBjYWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbC5zdWNjZXNzKGFuc3dlcik7XHJcblx0XHRcdFx0XHR9LCAwKTtcclxuXHRcdFx0XHR9KShhbnN3ZXIsIGNhbGwpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBVbmZvbGRpbmcgdHJhbnNmb3JtYXRpb25cclxuXHRTZXNzaW9uLnByb3RvdHlwZS51bmZvbGQgPSBmdW5jdGlvbiggcnVsZSApIHtcclxuXHRcdGlmKHJ1bGUuYm9keSA9PT0gbnVsbClcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0dmFyIGhlYWQgPSBydWxlLmhlYWQ7XHJcblx0XHR2YXIgYm9keSA9IHJ1bGUuYm9keTtcclxuXHRcdHZhciBhdG9tID0gYm9keS5zZWxlY3QoKTtcclxuXHRcdHZhciB0aHJlYWQgPSBuZXcgVGhyZWFkKCB0aGlzICk7XHJcblx0XHR2YXIgdW5mb2xkZWQgPSBbXTtcclxuXHRcdHRocmVhZC5hZGRfZ29hbCggYXRvbSApO1xyXG5cdFx0dGhyZWFkLnN0ZXAoKTtcclxuXHRcdGZvciggdmFyIGkgPSB0aHJlYWQucG9pbnRzLmxlbmd0aC0xOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0dmFyIHBvaW50ID0gdGhyZWFkLnBvaW50c1tpXTtcclxuXHRcdFx0dmFyIGhlYWQyID0gaGVhZC5hcHBseSggcG9pbnQuc3Vic3RpdHV0aW9uICk7XHJcblx0XHRcdHZhciBib2R5MiA9IGJvZHkucmVwbGFjZSggcG9pbnQuZ29hbCApO1xyXG5cdFx0XHRpZiggYm9keTIgIT09IG51bGwgKVxyXG5cdFx0XHRcdGJvZHkyID0gYm9keTIuYXBwbHkoIHBvaW50LnN1YnN0aXR1dGlvbiApO1xyXG5cdFx0XHR1bmZvbGRlZC5wdXNoKCBuZXcgUnVsZSggaGVhZDIsIGJvZHkyICkgKTtcclxuXHRcdH1cclxuXHRcdHZhciBydWxlcyA9IHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXTtcclxuXHRcdHZhciBpbmRleCA9IGluZGV4T2YoIHJ1bGVzLCBydWxlICk7XHJcblx0XHRpZiggdW5mb2xkZWQubGVuZ3RoID4gMCAmJiBpbmRleCAhPT0gLTEgKSB7XHJcblx0XHRcdHJ1bGVzLnNwbGljZS5hcHBseSggcnVsZXMsIFtpbmRleCwgMV0uY29uY2F0KHVuZm9sZGVkKSApO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cdFRocmVhZC5wcm90b3R5cGUudW5mb2xkID0gZnVuY3Rpb24ocnVsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2Vzc2lvbi51bmZvbGQocnVsZSk7XHJcblx0fTtcclxuXHJcblx0XHJcblx0XHJcblx0Ly8gSU5URVJQUkVUIEVYUFJFU1NJT05TXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5pbnRlcnByZXQgPSBmdW5jdGlvbiggdGhyZWFkICkge1xyXG5cdFx0cmV0dXJuIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIHRocmVhZC5sZXZlbC5pbmRpY2F0b3IgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLmludGVycHJldCA9IGZ1bmN0aW9uKCB0aHJlYWQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cdFxyXG5cdC8vIFRlcm1zXHJcblx0VGVybS5wcm90b3R5cGUuaW50ZXJwcmV0ID0gZnVuY3Rpb24oIHRocmVhZCApIHtcclxuXHRcdGlmKCBwbC50eXBlLmlzX3VuaXRhcnlfbGlzdCggdGhpcyApICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5hcmdzWzBdLmludGVycHJldCggdGhyZWFkICk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcGwub3BlcmF0ZSggdGhyZWFkLCB0aGlzICk7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHRcclxuXHRcclxuXHQvLyBDT01QQVJFIFBST0xPRyBPQkpFQ1RTXHJcblx0XHJcblx0Ly8gVmFyaWFibGVzXHJcblx0VmFyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdGlmKCB0aGlzLmlkIDwgb2JqLmlkICkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9IGVsc2UgaWYoIHRoaXMuaWQgPiBvYmouaWQgKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHQvLyBOdW1iZXJzXHJcblx0TnVtLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdGlmKCB0aGlzLnZhbHVlID09PSBvYmoudmFsdWUgJiYgdGhpcy5pc19mbG9hdCA9PT0gb2JqLmlzX2Zsb2F0ICkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH0gZWxzZSBpZiggdGhpcy52YWx1ZSA8IG9iai52YWx1ZSB8fCB0aGlzLnZhbHVlID09PSBvYmoudmFsdWUgJiYgdGhpcy5pc19mbG9hdCAmJiAhb2JqLmlzX2Zsb2F0ICkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9IGVsc2UgaWYoIHRoaXMudmFsdWUgPiBvYmoudmFsdWUgKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cdH07XHJcblx0XHJcblx0Ly8gVGVybXNcclxuXHRUZXJtLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdGlmKCB0aGlzLmFyZ3MubGVuZ3RoIDwgb2JqLmFyZ3MubGVuZ3RoIHx8IHRoaXMuYXJncy5sZW5ndGggPT09IG9iai5hcmdzLmxlbmd0aCAmJiB0aGlzLmlkIDwgb2JqLmlkICkge1xyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9IGVsc2UgaWYoIHRoaXMuYXJncy5sZW5ndGggPiBvYmouYXJncy5sZW5ndGggfHwgdGhpcy5hcmdzLmxlbmd0aCA9PT0gb2JqLmFyZ3MubGVuZ3RoICYmIHRoaXMuaWQgPiBvYmouaWQgKSB7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0dmFyIGFyZyA9IHBsLmNvbXBhcmUoIHRoaXMuYXJnc1tpXSwgb2JqLmFyZ3NbaV0gKTtcclxuXHRcdFx0XHRpZiggYXJnICE9PSAwICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGFyZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblx0fTtcclxuXHRcclxuXHJcblx0XHJcblx0Ly8gU1VCU1RJVFVUSU9OU1xyXG5cdFxyXG5cdC8vIExvb2t1cCB2YXJpYWJsZVxyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG5cdFx0aWYoIHRoaXMubGlua3NbdmFyaWFibGVdICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5saW5rc1t2YXJpYWJsZV07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cdFxyXG5cdC8vIEZpbHRlciB2YXJpYWJsZXNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKCBwcmVkaWNhdGUgKSB7XHJcblx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdGZvciggdmFyIGlkIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KGlkKSkgY29udGludWU7XHJcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMubGlua3NbaWRdO1xyXG5cdFx0XHRpZiggcHJlZGljYXRlKCBpZCwgdmFsdWUgKSApIHtcclxuXHRcdFx0XHRsaW5rc1tpZF0gPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBTdWJzdGl0dXRpb24oIGxpbmtzLCB0aGlzLmF0dHJzICk7XHJcblx0fTtcclxuXHRcclxuXHQvLyBFeGNsdWRlIHZhcmlhYmxlc1xyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZXhjbHVkZSA9IGZ1bmN0aW9uKCB2YXJpYWJsZXMgKSB7XHJcblx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdGZvciggdmFyIHZhcmlhYmxlIGluIHRoaXMubGlua3MgKSB7XHJcblx0XHRcdGlmKCF0aGlzLmxpbmtzLmhhc093blByb3BlcnR5KHZhcmlhYmxlKSkgY29udGludWU7XHJcblx0XHRcdGlmKCBpbmRleE9mKCB2YXJpYWJsZXMsIHZhcmlhYmxlICkgPT09IC0xICkge1xyXG5cdFx0XHRcdGxpbmtzW3ZhcmlhYmxlXSA9IHRoaXMubGlua3NbdmFyaWFibGVdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmV3IFN1YnN0aXR1dGlvbiggbGlua3MsIHRoaXMuYXR0cnMgKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEFkZCBsaW5rXHJcblx0U3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiggdmFyaWFibGUsIHZhbHVlICkge1xyXG5cdFx0dGhpcy5saW5rc1t2YXJpYWJsZV0gPSB2YWx1ZTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIEdldCBkb21haW5cclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmRvbWFpbiA9IGZ1bmN0aW9uKCBwbGFpbiApIHtcclxuXHRcdHZhciBmID0gcGxhaW4gPT09IHRydWUgPyBmdW5jdGlvbih4KXtyZXR1cm4geDt9IDogZnVuY3Rpb24oeCl7cmV0dXJuIG5ldyBWYXIoeCk7fTtcclxuXHRcdHZhciB2YXJzID0gW107XHJcblx0XHRmb3IoIHZhciB4IGluIHRoaXMubGlua3MgKVxyXG5cdFx0XHR2YXJzLnB1c2goIGYoeCkgKTtcclxuXHRcdHJldHVybiB2YXJzO1xyXG5cdH07XHJcblxyXG5cdC8vIEdldCBhbiBhdHRyaWJ1dGVcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmdldF9hdHRyaWJ1dGUgPSBmdW5jdGlvbiggdmFyaWFibGUsIG1vZHVsZSApIHtcclxuXHRcdGlmKCB0aGlzLmF0dHJzW3ZhcmlhYmxlXSApXHJcblx0XHRcdHJldHVybiB0aGlzLmF0dHJzW3ZhcmlhYmxlXVttb2R1bGVdO1xyXG5cdH1cclxuXHJcblx0Ly8gU2V0IGFuIGF0dHJpYnV0ZSAoaW4gYSBuZXcgc3Vic3RpdHV0aW9uKVxyXG5cdFN1YnN0aXR1dGlvbi5wcm90b3R5cGUuc2V0X2F0dHJpYnV0ZSA9IGZ1bmN0aW9uKCB2YXJpYWJsZSwgbW9kdWxlLCB2YWx1ZSApIHtcclxuXHRcdHZhciBzdWJzID0gbmV3IFN1YnN0aXR1dGlvbiggdGhpcy5saW5rcyApO1xyXG5cdFx0Zm9yKCB2YXIgdiBpbiB0aGlzLmF0dHJzICkge1xyXG5cdFx0XHRpZiggdiA9PT0gdmFyaWFibGUgKSB7XHJcblx0XHRcdFx0c3Vicy5hdHRyc1t2XSA9IHt9O1xyXG5cdFx0XHRcdGZvciggdmFyIG0gaW4gdGhpcy5hdHRyc1t2XSApIHtcclxuXHRcdFx0XHRcdHN1YnMuYXR0cnNbdl1bbV0gPSB0aGlzLmF0dHJzW3ZdW21dO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdWJzLmF0dHJzW3ZdID0gdGhpcy5hdHRyc1t2XTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYoICFzdWJzLmF0dHJzW3ZhcmlhYmxlXSApIHtcclxuXHRcdFx0c3Vicy5hdHRyc1t2YXJpYWJsZV0gPSB7fTtcclxuXHRcdH1cclxuXHRcdHN1YnMuYXR0cnNbdmFyaWFibGVdW21vZHVsZV0gPSB2YWx1ZTtcclxuXHRcdHJldHVybiBzdWJzO1xyXG5cdH1cclxuXHJcblx0Ly8gQ2hlY2sgaWYgYSB2YXJpYWJsZXMgaGFzIGF0dHJpYnV0ZXNcclxuXHRTdWJzdGl0dXRpb24ucHJvdG90eXBlLmhhc19hdHRyaWJ1dGVzID0gZnVuY3Rpb24oIHZhcmlhYmxlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXR0cnNbdmFyaWFibGVdICYmIHRoaXMuYXR0cnNbdmFyaWFibGVdICE9PSB7fTtcclxuXHR9XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gR0VORVJBVEUgSkFWQVNDUklQVCBDT0RFIEZST00gUFJPTE9HIE9CSkVDVFNcclxuXHRcclxuXHQvLyBWYXJpYWJsZXNcclxuXHRWYXIucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnbmV3IHBsLnR5cGUuVmFyKFwiJyArIHRoaXMuaWQudG9TdHJpbmcoKSArICdcIiknO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gTnVtYmVyc1xyXG5cdE51bS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICduZXcgcGwudHlwZS5OdW0oJyArIHRoaXMudmFsdWUudG9TdHJpbmcoKSArICcsICcgKyB0aGlzLmlzX2Zsb2F0LnRvU3RyaW5nKCkgKyAnKSc7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnbmV3IHBsLnR5cGUuVGVybShcIicgKyB0aGlzLmlkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIiwgWycgKyBtYXAoIHRoaXMuYXJncywgZnVuY3Rpb24oIGFyZyApIHtcclxuXHRcdFx0cmV0dXJuIGFyZy5jb21waWxlKCk7XHJcblx0XHR9ICkgKyAnXSknO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gUnVsZXNcclxuXHRSdWxlLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gJ25ldyBwbC50eXBlLlJ1bGUoJyArIHRoaXMuaGVhZC5jb21waWxlKCkgKyAnLCAnICsgKHRoaXMuYm9keSA9PT0gbnVsbCA/ICdudWxsJyA6IHRoaXMuYm9keS5jb21waWxlKCkpICsgJyknO1xyXG5cdH07XHJcblx0XHJcblx0Ly8gU2Vzc2lvbnNcclxuXHRTZXNzaW9uLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc3RyLCBvYmogPSBbXSwgcnVsZXM7XHJcblx0XHRmb3IoIHZhciBfaW5kaWNhdG9yIGluIHRoaXMubW9kdWxlcy51c2VyLnJ1bGVzICkge1xyXG5cdFx0XHRpZighdGhpcy5tb2R1bGVzLnVzZXIucnVsZXMuaGFzT3duUHJvcGVydHkoX2luZGljYXRvcikpIGNvbnRpbnVlO1xyXG5cdFx0XHR2YXIgaW5kaWNhdG9yID0gdGhpcy5tb2R1bGVzLnVzZXIucnVsZXNbX2luZGljYXRvcl07XHJcblx0XHRcdHJ1bGVzID0gW107XHJcblx0XHRcdHN0ciA9IFwiXFxcIlwiICsgX2luZGljYXRvciArIFwiXFxcIjogW1wiO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaW5kaWNhdG9yLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0cnVsZXMucHVzaChpbmRpY2F0b3JbaV0uY29tcGlsZSgpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzdHIgKz0gcnVsZXMuam9pbigpO1xyXG5cdFx0XHRzdHIgKz0gXCJdXCI7XHJcblx0XHRcdG9iai5wdXNoKCBzdHIgKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBcIntcIiArIG9iai5qb2luKCkgKyBcIn07XCI7XHJcblx0fTtcclxuXHJcblx0Ly8gTW9kdWxlXHJcblx0TW9kdWxlLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbGVuZ3RoID0gMDtcclxuXHRcdHZhciBkZXBlbmRlbmNpZXMgPSAwO1xyXG5cdFx0dmFyIHN0ciA9IFwidmFyIHBsO1xcblwiO1xyXG5cdFx0c3RyICs9IFwiKGZ1bmN0aW9uKHBsKSB7XFxuXCI7XHJcblx0XHQvLyBuYW1lXHJcblx0XHRzdHIgKz0gXCJcXHR2YXIgbmFtZSA9IFxcXCJcIiArIHRoaXMuaWQgKyBcIlxcXCI7XFxuXCI7XHJcblx0XHQvLyBwcmVkaWNhdGVzXHJcblx0XHRzdHIgKz0gXCJcXHR2YXIgcHJlZGljYXRlcyA9IGZ1bmN0aW9uKCkge1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0XFx0cmV0dXJuIHtcXG5cIjtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiB0aGlzLnJ1bGVzKSB7XHJcblx0XHRcdGlmKGxlbmd0aCA+IDApXHJcblx0XHRcdFx0c3RyICs9IFwiLFxcblwiO1xyXG5cdFx0XHRzdHIgKz0gXCJcXHRcXHRcXHRcXFwiXCIgKyBwcm9wICsgXCJcXFwiOiBcIjtcclxuXHRcdFx0aWYodHlwZW9mIHRoaXMucnVsZXNbcHJvcF0gPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdHN0ciArPSB0aGlzLnJ1bGVzW3Byb3BdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0ciArPSBcIltcXG5cIjtcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5ydWxlc1twcm9wXS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0c3RyICs9IFwiXFx0XFx0XFx0XFx0XCIgKyB0aGlzLnJ1bGVzW3Byb3BdW2ldLmNvbXBpbGUoKTtcclxuXHRcdFx0XHRcdGlmKGkgPCB0aGlzLnJ1bGVzW3Byb3BdLmxlbmd0aC0xKVxyXG5cdFx0XHRcdFx0XHRzdHIgKz0gXCIsXCI7XHJcblx0XHRcdFx0XHRzdHIgKz0gXCJcXG5cIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3RyICs9IFwiXFx0XFx0XFx0XVwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxlbmd0aCsrO1xyXG5cdFx0fVxyXG5cdFx0c3RyICs9IFwiXFxuXFx0XFx0fTtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdH07XFxuXCI7XHJcblx0XHQvLyBleHBvcnRzXHJcblx0XHRzdHIgKz0gXCJcXHR2YXIgZXhwb3J0cyA9IFtcIjtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmV4cG9ydHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYoaSA+IDApXHJcblx0XHRcdFx0c3RyICs9IFwiLCBcIjtcclxuXHRcdFx0c3RyICs9IFwiXFxcIlwiICsgdGhpcy5leHBvcnRzW2ldICsgXCJcXFwiXCI7XHJcblx0XHR9XHJcblx0XHRzdHIgKz0gXCJdO1xcblwiO1xyXG5cdFx0Ly8gb3B0aW9uc1xyXG5cdFx0c3RyICs9IFwiXFx0dmFyIG9wdGlvbnMgPSBmdW5jdGlvbigpIHtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdHJldHVybiB7XFxuXCI7XHJcblx0XHQvLyBkZXBlbmRlbmNpZXNcclxuXHRcdHN0ciArPSBcIlxcdFxcdFxcdGRlcGVuZGVuY2llczogW1wiO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIHRoaXMubW9kdWxlcykge1xyXG5cdFx0XHRpZihkZXBlbmRlbmNpZXMgPiAwKVxyXG5cdFx0XHRcdHN0ciArPSBcIiwgXCI7XHJcblx0XHRcdHN0ciArPSBcIlxcXCJcIiArIHByb3AgKyBcIlxcXCJcIjtcclxuXHRcdFx0ZGVwZW5kZW5jaWVzKys7XHJcblx0XHR9XHJcblx0XHRzdHIgKz0gXCJdXFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHR9O1xcblwiO1xyXG5cdFx0c3RyICs9IFwifTtcXG5cIjtcclxuXHRcdC8vIGZpeGVkIGNvZGVcclxuXHRcdHN0ciArPSBcIlxcdGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHApIHtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdFxcdHBsID0gcDtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdFxcdG5ldyBwbC50eXBlLk1vZHVsZShuYW1lLCBwcmVkaWNhdGVzKCksIGV4cG9ydHMsIG9wdGlvbnMoKSk7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHRcXHR9O1xcblwiO1xyXG5cdFx0c3RyICs9IFwiXFx0fSBlbHNlIHtcXG5cIjtcclxuXHRcdHN0ciArPSBcIlxcdFxcdG5ldyBwbC50eXBlLk1vZHVsZShuYW1lLCBwcmVkaWNhdGVzKCksIGV4cG9ydHMsIG9wdGlvbnMoKSk7XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJcXHR9XFxuXCI7XHJcblx0XHRzdHIgKz0gXCJ9KShwbCk7XFxuXCI7XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH07XHJcblx0XHJcblx0XHJcblx0XHJcblx0Ly8gUFJPTE9HIFRPIEpBVkFTQ1JJUFRcclxuXHRWYXIucHJvdG90eXBlLnRvSmF2YVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcclxuXHR9O1xyXG5cdFxyXG5cdC8vIE51bWJlcnNcclxuXHROdW0ucHJvdG90eXBlLnRvSmF2YVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XHJcblx0fTtcclxuXHRcclxuXHQvLyBUZXJtc1xyXG5cdFRlcm0ucHJvdG90eXBlLnRvSmF2YVNjcmlwdCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdC8vIEF0b20gPT4gU3RyaW5nXHJcblx0XHRpZiggdGhpcy5hcmdzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRvU3RyaW5nKG9wdGlvbnMpO1xyXG5cdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2xpc3QoIHRoaXMgKSApIHtcclxuXHRcdFx0Ly8gTGlzdCA9PiBBcnJheVxyXG5cdFx0XHR2YXIgYWxsX29iaiA9IHRydWU7XHJcblx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0dmFyIG9iaiA9IHt9O1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IHRoaXM7XHJcblx0XHRcdHZhciB2YWx1ZTtcclxuXHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdHZhbHVlID0gcG9pbnRlci5hcmdzWzBdLnRvSmF2YVNjcmlwdChvcHRpb25zKTtcclxuXHRcdFx0XHRhcnIucHVzaCggdmFsdWUgKTtcclxuXHRcdFx0XHRhbGxfb2JqID0gYWxsX29iaiAmJiBwbC50eXBlLmlzX3Rlcm0ocG9pbnRlci5hcmdzWzBdKSAmJiBwb2ludGVyLmFyZ3NbMF0uaW5kaWNhdG9yID09PSBcIi0vMlwiICYmIHBsLnR5cGUuaXNfYXRvbShwb2ludGVyLmFyZ3NbMF0uYXJnc1swXSk7XHJcblx0XHRcdFx0aWYoYWxsX29iailcclxuXHRcdFx0XHRcdG9ialtwb2ludGVyLmFyZ3NbMF0uYXJnc1swXS5pZF0gPSBwb2ludGVyLmFyZ3NbMF0uYXJnc1sxXS50b0phdmFTY3JpcHQob3B0aW9ucyk7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiW10vMFwiIClcclxuXHRcdFx0XHRyZXR1cm4gYWxsX29iaiAmJiBhcnIubGVuZ3RoID4gMCA/IG9iaiA6IGFycjtcclxuXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy50b1N0cmluZyhvcHRpb25zKTtcclxuXHR9O1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFJVTEVTXHJcblx0XHJcblx0Ly8gUmV0dXJuIHNpbmdsZXRvbiB2YXJpYWJsZXMgaW4gdGhlIHNlc3Npb25cclxuXHRSdWxlLnByb3RvdHlwZS5zaW5nbGV0b25fdmFyaWFibGVzID0gZnVuY3Rpb24oaW5jbHVkZV9uYW1lZCkge1xyXG5cdFx0aW5jbHVkZV9uYW1lZCA9IGluY2x1ZGVfbmFtZWQgfHwgZmFsc2U7XHJcblx0XHR2YXIgdmFyaWFibGVzID0gdGhpcy5oZWFkLnZhcmlhYmxlcygpO1xyXG5cdFx0dmFyIGNvdW50ID0ge307XHJcblx0XHR2YXIgc2luZ2xldG9uID0gW107XHJcblx0XHRpZih0aGlzLmJvZHkgIT09IG51bGwpXHJcblx0XHRcdHZhcmlhYmxlcyA9IHZhcmlhYmxlcy5jb25jYXQodGhpcy5ib2R5LnZhcmlhYmxlcygpKTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYoY291bnRbdmFyaWFibGVzW2ldXSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdGNvdW50W3ZhcmlhYmxlc1tpXV0gPSAwO1xyXG5cdFx0XHRjb3VudFt2YXJpYWJsZXNbaV1dKys7XHJcblx0XHR9XHJcblx0XHRmb3IodmFyIGtleSBpbiBjb3VudCkge1xyXG5cdFx0XHRpZighY291bnQuaGFzT3duUHJvcGVydHkoa2V5KSlcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0aWYoY291bnRba2V5XSA9PT0gMSkge1xyXG5cdFx0XHRcdHZhciBjaGFyY29kZSA9IGNvZGVQb2ludEF0KGtleSwgMSk7XHJcblx0XHRcdFx0aWYoIWluY2x1ZGVfbmFtZWQgfHwga2V5ID09PSBcIl9cIilcclxuXHRcdFx0XHRcdGlmKGtleSA9PT0gXCJfXCIgfHwga2V5WzBdID09PSBcIl9cIiAmJiAoY2hhcmNvZGUgPT09IDk1IHx8IGNoYXJjb2RlID49IDY1ICYmIGNoYXJjb2RlIDw9IDkwKSlcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0c2luZ2xldG9uLnB1c2goa2V5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNpbmdsZXRvbjtcclxuXHR9O1xyXG5cclxuXHJcblxyXG5cdC8vIE5PREVKU1xyXG5cclxuXHR2YXIgbm9kZWpzX2ZsYWcgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXByb2Nlc3MuYnJvd3NlclxyXG5cclxuXHR2YXIgbm9kZWpzX2FyZ3VtZW50cyA9IG5vZGVqc19mbGFnID9cclxuXHRcdGFycmF5VG9MaXN0KCBtYXAocHJvY2Vzcy5hcmd2LnNsaWNlKDEpLCBmdW5jdGlvbihhcmcpIHsgcmV0dXJuIG5ldyBUZXJtKCBhcmcgKTsgfSkpIDpcclxuXHRcdG5ldyBUZXJtKFwiW11cIiwgW10pO1xyXG5cdFxyXG5cdFxyXG5cdFxyXG5cdC8vIFBST0xPR1xyXG5cclxuXHR2YXIgcGwgPSB7XHJcblx0XHRcclxuXHRcdC8vIEVudmlyb25tZW50XHJcblx0XHRfX2Vudjogbm9kZWpzX2ZsYWcgPyBnbG9iYWwgOiB3aW5kb3csXHJcblx0XHRcclxuXHRcdC8vIE1vZHVsZXNcclxuXHRcdG1vZHVsZXM6IHt9LFxyXG5cdFx0XHJcblx0XHQvLyBWZXJzaW9uXHJcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uLFxyXG5cdFx0XHJcblx0XHQvLyBQYXJzZXJcclxuXHRcdHBhcnNlcjoge1xyXG5cdFx0XHR0b2tlbml6ZXI6IFRva2VuaXplcixcclxuXHRcdFx0ZXhwcmVzc2lvbjogcGFyc2VFeHByXHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBVdGlsc1xyXG5cdFx0dXRpbHM6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFN0cmluZyB0byBpbmRpY2F0b3JcclxuXHRcdFx0c3RyX2luZGljYXRvcjogc3RyX2luZGljYXRvcixcclxuXHRcdFx0Ly8gQ29kZSBwb2ludCBhdFxyXG5cdFx0XHRjb2RlUG9pbnRBdDogY29kZVBvaW50QXQsXHJcblx0XHRcdC8vIEZyb20gY29kZSBwb2ludFxyXG5cdFx0XHRmcm9tQ29kZVBvaW50OiBmcm9tQ29kZVBvaW50LFxyXG5cdFx0XHQvLyBMZW5ndGggb2Ygc3RyaW5nXHJcblx0XHRcdHN0cmluZ0xlbmd0aDogc3RyaW5nTGVuZ3RoXHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gU3RhdGlzdGljc1xyXG5cdFx0c3RhdGlzdGljczoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTnVtYmVyIG9mIGNyZWF0ZWQgdGVybXNcclxuXHRcdFx0Z2V0Q291bnRUZXJtczogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRlcm1fcmVmO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gSmF2YVNjcmlwdCB0byBQcm9sb2dcclxuXHRcdGZyb21KYXZhU2NyaXB0OiB7XHJcblx0XHRcdFxyXG5cdFx0XHQvLyBUeXBlIHRlc3RpbmdcclxuXHRcdFx0dGVzdDoge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEJvb2xlYW5cclxuXHRcdFx0XHRib29sZWFuOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gTnVtYmVyXHJcblx0XHRcdFx0bnVtYmVyOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCI7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBTdHJpbmdcclxuXHRcdFx0XHRzdHJpbmc6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIjtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIExpc3RcclxuXHRcdFx0XHRsaXN0OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gVmFyaWFibGVcclxuXHRcdFx0XHR2YXJpYWJsZTogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBvYmogPT09IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBPYmplY3RcclxuXHRcdFx0XHRvYmplY3Q6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHR0b2JqID0gdG9iaiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0b2JqO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRvYmogJiYgIShvYmogaW5zdGFuY2VvZiBBcnJheSkgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIjtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIEFueVxyXG5cdFx0XHRcdGFueTogZnVuY3Rpb24oIF8sIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGdW5jdGlvbiBjb252ZXJzaW9uXHJcblx0XHRcdGNvbnZlcnNpb246IHtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBCb2xlYW5cclxuXHRcdFx0XHRib29sZWFuOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBvYmogPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgW10gKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIE51bWJlclxyXG5cdFx0XHRcdG51bWJlcjogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgTnVtKCBvYmosIG9iaiAlIDEgIT09IDAgKTtcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vIFN0cmluZ1xyXG5cdFx0XHRcdHN0cmluZzogZnVuY3Rpb24oIG9iaiwgdG9iaiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgVGVybSggb2JqLCBbXSApO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly8gTGlzdFxyXG5cdFx0XHRcdGxpc3Q6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHR0b2JqID0gdG9iaiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiB0b2JqO1xyXG5cdFx0XHRcdFx0dmFyIGFyciA9IFtdO1xyXG5cdFx0XHRcdFx0dmFyIGVsZW07XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0ZWxlbSA9IHBsLmZyb21KYXZhU2NyaXB0LmFwcGx5KCBvYmpbaV0sIHRvYmogKTtcclxuXHRcdFx0XHRcdFx0aWYoIGVsZW0gPT09IHVuZGVmaW5lZCApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdFx0YXJyLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBhcnJheVRvTGlzdCggYXJyICk7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBWYXJpYWJsZVxyXG5cdFx0XHRcdHZhcmlhYmxlOiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBWYXIoIFwiX1wiICk7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gT2JqZWN0XHJcblx0XHRcdFx0b2JqZWN0OiBmdW5jdGlvbiggb2JqLCB0b2JqICkge1xyXG5cdFx0XHRcdFx0dG9iaiA9IHRvYmogPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdG9iajtcclxuXHRcdFx0XHRcdHZhciBsaXN0ID0gbmV3IFRlcm0oXCJbXVwiLCBbXSk7XHJcblx0XHRcdFx0XHR2YXIgYXJyID0gW107XHJcblx0XHRcdFx0XHRmb3IodmFyIHByb3AgaW4gb2JqKSB7XHJcblx0XHRcdFx0XHRcdGlmKCFvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRhcnIucHVzaChuZXcgVGVybShcIi1cIiwgW1xyXG5cdFx0XHRcdFx0XHRcdHBsLmZyb21KYXZhU2NyaXB0LmFwcGx5KHByb3AsIHRvYmopLFxyXG5cdFx0XHRcdFx0XHRcdHBsLmZyb21KYXZhU2NyaXB0LmFwcGx5KG9ialtwcm9wXSwgdG9iailcclxuXHRcdFx0XHRcdFx0XSkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIGFycmF5VG9MaXN0KGFycik7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcclxuXHRcdFx0XHQvLyBBbnlcclxuXHRcdFx0XHRhbnk6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFRyYW5zZm9ybSBvYmplY3RcclxuXHRcdFx0YXBwbHk6IGZ1bmN0aW9uKCBvYmosIHRvYmogKSB7XHJcblx0XHRcdFx0dG9iaiA9IHRvYmogPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogdG9iajtcclxuXHRcdFx0XHRmb3IoIHZhciBpIGluIHBsLmZyb21KYXZhU2NyaXB0LnRlc3QgKVxyXG5cdFx0XHRcdFx0aWYoIGkgIT09IFwiYW55XCIgJiYgcGwuZnJvbUphdmFTY3JpcHQudGVzdFtpXSggb2JqLCB0b2JqICkgKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcGwuZnJvbUphdmFTY3JpcHQuY29udmVyc2lvbltpXSggb2JqLCB0b2JqICk7XHJcblx0XHRcdFx0cmV0dXJuIHBsLmZyb21KYXZhU2NyaXB0LmNvbnZlcnNpb24uYW55KCBvYmosIHRvYmogKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVHlwZXNcclxuXHRcdHR5cGU6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIE9iamVjdHNcclxuXHRcdFx0VmFyOiBWYXIsXHJcblx0XHRcdE51bTogTnVtLFxyXG5cdFx0XHRUZXJtOiBUZXJtLFxyXG5cdFx0XHRSdWxlOiBSdWxlLFxyXG5cdFx0XHRTdGF0ZTogU3RhdGUsXHJcblx0XHRcdFN0cmVhbTogU3RyZWFtLFxyXG5cdFx0XHRNb2R1bGU6IE1vZHVsZSxcclxuXHRcdFx0VGhyZWFkOiBUaHJlYWQsXHJcblx0XHRcdFNlc3Npb246IFNlc3Npb24sXHJcblx0XHRcdFN1YnN0aXR1dGlvbjogU3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRGaWxlOiBUYXVGaWxlLFxyXG5cdFx0XHREaXJlY3Rvcnk6IFRhdURpcmVjdG9yeSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE9yZGVyXHJcblx0XHRcdG9yZGVyOiBbVmFyLCBOdW0sIFRlcm0sIFN0cmVhbV0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDb21wYXJlIHR5cGVzXHJcblx0XHRcdGNvbXBhcmU6IGZ1bmN0aW9uKCB4LCB5ICkge1xyXG5cdFx0XHRcdHZhciBvcmRfeCA9IGluZGV4T2YoIHBsLnR5cGUub3JkZXIsIHguY29uc3RydWN0b3IgKTtcclxuXHRcdFx0XHR2YXIgb3JkX3kgPSBpbmRleE9mKCBwbC50eXBlLm9yZGVyLCB5LmNvbnN0cnVjdG9yICk7XHJcblx0XHRcdFx0aWYoIG9yZF94IDwgb3JkX3kgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gLTE7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBvcmRfeCA+IG9yZF95ICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIDE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKCB4LmNvbnN0cnVjdG9yID09PSBOdW0gKVxyXG5cdFx0XHRcdFx0XHRpZiggeC5pc19mbG9hdCAmJiB5LmlzX2Zsb2F0IClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0XHRcdFx0ZWxzZSBpZiggeC5pc19mbG9hdCApXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHRcdFx0XHRlbHNlIGlmKCB5LmlzX2Zsb2F0IClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgc3Vic3RpdHV0aW9uXHJcblx0XHRcdGlzX3N1YnN0aXR1dGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgU3Vic3RpdHV0aW9uO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBzdGF0ZVxyXG5cdFx0XHRpc19zdGF0ZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgU3RhdGU7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHJ1bGVcclxuXHRcdFx0aXNfcnVsZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgUnVsZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgdmFyaWFibGVcclxuXHRcdFx0aXNfdmFyaWFibGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFZhcjtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgc3RyZWFtXHJcblx0XHRcdGlzX3N0cmVhbTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgU3RyZWFtO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gYW5vbnltb3VzIHZhcmlhYmxlXHJcblx0XHRcdGlzX2Fub255bW91c192YXI6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFZhciAmJiBvYmouaWQgPT09IFwiX1wiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBjYWxsYWJsZSB0ZXJtXHJcblx0XHRcdGlzX2NhbGxhYmxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtXHJcblx0XHRcdFx0JiYgKGluZGV4T2YoW1wiLC8yXCIsXCI7LzJcIixcIi0+LzJcIl0sIG9iai5pbmRpY2F0b3IpID09PSAtMVxyXG5cdFx0XHRcdHx8IHBsLnR5cGUuaXNfY2FsbGFibGUob2JqLmFyZ3NbMF0pICYmIHBsLnR5cGUuaXNfY2FsbGFibGUob2JqLmFyZ3NbMV0pKVxyXG5cdFx0XHRcdHx8IG9iaiBpbnN0YW5jZW9mIFZhcjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgbnVtYmVyXHJcblx0XHRcdGlzX251bWJlcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgTnVtO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gaW50ZWdlclxyXG5cdFx0XHRpc19pbnRlZ2VyOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgIW9iai5pc19mbG9hdDtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgZmxvYXRcclxuXHRcdFx0aXNfZmxvYXQ6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiBvYmouaXNfZmxvYXQ7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHRlcm1cclxuXHRcdFx0aXNfdGVybTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIGF0b21cclxuXHRcdFx0aXNfYXRvbTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJncy5sZW5ndGggPT09IDA7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGdyb3VuZCB0ZXJtXHJcblx0XHRcdGlzX2dyb3VuZDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRpZiggb2JqIGluc3RhbmNlb2YgVmFyICkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdGlmKCBvYmogaW5zdGFuY2VvZiBUZXJtIClcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgb2JqLmFyZ3MubGVuZ3RoOyBpKysgKVxyXG5cdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfZ3JvdW5kKCBvYmouYXJnc1tpXSApIClcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhdG9taWNcclxuXHRcdFx0aXNfYXRvbWljOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzLmxlbmd0aCA9PT0gMCB8fCBvYmogaW5zdGFuY2VvZiBOdW07XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBjb21wb3VuZFxyXG5cdFx0XHRpc19jb21wb3VuZDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJncy5sZW5ndGggPiAwO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBsaXN0XHJcblx0XHRcdGlzX2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgKG9iai5pbmRpY2F0b3IgPT09IFwiW10vMFwiIHx8IG9iai5pbmRpY2F0b3IgPT09IFwiLi8yXCIpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gZW1wdHkgbGlzdFxyXG5cdFx0XHRpc19lbXB0eV9saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiW10vMFwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBub24gZW1wdHkgbGlzdFxyXG5cdFx0XHRpc19ub25fZW1wdHlfbGlzdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIi4vMlwiO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBmdWxseSBsaXN0XHJcblx0XHRcdGlzX2Z1bGx5X2xpc3Q6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0d2hpbGUoIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdG9iaiA9IG9iai5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVmFyIHx8IG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCJbXS8wXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGluc3RhbnRpYXRlZCBsaXN0XHJcblx0XHRcdGlzX2luc3RhbnRpYXRlZF9saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHdoaWxlKCBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRvYmogPSBvYmouYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmluZGljYXRvciA9PT0gXCJbXS8wXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhbiB1bml0YXJ5IGxpc3RcclxuXHRcdFx0aXNfdW5pdGFyeV9saXN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwiLi8yXCIgJiYgb2JqLmFyZ3NbMV0gaW5zdGFuY2VvZiBUZXJtICYmIG9iai5hcmdzWzFdLmluZGljYXRvciA9PT0gXCJbXS8wXCI7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGNoYXJhY3RlclxyXG5cdFx0XHRpc19jaGFyYWN0ZXI6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgb2JqLmFyZ3MubGVuZ3RoID09PSAwICYmIChvYmouaWQubGVuZ3RoID09PSAxIHx8IG9iai5pZC5sZW5ndGggPiAwICYmIG9iai5pZC5sZW5ndGggPD0gMiAmJiBjb2RlUG9pbnRBdCggb2JqLmlkLCAwICkgPj0gNjU1MzYpO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBpbl9jaGFyYWN0ZXJcclxuXHRcdFx0aXNfaW5fY2hhcmFjdGVyOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIChvYmouaW5kaWNhdG9yID09PSBcImVuZF9vZl9maWxlLzBcIlxyXG5cdFx0XHRcdHx8IG9iai5pZC5sZW5ndGggPT09IDFcclxuXHRcdFx0XHR8fCBvYmouaWQubGVuZ3RoID4gMCAmJiBvYmouaWQubGVuZ3RoIDw9IDIgJiYgY29kZVBvaW50QXQob2JqLmlkLCAwKSA+PSA2NTUzNik7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGNoYXJhY3Rlcl9jb2RlXHJcblx0XHRcdGlzX2NoYXJhY3Rlcl9jb2RlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgIW9iai5pc19mbG9hdCAmJiBvYmoudmFsdWUgPj0gMCAmJiBvYmoudmFsdWUgPD0gMTExNDExMTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgaW5fY2hhcmFjdGVyX2NvZGVcclxuXHRcdFx0aXNfaW5fY2hhcmFjdGVyX2NvZGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiAhb2JqLmlzX2Zsb2F0ICYmIG9iai52YWx1ZSA+PSAtMSAmJiBvYmoudmFsdWUgPD0gMTExNDExMTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgYnl0ZVxyXG5cdFx0XHRpc19ieXRlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBOdW0gJiYgIW9iai5pc19mbG9hdCAmJiBvYmoudmFsdWUgPj0gMCAmJiBvYmoudmFsdWUgPD0gMjU1O1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBpbl9ieXRlXHJcblx0XHRcdGlzX2luX2J5dGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE51bSAmJiAhb2JqLmlzX2Zsb2F0ICYmIG9iai52YWx1ZSA+PSAtMSAmJiBvYmoudmFsdWUgPD0gMjU1O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYW4gb3BlcmF0b3JcclxuXHRcdFx0aXNfb3BlcmF0b3I6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgcGwuYXJpdGhtZXRpYy5ldmFsdWF0aW9uW29iai5pbmRpY2F0b3JdO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSXMgYSBkaXJlY3RpdmVcclxuXHRcdFx0aXNfZGlyZWN0aXZlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIChwbC5kaXJlY3RpdmVbb2JqLmluZGljYXRvcl0gIT09IHVuZGVmaW5lZCB8fCBwbC5kaXJlY3RpdmVbb2JqLmlkICsgXCIvKlwiXSAhPT0gdW5kZWZpbmVkKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGEgYnVpbHQtaW4gcHJlZGljYXRlXHJcblx0XHRcdGlzX2J1aWx0aW46IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRlcm0gJiYgcGwuYnVpbHRpbi5ydWxlcy5oYXNPd25Qcm9wZXJ0eShvYmouaW5kaWNhdG9yKSAmJiBvYmouaW5kaWNhdG9yICE9PSBcImdvYWxfZXhwYW5zaW9uLzJcIjtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIElzIGFuIGVycm9yXHJcblx0XHRcdGlzX2Vycm9yOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmogaW5zdGFuY2VvZiBUZXJtICYmIG9iai5pbmRpY2F0b3IgPT09IFwidGhyb3cvMVwiO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYW4gZXJyb3Igc3RhdGVcclxuXHRcdFx0aXNfZXJyb3Jfc3RhdGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfc3RhdGUoIG9iaiApICYmIG9iai5lcnJvciAmJiBvYmouZXJyb3IgPT09IHRydWU7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHByZWRpY2F0ZSBpbmRpY2F0b3JcclxuXHRcdFx0aXNfcHJlZGljYXRlX2luZGljYXRvcjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouaW5kaWNhdG9yID09PSBcIi8vMlwiICYmIG9iai5hcmdzWzBdIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJnc1swXS5hcmdzLmxlbmd0aCA9PT0gMCAmJiBvYmouYXJnc1sxXSBpbnN0YW5jZW9mIE51bSAmJiBvYmouYXJnc1sxXS5pc19mbG9hdCA9PT0gZmFsc2U7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIGZsYWdcclxuXHRcdFx0aXNfZmxhZzogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGVybSAmJiBvYmouYXJncy5sZW5ndGggPT09IDAgJiYgcGwuZmxhZ1tvYmouaWRdICE9PSB1bmRlZmluZWQ7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIHZhbGlkIHZhbHVlIGZvciBhIGZsYWdcclxuXHRcdFx0aXNfdmFsdWVfZmxhZzogZnVuY3Rpb24oIGZsYWcsIG9iaiApIHtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfZmxhZyggZmxhZyApICkgcmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdGZvciggdmFyIHZhbHVlIGluIHBsLmZsYWdbZmxhZy5pZF0uYWxsb3dlZCApIHtcclxuXHRcdFx0XHRcdGlmKCFwbC5mbGFnW2ZsYWcuaWRdLmFsbG93ZWQuaGFzT3duUHJvcGVydHkodmFsdWUpKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdGlmKCBwbC5mbGFnW2ZsYWcuaWRdLmFsbG93ZWRbdmFsdWVdLmVxdWFscyggb2JqICkgKSByZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBpbyBtb2RlXHJcblx0XHRcdGlzX2lvX21vZGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfYXRvbSggb2JqICkgJiYgW1wicmVhZFwiLFwid3JpdGVcIixcImFwcGVuZFwiXS5pbmRleE9mKCBvYmouaWQgKSAhPT0gLTE7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHN0cmVhbSBvcHRpb25cclxuXHRcdFx0aXNfc3RyZWFtX29wdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKCBvYmogKSAmJiAoXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImFsaWFzLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInJlcG9zaXRpb24vMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJ0eXBlLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0ZXh0XCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiYmluYXJ5XCIpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImVvZl9hY3Rpb24vMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcImVycm9yXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZW9mX2NvZGVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJyZXNldFwiKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHN0cmVhbSBwb3NpdGlvblxyXG5cdFx0XHRpc19zdHJlYW1fcG9zaXRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybShvYmopICYmIChcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZW5kX29mX3N0cmVhbS8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJwb3NpdGlvbi8zXCJcclxuXHRcdFx0XHRcdFx0JiYgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzBdKVxyXG5cdFx0XHRcdFx0XHQmJiBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMV0pXHJcblx0XHRcdFx0XHRcdCYmIHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1syXSlcclxuXHRcdFx0XHQpXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHN0cmVhbSBwcm9wZXJ0eVxyXG5cdFx0XHRpc19zdHJlYW1fcHJvcGVydHk6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybSggb2JqICkgJiYgKFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJpbnB1dC8wXCIgfHwgXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm91dHB1dC8wXCIgfHwgXHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImFsaWFzLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20oIG9iai5hcmdzWzBdICkpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcImZpbGVfbmFtZS8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKCBvYmouYXJnc1swXSApKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJyZXBvc2l0aW9uLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIikpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInR5cGUvMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRleHRcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJiaW5hcnlcIikpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcIm1vZGUvMVwiICYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKCBvYmouYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInJlYWRcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJ3cml0ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImFwcGVuZFwiKSkgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwiZW9mX2FjdGlvbi8xXCIgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG9iai5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwiZXJyb3JcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJlb2ZfY29kZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcInJlc2V0XCIpKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJlbmRfb2Zfc3RyZWFtLzFcIiAmJiAocGwudHlwZS5pc192YXJpYWJsZSggb2JqLmFyZ3NbMF0gKSB8fCBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJhdFwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcInBhc3RcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJub3RcIikpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInBvc2l0aW9uLzFcIlxyXG5cdFx0XHRcdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShvYmouYXJnc1swXSkgfHwgcGwudHlwZS5pc190ZXJtKG9iai5hcmdzWzBdKSAmJiBvYmouYXJnc1swXS5pbmRpY2F0b3IgPT09IFwicG9zaXRpb24vM1wiXHJcblx0XHRcdFx0XHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUob2JqLmFyZ3NbMF0uYXJnc1swXSkgfHwgcGwudHlwZS5pc19pbnRlZ2VyKG9iai5hcmdzWzBdLmFyZ3NbMF0pKVxyXG5cdFx0XHRcdFx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKG9iai5hcmdzWzBdLmFyZ3NbMV0pIHx8IHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1swXS5hcmdzWzFdKSlcclxuXHRcdFx0XHRcdFx0XHQmJiAocGwudHlwZS5pc192YXJpYWJsZShvYmouYXJnc1swXS5hcmdzWzJdKSB8fCBwbC50eXBlLmlzX2ludGVnZXIob2JqLmFyZ3NbMF0uYXJnc1syXSkpKVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHN0cmVhbWFibGUgdGVybVxyXG5cdFx0XHRpc19zdHJlYW1hYmxlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBvYmouX19wcm90b19fLnN0cmVhbSAhPT0gdW5kZWZpbmVkO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSByZWFkIG9wdGlvblxyXG5cdFx0XHRpc19yZWFkX29wdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKCBvYmogKSAmJiBbXCJ2YXJpYWJsZXMvMVwiLFwidmFyaWFibGVfbmFtZXMvMVwiLFwic2luZ2xldG9ucy8xXCJdLmluZGV4T2YoIG9iai5pbmRpY2F0b3IgKSAhPT0gLTE7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHdyaXRlIG9wdGlvblxyXG5cdFx0XHRpc193cml0ZV9vcHRpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfdGVybSggb2JqICkgJiYgKFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJxdW90ZWQvMVwiICYmIHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiYgKG9iai5hcmdzWzBdLmlkID09PSBcInRydWVcIiB8fCBvYmouYXJnc1swXS5pZCA9PT0gXCJmYWxzZVwiKSB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJpZ25vcmVfb3BzLzFcIiAmJiBwbC50eXBlLmlzX2F0b20ob2JqLmFyZ3NbMF0pICYmIChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIikgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwibnVtYmVydmFycy8xXCIgJiYgcGwudHlwZS5pc19hdG9tKG9iai5hcmdzWzBdKSAmJiAob2JqLmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiIHx8IG9iai5hcmdzWzBdLmlkID09PSBcImZhbHNlXCIpIHx8XHJcblx0XHRcdFx0XHRvYmouaW5kaWNhdG9yID09PSBcInZhcmlhYmxlX25hbWVzLzFcIiAmJiBwbC50eXBlLmlzX2Z1bGx5X2xpc3Qob2JqLmFyZ3NbMF0pXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgY2xvc2Ugb3B0aW9uXHJcblx0XHRcdGlzX2Nsb3NlX29wdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKCBvYmogKSAmJlxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJmb3JjZS8xXCIgJiZcclxuXHRcdFx0XHRcdHBsLnR5cGUuaXNfYXRvbShvYmouYXJnc1swXSkgJiZcclxuXHRcdFx0XHRcdChvYmouYXJnc1swXS5pZCA9PT0gXCJ0cnVlXCIgfHwgb2JqLmFyZ3NbMF0uaWQgPT09IFwiZmFsc2VcIik7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBJcyBhIG1vZGlmaWFibGUgZmxhZ1xyXG5cdFx0XHRpc19tb2RpZmlhYmxlX2ZsYWc6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfZmxhZyggb2JqICkgJiYgcGwuZmxhZ1tvYmouaWRdLmNoYW5nZWFibGU7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIG1vZHVsZVxyXG5cdFx0XHRpc19tb2R1bGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vZHVsZTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgdmlydHVhbCBmaWxlXHJcblx0XHRcdGlzX2ZpbGU6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRcdFx0cmV0dXJuIG9iaiBpbnN0YW5jZW9mIFRhdUZpbGU7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBJcyBhIHZpcnR1YWwgZGlyZWN0b3J5XHJcblx0XHRcdGlzX2RpcmVjdG9yeTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdFx0XHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgVGF1RGlyZWN0b3J5O1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBwcmVkaWNhdGUgcHJvcGVydHlcclxuXHRcdFx0aXNfcHJlZGljYXRlX3Byb3BlcnR5OiBmdW5jdGlvbihvYmopIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwudHlwZS5pc190ZXJtKG9iaikgJiYgKFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJidWlsdF9pbi8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwic3RhdGljLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJkeW5hbWljLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJuYXRpdmVfY29kZS8wXCIgfHxcclxuXHRcdFx0XHRcdG9iai5pbmRpY2F0b3IgPT09IFwibXVsdGlmaWxlLzBcIiB8fFxyXG5cdFx0XHRcdFx0b2JqLmluZGljYXRvciA9PT0gXCJtZXRhX3ByZWRpY2F0ZS8xXCJcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gSXMgYSBtZXRhLWFyZ3VtZW50IHNwZWNpZmllclxyXG5cdFx0XHRpc19tZXRhX2FyZ3VtZW50X3NwZWNpZmllcjogZnVuY3Rpb24ob2JqKSB7XHJcblx0XHRcdFx0cmV0dXJuIHBsLnR5cGUuaXNfaW50ZWdlcihvYmopICYmIG9iai52YWx1ZSA+PSAwIHx8XHJcblx0XHRcdFx0XHRwbC50eXBlLmlzX2F0b20ob2JqKSAmJiBpbmRleE9mKFtcIitcIiwgXCItXCIsIFwiP1wiLCBcIipcIiwgXCJeXCIsIFwiOlwiLCBcIi8vXCJdLCBvYmouaWQpICE9PSAtMTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIElzIGEgdGltZSBwcm9wZXJ0eVxyXG5cdFx0XHRpc190aW1lX3Byb3BlcnR5OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdHJldHVybiBwbC50eXBlLmlzX3Rlcm0ob2JqKSAmJiBvYmouYXJncy5sZW5ndGggPT09IDEgXHJcblx0XHRcdFx0JiYgKHBsLnR5cGUuaXNfdmFyaWFibGUob2JqLmFyZ3NbMF0pIHx8IHBsLnR5cGUuaXNfaW50ZWdlcihvYmouYXJnc1swXSkpXHJcblx0XHRcdFx0JiYgaW5kZXhPZihbXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsIFwibWlsbGlzZWNvbmRzXCIsIFwid2Vla2RheVwiXSwgb2JqLmlkKSAhPT0gLTE7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBBcml0aG1ldGljIGZ1bmN0aW9uc1xyXG5cdFx0YXJpdGhtZXRpYzoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRXZhbHVhdGlvblxyXG5cdFx0XHRldmFsdWF0aW9uOiB7XHJcblx0XHRcdFx0XCJlLzBcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIF8gKSB7IHJldHVybiBNYXRoLkU7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwicGkvMFwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggXyApIHsgcmV0dXJuIE1hdGguUEk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwidGF1LzBcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIF8gKSB7IHJldHVybiAyKk1hdGguUEk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZXBzaWxvbi8wXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCBfICkgeyByZXR1cm4gTnVtYmVyLkVQU0lMT047IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiKy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4geDsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCItLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiAteDsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJcXFxcLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIH54OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImFicy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5hYnMoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJzaWduLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnNpZ24oIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJmbG9hdF9pbnRlZ2VyX3BhcnQvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBwYXJzZUludCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImZsb2F0X2ZyYWN0aW9uYWxfcGFydC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4geCAtIHBhcnNlSW50KCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZmxvYXQvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIHBhcnNlRmxvYXQoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJmbG9vci8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguZmxvb3IoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJ0cnVuY2F0ZS8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIHBhcnNlSW50KCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwicm91bmQvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IHRydWUsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnJvdW5kKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiY2VpbGluZy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogdHJ1ZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguY2VpbCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInNpbi8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5zaW4oIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJjb3MvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguY29zKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwidGFuLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLnRhbiggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImFzaW4vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4gTWF0aC5hYnMoeCkgPD0gMSA/IE1hdGguYXNpbih4KSA6IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImFjb3MvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4gTWF0aC5hYnMoeCkgPD0gMSA/IE1hdGguYWNvcyh4KSA6IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImF0YW4vMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguYXRhbiggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImF0YW4yLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHggPT09IDAgJiYgeSA9PT0gMCA/IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpIDogTWF0aC5hdGFuMih4LCB5KTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhY29zaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiB4ID49IDEgPyBNYXRoLmFjb3NoKHgpIDogcGwuZXJyb3IuZXZhbHVhdGlvbihcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcik7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiYXNpbmgvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgXyApIHsgcmV0dXJuIE1hdGguYXNpbmgoIHggKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJhdGFuaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiBNYXRoLmFicyh4KSA8IDEgPyBNYXRoLmF0YW5oKHgpIDogcGwuZXJyb3IuZXZhbHVhdGlvbihcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcik7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiY29zaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5jb3NoKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwic2luaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC5zaW5oKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwidGFuaC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCBfICkgeyByZXR1cm4gTWF0aC50YW5oKCB4ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiZXhwLzFcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IHRydWUsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIF8gKSB7IHJldHVybiBNYXRoLmV4cCggeCApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInNxcnQvMVwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgdGhyZWFkICkgeyByZXR1cm4geCA+PSAwID8gTWF0aC5zcXJ0KCB4ICkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImxvZy8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiB4ID4gMCA/IE1hdGgubG9nKCB4ICkgOiBwbC5lcnJvci5ldmFsdWF0aW9uKCBcInVuZGVmaW5lZFwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImxvZy8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB4ID4gMCAmJiB5ID4gMCA/IE1hdGgubG9nKHkpL01hdGgubG9nKHgpIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ1bmRlZmluZWRcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJsb2cxMC8xXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiB0cnVlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB0aHJlYWQgKSB7IHJldHVybiB4ID4gMCA/IE1hdGgubG9nKHgpL01hdGgubG9nKDEwKSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwidW5kZWZpbmVkXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiKy8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCArIHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiLS8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogbnVsbCxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBudWxsLFxyXG5cdFx0XHRcdFx0Zm46ICBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggLSB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIiovMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggKiB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIi8vMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geSA/IHggLyB5IDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIvLy8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHkgPyBNYXRoLnRydW5jKCB4IC8geSApIDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJkaXYvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB5ID8gTWF0aC5mbG9vciggeCAvIHkgKSA6IHBsLmVycm9yLmV2YWx1YXRpb24oIFwiemVyb19kaXZpc29yXCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiKiovMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogdHJ1ZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geCA9PSAwICYmIHkgPCAwID8gcGwuZXJyb3IuZXZhbHVhdGlvbihcInplcm9fZGl2aXNvclwiLCB0aHJlYWQuX19jYWxsX2luZGljYXRvcikgOiBNYXRoLnBvdyh4LCB5KTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJeLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIHRocmVhZCApIHsgcmV0dXJuIHggPT0gMCAmJiB5IDwgMCA/IHBsLmVycm9yLmV2YWx1YXRpb24oXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IpIDogTWF0aC5wb3coeCwgeSk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwiPDwvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCA8PCB5OyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcIj4+LzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIHggPj4geTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCIvXFxcXC8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4ICYgeTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJcXFxcLy8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiB4IHwgeTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJ4b3IvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCBfICkgeyByZXR1cm4geCBeIHk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwicmVtLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBmYWxzZSxcclxuXHRcdFx0XHRcdHR5cGVfcmVzdWx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgdGhyZWFkICkgeyByZXR1cm4geSA/IHggJSB5IDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJtb2QvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IGZhbHNlLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0Zm46IGZ1bmN0aW9uKCB4LCB5LCB0aHJlYWQgKSB7IHJldHVybiB5ID8geCAtIE1hdGguZmxvb3IoIHggLyB5ICkgKiB5IDogcGwuZXJyb3IuZXZhbHVhdGlvbiggXCJ6ZXJvX2Rpdmlzb3JcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTsgfVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJtYXgvMlwiOiB7XHJcblx0XHRcdFx0XHR0eXBlX2FyZ3M6IG51bGwsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogbnVsbCxcclxuXHRcdFx0XHRcdGZuOiBmdW5jdGlvbiggeCwgeSwgXyApIHsgcmV0dXJuIE1hdGgubWF4KCB4LCB5ICk7IH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwibWluLzJcIjoge1xyXG5cdFx0XHRcdFx0dHlwZV9hcmdzOiBudWxsLFxyXG5cdFx0XHRcdFx0dHlwZV9yZXN1bHQ6IG51bGwsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiBNYXRoLm1pbiggeCwgeSApOyB9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcImdjZC8yXCI6IHtcclxuXHRcdFx0XHRcdHR5cGVfYXJnczogZmFsc2UsXHJcblx0XHRcdFx0XHR0eXBlX3Jlc3VsdDogZmFsc2UsXHJcblx0XHRcdFx0XHRmbjogZnVuY3Rpb24oIHgsIHksIF8gKSB7IHJldHVybiBnY2QoeCwgeSk7IH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBEaXJlY3RpdmVzXHJcblx0XHRkaXJlY3RpdmU6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIGR5bmFtaWMvMVxyXG5cdFx0XHRcImR5bmFtaWMvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBhdG9tLCBvcHRpb25zICkge1xyXG5cdFx0XHRcdHZhciBpbmRpY2F0b3JzID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2xpc3QoaW5kaWNhdG9ycykpXHJcblx0XHRcdFx0XHRpbmRpY2F0b3JzID0gYXJyYXlUb0xpc3QoW2luZGljYXRvcnNdKTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGluZGljYXRvcnM7XHJcblx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRpbmRpY2F0b3IgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NvbXBvdW5kKCBpbmRpY2F0b3IgKSB8fCBpbmRpY2F0b3IuaW5kaWNhdG9yICE9PSBcIi8vMlwiICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIGluZGljYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IuYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvci5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGluZGljYXRvci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgaW5kaWNhdG9yLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggaW5kaWNhdG9yLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBpbmRpY2F0b3IuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dmFyIGtleSA9IGluZGljYXRvci5hcmdzWzBdLmlkICsgXCIvXCIgKyBpbmRpY2F0b3IuYXJnc1sxXS52YWx1ZTtcclxuXHRcdFx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdO1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnB1YmxpY19wcmVkaWNhdGVzW2tleV0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRpZiggIWdldF9tb2R1bGUucnVsZXNba2V5XSApXHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNba2V5XSA9IFtdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShwb2ludGVyKSB8fCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgaW5kaWNhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gZHluYW1pYy9bMi4uXVxyXG5cdFx0XHRcImR5bmFtaWMvKlwiOiBmdW5jdGlvbiggdGhyZWFkLCBhdG9tICkge1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhdG9tLmFyZ3MubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHBsLmRpcmVjdGl2ZVtcImR5bmFtaWMvMVwiXSh0aHJlYWQsIG5ldyBUZXJtKFwiZHluYW1pY1wiLCBbYXRvbS5hcmdzW2ldXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIG11bHRpZmlsZS8xXHJcblx0XHRcdFwibXVsdGlmaWxlLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgYXRvbSwgb3B0aW9ucyApIHtcclxuXHRcdFx0XHR2YXIgaW5kaWNhdG9yID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jb21wb3VuZCggaW5kaWNhdG9yICkgfHwgaW5kaWNhdG9yLmluZGljYXRvciAhPT0gXCIvLzJcIiApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgaW5kaWNhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBpbmRpY2F0b3IuYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGluZGljYXRvci5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggaW5kaWNhdG9yLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgaW5kaWNhdG9yLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGluZGljYXRvci5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGluZGljYXRvci5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBwcmVkaWNhdGVfaW5kaWNhdG9yID0gYXRvbS5hcmdzWzBdLmFyZ3NbMF0uaWQgKyBcIi9cIiArIGF0b20uYXJnc1swXS5hcmdzWzFdLnZhbHVlO1xyXG5cdFx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW29wdGlvbnMuY29udGV4dF9tb2R1bGVdO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5tdWx0aWZpbGVfcHJlZGljYXRlc1twcmVkaWNhdGVfaW5kaWNhdG9yXSA9IHRydWU7XHJcblx0XHRcdFx0XHRpZighZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShwcmVkaWNhdGVfaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW3ByZWRpY2F0ZV9pbmRpY2F0b3JdID0gW107XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNbcHJlZGljYXRlX2luZGljYXRvcl0gPSBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBtZXRhX3ByZWRpY2F0ZS8xXHJcblx0XHRcdFwibWV0YV9wcmVkaWNhdGUvMVwiOiBmdW5jdGlvbih0aHJlYWQsIGF0b20sIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdFx0XHR2YXIgaGVhZCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZShoZWFkKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaGVhZC5hcmdzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBoZWFkLmFyZ3NbaV07XHJcblx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX21ldGFfYXJndW1lbnRfc3BlY2lmaWVyKGFyZykpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwibWV0YV9hcmd1bWVudF9zcGVjaWZpZXJcIiwgYXJnLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXS5tZXRhX3ByZWRpY2F0ZXNbaGVhZC5pbmRpY2F0b3JdID0gaGVhZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBzZXRfcHJvbG9nX2ZsYWdcclxuXHRcdFx0XCJzZXRfcHJvbG9nX2ZsYWcvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBhdG9tICkge1xyXG5cdFx0XHRcdHZhciBmbGFnID0gYXRvbS5hcmdzWzBdLCB2YWx1ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggZmxhZyApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggZmxhZyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19mbGFnKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuZG9tYWluKCBcInByb2xvZ19mbGFnXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX21vZGlmaWFibGVfZmxhZyggZmxhZyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwibW9kaWZ5XCIsIFwiZmxhZ1wiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YWx1ZV9mbGFnKCBmbGFnLCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmRvbWFpbiggXCJmbGFnX3ZhbHVlXCIsIG5ldyBUZXJtKCBcIitcIiwgW2ZsYWcsIHZhbHVlXSApLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLmZsYWdbZmxhZy5pZF0gPSB2YWx1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBtb2R1bGUvMlxyXG5cdFx0XHRcIm1vZHVsZS8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgYXRvbSwgb3B0aW9ucykge1xyXG5cdFx0XHRcdHZhciBvcHRpb25zID0gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID8ge30gOiBvcHRpb25zO1xyXG5cdFx0XHRcdG9wdGlvbnMuY29udGV4dF9tb2R1bGUgPSBvcHRpb25zLmNvbnRleHRfbW9kdWxlID09PSB1bmRlZmluZWQgPyBcInVzZXJcIiA6IG9wdGlvbnMuY29udGV4dF9tb2R1bGU7XHJcblx0XHRcdFx0dmFyIG1vZHVsZV9pZCA9IGF0b20uYXJnc1swXSwgZXhwb3J0cyA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKG1vZHVsZV9pZCkgfHwgcGwudHlwZS5pc192YXJpYWJsZShleHBvcnRzKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19hdG9tKG1vZHVsZV9pZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJhdG9tXCIsIG1vZHVsZV9pZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfbGlzdChleHBvcnRzKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImxpc3RcIiwgZXhwb3J0cywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkLmluZGljYXRvcl0pKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwb2ludGVyID0gZXhwb3J0cztcclxuXHRcdFx0XHRcdFx0dmFyIGluZGljYXRvcnMgPSBbXTtcclxuXHRcdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHByZWRpY2F0ZSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc19wcmVkaWNhdGVfaW5kaWNhdG9yKHByZWRpY2F0ZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnR5cGUoXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIHByZWRpY2F0ZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0aW5kaWNhdG9ycy5wdXNoKHByZWRpY2F0ZS5hcmdzWzBdLmlkICsgXCIvXCIgKyBwcmVkaWNhdGUuYXJnc1sxXS52YWx1ZSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2VtcHR5X2xpc3QocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci50eXBlKFwibGlzdFwiLCBleHBvcnRzLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBuZXdfbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVfaWQuaWQsIHt9LCBpbmRpY2F0b3JzLCB7XHJcblx0XHRcdFx0XHRcdFx0c2Vzc2lvbjogdGhyZWFkLnNlc3Npb25cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkLmlkXSA9IG5ld19tb2R1bGU7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV0ubW9kdWxlc1ttb2R1bGVfaWQuaWRdID0gbmV3X21vZHVsZTtcclxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb250ZXh0X21vZHVsZSA9IG1vZHVsZV9pZC5pZDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKHBsLmVycm9yLnBlcm1pc3Npb24oXCJjcmVhdGVcIiwgXCJtb2R1bGVcIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIHVzZV9tb2R1bGUvMVxyXG5cdFx0XHRcInVzZV9tb2R1bGUvMVwiOiBmdW5jdGlvbih0aHJlYWQsIGF0b20sIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdFx0XHRvcHRpb25zLmNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZSA9PT0gdW5kZWZpbmVkID8gXCJ1c2VyXCIgOiBvcHRpb25zLmNvbnRleHRfbW9kdWxlO1xyXG5cdFx0XHRcdHZhciBtb2R1bGVfaWQgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShtb2R1bGVfaWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0obW9kdWxlX2lkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcInRlcm1cIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZihtb2R1bGVfaWQuaW5kaWNhdG9yID09PSBcImxpYnJhcnkvMVwiKSB7XHJcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gbW9kdWxlX2lkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gcGwubW9kdWxlc1tuYW1lXTtcclxuXHRcdFx0XHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRpZighdGhyZWFkLnNlc3Npb24ubW9kdWxlc1tvcHRpb25zLmNvbnRleHRfbW9kdWxlXS5tb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW25hbWVdID0gZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbb3B0aW9ucy5jb250ZXh0X21vZHVsZV0ubW9kdWxlc1tuYW1lXSA9IGdldF9tb2R1bGU7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZ2V0X21vZHVsZS5kZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRlcm0gPSBuZXcgVGVybShcInVzZV9tb2R1bGVcIiwgW25ldyBUZXJtKFwibGlicmFyeVwiLCBbbmV3IFRlcm0oZ2V0X21vZHVsZS5kZXBlbmRlbmNpZXNbaV0pXSldKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cGwuZGlyZWN0aXZlW1widXNlX21vZHVsZS8xXCJdKHRocmVhZCwgdGVybSwge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlOiBuYW1lXHJcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyhwbC5lcnJvci5leGlzdGVuY2UoXCJtb2R1bGVcIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR2YXIgbmFtZSA9IG1vZHVsZV9pZC5pZDtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLmNvbnN1bHQobmFtZSwge1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRleHRfbW9kdWxlOiBvcHRpb25zLmNvbnRleHRfbW9kdWxlLFxyXG5cdFx0XHRcdFx0XHRcdHRleHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VQcm9ncmFtKHRocmVhZCwgb3B0aW9ucy5zdHJpbmcsIG9wdGlvbnMpO1xyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5lcnJvcihwbC5lcnJvci5leGlzdGVuY2UoXCJtb2R1bGVcIiwgbW9kdWxlX2lkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIGNoYXJfY29udmVyc2lvbi8yXHJcblx0XHRcdFwiY2hhcl9jb252ZXJzaW9uLzJcIjogZnVuY3Rpb24odGhyZWFkLCBhdG9tLCBvcHRpb25zKSB7XHJcblx0XHRcdFx0dmFyIGluY2hhciA9IGF0b20uYXJnc1swXSwgb3V0Y2hhciA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGluY2hhcikgfHwgcGwudHlwZS5pc192YXJpYWJsZShvdXRjaGFyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jaGFyYWN0ZXIoaW5jaGFyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImNoYXJhY3RlclwiLCBpbmNoYXIsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NoYXJhY3RlcihvdXRjaGFyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcocGwuZXJyb3IudHlwZShcImNoYXJhY3RlclwiLCBvdXRjaGFyLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZihpbmNoYXIuaWQgPT09IG91dGNoYXIuaWQpIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRocmVhZC5zZXNzaW9uLl9fY2hhcl9jb252ZXJzaW9uW2luY2hhci5pZF07XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5fX2NoYXJfY29udmVyc2lvbltpbmNoYXIuaWRdID0gb3V0Y2hhci5pZDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG9wdGlvbnMudG9rZW5zID0gb3B0aW9ucy50b2tlbml6ZXIuZ2V0X3Rva2VucyhvcHRpb25zLmN1cnJlbnRfdG9rZW4pO1xyXG5cdFx0XHRcdFx0b3B0aW9ucy5jdXJyZW50X3Rva2VuID0gMDtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIG9wLzNcclxuXHRcdFx0XCJvcC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIGF0b20gKSB7XHJcblx0XHRcdFx0dmFyIHByaW9yaXR5ID0gYXRvbS5hcmdzWzBdLCB0eXBlID0gYXRvbS5hcmdzWzFdLCBvcGVyYXRvcnMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19hdG9tKG9wZXJhdG9ycykpXHJcblx0XHRcdFx0XHRvcGVyYXRvcnMgPSBuZXcgVGVybShcIi5cIiwgW29wZXJhdG9ycywgbmV3IFRlcm0oXCJbXVwiKV0pO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcmlvcml0eSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHR5cGUgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19pbnRlZ2VyKCBwcmlvcml0eSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBwcmlvcml0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggdHlwZSApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCB0eXBlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcGVyYXRvcnMgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2VtcHR5X2xpc3QoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gb3BlcmF0b3JzO1xyXG5cdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdHZhciBvcGVyYXRvciA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wZXJhdG9yICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBvcGVyYXRvciApICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBwcmlvcml0eS52YWx1ZSA8IDAgfHwgcHJpb3JpdHkudmFsdWUgPiAxMjAwICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5kb21haW4oIFwib3BlcmF0b3JfcHJpb3JpdHlcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCIsXCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm1vZGlmeVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwie31cIiApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IucGVybWlzc2lvbiggXCJjcmVhdGVcIiwgXCJvcGVyYXRvclwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoIG9wZXJhdG9yLmlkID09PSBcIltdXCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJ8XCIgJiYgcHJpb3JpdHkudmFsdWUgIT09IDAgJiYgKHByaW9yaXR5LnZhbHVlIDwgMTAwMSB8fCB0eXBlLmlkLmxlbmd0aCAhPT0gMyApICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9yLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggW1wiZnlcIiwgXCJmeFwiLCBcInlmXCIsIFwieGZcIiwgXCJ4ZnhcIiwgXCJ5ZnhcIiwgXCJ4ZnlcIl0uaW5kZXhPZiggdHlwZS5pZCApID09PSAtMSApIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfd2FybmluZyggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3NwZWNpZmllclwiLCB0eXBlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGZpeCA9IHsgcHJlZml4OiBudWxsLCBpbmZpeDogbnVsbCwgcG9zdGZpeDogbnVsbCB9O1xyXG5cdFx0XHRcdFx0XHRcdGZvciggdmFyIHAgaW4gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZighdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnMuaGFzT3duUHJvcGVydHkocCkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIGNsYXNzZXMgPSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twXVtvcGVyYXRvci5pZF07XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggY2xhc3NlcyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwiZnhcIiApICE9PSAtMSApIHsgZml4LnByZWZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwiZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcImZ5XCIgKSAhPT0gLTEgKSB7IGZpeC5wcmVmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcImZ5XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZlwiICkgIT09IC0xICkgeyBmaXgucG9zdGZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInlmXCIgKSAhPT0gLTEgKSB7IGZpeC5wb3N0Zml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ5ZlwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwieGZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5pbmZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZnlcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZnlcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcInlmeFwiICkgIT09IC0xICkgeyBmaXguaW5maXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcInlmeFwiIH07IH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0dmFyIGN1cnJlbnRfY2xhc3M7XHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoKCB0eXBlLmlkICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y2FzZSBcImZ5XCI6IGNhc2UgXCJmeFwiOiBjdXJyZW50X2NsYXNzID0gXCJwcmVmaXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwieWZcIjogY2FzZSBcInhmXCI6IGN1cnJlbnRfY2xhc3MgPSBcInBvc3RmaXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OiBjdXJyZW50X2NsYXNzID0gXCJpbmZpeFwiOyBicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYoZml4LmluZml4ICYmIGN1cnJlbnRfY2xhc3MgPT09IFwicG9zdGZpeFwiIHx8IGZpeC5wb3N0Zml4ICYmIGN1cnJlbnRfY2xhc3MgPT09IFwiaW5maXhcIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGZpeFtjdXJyZW50X2NsYXNzXSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmVtb3ZlKCB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1tmaXhbY3VycmVudF9jbGFzc10ucHJpb3JpdHldW29wZXJhdG9yLmlkXSwgZml4W2N1cnJlbnRfY2xhc3NdLnR5cGUgKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW2ZpeFtjdXJyZW50X2NsYXNzXS5wcmlvcml0eV1bb3BlcmF0b3IuaWRdLmxlbmd0aCA9PT0gMCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBwcmlvcml0eS52YWx1ZSA+IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCAhdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdICkgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWUudG9TdHJpbmcoKV0gPSB7fTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoICF0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdICkgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcHJpb3JpdHkudmFsdWVdW29wZXJhdG9yLmlkXSA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdLnB1c2goIHR5cGUuaWQgKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X3dhcm5pbmcoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgfHwgcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd193YXJuaW5nKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3BlcmF0b3JzLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBpbml0aWFsaXphdGlvbi8xXHJcblx0XHRcdFwiaW5pdGlhbGl6YXRpb24vMVwiOiBmdW5jdGlvbih0aHJlYWQsIGF0b20sIG9wdGlvbnMpIHtcclxuXHRcdFx0XHR2YXIgZ29hbCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0XHRvcHRpb25zLmluaXRpYWxpemF0aW9uLnB1c2goZ29hbCk7XHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBGbGFnc1xyXG5cdFx0ZmxhZzoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gQm91bmRlZCBudW1iZXJzXHJcblx0XHRcdGJvdW5kZWQ6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwidHJ1ZVwiICksIG5ldyBUZXJtKCBcImZhbHNlXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcInRydWVcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBNYXhpbXVtIGludGVnZXJcclxuXHRcdFx0bWF4X2ludGVnZXI6IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IE51bSggTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBOdW0oIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogZmFsc2VcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIE1pbmltdW0gaW50ZWdlclxyXG5cdFx0XHRtaW5faW50ZWdlcjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgTnVtKCBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IE51bSggTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUm91bmRpbmcgZnVuY3Rpb25cclxuXHRcdFx0aW50ZWdlcl9yb3VuZGluZ19mdW5jdGlvbjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJkb3duXCIgKSwgbmV3IFRlcm0oIFwidG93YXJkX3plcm9cIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwidG93YXJkX3plcm9cIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBDaGFyYWN0ZXIgY29udmVyc2lvblxyXG5cdFx0XHRjaGFyX2NvbnZlcnNpb246IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwib25cIiApLCBuZXcgVGVybSggXCJvZmZcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwib25cIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IHRydWVcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIERlYnVnZ2VyXHJcblx0XHRcdGRlYnVnOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcIm9uXCIgKSwgbmV3IFRlcm0oIFwib2ZmXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcIm9mZlwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gTWF4aW11bSBhcml0eSBvZiBwcmVkaWNhdGVzXHJcblx0XHRcdG1heF9hcml0eToge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJ1bmJvdW5kZWRcIiApXSxcclxuXHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oIFwidW5ib3VuZGVkXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiBmYWxzZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVW5rd25vdyBwcmVkaWNhdGVzIGJlaGF2aW9yXHJcblx0XHRcdHVua25vd246IHtcclxuXHRcdFx0XHRhbGxvd2VkOiBbbmV3IFRlcm0oIFwiZXJyb3JcIiApLCBuZXcgVGVybSggXCJmYWlsXCIgKSwgbmV3IFRlcm0oIFwid2FybmluZ1wiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJlcnJvclwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRG91YmxlIHF1b3RlcyBiZWhhdmlvclxyXG5cdFx0XHRkb3VibGVfcXVvdGVzOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcImNoYXJzXCIgKSwgbmV3IFRlcm0oIFwiY29kZXNcIiApLCBuZXcgVGVybSggXCJhdG9tXCIgKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcImNoYXJzXCIgKSxcclxuXHRcdFx0XHRjaGFuZ2VhYmxlOiB0cnVlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBPY2N1cnMgY2hlY2sgYmVoYXZpb3JcclxuXHRcdFx0b2NjdXJzX2NoZWNrOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcImZhbHNlXCIgKSwgbmV3IFRlcm0oIFwidHJ1ZVwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJmYWxzZVwiICksXHJcblx0XHRcdFx0Y2hhbmdlYWJsZTogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRGlhbGVjdFxyXG5cdFx0XHRkaWFsZWN0OiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcInRhdVwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggXCJ0YXVcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBWZXJzaW9uXHJcblx0XHRcdHZlcnNpb25fZGF0YToge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtuZXcgVGVybSggXCJ0YXVcIiwgW25ldyBOdW0odmVyc2lvbi5tYWpvcixmYWxzZSksIG5ldyBOdW0odmVyc2lvbi5taW5vcixmYWxzZSksIG5ldyBOdW0odmVyc2lvbi5wYXRjaCxmYWxzZSksIG5ldyBUZXJtKHZlcnNpb24uc3RhdHVzKV0gKV0sXHJcblx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKCBcInRhdVwiLCBbbmV3IE51bSh2ZXJzaW9uLm1ham9yLGZhbHNlKSwgbmV3IE51bSh2ZXJzaW9uLm1pbm9yLGZhbHNlKSwgbmV3IE51bSh2ZXJzaW9uLnBhdGNoLGZhbHNlKSwgbmV3IFRlcm0odmVyc2lvbi5zdGF0dXMpXSApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBOb2RlSlNcclxuXHRcdFx0bm9kZWpzOiB7XHJcblx0XHRcdFx0YWxsb3dlZDogW25ldyBUZXJtKCBcInRydWVcIiApLCBuZXcgVGVybSggXCJmYWxzZVwiICldLFxyXG5cdFx0XHRcdHZhbHVlOiBuZXcgVGVybSggbm9kZWpzX2ZsYWcgPyBcInRydWVcIiA6IFwiZmFsc2VcIiApLFxyXG5cdFx0XHRcdGNoYW5nZWFibGU6IGZhbHNlXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBBcmd1bWVudHNcclxuXHRcdFx0YXJndjoge1xyXG5cdFx0XHRcdGFsbG93ZWQ6IFtub2RlanNfYXJndW1lbnRzXSxcclxuXHRcdFx0XHR2YWx1ZTogbm9kZWpzX2FyZ3VtZW50cyxcclxuXHRcdFx0XHRjaGFuZ2VibGU6IGZhbHNlXHJcblx0XHRcdH1cclxuXHRcdFx0XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBVbmlmeVxyXG5cdFx0dW5pZnk6IGZ1bmN0aW9uKHQxLCB0Miwgb2NjdXJzX2NoZWNrKSB7XHJcblx0XHRcdG9jY3Vyc19jaGVjayA9IG9jY3Vyc19jaGVjayA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvY2N1cnNfY2hlY2s7XHJcblx0XHRcdHZhciBsZWZ0ID0gQXJyYXkuaXNBcnJheSh0MSkgPyB0MSA6IFt0MV07XHJcblx0XHRcdHZhciByaWdodCA9IEFycmF5LmlzQXJyYXkodDIpID8gdDIgOiBbdDJdO1xyXG5cdFx0XHRpZihsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKVxyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHR2YXIgc3VicyA9IG5ldyBTdWJzdGl0dXRpb24oKTtcclxuXHRcdFx0d2hpbGUobGVmdC5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0dmFyIHMgPSBsZWZ0LnBvcCgpO1xyXG5cdFx0XHRcdHZhciB0ID0gcmlnaHQucG9wKCk7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShzKSlcclxuXHRcdFx0XHRcdHMgPSBzLmFwcGx5KHN1YnMpO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodCkpXHJcblx0XHRcdFx0XHR0ID0gdC5hcHBseShzdWJzKTtcclxuXHRcdFx0XHQvLyBzYW1lIG9iamVjdFxyXG5cdFx0XHRcdGlmKHMgPT0gdClcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdC8vIGNvbXBvdW5kIHRlcm1zXHJcblx0XHRcdFx0aWYocGwudHlwZS5pc190ZXJtKHMpICYmIHBsLnR5cGUuaXNfdGVybSh0KSkge1xyXG5cdFx0XHRcdFx0aWYocy5pbmRpY2F0b3IgIT09IHQuaW5kaWNhdG9yKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IHMuYXJncy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0XHRcdFx0bGVmdC5wdXNoKHMuYXJnc1tpXSk7XHJcblx0XHRcdFx0XHRcdHJpZ2h0LnB1c2godC5hcmdzW2ldKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBudW1iZXJzXHJcblx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfbnVtYmVyKHMpICYmIHBsLnR5cGUuaXNfbnVtYmVyKHQpKSB7XHJcblx0XHRcdFx0XHRpZihzLnZhbHVlICE9PSB0LnZhbHVlIHx8IHMuaXNfZmxvYXQgIT09IHQuaXNfZmxvYXQpXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdC8vIHZhcmlhYmxlIC0gdGVybVxyXG5cdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHMpKSB7XHJcblx0XHRcdFx0XHR0ID0gdC5hcHBseShzdWJzKTtcclxuXHRcdFx0XHRcdC8vIHggPSB4XHJcblx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHQpICYmIHMuaWQgPT09IHQuaWQpXHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0Ly8gb2NjdXJzIGNoZWNrXHJcblx0XHRcdFx0XHRpZihvY2N1cnNfY2hlY2sgPT09IHRydWUgJiYgaW5kZXhPZih0LnZhcmlhYmxlcygpLCBzLmlkKSAhPT0gLTEpXHJcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdFx0Ly8gYW5vbnltb3VzIHZhcmlhYmxlXHJcblx0XHRcdFx0XHRpZihzLmlkICE9PSBcIl9cIilcclxuXHRcdFx0XHRcdFx0c3Vicy5hZGQocy5pZCwgdCk7XHJcblx0XHRcdFx0Ly8gdGVybSAtIHZhcmlhYmxlXHJcblx0XHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodCkpIHtcclxuXHRcdFx0XHRcdGxlZnQucHVzaCh0KTtcclxuXHRcdFx0XHRcdHJpZ2h0LnB1c2gocyk7XHJcblx0XHRcdFx0Ly8gdXNlci1kZWZpbmVkIHRlcm1zXHJcblx0XHRcdFx0fSBlbHNlIGlmKHMudW5pZnkgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0dmFyIHVzZXJfc3VicyA9IHMuYXBwbHkoc3VicykudW5pZnkodC5hcHBseShzdWJzKSwgb2NjdXJzX2NoZWNrKTtcclxuXHRcdFx0XHRcdGlmKHVzZXJfc3VicyA9PSBudWxsKVxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSBpbiB1c2VyX3N1YnMubGlua3MpXHJcblx0XHRcdFx0XHRcdHN1YnMuYWRkKGksIHVzZXJfc3Vicy5saW5rc1tpXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc3Vicy5hcHBseShzdWJzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gSXMgcmVuYW1lXHJcblx0XHRpc19yZW5hbWU6IGZ1bmN0aW9uKG9iajEsIG9iajIsIGxpbmtzKSB7XHJcblx0XHRcdGxpbmtzID0gbGlua3MgfHwge307XHJcblx0XHRcdGlmKG9iajEuaXNfcmVuYW1lICYmIG9iajIuaXNfcmVuYW1lKVxyXG5cdFx0XHRcdHJldHVybiBvYmoxLmlzX3JlbmFtZShvYmoyLCBsaW5rcyk7XHJcblx0XHRcdGVsc2UgaWYob2JqMS5lcXVhbHMgJiYgb2JqMi5lcXVhbHMpXHJcblx0XHRcdFx0cmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQ29tcGFyZVxyXG5cdFx0Y29tcGFyZTogZnVuY3Rpb24oIG9iajEsIG9iajIgKSB7XHJcblx0XHRcdHZhciB0eXBlID0gcGwudHlwZS5jb21wYXJlKCBvYmoxLCBvYmoyICk7XHJcblx0XHRcdHJldHVybiB0eXBlICE9PSAwID8gdHlwZSA6IG9iajEuY29tcGFyZSggb2JqMiApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQXJpdGhtZXRpYyBjb21wYXJpc29uXHJcblx0XHRhcml0aG1ldGljX2NvbXBhcmU6IGZ1bmN0aW9uKCB0aHJlYWQsIG9iajEsIG9iajIgKSB7XHJcblx0XHRcdHZhciBleHByMSA9IG9iajEuaW50ZXJwcmV0KCB0aHJlYWQgKTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggZXhwcjEgKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZXhwcjE7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGV4cHIyID0gb2JqMi5pbnRlcnByZXQoIHRocmVhZCApO1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIGV4cHIyICkgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZXhwcjI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBleHByMS52YWx1ZSA8IGV4cHIyLnZhbHVlID8gLTEgOiAoZXhwcjEudmFsdWUgPiBleHByMi52YWx1ZSA/IDEgOiAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIE9wZXJhdGVcclxuXHRcdG9wZXJhdGU6IGZ1bmN0aW9uKCB0aHJlYWQsIG9iaiApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfb3BlcmF0b3IoIG9iaiApICkge1xyXG5cdFx0XHRcdHZhciBvcCA9IHBsLnR5cGUuaXNfb3BlcmF0b3IoIG9iaiApO1xyXG5cdFx0XHRcdHZhciBhcmdzID0gW10sIHZhbHVlO1xyXG5cdFx0XHRcdHZhciB0eXBlID0gZmFsc2U7XHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBvYmouYXJncy5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdHZhbHVlID0gb2JqLmFyZ3NbaV0uaW50ZXJwcmV0KCB0aHJlYWQgKTtcclxuXHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIHZhbHVlICkgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggb3AudHlwZV9hcmdzICE9PSBudWxsICYmIHZhbHVlLmlzX2Zsb2F0ICE9PSBvcC50eXBlX2FyZ3MgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBwbC5lcnJvci50eXBlKCBvcC50eXBlX2FyZ3MgPyBcImZsb2F0XCIgOiBcImludGVnZXJcIiwgdmFsdWUsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhcmdzLnB1c2goIHZhbHVlLnZhbHVlICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0eXBlID0gdHlwZSB8fCB2YWx1ZS5pc19mbG9hdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YXJncy5wdXNoKCB0aHJlYWQgKTtcclxuXHRcdFx0XHR2YWx1ZSA9IHBsLmFyaXRobWV0aWMuZXZhbHVhdGlvbltvYmouaW5kaWNhdG9yXS5mbi5hcHBseSggdGhpcywgYXJncyApO1xyXG5cdFx0XHRcdGlmKG9iai5pbmRpY2F0b3IgPT09IFwiXi8yXCIgJiYgIXR5cGUgJiYgdmFsdWUgIT09IHBhcnNlSW50KHZhbHVlLCAxMCkpXHJcblx0XHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IudHlwZSggXCJmbG9hdFwiLCBuZXcgTnVtKGFyZ3NbMF0sZmFsc2UpLCB0aHJlYWQuX19jYWxsX2luZGljYXRvciApO1xyXG5cdFx0XHRcdHR5cGUgPSBvcC50eXBlX3Jlc3VsdCA9PT0gbnVsbCA/IHR5cGUgOiBvcC50eXBlX3Jlc3VsdDtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggdmFsdWUgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fCB2YWx1ZSA9PT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLmV2YWx1YXRpb24oIFwiZmxvYXRfb3ZlcmZsb3dcIiwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHR5cGUgPT09IGZhbHNlICYmIHRocmVhZC5nZXRfZmxhZyggXCJib3VuZGVkXCIgKS5pZCA9PT0gXCJ0cnVlXCIgJiYgKHZhbHVlID4gdGhyZWFkLmdldF9mbGFnKCBcIm1heF9pbnRlZ2VyXCIgKS52YWx1ZSB8fCB2YWx1ZSA8IHRocmVhZC5nZXRfZmxhZyggXCJtaW5faW50ZWdlclwiICkudmFsdWUpICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBsLmVycm9yLmV2YWx1YXRpb24oIFwiaW50X292ZXJmbG93XCIsIHRocmVhZC5fX2NhbGxfaW5kaWNhdG9yICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBuZXcgTnVtKCB2YWx1ZSwgdHlwZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gcGwuZXJyb3IudHlwZSggXCJldmFsdWFibGVcIiwgc3RyX2luZGljYXRvcihvYmouaW5kaWNhdG9yKSwgdGhyZWFkLl9fY2FsbF9pbmRpY2F0b3IgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRXJyb3JzXHJcblx0XHRlcnJvcjoge1xyXG5cdFx0XHRcclxuXHRcdFx0Ly8gRXhpc3RlbmNlIGVycm9yXHJcblx0XHRcdGV4aXN0ZW5jZTogZnVuY3Rpb24oIHR5cGUsIG9iamVjdCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdGlmKCB0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiIClcclxuXHRcdFx0XHRcdG9iamVjdCA9IHN0cl9pbmRpY2F0b3IoIG9iamVjdCApO1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwiZXhpc3RlbmNlX2Vycm9yXCIsIFtuZXcgVGVybSggdHlwZSApLCBvYmplY3RdICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gVHlwZSBlcnJvclxyXG5cdFx0XHR0eXBlOiBmdW5jdGlvbiggZXhwZWN0ZWQsIGZvdW5kLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJ0eXBlX2Vycm9yXCIsIFtuZXcgVGVybSggZXhwZWN0ZWQgKSwgZm91bmRdICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gSW5zdGFudGF0aW9uIGVycm9yXHJcblx0XHRcdGluc3RhbnRpYXRpb246IGZ1bmN0aW9uKCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJpbnN0YW50aWF0aW9uX2Vycm9yXCIgKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBVbmluc3RhbnRhdGlvbiBlcnJvclxyXG5cdFx0XHR1bmluc3RhbnRpYXRpb246IGZ1bmN0aW9uKCBmb3VuZCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwidW5pbnN0YW50aWF0aW9uX2Vycm9yXCIsIFtuZXcgVGVybSggZm91bmQgKV0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBEb21haW4gZXJyb3JcclxuXHRcdFx0ZG9tYWluOiBmdW5jdGlvbiggZXhwZWN0ZWQsIGZvdW5kLCBpbmRpY2F0b3IgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcImVycm9yXCIsIFtuZXcgVGVybSggXCJkb21haW5fZXJyb3JcIiwgW25ldyBUZXJtKCBleHBlY3RlZCApLCBmb3VuZF0pLCBzdHJfaW5kaWNhdG9yKCBpbmRpY2F0b3IgKV0gKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0XHJcblx0XHRcdC8vIFJlcHJlc2VudGF0aW9uIGVycm9yXHJcblx0XHRcdHJlcHJlc2VudGF0aW9uOiBmdW5jdGlvbiggZmxhZywgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwicmVwcmVzZW50YXRpb25fZXJyb3JcIiwgW25ldyBUZXJtKCBmbGFnICldICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gUGVybWlzc2lvbiBlcnJvclxyXG5cdFx0XHRwZXJtaXNzaW9uOiBmdW5jdGlvbiggb3BlcmF0aW9uLCB0eXBlLCBmb3VuZCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwicGVybWlzc2lvbl9lcnJvclwiLCBbbmV3IFRlcm0oIG9wZXJhdGlvbiApLCBuZXcgVGVybSggdHlwZSApLCBmb3VuZF0gKSwgc3RyX2luZGljYXRvciggaW5kaWNhdG9yICldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBFdmFsdWF0aW9uIGVycm9yXHJcblx0XHRcdGV2YWx1YXRpb246IGZ1bmN0aW9uKCBlcnJvciwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwiZXZhbHVhdGlvbl9lcnJvclwiLCBbbmV3IFRlcm0oIGVycm9yICldICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRcclxuXHRcdFx0Ly8gU3ludGF4IGVycm9yXHJcblx0XHRcdHN5bnRheDogZnVuY3Rpb24oIHRva2VuLCBleHBlY3RlZCwgbGFzdCApIHtcclxuXHRcdFx0XHR0b2tlbiA9IHRva2VuIHx8IHt2YWx1ZTogXCJcIiwgbGluZTogMCwgY29sdW1uOiAwLCBtYXRjaGVzOiBbXCJcIl0sIHN0YXJ0OiAwfTtcclxuXHRcdFx0XHR2YXIgcG9zaXRpb24gPSBsYXN0ICYmIHRva2VuLm1hdGNoZXMubGVuZ3RoID4gMCA/IHRva2VuLnN0YXJ0ICsgdG9rZW4ubWF0Y2hlc1swXS5sZW5ndGggOiB0b2tlbi5zdGFydDtcclxuXHRcdFx0XHR2YXIgZm91bmQgPSBsYXN0ID8gbmV3IFRlcm0oXCJ0b2tlbl9ub3RfZm91bmRcIikgOiBuZXcgVGVybShcImZvdW5kXCIsIFtuZXcgVGVybSh0b2tlbi52YWx1ZS50b1N0cmluZygpKV0pO1xyXG5cdFx0XHRcdHZhciBpbmZvID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IFRlcm0oIFwibGluZVwiLCBbbmV3IE51bSh0b2tlbi5saW5lKzEpXSApLCBuZXcgVGVybSggXCIuXCIsIFtuZXcgVGVybSggXCJjb2x1bW5cIiwgW25ldyBOdW0ocG9zaXRpb24pXSApLCBuZXcgVGVybSggXCIuXCIsIFtmb3VuZCwgbmV3IFRlcm0oIFwiW11cIiwgW10gKV0gKV0gKV0gKTtcclxuXHRcdFx0XHRyZXR1cm4gbmV3IFRlcm0oIFwiZXJyb3JcIiwgW25ldyBUZXJtKCBcInN5bnRheF9lcnJvclwiLCBbbmV3IFRlcm0oIGV4cGVjdGVkICldICksIGluZm9dICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBTeW50YXggZXJyb3IgYnkgcHJlZGljYXRlXHJcblx0XHRcdHN5bnRheF9ieV9wcmVkaWNhdGU6IGZ1bmN0aW9uKCBleHBlY3RlZCwgaW5kaWNhdG9yICkge1xyXG5cdFx0XHRcdHJldHVybiBuZXcgVGVybSggXCJlcnJvclwiLCBbbmV3IFRlcm0oIFwic3ludGF4X2Vycm9yXCIsIFtuZXcgVGVybSggZXhwZWN0ZWQgKSBdICksIHN0cl9pbmRpY2F0b3IoIGluZGljYXRvciApXSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gV2FybmluZ3NcclxuXHRcdHdhcm5pbmc6IHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIFNpbmdsZXRvbiB2YXJpYWJsZXNcclxuXHRcdFx0c2luZ2xldG9uOiBmdW5jdGlvbiggdmFyaWFibGVzLCBydWxlLCBsaW5lICkge1xyXG5cdFx0XHRcdHZhciBsaXN0ID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdGZvciggdmFyIGkgPSB2YXJpYWJsZXMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tIClcclxuXHRcdFx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgVmFyKHZhcmlhYmxlc1tpXSksIGxpc3RdICk7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcIndhcm5pbmdcIiwgW25ldyBUZXJtKCBcInNpbmdsZXRvbl92YXJpYWJsZXNcIiwgW2xpc3QsIHN0cl9pbmRpY2F0b3IocnVsZSldKSwgbmV3IFRlcm0oXCIuXCIsW25ldyBUZXJtKCBcImxpbmVcIiwgWyBuZXcgTnVtKCBsaW5lLCBmYWxzZSApIF0pLCBuZXcgVGVybShcIltdXCIpXSldICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdFxyXG5cdFx0XHQvLyBGYWlsZWQgZ29hbFxyXG5cdFx0XHRmYWlsZWRfZ29hbDogZnVuY3Rpb24oIGdvYWwsIGxpbmUgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBUZXJtKCBcIndhcm5pbmdcIiwgW25ldyBUZXJtKCBcImZhaWxlZF9nb2FsXCIsIFtnb2FsXSksIG5ldyBUZXJtKFwiLlwiLFtuZXcgVGVybSggXCJsaW5lXCIsIFsgbmV3IE51bSggbGluZSwgZmFsc2UgKSBdKSwgbmV3IFRlcm0oXCJbXVwiKV0pXSApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gRm9ybWF0IG9mIHJlbmFtZWQgdmFyaWFibGVzXHJcblx0XHRmb3JtYXRfdmFyaWFibGU6IGZ1bmN0aW9uKCBpZCwgdmFyaWFibGUgKSB7XHJcblx0XHRcdHZhciBjaGFyY29kZSA9IHZhcmlhYmxlICYmIHZhcmlhYmxlLmxlbmd0aCA+IDAgPyBjb2RlUG9pbnRBdCh2YXJpYWJsZSwgMSkgOiAwO1xyXG5cdFx0XHRpZih2YXJpYWJsZSA9PT0gXCJfXCIgfHwgdmFyaWFibGUgJiYgdmFyaWFibGVbMF0gPT09IFwiX1wiICYmIChjaGFyY29kZSA9PT0gOTUgfHwgY2hhcmNvZGUgPj0gNjUgJiYgY2hhcmNvZGUgPD0gOTApKVxyXG5cdFx0XHRcdHJldHVybiBcIl9fXCIgKyBpZDtcclxuXHRcdFx0cmV0dXJuIFwiX1wiICsgaWQ7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBGb3JtYXQgb2YgY29tcHV0ZWQgYW5zd2Vyc1xyXG5cdFx0Zm9ybWF0X2Fuc3dlcjogZnVuY3Rpb24oIGFuc3dlciwgdGhyZWFkLCBvcHRpb25zICkge1xyXG5cdFx0XHRpZiggdGhyZWFkIGluc3RhbmNlb2YgU2Vzc2lvbiApXHJcblx0XHRcdFx0dGhyZWFkID0gdGhyZWFkLnRocmVhZDtcclxuXHRcdFx0dmFyIG9wdGlvbnMgPSBvcHRpb25zID8gb3B0aW9ucyA6IHt9O1xyXG5cdFx0XHRvcHRpb25zLnNlc3Npb24gPSB0aHJlYWQgPyB0aHJlYWQuc2Vzc2lvbiA6IHVuZGVmaW5lZDtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfZXJyb3IoIGFuc3dlciApICkge1xyXG5cdFx0XHRcdHJldHVybiBcInVuY2F1Z2h0IGV4Y2VwdGlvbjogXCIgKyBhbnN3ZXIuYXJnc1swXS50b1N0cmluZyhvcHRpb25zKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBhbnN3ZXIgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdHJldHVybiBcImZhbHNlXCI7XHJcblx0XHRcdH0gZWxzZSBpZiggYW5zd2VyID09PSBudWxsICkge1xyXG5cdFx0XHRcdHJldHVybiBcImxpbWl0IGV4Y2VlZGVkXCI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3N1YnN0aXR1dGlvbiggYW5zd2VyICkgKSB7XHJcblx0XHRcdFx0XHR2YXIgZG9tID0gYW5zd2VyLmRvbWFpbiggdHJ1ZSApO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgbGluayBpbiBhbnN3ZXIubGlua3MgKXtcclxuXHRcdFx0XHRcdFx0aWYoICFhbnN3ZXIubGlua3MuaGFzT3duUHJvcGVydHkobGluaykgKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoYW5zd2VyLmxpbmtzW2xpbmtdKSApIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgbGlua3MgPSB7fTtcclxuXHRcdFx0XHRcdFx0XHRsaW5rc1thbnN3ZXIubGlua3NbbGlua10uaWRdID0gbmV3IFZhcihsaW5rKTtcclxuXHRcdFx0XHRcdFx0XHRhbnN3ZXIgPSBhbnN3ZXIuYXBwbHkoIG5ldyBTdWJzdGl0dXRpb24obGlua3MpICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGFuc3dlciA9IGFuc3dlci5maWx0ZXIoIGZ1bmN0aW9uKCBpZCwgdmFsdWUgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAhcGwudHlwZS5pc192YXJpYWJsZSggdmFsdWUgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdHBsLnR5cGUuaXNfdmFyaWFibGUoIHZhbHVlICkgJiYgYW5zd2VyLmhhc19hdHRyaWJ1dGVzKCBpZCApIHx8XHJcblx0XHRcdFx0XHRcdFx0aW5kZXhPZiggZG9tLCB2YWx1ZS5pZCApICE9PSAtMSAmJiBpZCAhPT0gdmFsdWUuaWQ7XHJcblx0XHRcdFx0XHR9ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGZvciggdmFyIGxpbmsgaW4gYW5zd2VyLmxpbmtzICkge1xyXG5cdFx0XHRcdFx0aWYoIWFuc3dlci5saW5rcy5oYXNPd25Qcm9wZXJ0eShsaW5rKSlcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYW5zd2VyLmxpbmtzW2xpbmtdICkgJiYgbGluayA9PT0gYW5zd2VyLmxpbmtzW2xpbmtdLmlkICkge1xyXG5cdFx0XHRcdFx0XHR2YXIgYXR0cnMgPSBhbnN3ZXIuYXR0cnNbbGlua107XHJcblx0XHRcdFx0XHRcdGZvciggdmFyIG1vZHVsZSBpbiBhdHRycyApIHtcclxuXHRcdFx0XHRcdFx0XHRpZighYXR0cnMuaGFzT3duUHJvcGVydHkobW9kdWxlKSlcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdGkrKztcclxuXHRcdFx0XHRcdFx0XHRpZiggc3RyICE9PSBcIlwiIClcclxuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSBcIiwgXCI7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IFwicHV0X2F0dHIoXCIgKyBsaW5rICsgXCIsIFwiICsgbW9kdWxlICsgXCIsIFwiICsgYXR0cnNbbW9kdWxlXS50b1N0cmluZyhvcHRpb25zKSArIFwiKVwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRpKys7XHJcblx0XHRcdFx0XHRcdGlmKCBzdHIgIT09IFwiXCIgKVxyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBcIiwgXCI7XHJcblx0XHRcdFx0XHRcdHN0ciArPSBsaW5rLnRvU3RyaW5nKCBvcHRpb25zICkgKyBcIiA9IFwiICtcclxuXHRcdFx0XHRcdFx0XHRhbnN3ZXIubGlua3NbbGlua10udG9TdHJpbmcoIG9wdGlvbnMsIHtwcmlvcml0eTogXCI3MDBcIiwgY2xhc3M6IFwieGZ4XCIsIGluZGljYXRvcjogXCI9LzJcIn0sIFwicmlnaHRcIiApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggaSA9PT0gMCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBcInRydWVcIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHN0cjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEZsYXR0ZW4gZGVmYXVsdCBlcnJvcnNcclxuXHRcdGZsYXR0ZW5fZXJyb3I6IGZ1bmN0aW9uKCBlcnJvciApIHtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX2Vycm9yKCBlcnJvciApICkgcmV0dXJuIG51bGw7XHJcblx0XHRcdGVycm9yID0gZXJyb3IuYXJnc1swXTtcclxuXHRcdFx0dmFyIG9iaiA9IHt9O1xyXG5cdFx0XHRvYmoudHlwZSA9IGVycm9yLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdG9iai50aHJvd24gPSBvYmoudHlwZSA9PT0gXCJzeW50YXhfZXJyb3JcIiA/IG51bGwgOiBlcnJvci5hcmdzWzFdLmlkO1xyXG5cdFx0XHRvYmouZXhwZWN0ZWQgPSBudWxsO1xyXG5cdFx0XHRvYmouZm91bmQgPSBudWxsO1xyXG5cdFx0XHRvYmoucmVwcmVzZW50YXRpb24gPSBudWxsO1xyXG5cdFx0XHRvYmouZXhpc3RlbmNlID0gbnVsbDtcclxuXHRcdFx0b2JqLmV4aXN0ZW5jZV90eXBlID0gbnVsbDtcclxuXHRcdFx0b2JqLmxpbmUgPSBudWxsO1xyXG5cdFx0XHRvYmouY29sdW1uID0gbnVsbDtcclxuXHRcdFx0b2JqLnBlcm1pc3Npb25fb3BlcmF0aW9uID0gbnVsbDtcclxuXHRcdFx0b2JqLnBlcm1pc3Npb25fdHlwZSA9IG51bGw7XHJcblx0XHRcdG9iai5ldmFsdWF0aW9uX3R5cGUgPSBudWxsO1xyXG5cdFx0XHRpZiggb2JqLnR5cGUgPT09IFwidHlwZV9lcnJvclwiIHx8IG9iai50eXBlID09PSBcImRvbWFpbl9lcnJvclwiICkge1xyXG5cdFx0XHRcdG9iai5leHBlY3RlZCA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0XHRvYmouZm91bmQgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMV0udG9TdHJpbmcoKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBvYmoudHlwZSA9PT0gXCJzeW50YXhfZXJyb3JcIiApIHtcclxuXHRcdFx0XHRpZiggZXJyb3IuYXJnc1sxXS5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRvYmouZXhwZWN0ZWQgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRvYmouZm91bmQgPSBlcnJvci5hcmdzWzFdLmFyZ3NbMV0uYXJnc1sxXS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0b2JqLmZvdW5kID0gb2JqLmZvdW5kLmlkID09PSBcInRva2VuX25vdF9mb3VuZFwiID8gb2JqLmZvdW5kLmlkIDogb2JqLmZvdW5kLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRvYmoubGluZSA9IGVycm9yLmFyZ3NbMV0uYXJnc1swXS5hcmdzWzBdLnZhbHVlO1xyXG5cdFx0XHRcdFx0b2JqLmNvbHVtbiA9IGVycm9yLmFyZ3NbMV0uYXJnc1sxXS5hcmdzWzBdLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG9iai50aHJvd24gPSBlcnJvci5hcmdzWzFdLmlkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmKCBvYmoudHlwZSA9PT0gXCJwZXJtaXNzaW9uX2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0b2JqLmZvdW5kID0gZXJyb3IuYXJnc1swXS5hcmdzWzJdLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0b2JqLnBlcm1pc3Npb25fb3BlcmF0aW9uID0gZXJyb3IuYXJnc1swXS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdG9iai5wZXJtaXNzaW9uX3R5cGUgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMV0uaWQ7XHJcblx0XHRcdH0gZWxzZSBpZiggb2JqLnR5cGUgPT09IFwiZXZhbHVhdGlvbl9lcnJvclwiICkge1xyXG5cdFx0XHRcdG9iai5ldmFsdWF0aW9uX3R5cGUgPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdH0gZWxzZSBpZiggb2JqLnR5cGUgPT09IFwicmVwcmVzZW50YXRpb25fZXJyb3JcIiApIHtcclxuXHRcdFx0XHRvYmoucmVwcmVzZW50YXRpb24gPSBlcnJvci5hcmdzWzBdLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdH0gZWxzZSBpZiggb2JqLnR5cGUgPT09IFwiZXhpc3RlbmNlX2Vycm9yXCIgKSB7XHJcblx0XHRcdFx0b2JqLmV4aXN0ZW5jZSA9IGVycm9yLmFyZ3NbMF0uYXJnc1sxXS50b1N0cmluZygpO1xyXG5cdFx0XHRcdG9iai5leGlzdGVuY2VfdHlwZSA9IGVycm9yLmFyZ3NbMF0uYXJnc1swXS5pZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gQ3JlYXRlIG5ldyBzZXNzaW9uXHJcblx0XHRjcmVhdGU6IGZ1bmN0aW9uKCBsaW1pdCApIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBwbC50eXBlLlNlc3Npb24oIGxpbWl0ICk7XHJcblx0XHR9XHJcblx0XHRcclxuXHR9O1xyXG5cclxuXHQvLyBCdWlsdC1pbiBwcmVkaWNhdGVzXHJcblx0cGwuYnVpbHRpbiA9IG5ldyBNb2R1bGUoXCJzeXN0ZW1cIiwge1xyXG5cclxuXHRcdC8vIFRFUk0gQU5EIEdPQUwgRVhQQU5TSU9OXHJcblxyXG5cdFx0Ly8gZ29hbF9leHBhbnNpb24vMlxyXG5cdFx0XCJnb2FsX2V4cGFuc2lvbi8yXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCIsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFZhcihcIlhfXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSksIG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pLG5ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJZXCIpXSldKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcIjtcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVmFyKFwiWF9cIiksbmV3IFZhcihcIllfXCIpXSldKSwgbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIllcIiksbmV3IFZhcihcIllfXCIpXSksbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIllcIildKV0pXSksbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiLT5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpXSksbmV3IFRlcm0oXCItPlwiLCBbbmV3IFZhcihcIlhfXCIpLG5ldyBWYXIoXCJZX1wiKV0pXSksIG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJZX1wiKV0pLG5ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIllfXCIpLG5ldyBWYXIoXCJZXCIpXSldKV0pLG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWF9cIildKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhdGNoXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWlwiKV0pLG5ldyBUZXJtKFwiY2F0Y2hcIiwgW25ldyBWYXIoXCJYX1wiKSxuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWl9cIildKV0pLCBuZXcgVGVybShcIjtcIiwgW25ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWlwiKSxuZXcgVmFyKFwiWl9cIildKSxuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJaX1wiKSxuZXcgVmFyKFwiWlwiKV0pXSldKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPVwiLCBbbmV3IFZhcihcIlhfXCIpLG5ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlpcIiksbmV3IFZhcihcIlpfXCIpXSldKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJcXFxcK1wiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcIlxcXFwrXCIsIFtuZXcgVmFyKFwiWF9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwibm9udmFyXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcIm9uY2VcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJvbmNlXCIsIFtuZXcgVmFyKFwiWF9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwibm9udmFyXCIsIFtuZXcgVmFyKFwiWFwiKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJYX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJaXCIpXSksbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIlpcIildKV0pLCBuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwic2V0b2ZcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJaXCIpXSksbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIlpcIildKV0pLCBuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiYmFnb2ZcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJZXCIpLG5ldyBWYXIoXCJaXCIpXSksbmV3IFRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiWV9cIiksbmV3IFZhcihcIlpcIildKV0pLCBuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiWVwiKSxuZXcgVmFyKFwiWV9cIildKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJub252YXJcIiwgW25ldyBWYXIoXCJYXCIpXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIlhfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpLG5ldyBWYXIoXCJBM1wiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBM1wiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKSxuZXcgVmFyKFwiQTNcIiksbmV3IFZhcihcIkE0XCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEzXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE0XCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpLFxyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBWYXIoXCJBMVwiKSxuZXcgVmFyKFwiQTJcIiksbmV3IFZhcihcIkEzXCIpLG5ldyBWYXIoXCJBNFwiKSxuZXcgVmFyKFwiQTVcIildKSxuZXcgVGVybShcImNhbGxcIiwgW25ldyBWYXIoXCJGX1wiKV0pXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCI9Li5cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTFcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTJcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTNcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTRcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiQTVcIiksbmV3IFRlcm0oXCJbXVwiLCBbXSldKV0pXSldKV0pXSldKSxuZXcgVGVybShcImdvYWxfZXhwYW5zaW9uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVmFyKFwiRl9cIildKV0pKSxcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVmFyKFwiQTFcIiksbmV3IFZhcihcIkEyXCIpLG5ldyBWYXIoXCJBM1wiKSxuZXcgVmFyKFwiQTRcIiksbmV3IFZhcihcIkE1XCIpLG5ldyBWYXIoXCJBNlwiKV0pLG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIkZfXCIpXSldKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIj0uLlwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFRlcm0oXCIuXCIsIFtuZXcgVmFyKFwiWFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBMlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBM1wiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNFwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNVwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJBNlwiKSxuZXcgVGVybShcIltdXCIsIFtdKV0pXSldKV0pXSldKV0pXSksbmV3IFRlcm0oXCJnb2FsX2V4cGFuc2lvblwiLCBbbmV3IFZhcihcIkZcIiksbmV3IFZhcihcIkZfXCIpXSldKSksXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IFZhcihcIlhcIiksbmV3IFZhcihcIkExXCIpLG5ldyBWYXIoXCJBMlwiKSxuZXcgVmFyKFwiQTNcIiksbmV3IFZhcihcIkE0XCIpLG5ldyBWYXIoXCJBNVwiKSxuZXcgVmFyKFwiQTZcIiksbmV3IFZhcihcIkE3XCIpXSksbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgVmFyKFwiRl9cIildKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiPS4uXCIsIFtuZXcgVmFyKFwiRlwiKSxuZXcgVGVybShcIi5cIiwgW25ldyBWYXIoXCJYXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkExXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEyXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkEzXCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE0XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE1XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE2XCIpLG5ldyBUZXJtKFwiLlwiLCBbbmV3IFZhcihcIkE3XCIpLG5ldyBUZXJtKFwiW11cIiwgW10pXSldKV0pXSldKV0pXSldKV0pLG5ldyBUZXJtKFwiZ29hbF9leHBhbnNpb25cIiwgW25ldyBWYXIoXCJGXCIpLG5ldyBWYXIoXCJGX1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gU1lTVEVNIFBSRURJQ0FURVMgKCQpXHJcblxyXG5cdFx0Ly8gJyRwdXNoX2dsb2JhbF9zdGFjaycvMlxyXG5cdFx0XCIkcHVzaF9nbG9iYWxfc3RhY2svMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBzdGFjayA9IGF0b20uYXJnc1swXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHN0YWNrKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnB1c2hfZ2xvYmFsX3N0YWNrKHN0YWNrLmlkLCB2YWx1ZSk7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vICckZmx1c2hfZ2xvYmFsX3N0YWNrJy8zXHJcblx0XHRcIiRmbHVzaF9nbG9iYWxfc3RhY2svM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBzdGFjayA9IGF0b20uYXJnc1swXSwgbGlzdCA9IGF0b20uYXJnc1sxXSwgdGFpbCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoc3RhY2spKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgdmFsdWVzID0gdGhyZWFkLmZsdXNoX2dsb2JhbF9zdGFjayhzdGFjay5pZCwgdGFpbCk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW2xpc3QsIHZhbHVlc10pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vICckZnJlZV92YXJpYWJsZV9zZXQnLzNcclxuXHRcdFwiJGZyZWVfdmFyaWFibGVfc2V0LzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgZ29hbF9pbiA9IGF0b20uYXJnc1swXSwgZ29hbF9vdXQgPSBhdG9tLmFyZ3NbMV0sIHZhcnMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBidiA9IFtdO1xyXG5cdFx0XHR2YXIgcG9pbnRlciA9IGdvYWxfaW47XHJcblx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCJeLzJcIikge1xyXG5cdFx0XHRcdGJ2ID0gYnYuY29uY2F0KHBvaW50ZXIuYXJnc1swXS52YXJpYWJsZXMoKSk7XHJcblx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZ3YgPSBwb2ludGVyLnZhcmlhYmxlcygpO1xyXG5cdFx0XHR2YXIgZnYgPSBhcnJheVRvTGlzdChtYXAoZGlmZmVyZW5jZShndiwgYnYpLCBmdW5jdGlvbih2KSB7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBWYXIodik7XHJcblx0XHRcdH0pKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2dvYWxfb3V0LCBwb2ludGVyXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbdmFycywgZnZdKSBcclxuXHRcdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KVxyXG5cdFx0XHRdKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gJyRtZW1iZXInLzJcclxuXHRcdFwiJG1lbWJlci8yXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJG1lbWJlclwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiWFwiKSxuZXcgcGwudHlwZS5UZXJtKFwiLlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiWFwiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSldKSwgbnVsbCksXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRtZW1iZXJcIiwgW25ldyBwbC50eXBlLlZhcihcIlhcIiksbmV3IHBsLnR5cGUuVGVybShcIi5cIiwgW25ldyBwbC50eXBlLlZhcihcIl9cIiksbmV3IHBsLnR5cGUuVmFyKFwiWHNcIildKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiJG1lbWJlclwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiWFwiKSxuZXcgcGwudHlwZS5WYXIoXCJYc1wiKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyAnJGJpbmRfYmFnb2Zfa2V5cy8yJy8yXHJcblx0XHRcIiRiaW5kX2JhZ29mX2tleXMvMlwiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRiaW5kX2JhZ29mX2tleXNcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLCBudWxsKSxcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJGJpbmRfYmFnb2Zfa2V5c1wiLCBbbmV3IHBsLnR5cGUuVGVybShcIi5cIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJLZXlcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLG5ldyBwbC50eXBlLlZhcihcIkJhZ1wiKV0pLG5ldyBwbC50eXBlLlZhcihcIlZhcnNcIildKSwgbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJ0ZXJtX3ZhcmlhYmxlc1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiS2V5XCIpLG5ldyBwbC50eXBlLlZhcihcIlZhcnNcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIkYmluZF9iYWdvZl9rZXlzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJCYWdcIiksbmV3IHBsLnR5cGUuVmFyKFwiVmFyc1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vICckZmluZGFsbCcvNFxyXG5cdFx0XCIkZmluZGFsbC80XCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJGZpbmRhbGxcIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMFwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKSxuZXcgcGwudHlwZS5WYXIoXCJJbnN0YW5jZXNcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGFpbFwiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiO1wiLCBbbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJjb3B5X3Rlcm1cIiwgW25ldyBwbC50eXBlLlRlcm0oXCItXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTBcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGUxXCIpLG5ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImNhbGxcIiwgW25ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJjb3B5X3Rlcm1cIiwgW25ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZTJcIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRwdXNoX2dsb2JhbF9zdGFja1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVmFyXCIpLG5ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlMlwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCJmYWxzZVwiLCBbXSldKV0pXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiJGZsdXNoX2dsb2JhbF9zdGFja1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVmFyXCIpLG5ldyBwbC50eXBlLlZhcihcIkluc3RhbmNlc1wiKSxuZXcgcGwudHlwZS5WYXIoXCJUYWlsXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gJyRiYWdvZicvM1xyXG5cdFx0XCIkYmFnb2YvM1wiOiBbXHJcblx0XHRcdG5ldyBwbC50eXBlLlJ1bGUobmV3IHBsLnR5cGUuVGVybShcIiRiYWdvZlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2VyXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJGZyZWVfdmFyaWFibGVfc2V0XCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiXlwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIiksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDBcIildKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJGVlwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiZmluZGFsbFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIi1cIiwgW25ldyBwbC50eXBlLlZhcihcIkZWXCIpLG5ldyBwbC50eXBlLlZhcihcIlRlbXBsYXRlXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiR29hbDFcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2Vyc1wiKSxuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkYmluZF9iYWdvZl9rZXlzXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlZhcihcIl9cIildKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcImtleWdyb3VwXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlZhcihcIktleUdyb3Vwc1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwia2V5c29ydFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiS2V5R3JvdXBzXCIpLG5ldyBwbC50eXBlLlZhcihcIktleVNvcnRlZFwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIkbWVtYmVyXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiRlZcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2VyXCIpXSksbmV3IHBsLnR5cGUuVmFyKFwiS2V5U29ydGVkXCIpXSldKV0pXSldKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyAnJHNldG9mJy8zXHJcblx0XHRcIiRzZXRvZi8zXCI6IFtcclxuXHRcdFx0bmV3IHBsLnR5cGUuUnVsZShuZXcgcGwudHlwZS5UZXJtKFwiJHNldG9mXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJcIildKSwgbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkZnJlZV92YXJpYWJsZV9zZXRcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJeXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJUZW1wbGF0ZVwiKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMFwiKV0pLG5ldyBwbC50eXBlLlZhcihcIkdvYWwxXCIpLG5ldyBwbC50eXBlLlZhcihcIkZWXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJmaW5kYWxsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiRlZcIiksbmV3IHBsLnR5cGUuVmFyKFwiVGVtcGxhdGVcIildKSxuZXcgcGwudHlwZS5WYXIoXCJHb2FsMVwiKSxuZXcgcGwudHlwZS5WYXIoXCJBbnN3ZXJzXCIpLG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiLFwiLCBbbmV3IHBsLnR5cGUuVGVybShcIiRiaW5kX2JhZ29mX2tleXNcIiwgW25ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVmFyKFwiX1wiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwia2V5Z3JvdXBcIiwgW25ldyBwbC50eXBlLlZhcihcIkFuc3dlcnNcIiksbmV3IHBsLnR5cGUuVmFyKFwiS2V5R3JvdXBzXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJrZXlzb3J0XCIsIFtuZXcgcGwudHlwZS5WYXIoXCJLZXlHcm91cHNcIiksbmV3IHBsLnR5cGUuVmFyKFwiS2V5U29ydGVkXCIpXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkbWVtYmVyXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiLVwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiRlZcIiksbmV3IHBsLnR5cGUuVmFyKFwiVW5zb3J0ZWRcIildKSxuZXcgcGwudHlwZS5WYXIoXCJLZXlTb3J0ZWRcIildKSxuZXcgcGwudHlwZS5UZXJtKFwic29ydFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVW5zb3J0ZWRcIiksbmV3IHBsLnR5cGUuVmFyKFwiQW5zd2VyXCIpXSldKV0pXSldKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vICckaWYvMydcclxuXHRcdFwiJGlmLzNcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCIkaWZcIiwgW25ldyBwbC50eXBlLlZhcihcIklmXCIpLG5ldyBwbC50eXBlLlZhcihcIlRoZW5cIiksbmV3IHBsLnR5cGUuVmFyKFwiRWxzZVwiKV0pLCBuZXcgcGwudHlwZS5UZXJtKFwiO1wiLCBbbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCJjYWxsXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJJZlwiKV0pLG5ldyBwbC50eXBlLlRlcm0oXCIsXCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiJHB1c2hfZ2xvYmFsX3N0YWNrXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJTdGFja1wiKSxuZXcgcGwudHlwZS5WYXIoXCJfXCIpXSksbmV3IHBsLnR5cGUuVGVybShcImNhbGxcIiwgW25ldyBwbC50eXBlLlZhcihcIlRoZW5cIildKV0pXSksbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBwbC50eXBlLlRlcm0oXCIkZmx1c2hfZ2xvYmFsX3N0YWNrXCIsIFtuZXcgcGwudHlwZS5WYXIoXCJTdGFja1wiKSxuZXcgcGwudHlwZS5UZXJtKFwiW11cIiwgW10pLG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSldKSxuZXcgcGwudHlwZS5UZXJtKFwiY2FsbFwiLCBbbmV3IHBsLnR5cGUuVmFyKFwiRWxzZVwiKV0pXSldKSlcclxuXHRcdF0sXHJcblxyXG5cclxuXHRcdC8vIEFUVFJJQlVURUQgVkFSSUFCTEVTXHJcblx0XHRcclxuXHRcdC8vcHV0X2F0dHIvM1xyXG5cdFx0XCJwdXRfYXR0ci8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdmFyaWFibGUgPSBhdG9tLmFyZ3NbMF0sIG1vZHVsZSA9IGF0b20uYXJnc1sxXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSh2YXJpYWJsZSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcInZhcmlhYmxlXCIsIHZhcmlhYmxlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbShtb2R1bGUpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG1vZHVsZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdWJzID0gcG9pbnQuc3Vic3RpdHV0aW9uLnNldF9hdHRyaWJ1dGUoIHZhcmlhYmxlLmlkLCBtb2R1bGUsIHZhbHVlICk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZShudWxsKSwgc3VicywgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBnZXRfYXR0ci8zXHJcblx0XHRcImdldF9hdHRyLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciB2YXJpYWJsZSA9IGF0b20uYXJnc1swXSwgbW9kdWxlID0gYXRvbS5hcmdzWzFdLCB2YWx1ZSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKHZhcmlhYmxlKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwidmFyaWFibGVcIiwgdmFyaWFibGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKG1vZHVsZSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgbW9kdWxlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGF0dHIgPSBwb2ludC5zdWJzdGl0dXRpb24uZ2V0X2F0dHJpYnV0ZSggdmFyaWFibGUuaWQsIG1vZHVsZSApO1xyXG5cdFx0XHRcdGlmKCBhdHRyICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oXCI9XCIsIFt2YWx1ZSwgYXR0cl0pICksXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblx0XHRcclxuXHRcdC8vIElOUFVUIEFORCBPVVRQVVRcclxuXHRcdFxyXG5cdFx0Ly8gb3AvM1xyXG5cdFx0XCJvcC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgcHJpb3JpdHkgPSBhdG9tLmFyZ3NbMF0sIHR5cGUgPSBhdG9tLmFyZ3NbMV0sIG9wZXJhdG9ycyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc19hdG9tKG9wZXJhdG9ycykpXHJcblx0XHRcdFx0b3BlcmF0b3JzID0gbmV3IFRlcm0oXCIuXCIsIFtvcGVyYXRvcnMsIG5ldyBUZXJtKFwiW11cIildKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByaW9yaXR5ICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggdHlwZSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIHByaW9yaXR5ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgcHJpb3JpdHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCB0eXBlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgdHlwZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2xpc3QoIG9wZXJhdG9ycyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggb3BlcmF0b3JzICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImNyZWF0ZVwiLCBcIm9wZXJhdG9yXCIsIG9wZXJhdG9ycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gb3BlcmF0b3JzO1xyXG5cdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0dmFyIG9wZXJhdG9yID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcGVyYXRvciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBvcGVyYXRvciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHByaW9yaXR5LnZhbHVlIDwgMCB8fCBwcmlvcml0eS52YWx1ZSA+IDEyMDAgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3ByaW9yaXR5XCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggb3BlcmF0b3IuaWQgPT09IFwiLFwiICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwibW9kaWZ5XCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJ7fVwiICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJbXVwiICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBvcGVyYXRvci5pZCA9PT0gXCJ8XCIgJiYgcHJpb3JpdHkudmFsdWUgIT09IDAgJiYgKHByaW9yaXR5LnZhbHVlIDwgMTAwMSB8fCB0eXBlLmlkLmxlbmd0aCAhPT0gMyApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBbXCJmeVwiLCBcImZ4XCIsIFwieWZcIiwgXCJ4ZlwiLCBcInhmeFwiLCBcInlmeFwiLCBcInhmeVwiXS5pbmRleE9mKCB0eXBlLmlkICkgPT09IC0xICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9zcGVjaWZpZXJcIiwgdHlwZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR2YXIgZml4ID0geyBwcmVmaXg6IG51bGwsIGluZml4OiBudWxsLCBwb3N0Zml4OiBudWxsIH07XHJcblx0XHRcdFx0XHRcdGZvciggdmFyIHAgaW4gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzLmhhc093blByb3BlcnR5KHApKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY2xhc3NlcyA9IHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3BdW29wZXJhdG9yLmlkXTtcclxuXHRcdFx0XHRcdFx0XHRpZiggY2xhc3NlcyApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBjbGFzc2VzLCBcImZ4XCIgKSAhPT0gLTEgKSB7IGZpeC5wcmVmaXggPSB7IHByaW9yaXR5OiBwLCB0eXBlOiBcImZ4XCIgfTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0aWYoIGluZGV4T2YoIGNsYXNzZXMsIFwiZnlcIiApICE9PSAtMSApIHsgZml4LnByZWZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwiZnlcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZlwiICkgIT09IC0xICkgeyBmaXgucG9zdGZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieGZcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ5ZlwiICkgIT09IC0xICkgeyBmaXgucG9zdGZpeCA9IHsgcHJpb3JpdHk6IHAsIHR5cGU6IFwieWZcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZnhcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ4ZnlcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ4ZnlcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggaW5kZXhPZiggY2xhc3NlcywgXCJ5ZnhcIiApICE9PSAtMSApIHsgZml4LmluZml4ID0geyBwcmlvcml0eTogcCwgdHlwZTogXCJ5ZnhcIiB9OyB9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50X2NsYXNzO1xyXG5cdFx0XHRcdFx0XHRzd2l0Y2goIHR5cGUuaWQgKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSBcImZ5XCI6IGNhc2UgXCJmeFwiOiBjdXJyZW50X2NsYXNzID0gXCJwcmVmaXhcIjsgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSBcInlmXCI6IGNhc2UgXCJ4ZlwiOiBjdXJyZW50X2NsYXNzID0gXCJwb3N0Zml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6IGN1cnJlbnRfY2xhc3MgPSBcImluZml4XCI7IGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKGZpeC5pbmZpeCAmJiBjdXJyZW50X2NsYXNzID09PSBcInBvc3RmaXhcIiB8fCBmaXgucG9zdGZpeCAmJiBjdXJyZW50X2NsYXNzID09PSBcImluZml4XCIpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiY3JlYXRlXCIsIFwib3BlcmF0b3JcIiwgb3BlcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIGZpeFtjdXJyZW50X2NsYXNzXSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJlbW92ZSggdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF0sIGZpeFtjdXJyZW50X2NsYXNzXS50eXBlICk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF0ubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWxldGUgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbZml4W2N1cnJlbnRfY2xhc3NdLnByaW9yaXR5XVtvcGVyYXRvci5pZF07XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKCBwcmlvcml0eS52YWx1ZSA+IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXSApIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlLnRvU3RyaW5nKCldID0ge307XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggIXRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3ByaW9yaXR5LnZhbHVlXVtvcGVyYXRvci5pZF0gKSB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdID0gW107XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twcmlvcml0eS52YWx1ZV1bb3BlcmF0b3IuaWRdLnB1c2goIHR5cGUuaWQgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgfHwgcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcGVyYXRvcnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY3VycmVudF9vcC8zXHJcblx0XHRcImN1cnJlbnRfb3AvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHByaW9yaXR5ID0gYXRvbS5hcmdzWzBdLCBzcGVjaWZpZXIgPSBhdG9tLmFyZ3NbMV0sIG9wZXJhdG9yID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgcG9pbnRzID0gW107XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcHJpb3JpdHkgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBwcmlvcml0eSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBwcmlvcml0eSApICYmICggcHJpb3JpdHkudmFsdWUgPCAwIHx8IHByaW9yaXR5LnZhbHVlID4gMTIwMCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIm9wZXJhdG9yX3ByaW9yaXR5XCIsIHByaW9yaXR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHNwZWNpZmllciApICYmICFwbC50eXBlLmlzX2F0b20oIHNwZWNpZmllciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHNwZWNpZmllciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfYXRvbSggc3BlY2lmaWVyICkgJiYgaW5kZXhPZiggW1wiZnlcIiwgXCJmeFwiLCBcInlmXCIsIFwieGZcIiwgXCJ4ZnhcIiwgXCJ5ZnhcIiwgXCJ4ZnlcIl0sIHNwZWNpZmllci5pZCApID09PSAtMSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJvcGVyYXRvcl9zcGVjaWZpZXJcIiwgc3BlY2lmaWVyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG9wZXJhdG9yICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggb3BlcmF0b3IgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcGVyYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvciggdmFyIHAgaW4gdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnMgKVxyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgbyBpbiB0aHJlYWQuc2Vzc2lvbi5fX29wZXJhdG9yc1twXSApXHJcblx0XHRcdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDwgdGhyZWFkLnNlc3Npb24uX19vcGVyYXRvcnNbcF1bb10ubGVuZ3RoOyBpKysgKVxyXG5cdFx0XHRcdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKCBcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKCBcIj1cIiwgW25ldyBOdW0oIHAsIGZhbHNlICksIHByaW9yaXR5XSApLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKCBcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHRocmVhZC5zZXNzaW9uLl9fb3BlcmF0b3JzW3BdW29dW2ldLCBbXSApLCBzcGVjaWZpZXJdICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggbywgW10gKSwgb3BlcmF0b3JdIClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdIClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XSApXHJcblx0XHRcdFx0XHRcdFx0XHQpLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHQpICk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHBvaW50cyApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFxyXG5cclxuXHJcblx0XHQvLyBMT0dJQyBBTkQgQ09OVFJPTCBTVFJVQ1RVUkVTXHJcblx0XHJcblx0XHQvLyA7LzIgKGRpc2p1bmN0aW9uKVxyXG5cdFx0XCI7LzJcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgbGVmdCA9IGF0b20uYXJnc1swXSwgcmlnaHQgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBjb250ZXh0X2xlZnQgPSBsZWZ0LmFyZ3NbMF07XHJcblx0XHRcdHZhciBmcmVlX2xlZnQgPSBsZWZ0LmluZGljYXRvciA9PT0gXCI6LzJcIiA/IGxlZnQuYXJnc1sxXSA6IGxlZnQ7XHJcblx0XHRcdC8vIGlmIHRoZW4gZWxzZVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oZnJlZV9sZWZ0KSAmJiBmcmVlX2xlZnQuaW5kaWNhdG9yID09PSBcIi0+LzJcIikge1xyXG5cdFx0XHRcdHZhciBjb25kID0gbGVmdC5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBuZXcgVGVybShcIjpcIiwgW2NvbnRleHRfbGVmdCwgbmV3IFRlcm0oXCJjYWxsXCIsIFtmcmVlX2xlZnQuYXJnc1swXV0pXSkgOiBmcmVlX2xlZnQuYXJnc1swXTtcclxuXHRcdFx0XHR2YXIgdGhlbiA9IGxlZnQuaW5kaWNhdG9yID09PSBcIjovMlwiID8gbmV3IFRlcm0oXCI6XCIsIFtjb250ZXh0X2xlZnQsIGZyZWVfbGVmdC5hcmdzWzFdXSkgOiBmcmVlX2xlZnQuYXJnc1sxXTtcclxuXHRcdFx0XHR2YXIgb3RoZXJ3aXNlID0gcmlnaHQ7XHJcblx0XHRcdFx0dmFyIGdvYWxfZnN0ID0gcG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKCBcIixcIiwgW2NvbmQsIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCIhXCIpLCB0aGVuXSldICkgKTtcclxuXHRcdFx0XHR2YXIgZ29hbF9zbmQgPSBwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oXCIhXCIpLCBvdGhlcndpc2VdKSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKGdvYWxfZnN0LCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSxcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShnb2FsX3NuZCwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludClcclxuXHRcdFx0XHRdKTtcclxuXHRcdFx0Ly8gc29mdC1jdXRcclxuXHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfdGVybShmcmVlX2xlZnQpICYmIGZyZWVfbGVmdC5pbmRpY2F0b3IgPT09IFwiKi0+LzJcIikge1xyXG5cdFx0XHRcdHZhciBjb25kID0gbGVmdC5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBuZXcgVGVybShcIjpcIiwgW2NvbnRleHRfbGVmdCwgZnJlZV9sZWZ0LmFyZ3NbMF1dKSA6IGZyZWVfbGVmdC5hcmdzWzBdO1xyXG5cdFx0XHRcdHZhciB0aGVuID0gbGVmdC5pbmRpY2F0b3IgPT09IFwiOi8yXCIgPyBuZXcgVGVybShcIjpcIiwgW2NvbnRleHRfbGVmdCwgZnJlZV9sZWZ0LmFyZ3NbMV1dKSA6IGZyZWVfbGVmdC5hcmdzWzFdO1xyXG5cdFx0XHRcdHZhciBvdGhlcndpc2UgPSByaWdodDtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiJGlmXCIsIFtjb25kLCB0aGVuLCBvdGhlcndpc2VdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0Ly8gb3RoZXJ3aXNlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdFx0bmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShsZWZ0KSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCksXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKHJpZ2h0KSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludClcclxuXHRcdFx0XHRdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gIS8wIChjdXQpXHJcblx0XHRcIiEvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHBhcmVudF9jdXQsIGxhc3RfY3V0LCBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0cGFyZW50X2N1dCA9IHBvaW50O1xyXG5cdFx0XHRsYXN0X2N1dCA9IG51bGw7XHJcblx0XHRcdHdoaWxlKCBwYXJlbnRfY3V0LnBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnRfY3V0LnBhcmVudC5nb2FsLnNlYXJjaCggYXRvbSApICkge1xyXG5cdFx0XHRcdGxhc3RfY3V0ID0gcGFyZW50X2N1dDtcclxuXHRcdFx0XHRwYXJlbnRfY3V0ID0gcGFyZW50X2N1dC5wYXJlbnQ7XHJcblx0XHRcdFx0aWYocGFyZW50X2N1dC5nb2FsICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgc2VsZWN0ZWQgPSBwYXJlbnRfY3V0LmdvYWwuc2VsZWN0KCk7XHJcblx0XHRcdFx0XHRpZihzZWxlY3RlZCAmJiBzZWxlY3RlZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpXHJcblx0XHRcdFx0XHRcdHNlbGVjdGVkID0gc2VsZWN0ZWQuYXJnc1sxXTtcclxuXHRcdFx0XHRcdGlmKCBzZWxlY3RlZCAmJiBzZWxlY3RlZC5pZCA9PT0gXCJjYWxsXCIgJiYgc2VsZWN0ZWQuc2VhcmNoKGF0b20pICkge1xyXG5cdFx0XHRcdFx0XHRwYXJlbnRfY3V0ID0gbGFzdF9jdXQ7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgc2V0dXBfY2FsbF9jbGVhbnVwID0gbnVsbDtcclxuXHRcdFx0Zm9yKCB2YXIgaSA9IHRocmVhZC5wb2ludHMubGVuZ3RoLTE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdHZhciBzdGF0ZSA9IHRocmVhZC5wb2ludHNbaV07XHJcblx0XHRcdFx0dmFyIG5vZGUgPSBzdGF0ZS5wYXJlbnQ7XHJcblx0XHRcdFx0d2hpbGUoIG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gcGFyZW50X2N1dC5wYXJlbnQgKSB7XHJcblx0XHRcdFx0XHRub2RlID0gbm9kZS5wYXJlbnQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBub2RlID09PSBudWxsICYmIG5vZGUgIT09IHBhcmVudF9jdXQucGFyZW50IClcclxuXHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBzdGF0ZSApO1xyXG5cdFx0XHRcdGVsc2UgaWYoc3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX2dvYWwpXHJcblx0XHRcdFx0XHRzZXR1cF9jYWxsX2NsZWFudXAgPSBzdGF0ZS5zZXR1cF9jYWxsX2NsZWFudXBfZ29hbFxyXG5cdFx0XHR9XHJcblx0XHRcdHRocmVhZC5wb2ludHMgPSBzdGF0ZXMucmV2ZXJzZSgpO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShzZXR1cF9jYWxsX2NsZWFudXApLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBcXCsgKG5lZ2F0aW9uKVxyXG5cdFx0XCJcXFxcKy8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ29hbCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGdvYWwgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jYWxsYWJsZSggZ29hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjYWxsYWJsZVwiLCBnb2FsLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gVFJBTlNQQVJFTlQgVkVSU0lPTiBPRiBUSEUgTkVHQVRJT05cclxuXHRcdFx0XHQvKnZhciBuZWdfdGhyZWFkO1xyXG5cdFx0XHRcdGlmKHBvaW50Lm5lZ2F0aW9uX3RocmVhZCkge1xyXG5cdFx0XHRcdFx0bmVnX3RocmVhZCA9IHBvaW50Lm5lZ2F0aW9uX3RocmVhZDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bmVnX3RocmVhZCA9IG5ldyBUaHJlYWQoIHRocmVhZC5zZXNzaW9uICk7XHJcblx0XHRcdFx0XHRuZWdfdGhyZWFkLmFkZF9nb2FsKCBnb2FsICk7XHJcblx0XHRcdFx0XHRwb2ludC5uZWdhdGlvbl90aHJlYWQgPSBuZWdfdGhyZWFkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRuZWdfdGhyZWFkLmFuc3dlciggZnVuY3Rpb24oIGFuc3dlciApIHtcclxuXHRcdFx0XHRcdGlmKGFuc3dlciA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYocGwudHlwZS5pc19lcnJvciggYW5zd2VyICkpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBhbnN3ZXIuYXJnc1swXSApO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKGFuc3dlciA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW3BvaW50XSApO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuY3VycmVudF9saW1pdCA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQuYWdhaW4oIGFuc3dlciAhPT0gbnVsbCApO1xyXG5cdFx0XHRcdH0gKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTsqL1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdC8vICdcXCsnKFgpIDotIGNhbGwoWCksICEsIGZhaWwuXHJcblx0XHRcdFx0Ly8gJ1xcKycoXykuXHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCIsXCIsIFsgbmV3IFRlcm0oIFwiY2FsbFwiLCBbZ29hbF0gKSwgbmV3IFRlcm0oIFwiIVwiLCBbXSApIF0gKSwgbmV3IFRlcm0oIFwiZmFpbFwiLCBbXSApIF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICksXHJcblx0XHRcdFx0XHRuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbnVsbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50IClcclxuXHRcdFx0XHRdICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIC0+LzIgKGltcGxpY2F0aW9uKVxyXG5cdFx0XCItPi8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY29uZCA9IGF0b20uYXJnc1swXSwgdGhlbiA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIGdvYWwgPSBwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRuZXcgVGVybShcImNhbGxcIiwgW2NvbmRdKSxcclxuXHRcdFx0XHRuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiIVwiKSwgdGhlbl0pXHJcblx0XHRcdF0pKTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIGdvYWwsIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gKi0+LzIgKHNvZnQtY3V0KVxyXG5cdFx0XCIqLT4vMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjb25kID0gYXRvbS5hcmdzWzBdLCB0aGVuID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgZ29hbCA9IHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdG5ldyBUZXJtKFwiY2FsbFwiLCBbY29uZF0pLCB0aGVuXSkpO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKGdvYWwsIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpXSk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBmYWlsLzBcclxuXHRcdFwiZmFpbC8wXCI6IGZ1bmN0aW9uKCBfMSwgXzIsIF8zICkge30sXHJcblx0XHRcclxuXHRcdC8vIGZhbHNlLzBcclxuXHRcdFwiZmFsc2UvMFwiOiBmdW5jdGlvbiggXzEsIF8yLCBfMyApIHt9LFxyXG5cdFx0XHJcblx0XHQvLyB0cnVlLzBcclxuXHRcdFwidHJ1ZS8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBfICkge1xyXG5cdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNhbGwvMS4uOFxyXG5cdFx0XCJjYWxsLzFcIjogY2FsbE4oMSksXHJcblx0XHRcImNhbGwvMlwiOiBjYWxsTigyKSxcclxuXHRcdFwiY2FsbC8zXCI6IGNhbGxOKDMpLFxyXG5cdFx0XCJjYWxsLzRcIjogY2FsbE4oNCksXHJcblx0XHRcImNhbGwvNVwiOiBjYWxsTig1KSxcclxuXHRcdFwiY2FsbC82XCI6IGNhbGxOKDYpLFxyXG5cdFx0XCJjYWxsLzdcIjogY2FsbE4oNyksXHJcblx0XHRcImNhbGwvOFwiOiBjYWxsTig4KSxcclxuXHRcdFxyXG5cdFx0Ly8gb25jZS8xXHJcblx0XHRcIm9uY2UvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdvYWwgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcImNhbGxcIiwgW2dvYWxdICksIG5ldyBUZXJtKCBcIiFcIiwgW10gKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBmb3JhbGwvMlxyXG5cdFx0XCJmb3JhbGwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGdlbmVyYXRlID0gYXRvbS5hcmdzWzBdLCB0ZXN0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJcXFxcK1wiLCBbbmV3IFRlcm0oIFwiLFwiLCBbbmV3IFRlcm0oIFwiY2FsbFwiLCBbZ2VuZXJhdGVdICksIG5ldyBUZXJtKCBcIlxcXFwrXCIsIFtuZXcgVGVybSggXCJjYWxsXCIsIFt0ZXN0XSApXSApXSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHJlcGVhdC8wXHJcblx0XHRcInJlcGVhdC8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBfICkge1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBudWxsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKSwgcG9pbnRdICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEVYQ0VQVElPTlNcclxuXHRcdFxyXG5cdFx0Ly8gdGhyb3cvMVxyXG5cdFx0XCJ0aHJvdy8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZXJyb3IgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZXJyb3IpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24odGhyZWFkLmxldmVsLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aHJlYWQucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSB0aHJlYWQucG9pbnRzW2ldO1xyXG5cdFx0XHRcdFx0aWYoc3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX2NhdGNoKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wb2ludHMgPSBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImNhdGNoXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX2NhdGNoLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgVmFyKFwiX1wiKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ0aHJvd1wiLCBbZXJyb3JdKVxyXG5cdFx0XHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInRocm93XCIsIFtlcnJvcl0pXHJcblx0XHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdCldO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKGVycm9yKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY2F0Y2gvM1xyXG5cdFx0XCJjYXRjaC8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGdvYWwgPSBhdG9tLmFyZ3NbMF0sIGNhdGNoZXIgPSBhdG9tLmFyZ3NbMV0sIHJlY292ZXIgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdHZhciBudGhyZWFkO1xyXG5cdFx0XHRpZighcG9pbnQuY2F0Y2gpIHtcclxuXHRcdFx0XHRudGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRcdFx0bnRocmVhZC5kZWJ1Z2dlciA9IHRocmVhZC5kZWJ1Z2dlcjtcclxuXHRcdFx0XHRudGhyZWFkLmZvcm1hdF9zdWNjZXNzID0gZnVuY3Rpb24oc3RhdGUpIHsgcmV0dXJuIHN0YXRlLnN1YnN0aXR1dGlvbjsgfTtcclxuXHRcdFx0XHRudGhyZWFkLmZvcm1hdF9lcnJvciA9IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiBzdGF0ZS5nb2FsOyB9O1xyXG5cdFx0XHRcdG50aHJlYWQuYWRkX2dvYWwoZ29hbCwgdHJ1ZSwgcG9pbnQpO1xyXG5cdFx0XHRcdHBvaW50LmNhdGNoID0gbnRocmVhZDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRudGhyZWFkID0gcG9pbnQuY2F0Y2g7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19lcnJvcihhbnN3ZXIpKSB7XHJcblx0XHRcdFx0XHR2YXIgb2NjdXJzX2NoZWNrID0gdGhyZWFkLmdldF9mbGFnKFwib2NjdXJzX2NoZWNrXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIjtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xyXG5cdFx0XHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KGFuc3dlci5hcmdzWzBdLCBjYXRjaGVyLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0XHRcdFx0aWYobWd1ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlLnN1YnN0aXR1dGlvbiA9IHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseShtZ3UpO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5nb2FsID0gcG9pbnQuZ29hbC5yZXBsYWNlKHJlY292ZXIpLmFwcGx5KG1ndSk7XHJcblx0XHRcdFx0XHRcdHN0YXRlLnBhcmVudCA9IHBvaW50O1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGVdKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihhbnN3ZXIuYXJnc1swXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKGFuc3dlciAhPT0gZmFsc2UgJiYgYW5zd2VyICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGUgPSBhbnN3ZXIgPT09IG51bGwgPyBbXSA6IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5hcHBseShhbnN3ZXIpLnJlcGxhY2UobnVsbCksXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseShhbnN3ZXIpLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZSwgcG9pbnRdKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYW5zd2VyID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbcG9pbnRdKTtcclxuXHRcdFx0XHRcdGlmKHRocmVhZC5oYXNfbGltaXQpXHJcblx0XHRcdFx0XHRcdHRocmVhZC5jdXJyZW50X2xpbWl0ID0gMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLmFnYWluKGFuc3dlciAhPT0gbnVsbCk7XHJcblx0XHRcdH07XHJcblx0XHRcdG50aHJlYWQuYW5zd2VyKGNhbGxiYWNrKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGNhbGxfY2xlYW51cC8yXHJcblx0XHRcImNhbGxfY2xlYW51cC8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNhbGwgPSBhdG9tLmFyZ3NbMF0sIGNsZWFudXAgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoY2FsbCkgfHwgcGwudHlwZS5pc192YXJpYWJsZShjbGVhbnVwKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjYWxsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2FsbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsZWFudXApKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbGVhbnVwLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBudGhyZWFkLCBjYWxsYmFjaztcclxuXHRcdFx0XHRpZihwb2ludC5oYXNPd25Qcm9wZXJ0eShcInNldHVwX2NhbGxfY2xlYW51cF90aHJlYWRcIikpIHtcclxuXHRcdFx0XHRcdG50aHJlYWQgPSBwb2ludC5zZXR1cF9jYWxsX2NsZWFudXBfdGhyZWFkO1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBwb2ludC5zZXR1cF9jYWxsX2NsZWFudXBfY2FsbGJhY2s7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oXCJjYWxsXCIsIFtjYWxsXSk7XHJcblx0XHRcdFx0XHRudGhyZWFkID0gbmV3IFRocmVhZCh0aHJlYWQuc2Vzc2lvbik7XHJcblx0XHRcdFx0XHRudGhyZWFkLmFkZF9nb2FsKGdvYWwsIHRydWUsIHBvaW50KTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oYW5zd2VyKSB7XHJcblx0XHRcdFx0XHRcdGlmKGFuc3dlciA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwsXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX3RocmVhZCA9IG50aHJlYWQ7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuc2V0dXBfY2FsbF9jbGVhbnVwX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihhbnN3ZXIgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGNsZWFudXBfYW5kX2ZhaWwgPSBuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsXCIsIFtjbGVhbnVwXSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcImZhaWxcIilcclxuXHRcdFx0XHRcdFx0XHRdKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoY2xlYW51cF9hbmRfZmFpbCksXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW3N0YXRlXSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX2Vycm9yKGFuc3dlcikpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY2xlYW51cF9hbmRfdGhyb3cgPSBuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsXCIsIFtjbGVhbnVwXSksXHJcblx0XHRcdFx0XHRcdFx0XHRhbnN3ZXJcclxuXHRcdFx0XHRcdFx0XHRdKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoY2xlYW51cF9hbmRfdGhyb3cpLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZV0pO1xyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGlmKG50aHJlYWQucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlID0gbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJjYWxsXCIsIFtjbGVhbnVwXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0KS5hcHBseShhbnN3ZXIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoYW5zd2VyKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbc3RhdGVdKTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHN0YXRlMSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5hcHBseShhbnN3ZXIpLnJlcGxhY2UobnVsbCksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseShhbnN3ZXIpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzdGF0ZTIgPSBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTIuc2V0dXBfY2FsbF9jbGVhbnVwX3RocmVhZCA9IG50aHJlYWQ7XHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTIuc2V0dXBfY2FsbF9jbGVhbnVwX2NhbGxiYWNrID0gY2FsbGJhY2s7XHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTIuc2V0dXBfY2FsbF9jbGVhbnVwX2dvYWwgPSBjbGVhbnVwLmFwcGx5KGFuc3dlcik7XHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTIuc2V0dXBfY2FsbF9jbGVhbnVwX2NhdGNoID0gY2xlYW51cDtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtzdGF0ZTEsIHN0YXRlMl0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQuYWdhaW4oKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bnRocmVhZC5hbnN3ZXIoY2FsbGJhY2spO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHNldHVwX2NhbGxfY2xlYW51cC8zXHJcblx0XHRcInNldHVwX2NhbGxfY2xlYW51cC8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHNldHVwID0gYXRvbS5hcmdzWzBdLCBjYWxsID0gYXRvbS5hcmdzWzFdLCBjbGVhbnVwID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHNldHVwKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKGNhbGwpIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoY2xlYW51cCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoc2V0dXApKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBzZXR1cCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNhbGwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjYWxsLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xlYW51cCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsZWFudXAsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIm9uY2VcIiwgW3NldHVwXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiY2FsbF9jbGVhbnVwXCIsIFtjYWxsLCBjbGVhbnVwXSlcclxuXHRcdFx0XHRcdF0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBVTklGSUNBVElPTlxyXG5cdFx0XHJcblx0XHQvLyA9LzIgKHVuaWZpY2F0aW9uKVxyXG5cdFx0XCI9LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvY2N1cnNfY2hlY2sgPSB0aHJlYWQuZ2V0X2ZsYWcoIFwib2NjdXJzX2NoZWNrXCIgKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCI7XHJcblx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZSgpO1xyXG5cdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdLCBvY2N1cnNfY2hlY2sgKTtcclxuXHRcdFx0aWYoIG1ndSAhPT0gbnVsbCApIHtcclxuXHRcdFx0XHRzdGF0ZS5nb2FsID0gcG9pbnQuZ29hbC5hcHBseSggbWd1ICkucmVwbGFjZSggbnVsbCApO1xyXG5cdFx0XHRcdHN0YXRlLnN1YnN0aXR1dGlvbiA9IHBvaW50LnN1YnN0aXR1dGlvbi5hcHBseSggbWd1ICk7XHJcblx0XHRcdFx0c3RhdGUucGFyZW50ID0gcG9pbnQ7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtzdGF0ZV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gdW5pZnlfd2l0aF9vY2N1cnNfY2hlY2svMlxyXG5cdFx0XCJ1bmlmeV93aXRoX29jY3Vyc19jaGVjay8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcclxuXHRcdFx0dmFyIG1ndSA9IHBsLnVuaWZ5KCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSwgdHJ1ZSApO1xyXG5cdFx0XHRpZiggbWd1ICE9PSBudWxsICkge1xyXG5cdFx0XHRcdHN0YXRlLmdvYWwgPSBwb2ludC5nb2FsLmFwcGx5KCBtZ3UgKS5yZXBsYWNlKCBudWxsICk7XHJcblx0XHRcdFx0c3RhdGUuc3Vic3RpdHV0aW9uID0gcG9pbnQuc3Vic3RpdHV0aW9uLmFwcGx5KCBtZ3UgKTtcclxuXHRcdFx0XHRzdGF0ZS5wYXJlbnQgPSBwb2ludDtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW3N0YXRlXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBcXD0vMlxyXG5cdFx0XCJcXFxcPS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb2NjdXJzX2NoZWNrID0gdGhyZWFkLmdldF9mbGFnKCBcIm9jY3Vyc19jaGVja1wiICkuaW5kaWNhdG9yID09PSBcInRydWUvMFwiO1xyXG5cdFx0XHR2YXIgbWd1ID0gcGwudW5pZnkoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdLCBvY2N1cnNfY2hlY2sgKTtcclxuXHRcdFx0aWYoIG1ndSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gc3Vic3VtZXNfdGVybS8yXHJcblx0XHQvKlxyXG5cdFx0c3Vic3VtZXNfdGVybShHZW5lcmFsLCBTcGVjaWZpYykgOi1cclxuXHRcdFx0XFwrIFxcKyAoXHJcblx0XHRcdHRlcm1fdmFyaWFibGVzKFNwZWNpZmljLCBWYXJzMSksXHJcblx0XHRcdHVuaWZ5X3dpdGhfb2NjdXJzX2NoZWNrKEdlbmVyYWwsIFNwZWNpZmljKSxcclxuXHRcdFx0dGVybV92YXJpYWJsZXMoVmFyczEsIFZhcnMyKSxcclxuXHRcdFx0VmFyczEgPT0gVmFyczJcclxuXHRcdCkuXHJcblx0XHQqL1xyXG5cdFx0XCJzdWJzdW1lc190ZXJtLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBnZW5lcmFsID0gYXRvbS5hcmdzWzBdLCBzcGVjaWZpYyA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHZhcnMxID0gdGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpO1xyXG5cdFx0XHR2YXIgdmFyczIgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiXFxcXCtcIiwgW1xyXG5cdFx0XHRcdFx0bmV3IFRlcm0oXCJcXFxcK1wiLCBbXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJ0ZXJtX3ZhcmlhYmxlc1wiLCBbc3BlY2lmaWMsIHZhcnMxXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwidW5pZnlfd2l0aF9vY2N1cnNfY2hlY2tcIiwgW2dlbmVyYWwsIHNwZWNpZmljXSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInRlcm1fdmFyaWFibGVzXCIsIFt2YXJzMSwgdmFyczJdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9PVwiLCBbdmFyczEsIHZhcnMyXSlcclxuXHRcdFx0XHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdFx0XSlcclxuXHRcdFx0XHRcdF0pXHJcblx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBBTEwgU09MVVRJT05TXHJcblxyXG5cdFx0Ly8gZmluZGFsbC8zXHJcblx0XHRcImZpbmRhbGwvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZW1wbGF0ZSA9IGF0b20uYXJnc1swXSwgZ29hbCA9IGF0b20uYXJnc1sxXSwgaW5zdGFuY2VzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgdGFpbCA9IG5ldyBUZXJtKFwiW11cIiwgW10pO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcImZpbmRhbGxcIiwgW3RlbXBsYXRlLCBnb2FsLCBpbnN0YW5jZXMsIHRhaWxdKSksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZmluZGFsbC80XHJcblx0XHRcImZpbmRhbGwvNFwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZW1wbGF0ZSA9IGF0b20uYXJnc1swXSwgZ29hbCA9IGF0b20uYXJnc1sxXSwgaW5zdGFuY2VzID0gYXRvbS5hcmdzWzJdLCB0YWlsID0gYXRvbS5hcmdzWzNdO1xyXG5cdFx0XHR2YXIgcHJvcGVyX2dvYWwgPSBnb2FsO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oZ29hbCkgJiYgZ29hbC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpXHJcblx0XHRcdFx0cHJvcGVyX2dvYWwgPSBnb2FsLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVyX2dvYWwpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKHByb3Blcl9nb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgZ29hbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluc3RhbmNlcykgJiYgIXBsLnR5cGUuaXNfbGlzdChpbnN0YW5jZXMpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGluc3RhbmNlcywgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHRhaWwpICYmICFwbC50eXBlLmlzX2xpc3QodGFpbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImxpc3RcIiwgdGFpbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiJGZpbmRhbGxcIiwgW3RlbXBsYXRlLCBnb2FsLCBpbnN0YW5jZXMsIHRhaWxdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYmFnb2YvM1xyXG5cdFx0XCJiYWdvZi8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlbXBsYXRlID0gYXRvbS5hcmdzWzBdLCBnb2FsID0gYXRvbS5hcmdzWzFdLCBpbnN0YW5jZXMgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoZ29hbCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGdvYWwsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShpbnN0YW5jZXMpICYmICFwbC50eXBlLmlzX2xpc3QoaW5zdGFuY2VzKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZShcImxpc3RcIiwgaW5zdGFuY2VzLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIkYmFnb2ZcIiwgW3RlbXBsYXRlLCBnb2FsLCBpbnN0YW5jZXNdKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzZXRvZi8zXHJcblx0XHRcInNldG9mLzNcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgdGVtcGxhdGUgPSBhdG9tLmFyZ3NbMF0sIGdvYWwgPSBhdG9tLmFyZ3NbMV0sIGluc3RhbmNlcyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShnb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShnb2FsKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgZ29hbCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluc3RhbmNlcykgJiYgIXBsLnR5cGUuaXNfbGlzdChpbnN0YW5jZXMpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKFwibGlzdFwiLCBpbnN0YW5jZXMsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIiRzZXRvZlwiLCBbdGVtcGxhdGUsIGdvYWwsIGluc3RhbmNlc10pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBURVJNIENSRUFUSU9OIEFORCBERUNPTVBPU0lUSU9OXHJcblx0XHRcclxuXHRcdC8vIGZ1bmN0b3IvM1xyXG5cdFx0XCJmdW5jdG9yLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdWJzO1xyXG5cdFx0XHR2YXIgdGVybSA9IGF0b20uYXJnc1swXSwgbmFtZSA9IGF0b20uYXJnc1sxXSwgYXJpdHkgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0ZXJtICkgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIG5hbWUgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhcml0eSApKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXJpdHkgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBhcml0eSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGF0b20uYXJnc1syXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBuYW1lICkgJiYgIXBsLnR5cGUuaXNfYXRvbWljKCBuYW1lICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB0ZXJtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggbmFtZSApICYmIHBsLnR5cGUuaXNfaW50ZWdlciggYXJpdHkgKSAmJiBhcml0eS52YWx1ZSA+IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggdGVybSApICYmIHBsLnR5cGUuaXNfaW50ZWdlciggYXJpdHkgKSAmJiBhcml0eS52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGF0b20uYXJnc1syXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHRlcm0gKSApIHtcclxuXHRcdFx0XHRpZiggYXRvbS5hcmdzWzJdLnZhbHVlID49IDAgKSB7XHJcblx0XHRcdFx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBhcml0eS52YWx1ZTsgaSsrIClcclxuXHRcdFx0XHRcdFx0YXJncy5wdXNoKCB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCkgKTtcclxuXHRcdFx0XHRcdHZhciBmdW5jdG9yID0gcGwudHlwZS5pc19udW1iZXIoIG5hbWUgKSA/IG5hbWUgOiBuZXcgVGVybSggbmFtZS5pZCwgYXJncyApO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbdGVybSwgZnVuY3Rvcl0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpZCA9IHBsLnR5cGUuaXNfbnVtYmVyKCB0ZXJtICkgPyB0ZXJtIDogbmV3IFRlcm0oIHRlcm0uaWQsIFtdICk7XHJcblx0XHRcdFx0dmFyIGxlbmd0aCA9IHBsLnR5cGUuaXNfbnVtYmVyKCB0ZXJtICkgPyBuZXcgTnVtKCAwLCBmYWxzZSApIDogbmV3IE51bSggdGVybS5hcmdzLmxlbmd0aCwgZmFsc2UgKTtcclxuXHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcIj1cIiwgW2lkLCBuYW1lXSApLCBuZXcgVGVybSggXCI9XCIsIFtsZW5ndGgsIGFyaXR5XSApXSApO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhcmcvM1xyXG5cdFx0XCJhcmcvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGF0b20uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGF0b20uYXJnc1swXS52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGF0b20uYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NvbXBvdW5kKCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY29tcG91bmRcIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIG4gPSBhdG9tLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0aWYoIG4gPiAwICYmIG4gPD0gYXRvbS5hcmdzWzFdLmFyZ3MubGVuZ3RoICkge1xyXG5cdFx0XHRcdFx0dmFyIGdvYWwgPSBuZXcgVGVybSggXCI9XCIsIFthdG9tLmFyZ3NbMV0uYXJnc1tuLTFdLCBhdG9tLmFyZ3NbMl1dICk7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBnb2FsICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID0uLi8yICh1bml2KVxyXG5cdFx0XCI9Li4vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3Q7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSAmJiAocGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzFdIClcclxuXHRcdFx0fHwgcGwudHlwZS5pc19ub25fZW1wdHlfbGlzdCggYXRvbS5hcmdzWzFdICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzFdLmFyZ3NbMF0gKSkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZnVsbHlfbGlzdCggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgJiYgcGwudHlwZS5pc19lbXB0eV9saXN0KCBhdG9tLmFyZ3NbMV0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub25fZW1wdHlfbGlzdFwiLCBhdG9tLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggYXRvbS5hcmdzWzBdICkgJiYgYXRvbS5hcmdzWzBdLmFyZ3MubGVuZ3RoID4gMCApIHtcclxuXHRcdFx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gYXRvbS5hcmdzWzBdLmFyZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCIuXCIsIFthdG9tLmFyZ3NbMF0uYXJnc1tpXSwgbGlzdF0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCIuXCIsIFtuZXcgVGVybSggYXRvbS5hcmdzWzBdLmlkICksIGxpc3RdICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGxpc3QgPSBuZXcgVGVybSggXCIuXCIsIFthdG9tLmFyZ3NbMF0sIG5ldyBUZXJtKCBcIltdXCIgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGlzdCwgYXRvbS5hcmdzWzFdXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzFdICkgKSB7XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBbXTtcclxuXHRcdFx0XHRsaXN0ID0gYXRvbS5hcmdzWzFdLmFyZ3NbMV07XHJcblx0XHRcdFx0d2hpbGUoIGxpc3QuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0YXJncy5wdXNoKCBsaXN0LmFyZ3NbMF0gKTtcclxuXHRcdFx0XHRcdGxpc3QgPSBsaXN0LmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tLmFyZ3NbMF0gKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIGFyZ3MubGVuZ3RoID09PSAwICYmIHBsLnR5cGUuaXNfY29tcG91bmQoIGF0b20uYXJnc1sxXS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIGF0b20uYXJnc1sxXS5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBhcmdzLmxlbmd0aCA+IDAgJiYgKHBsLnR5cGUuaXNfY29tcG91bmQoIGF0b20uYXJnc1sxXS5hcmdzWzBdICkgfHwgcGwudHlwZS5pc19udW1iZXIoIGF0b20uYXJnc1sxXS5hcmdzWzBdICkpICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbS5hcmdzWzFdLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIGFyZ3MubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFthdG9tLmFyZ3NbMV0uYXJnc1swXSwgYXRvbS5hcmdzWzBdXSwgcG9pbnQgKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggYXRvbS5hcmdzWzFdLmFyZ3NbMF0uaWQsIGFyZ3MgKSwgYXRvbS5hcmdzWzBdXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNvcHlfdGVybS8yXHJcblx0XHRcImNvcHlfdGVybS8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIG9yaWdpbmFsX3Rlcm0gPSBhdG9tLmFyZ3NbMF0sIHJlbmFtZWRfdGVybSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0dmFyIG5ld190ZXJtID0gb3JpZ2luYWxfdGVybS5yZW5hbWUodGhyZWFkKTtcclxuXHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoW1xyXG5cdFx0XHRcdG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW3JlbmFtZWRfdGVybSwgbmV3X3Rlcm1dKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludClcclxuXHRcdFx0XHRdXHJcblx0XHRcdCk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyB0ZXJtX3ZhcmlhYmxlcy8yXHJcblx0XHRcInRlcm1fdmFyaWFibGVzLzJcIjogW1xyXG5cdFx0XHRuZXcgcGwudHlwZS5SdWxlKG5ldyBwbC50eXBlLlRlcm0oXCJ0ZXJtX3ZhcmlhYmxlc1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVybVwiKSxuZXcgcGwudHlwZS5WYXIoXCJWYXJzXCIpXSksIG5ldyBwbC50eXBlLlRlcm0oXCJ0ZXJtX3ZhcmlhYmxlc1wiLCBbbmV3IHBsLnR5cGUuVmFyKFwiVGVybVwiKSxuZXcgcGwudHlwZS5WYXIoXCJWYXJzXCIpLG5ldyBwbC50eXBlLlRlcm0oXCJbXVwiLCBbXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gdGVybV92YXJpYWJsZXMvM1xyXG5cdFx0XCJ0ZXJtX3ZhcmlhYmxlcy8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRlcm0gPSBhdG9tLmFyZ3NbMF0sIHZhcnMgPSBhdG9tLmFyZ3NbMV0sIHRhaWwgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc19mdWxseV9saXN0KCB2YXJzICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgdmFycywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBsaXN0ID0gYXJyYXlUb0xpc3QobWFwKG51Yih0ZXJtLnZhcmlhYmxlcygpKSwgZnVuY3Rpb24odikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBWYXIodik7XHJcblx0XHRcdFx0fSksIHRhaWwpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFt2YXJzLCBsaXN0XSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbnVtYmVydmFycy8zXHJcblx0XHRcIm51bWJlcnZhcnMvM1wiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciB0ZXJtID0gYXRvbS5hcmdzWzBdLCBzdGFydCA9IGF0b20uYXJnc1sxXSwgZW5kID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHN0YXJ0KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19pbnRlZ2VyKHN0YXJ0KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCBzdGFydCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGVuZCkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlcihlbmQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIGVuZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgdmFyaWFibGVzID0gbnViKHRlcm0udmFyaWFibGVzKCkpO1xyXG5cdFx0XHRcdHZhciB2YWx1ZSA9IHN0YXJ0LnZhbHVlO1xyXG5cdFx0XHRcdHZhciB1bmlmX2JvZHkgPSBuZXcgVGVybShcInRydWVcIik7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0dW5pZl9ib2R5ID0gbmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVmFyKHZhcmlhYmxlc1tpXSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIkVkFSXCIsIFtuZXcgTnVtKHZhbHVlLCBmYWxzZSldKV0pLFxyXG5cdFx0XHRcdFx0XHRcdHVuaWZfYm9keV0pO1xyXG5cdFx0XHRcdFx0dmFsdWUrKztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHVuaWZfZW5kID0gbmV3IFRlcm0oXCI9XCIsIFtlbmQsIG5ldyBOdW0odmFsdWUsIGZhbHNlKV0pO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoZW5kKSB8fCBlbmQudmFsdWUgPT09IHZhbHVlKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFt1bmlmX2JvZHksIHVuaWZfZW5kXSkpLFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBDTEFVU0UgUkVUUklFVkFMIEFORCBJTkZPUk1BVElPTlxyXG5cdFx0XHJcblx0XHQvLyBjbGF1c2UvMlxyXG5cdFx0XCJjbGF1c2UvMlwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBoZWFkID0gYXRvbS5hcmdzWzBdLCBib2R5ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkID0gXCJ1c2VyXCI7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShoZWFkKSAmJiBoZWFkLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20oaGVhZC5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgaGVhZC5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBoZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aGVhZCA9IGhlYWQuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZ2V0X21vZHVsZSA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXTtcclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGJvZHkpICYmICFwbC50eXBlLmlzX2NhbGxhYmxlKGJvZHkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBib2R5LCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoaGVhZC5pbmRpY2F0b3IgPT09IFwiLC8yXCIgfHwgdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJhY2Nlc3NcIiwgXCJwcml2YXRlX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpICYmIGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdKSB7XHJcblx0XHRcdFx0aWYoZ2V0X21vZHVsZS5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIHJ1bGUgPSBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXVtpXTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgPSB7fTtcclxuXHRcdFx0XHRcdFx0cnVsZSA9IHJ1bGUucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdFx0XHRcdGlmKHJ1bGUuYm9keSA9PT0gbnVsbClcclxuXHRcdFx0XHRcdFx0XHRydWxlLmJvZHkgPSBuZXcgVGVybShcInRydWVcIik7XHJcblx0XHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3J1bGUuaGVhZCwgaGVhZF0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcnVsZS5ib2R5LCBib2R5XSlcclxuXHRcdFx0XHRcdFx0XSk7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UoZ29hbCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKHN0YXRlcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwiYWNjZXNzXCIsIFwicHJpdmF0ZV9wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjdXJyZW50X3ByZWRpY2F0ZS8xXHJcblx0XHRcImN1cnJlbnRfcHJlZGljYXRlLzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgaW5kaWNhdG9yID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oaW5kaWNhdG9yKSAmJiBpbmRpY2F0b3IuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfYXRvbShpbmRpY2F0b3IuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIGluZGljYXRvci5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBpbmRpY2F0b3IuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRpbmRpY2F0b3IgPSBpbmRpY2F0b3IuYXJnc1sxXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRtb2R1bGVfaWQgPSBcInVzZXJcIjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShpbmRpY2F0b3IpICYmICghcGwudHlwZS5pc19jb21wb3VuZChpbmRpY2F0b3IpIHx8IGluZGljYXRvci5pbmRpY2F0b3IgIT09IFwiLy8yXCIpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoIFwicHJlZGljYXRlX2luZGljYXRvclwiLCBpbmRpY2F0b3IsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZSggaW5kaWNhdG9yICkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yLmFyZ3NbMF0pICYmICFwbC50eXBlLmlzX2F0b20oaW5kaWNhdG9yLmFyZ3NbMF0pKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBpbmRpY2F0b3IuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvcikgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yLmFyZ3NbMV0pICYmICFwbC50eXBlLmlzX2ludGVnZXIoaW5kaWNhdG9yLmFyZ3NbMV0pKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIGluZGljYXRvci5hcmdzWzFdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaW5kaWNhdG9yKSAmJiBwbC50eXBlLmlzX2ludGVnZXIoaW5kaWNhdG9yLmFyZ3NbMV0pICYmIGluZGljYXRvci5hcmdzWzFdLnZhbHVlIDwgMCkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5kb21haW4oXCJub3RfbGVzc190aGFuX3plcm9cIiwgaW5kaWNhdG9yLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdHZhciBnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0XHRmb3IodmFyIHByb3AgaW4gZ2V0X21vZHVsZS5ydWxlcykge1xyXG5cdFx0XHRcdFx0XHRpZighZ2V0X21vZHVsZS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0dmFyIHByZWRpY2F0ZSA9IHN0cl9pbmRpY2F0b3IocHJvcCk7XHJcblx0XHRcdFx0XHRcdHZhciBnb2FsID0gbmV3IFRlcm0oXCI9XCIsIFtwcmVkaWNhdGUsIGluZGljYXRvcl0pO1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKGdvYWwpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBjdXJyZW50X21vZHVsZS8xXHJcblx0XHRcImN1cnJlbnRfbW9kdWxlLzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShtb2R1bGVfaWQpICYmICFwbC50eXBlLmlzX2F0b20obW9kdWxlX2lkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiYXRvbVwiLCBtb2R1bGVfaWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShtb2R1bGVfaWQpKSB7XHJcblx0XHRcdFx0XHR2YXIgc3RhdGVzID0gW107XHJcblx0XHRcdFx0XHRmb3IodmFyIHByb3AgaW4gdGhyZWFkLnNlc3Npb24ubW9kdWxlcykge1xyXG5cdFx0XHRcdFx0XHRpZighdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIj1cIiwgW21vZHVsZV9pZCwgbmV3IFRlcm0ocHJvcCldKSksXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYodGhyZWFkLnNlc3Npb24ubW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShtb2R1bGVfaWQuaWQpKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHByZWRpY2F0ZV9wcm9wZXJ0eS8yXHJcblx0XHRcInByZWRpY2F0ZV9wcm9wZXJ0eS8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGhlYWQgPSBhdG9tLmFyZ3NbMF0sIHByb3BlcnR5ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgbW9kdWxlX2lkO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oaGVhZCkgJiYgaGVhZC5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKGhlYWQuYXJnc1swXSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIGhlYWQuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gaGVhZC5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGhlYWQgPSBoZWFkLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkgJiYgIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkgJiYgIXBsLnR5cGUuaXNfcHJlZGljYXRlX3Byb3BlcnR5KHByb3BlcnR5KSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5kb21haW4oXCJwcmVkaWNhdGVfcHJvcGVydHlcIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSBtb2R1bGVfaWQgPyB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0gOiB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnVzZXI7XHJcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtdO1xyXG5cdFx0XHRcdC8vIGFsbCBwcmVkaWNhdGVzXHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0Ly8gYnVpbHQtaW4gcHJlZGljYXRlcyAoYnVpbHRfaW4gKyBzdGF0aWMgKyBuYXRpdmVfY29kZSArIG1ldGFfcHJlZGljYXRlPylcclxuXHRcdFx0XHRcdGlmKCFtb2R1bGVfaWQpIHtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBwcm9wIGluIHBsLmJ1aWx0aW4ucnVsZXMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwuYnVpbHRpbi5ydWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBpbmRpY2F0b3IgPSBzdHJfaW5kaWNhdG9yKHByb3ApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBhcmdzID0gW107XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGluZGljYXRvci5hcmdzWzFdLnZhbHVlOyBpKyspXHJcblx0XHRcdFx0XHRcdFx0XHRhcmdzLnB1c2godGhyZWFkLm5leHRfZnJlZV92YXJpYWJsZSgpKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdW5pZl9oZWFkID0gbmV3IFRlcm0oaW5kaWNhdG9yLmFyZ3NbMF0uaWQsIGFyZ3MpO1xyXG5cdFx0XHRcdFx0XHRcdHZhciBjdXJyZW50X3Byb3BlcnRpZXMgPSBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInN0YXRpY1wiKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiYnVpbHRfaW5cIiksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIm5hdGl2ZV9jb2RlXCIpXHJcblx0XHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHRcdFx0XHRpZihwbC5idWlsdGluLm1ldGFfcHJlZGljYXRlcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibWV0YV9wcmVkaWNhdGVcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwbC5idWlsdGluLm1ldGFfcHJlZGljYXRlc1twcm9wXVxyXG5cdFx0XHRcdFx0XHRcdFx0XSkpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGFsbCBwcmVkaWNhdGVzLCBvbmUgcHJvcGVydHkgLyBhbGwgcHJvcGVydGllc1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjdXJyZW50X3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJvcGVydHkpIHx8IGN1cnJlbnRfcHJvcGVydGllc1tpXS5pbmRpY2F0b3IgPT09IHByb3BlcnR5LmluZGljYXRvcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwb2ludHMucHVzaChuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2hlYWQsIHVuaWZfaGVhZF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtwcm9wZXJ0eSwgY3VycmVudF9wcm9wZXJ0aWVzW2ldXSlcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Ly8gdXNlci1kZWZpbmVkIHByZWRpY2F0ZXNcclxuXHRcdFx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKSB7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgcHJvcCBpbiBnZXRfbW9kdWxlLnJ1bGVzKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIWdldF9tb2R1bGUucnVsZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaW5kaWNhdG9yID0gc3RyX2luZGljYXRvcihwcm9wKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBpbmRpY2F0b3IuYXJnc1sxXS52YWx1ZTsgaSsrKVxyXG5cdFx0XHRcdFx0XHRcdFx0YXJncy5wdXNoKHRocmVhZC5uZXh0X2ZyZWVfdmFyaWFibGUoKSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHVuaWZfaGVhZCA9IG5ldyBUZXJtKGluZGljYXRvci5hcmdzWzBdLmlkLCBhcmdzKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgY3VycmVudF9wcm9wZXJ0aWVzID0gW107XHJcblx0XHRcdFx0XHRcdFx0aWYodGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUocHJvcCwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwiZHluYW1pY1wiKSk7XHJcblx0XHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJzdGF0aWNcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGdldF9tb2R1bGUucnVsZXNbcHJvcF0gaW5zdGFuY2VvZiBGdW5jdGlvbilcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibmF0aXZlX2NvZGVcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRocmVhZC5pc19tdWx0aWZpbGVfcHJlZGljYXRlKHByb3AsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm11bHRpZmlsZVwiKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5tZXRhX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkocHJvcCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm1ldGFfcHJlZGljYXRlXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5tZXRhX3ByZWRpY2F0ZXNbcHJvcF1cclxuXHRcdFx0XHRcdFx0XHRcdF0pKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBhbGwgcHJlZGljYXRlcywgb25lIHByb3BlcnR5IC8gYWxsIHByb3BlcnRpZXNcclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY3VycmVudF9wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSB8fCBjdXJyZW50X3Byb3BlcnRpZXNbaV0uaW5kaWNhdG9yID09PSBwcm9wZXJ0eS5pbmRpY2F0b3IpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRzLnB1c2gobmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtoZWFkLCB1bmlmX2hlYWRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcHJvcGVydHksIGN1cnJlbnRfcHJvcGVydGllc1tpXV0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XSkpLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBvbmUgcHJlZGljYXRlXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBidWlsdGluID0gIW1vZHVsZV9pZCAmJiBwbC50eXBlLmlzX2J1aWx0aW4oaGVhZCk7XHJcblx0XHRcdFx0XHR2YXIgcHJlZGljYXRlID0gYnVpbHRpbiA/IHBsLmJ1aWx0aW4ucnVsZXNbaGVhZC5pbmRpY2F0b3JdIDogZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl07XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlID0gYnVpbHRpbiA/IHBsLmJ1aWx0aW4gOiBnZXRfbW9kdWxlO1xyXG5cdFx0XHRcdFx0aWYocHJlZGljYXRlKSB7XHJcblx0XHRcdFx0XHRcdHZhciBjdXJyZW50X3Byb3BlcnRpZXM7XHJcblx0XHRcdFx0XHRcdGlmKGJ1aWx0aW4pIHtcclxuXHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMgPSBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInN0YXRpY1wiKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiYnVpbHRfaW5cIiksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIm5hdGl2ZV9jb2RlXCIpXHJcblx0XHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRpZih0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgbW9kdWxlX2lkKSlcclxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwiZHluYW1pY1wiKSk7XHJcblx0XHRcdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJzdGF0aWNcIikpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHByZWRpY2F0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudF9wcm9wZXJ0aWVzLnB1c2gobmV3IFRlcm0oXCJuYXRpdmVfY29kZVwiKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYodGhyZWFkLmlzX211bHRpZmlsZV9wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50X3Byb3BlcnRpZXMucHVzaChuZXcgVGVybShcIm11bHRpZmlsZVwiKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5tZXRhX3ByZWRpY2F0ZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKVxyXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRfcHJvcGVydGllcy5wdXNoKG5ldyBUZXJtKFwibWV0YV9wcmVkaWNhdGVcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5tZXRhX3ByZWRpY2F0ZXNbaGVhZC5pbmRpY2F0b3JdXHJcblx0XHRcdFx0XHRcdFx0XSkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgYXJncyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaGVhZC5hcmdzLmxlbmd0aDsgaSsrKVxyXG5cdFx0XHRcdFx0XHRcdGFyZ3MucHVzaCh0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCkpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdW5pZl9oZWFkID0gbmV3IFRlcm0oaGVhZC5pZCwgYXJncyk7XHJcblx0XHRcdFx0XHRcdC8vIG9uZSBwcmVkaWNhdGUsIG9uZSBwcm9wZXJ0eSAvIGFsbCBwcm9wZXJ0aWVzXHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjdXJyZW50X3Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHByb3BlcnR5KSB8fCBjdXJyZW50X3Byb3BlcnRpZXNbaV0uaW5kaWNhdG9yID09PSBwcm9wZXJ0eS5pbmRpY2F0b3IpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHBvaW50cy5wdXNoKG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFtoZWFkLCB1bmlmX2hlYWRdKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3Byb3BlcnR5LCBjdXJyZW50X3Byb3BlcnRpZXNbaV1dKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRdKSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZChwb2ludHMpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGxpc3RpbmcvMFxyXG5cdFx0XCJsaXN0aW5nLzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IGF0b20uY29udGV4dF9tb2R1bGUgPyBhdG9tLmNvbnRleHRfbW9kdWxlIDogXCJ1c2VyXCI7XHJcblx0XHRcdHZhciBydWxlcyA9IHt9O1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXSkpIHtcclxuXHRcdFx0XHRydWxlcyA9IHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdLnJ1bGVzO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBzdHIgPSBcIlwiO1xyXG5cdFx0XHRmb3IodmFyIGluZGljYXRvciBpbiBydWxlcykge1xyXG5cdFx0XHRcdGlmKCFydWxlcy5oYXNPd25Qcm9wZXJ0eShpbmRpY2F0b3IpKSBjb250aW51ZTtcclxuXHRcdFx0XHR2YXIgcHJlZGljYXRlID0gcnVsZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRzdHIgKz0gXCIlIFwiICsgaW5kaWNhdG9yICsgXCJcXG5cIjtcclxuXHRcdFx0XHRpZihwcmVkaWNhdGUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByZWRpY2F0ZS5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRcdFx0c3RyICs9IHByZWRpY2F0ZVtpXS50b1N0cmluZygge3Nlc3Npb246IHRocmVhZC5zZXNzaW9ufSApICsgXCJcXG5cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyICs9IFwiLypcXG5cIiArIHByZWRpY2F0ZS50b1N0cmluZygpICsgXCJcXG4qL1wiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzdHIgKz0gXCJcXG5cIjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJ3cml0ZVwiLCBbbmV3IFRlcm0oc3RyLCBbXSldKSksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGxpc3RpbmcvMVxyXG5cdFx0XCJsaXN0aW5nLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBpbmRpY2F0b3IgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihpbmRpY2F0b3IuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBpbmRpY2F0b3IuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRpbmRpY2F0b3IgPSBpbmRpY2F0b3IuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGluZGljYXRvcikpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ByZWRpY2F0ZV9pbmRpY2F0b3IoaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJwcmVkaWNhdGVfaW5kaWNhdG9yXCIsIGluZGljYXRvciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBydWxlcyA9IHt9O1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbY29udGV4dF9tb2R1bGVdKSkge1xyXG5cdFx0XHRcdFx0cnVsZXMgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW2NvbnRleHRfbW9kdWxlXS5ydWxlcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0dmFyIHN0cl9pbmRpY2F0b3IgPSBpbmRpY2F0b3IuYXJnc1swXS5pZCArIFwiL1wiICsgaW5kaWNhdG9yLmFyZ3NbMV0udmFsdWU7XHJcblx0XHRcdFx0aWYocnVsZXMuaGFzT3duUHJvcGVydHkoc3RyX2luZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdHZhciBwcmVkaWNhdGUgPSBydWxlc1tzdHJfaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdGlmKHByZWRpY2F0ZSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcblx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVkaWNhdGUubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IHByZWRpY2F0ZVtpXS50b1N0cmluZygge3Nlc3Npb246IHRocmVhZC5zZXNzaW9ufSApICsgXCJcXG5cIjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN0ciArPSBcIi8qXFxuXCIgKyBwcmVkaWNhdGUudG9TdHJpbmcoKSArIFwiXFxuKi9cIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHN0ciArPSBcIlxcblwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgVGVybShcIndyaXRlXCIsIFtuZXcgVGVybShzdHIsIFtdKV0pKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBMSVNUIE9QRVJBVElPTlNcclxuXHJcblx0XHQvLyBzb3J0LzJcclxuXHRcdFwic29ydC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXSwgZXhwZWN0ZWQgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGV4cGVjdGVkICkgJiYgIXBsLnR5cGUuaXNfZnVsbHlfbGlzdCggZXhwZWN0ZWQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBleHBlY3RlZCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0YXJyLnB1c2goIHBvaW50ZXIuYXJnc1swXSApO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgc29ydGVkX2FyciA9IGFyci5zb3J0KCBwbC5jb21wYXJlICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gc29ydGVkX2Fyci5sZW5ndGgtMTsgaSA+IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0aWYoIHNvcnRlZF9hcnJbaV0uZXF1YWxzKHNvcnRlZF9hcnJbaS0xXSkgKVxyXG5cdFx0XHRcdFx0XHRcdHNvcnRlZF9hcnIuc3BsaWNlKGksMSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgc29ydGVkX2xpc3QgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gc29ydGVkX2Fyci5sZW5ndGgtMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdHNvcnRlZF9saXN0ID0gbmV3IFRlcm0oIFwiLlwiLCBbc29ydGVkX2FycltpXSwgc29ydGVkX2xpc3RdICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtzb3J0ZWRfbGlzdCwgZXhwZWN0ZWRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBrZXlzb3J0LzJcclxuXHRcdFwia2V5c29ydC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXSwgZXhwZWN0ZWQgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGV4cGVjdGVkICkgJiYgIXBsLnR5cGUuaXNfZnVsbHlfbGlzdCggZXhwZWN0ZWQgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBleHBlY3RlZCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBhcnIgPSBbXTtcclxuXHRcdFx0XHR2YXIgZWxlbTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0ZWxlbSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBlbGVtICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3Rlcm0oIGVsZW0gKSB8fCBlbGVtLmluZGljYXRvciAhPT0gXCItLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcInBhaXJcIiwgZWxlbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbGVtLmFyZ3NbMF0ucGFpciA9IGVsZW0uYXJnc1sxXTtcclxuXHRcdFx0XHRcdGFyci5wdXNoKCBlbGVtLmFyZ3NbMF0gKTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoZXhwZWN0ZWQpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwb2ludGVyID0gZXhwZWN0ZWQ7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBoZWFkID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpICYmICghcGwudHlwZS5pc190ZXJtKGhlYWQpIHx8IGhlYWQuaW5kaWNhdG9yICE9PSBcIi0vMlwiKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcInBhaXJcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpICYmICFwbC50eXBlLmlzX2VtcHR5X2xpc3QocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBleHBlY3RlZCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIHNvcnRlZF9hcnIgPSBhcnIuc29ydCggcGwuY29tcGFyZSApO1xyXG5cdFx0XHRcdFx0dmFyIHNvcnRlZF9saXN0ID0gbmV3IHBsLnR5cGUuVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gc29ydGVkX2Fyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcclxuXHRcdFx0XHRcdFx0c29ydGVkX2xpc3QgPSBuZXcgcGwudHlwZS5UZXJtKCBcIi5cIiwgW25ldyBwbC50eXBlLlRlcm0oIFwiLVwiLCBbc29ydGVkX2FycltpXSwgc29ydGVkX2FycltpXS5wYWlyXSApLCBzb3J0ZWRfbGlzdF0gKTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHNvcnRlZF9hcnJbaV0ucGFpcjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IHBsLnR5cGUuU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IHBsLnR5cGUuVGVybSggXCI9XCIsIFtzb3J0ZWRfbGlzdCwgZXhwZWN0ZWRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBrZXlncm91cFxyXG5cdFx0XCJrZXlncm91cC8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF0sIGV4cGVjdGVkID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGxpc3QpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGV4cGVjdGVkKSAmJiAhcGwudHlwZS5pc19mdWxseV9saXN0KGV4cGVjdGVkKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibGlzdFwiLCBleHBlY3RlZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIga2V5cyA9IFtdO1xyXG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBbXTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3RcclxuXHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdHZhciBlbGVtID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShlbGVtKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShlbGVtKSB8fCBlbGVtLmluZGljYXRvciAhPT0gXCItLzJcIikge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcInBhaXJcIiwgZWxlbSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGtleSA9IGVsZW0uYXJnc1swXSwgdmFsdWUgPSBlbGVtLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR2YXIgaW5kZXggPSAtMTtcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmKHBsLmNvbXBhcmUoa2V5LCBrZXlzW2ldKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gaTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoaW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdGluZGV4ID0ga2V5cy5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdGtleXMucHVzaChrZXkpO1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaChbXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YWx1ZXNbaW5kZXhdLnB1c2godmFsdWUpO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfZW1wdHlfbGlzdChwb2ludGVyKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGV4cGVjdGVkKSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGV4cGVjdGVkO1xyXG5cdFx0XHRcdFx0XHR3aGlsZShwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaGVhZCA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShoZWFkKSAmJiAoIXBsLnR5cGUuaXNfdGVybShoZWFkKSB8fCBoZWFkLmluZGljYXRvciAhPT0gXCItLzJcIikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwicGFpclwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHBvaW50ZXIpICYmICFwbC50eXBlLmlzX2VtcHR5X2xpc3QocG9pbnRlcikpIHtcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImxpc3RcIiwgZXhwZWN0ZWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRncm91cCA9IG5ldyBUZXJtKFwiW11cIiwgW10pO1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0ga2V5cy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pXHJcblx0XHRcdFx0XHRcdGdyb3VwID0gbmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcIi1cIiwgW2tleXNbaV0sIGFycmF5VG9MaXN0KHZhbHVlc1tpXSldKSwgZ3JvdXBdKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRcdFx0bmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZShuZXcgcGwudHlwZS5UZXJtKFwiPVwiLCBbZXhwZWN0ZWQsIGdyb3VwXSkpLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHRdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIENMQVVTRSBDUkVBVElPTiBBTkQgREVTVFJVQ1RJT05cclxuXHRcdFxyXG5cdFx0Ly8gYXNzZXJ0YS8xXHJcblx0XHRcImFzc2VydGEvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBjbGF1c2UgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGNsYXVzZSkgJiYgY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IGNsYXVzZS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdGNsYXVzZSA9IGNsYXVzZS5hcmdzWzFdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19jYWxsYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBjbGF1c2UsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGhlYWQsIGJvZHksIGdldF9tb2R1bGU7XHJcblx0XHRcdFx0aWYoY2xhdXNlLmluZGljYXRvciA9PT0gXCI6LS8yXCIpIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2UuYXJnc1swXTtcclxuXHRcdFx0XHRcdGJvZHkgPSBib2R5X2NvbnZlcnNpb24oY2xhdXNlLmFyZ3NbMV0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlO1xyXG5cdFx0XHRcdFx0Ym9keSA9IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5pbnN0YW50aWF0aW9uKGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGhlYWQsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKGJvZHkgIT09IG51bGwgJiYgIXBsLnR5cGUuaXNfY2FsbGFibGUoYm9keSkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGJvZHksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCghcGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdKVxyXG5cdFx0XHRcdHx8IHRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBtb2R1bGVfaWQpKVxyXG5cdFx0XHRcdCYmIGhlYWQuaW5kaWNhdG9yICE9PSBcIiwvMlwiXHJcblx0XHRcdFx0JiYgIXRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGhlYWQuaW5kaWNhdG9yKSkge1xyXG5cdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSkpIHtcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZSA9IG5ldyBNb2R1bGUobW9kdWxlX2lkLCB7fSwgXCJhbGxcIiwge3Nlc3Npb246IHRocmVhZC5zZXNzaW9ufSk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLm1vZHVsZXNbbW9kdWxlX2lkXSA9IGdldF9tb2R1bGU7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlID0gdGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPT09IHVuZGVmaW5lZClcclxuXHRcdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPSBbXTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucHVibGljX3ByZWRpY2F0ZXNbaGVhZC5pbmRpY2F0b3JdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGdldF9tb2R1bGUucnVsZXNbaGVhZC5pbmRpY2F0b3JdID0gW25ldyBSdWxlKGhlYWQsIGJvZHksIHRydWUpXS5jb25jYXQoZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0pO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS51cGRhdGVfaW5kaWNlc19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IpO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MocG9pbnQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhc3NlcnR6LzFcclxuXHRcdFwiYXNzZXJ0ei8xXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGNsYXVzZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIG1vZHVsZV9pZCA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oY2xhdXNlKSAmJiBjbGF1c2UuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gY2xhdXNlLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0Y2xhdXNlID0gY2xhdXNlLmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShjbGF1c2UpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImNhbGxhYmxlXCIsIGNsYXVzZSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaGVhZCwgYm9keSwgZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRpZihjbGF1c2UuaW5kaWNhdG9yID09PSBcIjotLzJcIikge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0Ym9keSA9IGJvZHlfY29udmVyc2lvbihjbGF1c2UuYXJnc1sxXSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGhlYWQgPSBjbGF1c2U7XHJcblx0XHRcdFx0XHRib2R5ID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoYm9keSAhPT0gbnVsbCAmJiAhcGwudHlwZS5pc19jYWxsYWJsZShib2R5KSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgYm9keSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoKCFwbC50eXBlLmlzX21vZHVsZSh0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF0pXHJcblx0XHRcdFx0fHwgdGhyZWFkLmlzX3B1YmxpY19wcmVkaWNhdGUoaGVhZC5pbmRpY2F0b3IsIG1vZHVsZV9pZCkpXHJcblx0XHRcdFx0JiYgaGVhZC5pbmRpY2F0b3IgIT09IFwiLC8yXCJcclxuXHRcdFx0XHQmJiAhdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc19tb2R1bGUodGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdKSkge1xyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlID0gbmV3IE1vZHVsZShtb2R1bGVfaWQsIHt9LCBcImFsbFwiLCB7c2Vzc2lvbjogdGhyZWFkLnNlc3Npb259KTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24ubW9kdWxlc1ttb2R1bGVfaWRdID0gZ2V0X21vZHVsZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9PT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdFx0XHRnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXSA9IFtdO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1toZWFkLmluZGljYXRvcl0gPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0ucHVzaChuZXcgUnVsZShoZWFkLCBib2R5LCB0cnVlKSk7XHJcblx0XHRcdFx0XHRnZXRfbW9kdWxlLnVwZGF0ZV9pbmRpY2VzX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvcik7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5wZXJtaXNzaW9uKFwibW9kaWZ5XCIsIFwic3RhdGljX3Byb2NlZHVyZVwiLCBzdHJfaW5kaWNhdG9yKGhlYWQuaW5kaWNhdG9yKSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHJldHJhY3QvMVxyXG5cdFx0XCJyZXRyYWN0LzFcIjogZnVuY3Rpb24odGhyZWFkLCBwb2ludCwgYXRvbSkge1xyXG5cdFx0XHR2YXIgY2xhdXNlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGNsYXVzZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoY2xhdXNlKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgY2xhdXNlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBoZWFkLCBib2R5LCBtb2R1bGVfYXRvbSwgbW9kdWxlX2lkO1xyXG5cdFx0XHRcdGlmKGNsYXVzZS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRcdG1vZHVsZV9hdG9tID0gY2xhdXNlLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRjbGF1c2UgPSBjbGF1c2UuYXJnc1sxXTtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX2F0b20obW9kdWxlX2F0b20pKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibW9kdWxlXCIsIG1vZHVsZV9hdG9tLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdG1vZHVsZV9hdG9tID0gbmV3IFRlcm0oXCJ1c2VyXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihjbGF1c2UuaW5kaWNhdG9yID09PSBcIjotLzJcIikge1xyXG5cdFx0XHRcdFx0aGVhZCA9IGNsYXVzZS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0Ym9keSA9IGNsYXVzZS5hcmdzWzFdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRoZWFkID0gY2xhdXNlO1xyXG5cdFx0XHRcdFx0Ym9keSA9IG5ldyBUZXJtKFwidHJ1ZVwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShoZWFkKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfY2FsbGFibGUoaGVhZCkpIHtcclxuXHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiY2FsbGFibGVcIiwgaGVhZCwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bW9kdWxlX2lkID0gbW9kdWxlX2F0b20uaWQ7XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfbW9kdWxlKGdldF9tb2R1bGUpKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdGlmKCFwb2ludC5yZXRyYWN0KSB7XHJcblx0XHRcdFx0XHRpZih0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShoZWFkLmluZGljYXRvciwgbW9kdWxlX2lkKVxyXG5cdFx0XHRcdFx0JiYgaGVhZC5pbmRpY2F0b3IgIT09IFwiLC8yXCJcclxuXHRcdFx0XHRcdCYmICF0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzLnN5c3RlbS5ydWxlcy5oYXNPd25Qcm9wZXJ0eShoZWFkLmluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdFx0aWYoZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0gPT09IFwiZnVuY3Rpb25cIikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZ2V0X21vZHVsZS5ydWxlc1toZWFkLmluZGljYXRvcl0ubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgb3J1bGUgPSBnZXRfbW9kdWxlLnJ1bGVzW2hlYWQuaW5kaWNhdG9yXVtpXTtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBydWxlID0gb3J1bGUucmVuYW1lKHRocmVhZCk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihydWxlLmJvZHkgPT09IG51bGwpXHJcblx0XHRcdFx0XHRcdFx0XHRcdHJ1bGUuYm9keSA9IG5ldyBUZXJtKFwidHJ1ZVwiLCBbXSk7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgb2NjdXJzX2NoZWNrID0gdGhyZWFkLmdldF9mbGFnKFwib2NjdXJzX2NoZWNrXCIpLmluZGljYXRvciA9PT0gXCJ0cnVlLzBcIjtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBtZ3UgPSBwbC51bmlmeShuZXcgVGVybShcIixcIiwgW2hlYWQsIGJvZHldKSwgbmV3IFRlcm0oXCIsXCIsIFtydWxlLmhlYWQsIHJ1bGUuYm9keV0pLCBvY2N1cnNfY2hlY2spO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYobWd1ICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBzdGF0ZSA9IG5ldyBTdGF0ZShcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiOlwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vZHVsZV9hdG9tLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcInJldHJhY3RcIiwgW25ldyBUZXJtKFwiOi1cIiwgW2hlYWQsIGJvZHldKV0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIixcIiwgW1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2hlYWQsIHJ1bGUuaGVhZF0pLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW2JvZHksIHJ1bGUuYm9keV0pXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdF0pKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHN0YXRlLnJldHJhY3QgPSBvcnVsZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0c3RhdGVzLnB1c2goc3RhdGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZChzdGF0ZXMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgc3RyX2luZGljYXRvcihoZWFkLmluZGljYXRvciksIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJldHJhY3QodGhyZWFkLCBwb2ludCwgaGVhZC5pbmRpY2F0b3IsIHBvaW50LnJldHJhY3QsIGdldF9tb2R1bGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gcmV0cmFjdGFsbC8xXHJcblx0XHRcInJldHJhY3RhbGwvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBoZWFkID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYocGwudHlwZS5pc190ZXJtKGhlYWQpICYmIGhlYWQuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBoZWFkLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0aGVhZCA9IGhlYWQuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2NhbGxhYmxlKGhlYWQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjYWxsYWJsZVwiLCBoZWFkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXRocmVhZC5pc19wdWJsaWNfcHJlZGljYXRlKGhlYWQuaW5kaWNhdG9yLCBjb250ZXh0X21vZHVsZSlcclxuXHRcdFx0fHwgaGVhZC5pbmRpY2F0b3IgPT09IFwiLC8yXCJcclxuXHRcdFx0fHwgdGhyZWFkLnNlc3Npb24ubW9kdWxlcy5zeXN0ZW0ucnVsZXMuaGFzT3duUHJvcGVydHkoaGVhZC5pbmRpY2F0b3IpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnBlcm1pc3Npb24oXCJtb2RpZnlcIiwgXCJzdGF0aWNfcHJvY2VkdXJlXCIsIHN0cl9pbmRpY2F0b3IoaGVhZC5pbmRpY2F0b3IpLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKFtcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI6XCIsIFtcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShjb250ZXh0X21vZHVsZSksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJyZXRyYWN0XCIsIFtuZXcgcGwudHlwZS5UZXJtKFwiOi1cIiwgW2hlYWQsIG5ldyBWYXIoXCJfXCIpXSldKVxyXG5cdFx0XHRcdFx0XHRdKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJmYWlsXCIsIFtdKVxyXG5cdFx0XHRcdFx0XSkpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSxcclxuXHRcdFx0XHRcdG5ldyBTdGF0ZShwb2ludC5nb2FsLnJlcGxhY2UobnVsbCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpXHJcblx0XHRcdFx0XSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gYWJvbGlzaC8xXHJcblx0XHRcImFib2xpc2gvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBwcmVkaWNhdGUgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBtb2R1bGVfaWQ7XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdGVybShwcmVkaWNhdGUpICYmIHByZWRpY2F0ZS5pbmRpY2F0b3IgPT09IFwiOi8yXCIpIHtcclxuXHRcdFx0XHRpZighcGwudHlwZS5pc19hdG9tKHByZWRpY2F0ZS5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJtb2R1bGVcIiwgcHJlZGljYXRlLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IHByZWRpY2F0ZS5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdHByZWRpY2F0ZSA9IHByZWRpY2F0ZS5hcmdzWzFdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG1vZHVsZV9pZCA9IFwidXNlclwiO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocHJlZGljYXRlKSB8fCBwbC50eXBlLmlzX3Rlcm0ocHJlZGljYXRlKSAmJiBwcmVkaWNhdGUuaW5kaWNhdG9yID09PSBcIi8vMlwiXHJcblx0XHRcdCYmIChwbC50eXBlLmlzX3ZhcmlhYmxlKHByZWRpY2F0ZS5hcmdzWzBdKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKHByZWRpY2F0ZS5hcmdzWzFdKSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuaW5zdGFudGlhdGlvbihhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdGVybShwcmVkaWNhdGUpIHx8IHByZWRpY2F0ZS5pbmRpY2F0b3IgIT09IFwiLy8yXCIpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcInByZWRpY2F0ZV9pbmRpY2F0b3JcIiwgcHJlZGljYXRlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfYXRvbShwcmVkaWNhdGUuYXJnc1swXSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IudHlwZShcImF0b21cIiwgcHJlZGljYXRlLmFyZ3NbMF0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19pbnRlZ2VyKHByZWRpY2F0ZS5hcmdzWzFdKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwiaW50ZWdlclwiLCBwcmVkaWNhdGUuYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKHByZWRpY2F0ZS5hcmdzWzFdLnZhbHVlIDwgMCkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci5kb21haW4oXCJub3RfbGVzc190aGFuX3plcm9cIiwgcHJlZGljYXRlLmFyZ3NbMV0sIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZihwbC50eXBlLmlzX251bWJlcih0aHJlYWQuZ2V0X2ZsYWcoXCJtYXhfYXJpdHlcIikpICYmIHByZWRpY2F0ZS5hcmdzWzFdLnZhbHVlID4gdGhyZWFkLmdldF9mbGFnKFwibWF4X2FyaXR5XCIpLnZhbHVlKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKFwibWF4X2FyaXR5XCIsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdldF9tb2R1bGUgPSB0aHJlYWQuc2Vzc2lvbi5tb2R1bGVzW21vZHVsZV9pZF07XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc19tb2R1bGUoZ2V0X21vZHVsZSkpIHtcclxuXHRcdFx0XHRcdHZhciBpbmRpY2F0b3IgPSBwcmVkaWNhdGUuYXJnc1swXS5pZCArIFwiL1wiICsgcHJlZGljYXRlLmFyZ3NbMV0udmFsdWU7XHJcblx0XHRcdFx0XHRpZih0aHJlYWQuaXNfcHVibGljX3ByZWRpY2F0ZShpbmRpY2F0b3IsIG1vZHVsZV9pZClcclxuXHRcdFx0XHRcdCYmIGluZGljYXRvciAhPT0gXCIsLzJcIlxyXG5cdFx0XHRcdFx0JiYgIXRocmVhZC5zZXNzaW9uLm1vZHVsZXMuc3lzdGVtLnJ1bGVzLmhhc093blByb3BlcnR5KGluZGljYXRvcikpIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdldF9tb2R1bGUucnVsZXNbaW5kaWNhdG9yXTtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIGdldF9tb2R1bGUuaW5kZXhlZF9jbGF1c2VzW2luZGljYXRvcl07XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBnZXRfbW9kdWxlLm5vbl9pbmRleGFibGVfY2xhdXNlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2V0X21vZHVsZS5wdWJsaWNfcHJlZGljYXRlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgZ2V0X21vZHVsZS5tdWx0aWZpbGVfcHJlZGljYXRlc1tpbmRpY2F0b3JdO1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IucGVybWlzc2lvbihcIm1vZGlmeVwiLCBcInN0YXRpY19wcm9jZWR1cmVcIiwgYXRvbS5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBBVE9NIFBST0NFU1NJTkdcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbV9sZW5ndGgvMlxyXG5cdFx0XCJhdG9tX2xlbmd0aC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbS5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1sxXSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGF0b20uYXJnc1sxXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGF0b20uYXJnc1sxXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggYXRvbS5hcmdzWzFdICkgJiYgYXRvbS5hcmdzWzFdLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgYXRvbS5hcmdzWzFdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGxlbmd0aCA9IG5ldyBOdW0oIHN0cmluZ0xlbmd0aChhdG9tLmFyZ3NbMF0uaWQpLCBmYWxzZSApO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xlbmd0aCwgYXRvbS5hcmdzWzFdXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbV9jb25jYXQvM1xyXG5cdFx0XCJhdG9tX2NvbmNhdC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyLCBnb2FsLCBzdGFydCA9IGF0b20uYXJnc1swXSwgZW5kID0gYXRvbS5hcmdzWzFdLCB3aG9sZSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHdob2xlICkgJiYgKHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0YXJ0ICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggZW5kICkpICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdGFydCApICYmICFwbC50eXBlLmlzX2F0b20oIHN0YXJ0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgc3RhcnQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZW5kICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggZW5kICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgZW5kLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHdob2xlICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggd2hvbGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCB3aG9sZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciB2MSA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0YXJ0ICk7XHJcblx0XHRcdFx0dmFyIHYyID0gcGwudHlwZS5pc192YXJpYWJsZSggZW5kICk7XHJcblx0XHRcdFx0Ly92YXIgdjMgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCB3aG9sZSApO1xyXG5cdFx0XHRcdGlmKCAhdjEgJiYgIXYyICkge1xyXG5cdFx0XHRcdFx0Z29hbCA9IG5ldyBUZXJtKCBcIj1cIiwgW3dob2xlLCBuZXcgVGVybSggc3RhcnQuaWQgKyBlbmQuaWQgKV0gKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiggdjEgJiYgIXYyICkge1xyXG5cdFx0XHRcdFx0c3RyID0gd2hvbGUuaWQuc3Vic3RyKCAwLCB3aG9sZS5pZC5sZW5ndGggLSBlbmQuaWQubGVuZ3RoICk7XHJcblx0XHRcdFx0XHRpZiggc3RyICsgZW5kLmlkID09PSB3aG9sZS5pZCApIHtcclxuXHRcdFx0XHRcdFx0Z29hbCA9IG5ldyBUZXJtKCBcIj1cIiwgW3N0YXJ0LCBuZXcgVGVybSggc3RyICldICk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiggdjIgJiYgIXYxICkge1xyXG5cdFx0XHRcdFx0c3RyID0gd2hvbGUuaWQuc3Vic3RyKCBzdGFydC5pZC5sZW5ndGggKTtcclxuXHRcdFx0XHRcdGlmKCBzdGFydC5pZCArIHN0ciA9PT0gd2hvbGUuaWQgKSB7XHJcblx0XHRcdFx0XHRcdGdvYWwgPSBuZXcgVGVybSggXCI9XCIsIFtlbmQsIG5ldyBUZXJtKCBzdHIgKV0gKTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSAwOyBpIDw9IHdob2xlLmlkLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHR2YXIgYXRvbTEgPSBuZXcgVGVybSggd2hvbGUuaWQuc3Vic3RyKCAwLCBpICkgKTtcclxuXHRcdFx0XHRcdFx0dmFyIGF0b20yID0gbmV3IFRlcm0oIHdob2xlLmlkLnN1YnN0ciggaSApICk7XHJcblx0XHRcdFx0XHRcdGdvYWwgPSBuZXcgVGVybSggXCIsXCIsIFtuZXcgVGVybSggXCI9XCIsIFthdG9tMSwgc3RhcnRdICksIG5ldyBUZXJtKCBcIj1cIiwgW2F0b20yLCBlbmRdICldICk7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggZ29hbCApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICkgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHN1Yl9hdG9tLzVcclxuXHRcdFwic3ViX2F0b20vNVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGksIGF0b20xID0gYXRvbS5hcmdzWzBdLCBiZWZvcmUgPSBhdG9tLmFyZ3NbMV0sIGxlbmd0aCA9IGF0b20uYXJnc1syXSwgYWZ0ZXIgPSBhdG9tLmFyZ3NbM10sIHN1YmF0b20gPSBhdG9tLmFyZ3NbNF07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGF0b20xICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbTEsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYmVmb3JlICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggYmVmb3JlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYmVmb3JlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxlbmd0aCApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGxlbmd0aCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGxlbmd0aCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhZnRlciApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGFmdGVyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYWZ0ZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGJlZm9yZSApICYmIGJlZm9yZS52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIGJlZm9yZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggbGVuZ3RoICkgJiYgbGVuZ3RoLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgbGVuZ3RoLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggcGwudHlwZS5pc19pbnRlZ2VyKCBhZnRlciApICYmIGFmdGVyLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgYWZ0ZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3ViYXRvbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN1YmF0b20gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBzdWJhdG9tLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGJzID0gW10sIGxzID0gW10sIGFzID0gW107XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGJlZm9yZSApICkge1xyXG5cdFx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8PSBhdG9tMS5pZC5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0YnMucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRicy5wdXNoKCBiZWZvcmUudmFsdWUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxlbmd0aCApICkge1xyXG5cdFx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8PSBhdG9tMS5pZC5sZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0bHMucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRscy5wdXNoKCBsZW5ndGgudmFsdWUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGFmdGVyICkgKSB7XHJcblx0XHRcdFx0XHRmb3IoIGkgPSAwOyBpIDw9IGF0b20xLmlkLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0XHRhcy5wdXNoKCBpICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFzLnB1c2goIGFmdGVyLnZhbHVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IoIHZhciBfaSBpbiBicyApIHtcclxuXHRcdFx0XHRcdGlmKCFicy5oYXNPd25Qcm9wZXJ0eShfaSkpIGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0aSA9IGJzW19pXTtcclxuXHRcdFx0XHRcdGZvciggdmFyIF9qIGluIGxzICkge1xyXG5cdFx0XHRcdFx0XHRpZighbHMuaGFzT3duUHJvcGVydHkoX2opKSBjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0dmFyIGogPSBsc1tfal07XHJcblx0XHRcdFx0XHRcdHZhciBrID0gYXRvbTEuaWQubGVuZ3RoIC0gaSAtIGo7XHJcblx0XHRcdFx0XHRcdGlmKCBpbmRleE9mKCBhcywgayApICE9PSAtMSApIHtcclxuXHRcdFx0XHRcdFx0aWYoIGkraitrID09PSBhdG9tMS5pZC5sZW5ndGggKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgc3RyID0gYXRvbTEuaWQuc3Vic3RyKCBpLCBqICk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiggYXRvbTEuaWQgPT09IGF0b20xLmlkLnN1YnN0ciggMCwgaSApICsgc3RyICsgYXRvbTEuaWQuc3Vic3RyKCBpK2osIGsgKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHBsMSA9IG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBzdHIgKSwgc3ViYXRvbV0gKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHBsMiA9IG5ldyBUZXJtKCBcIj1cIiwgW2JlZm9yZSwgbmV3IE51bSggaSApXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGwzID0gbmV3IFRlcm0oIFwiPVwiLCBbbGVuZ3RoLCBuZXcgTnVtKCBqICldICk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwbDQgPSBuZXcgVGVybSggXCI9XCIsIFthZnRlciwgbmV3IE51bSggayApXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKCBcIixcIiwgWyBuZXcgVGVybSggXCIsXCIsIFsgbmV3IFRlcm0oIFwiLFwiLCBbcGwyLCBwbDNdICksIHBsNF0gKSwgcGwxXSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZXMucHVzaCggbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApICk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbV9jaGFycy8yXHJcblx0XHRcImF0b21fY2hhcnMvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGF0b20xID0gYXRvbS5hcmdzWzBdLCBsaXN0ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBhdG9tMSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYXRvbTEgKSApIHtcclxuXHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKGxpc3QpKSB7XHJcblx0XHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdFx0d2hpbGUocGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBsLnR5cGUuaXNfY2hhcmFjdGVyKHBvaW50ZXIuYXJnc1swXSkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlci5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJjaGFyYWN0ZXJcIiwgcG9pbnRlci5hcmdzWzBdLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR2YXIgbGlzdDEgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHR2YXIgdW5pbGVuID0gc3RyaW5nTGVuZ3RoKGF0b20xLmlkKTtcclxuXHRcdFx0XHRcdGZvciggdmFyIGkgPSB1bmlsZW4tMTsgaSA+PSAwOyBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGxpc3QxID0gbmV3IFRlcm0oIFwiLlwiLCBbbmV3IFRlcm0oIGF0b20xLmlkLmNoYXJBdCggaSApICksIGxpc3QxXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbGlzdCwgbGlzdDFdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0XHJcblx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHR2YXIgdiA9IHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICk7XHJcblx0XHRcdFx0XHR2YXIgc3RyID0gXCJcIjtcclxuXHRcdFx0XHRcdHdoaWxlKCBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2NoYXJhY3RlciggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICYmIHYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJjaGFyYWN0ZXJcIiwgcG9pbnRlci5hcmdzWzBdLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHN0ciArPSBwb2ludGVyLmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgJiYgdiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggc3RyICksIGF0b20xXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21fY29kZXMvMlxyXG5cdFx0XCJhdG9tX2NvZGVzLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBhdG9tMSA9IGF0b20uYXJnc1swXSwgbGlzdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApICYmICFwbC50eXBlLmlzX2F0b20oIGF0b20xICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgYXRvbTEsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20xICkgKSB7XHJcblx0XHRcdFx0XHRpZighcGwudHlwZS5pc192YXJpYWJsZShsaXN0KSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0XHRcdHdoaWxlKHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIikge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCFwbC50eXBlLmlzX2NoYXJhY3Rlcl9jb2RlKHBvaW50ZXIuYXJnc1swXSkgJiYgIXBsLnR5cGUuaXNfdmFyaWFibGUocG9pbnRlci5hcmdzWzBdKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIHBvaW50ZXIuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGxpc3QxID0gbmV3IFRlcm0oIFwiW11cIiApO1xyXG5cdFx0XHRcdFx0dmFyIHVuaWxlbiA9IHN0cmluZ0xlbmd0aChhdG9tMS5pZCk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gdW5pbGVuLTE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0MSA9IG5ldyBUZXJtKCBcIi5cIiwgW25ldyBOdW0oIGNvZGVQb2ludEF0KGF0b20xLmlkLGkpLCBmYWxzZSApLCBsaXN0MV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xpc3QsIGxpc3QxXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdFxyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0dmFyIHYgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9tMSApO1xyXG5cdFx0XHRcdFx0dmFyIHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXJfY29kZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICYmIHYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gZnJvbUNvZGVQb2ludCggcG9pbnRlci5hcmdzWzBdLnZhbHVlICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgJiYgdiApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgVGVybSggc3RyICksIGF0b20xXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNoYXJfY29kZS8yXHJcblx0XHRcImNoYXJfY29kZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY2hhciA9IGF0b20uYXJnc1swXSwgY29kZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGNoYXIgKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNoYXIgKSAmJiAhcGwudHlwZS5pc19jaGFyYWN0ZXIoIGNoYXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2hhcmFjdGVyXCIsIGNoYXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29kZSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIGNvZGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBjb2RlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19jaGFyYWN0ZXJfY29kZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0XHR2YXIgY29kZTEgPSBuZXcgTnVtKCBjb2RlUG9pbnRBdChjaGFyLmlkLDAgKSwgZmFsc2UgKTtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2NvZGUxLCBjb2RlXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGNoYXIxID0gbmV3IFRlcm0oIGZyb21Db2RlUG9pbnQoIGNvZGUudmFsdWUgKSApO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbY2hhcjEsIGNoYXJdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gbnVtYmVyX2NoYXJzLzJcclxuXHRcdFwibnVtYmVyX2NoYXJzLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHIsIG51bSA9IGF0b20uYXJnc1swXSwgbGlzdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApICYmIHBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbnVtICkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKCBudW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibnVtYmVyXCIsIG51bSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgJiYgIXBsLnR5cGUuaXNfbGlzdCggbGlzdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIGxpc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgaXN2YXIgPSBwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKTtcclxuXHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSApIHtcdFxyXG5cdFx0XHRcdFx0dmFyIHBvaW50ZXIgPSBsaXN0O1xyXG5cdFx0XHRcdFx0dmFyIHRvdGFsID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHN0ciA9IFwiXCI7XHJcblx0XHRcdFx0XHR3aGlsZSggcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXIoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRvdGFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2hhcmFjdGVyXCIsIHBvaW50ZXIuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gcG9pbnRlci5hcmdzWzBdLmlkO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0b3RhbCA9IHRvdGFsICYmIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApO1xyXG5cdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCAhdG90YWwgJiYgaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHRvdGFsICkge1xyXG5cdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICYmIGlzdmFyICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZXhwciA9IHRocmVhZC5wYXJzZSggc3RyICk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG51bTIgPSBleHByLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIG51bTIgKSB8fCBleHByLnRva2Vuc1tleHByLnRva2Vucy5sZW5ndGgtMV0uc3BhY2UgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnN5bnRheF9ieV9wcmVkaWNhdGUoIFwicGFyc2VhYmxlX251bWJlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW251bSwgbnVtMl0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggIWlzdmFyICkge1xyXG5cdFx0XHRcdFx0c3RyID0gbnVtLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0XHR2YXIgbGlzdDIgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0MiA9IG5ldyBUZXJtKCBcIi5cIiwgWyBuZXcgVGVybSggc3RyLmNoYXJBdCggaSApICksIGxpc3QyIF0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xpc3QsIGxpc3QyXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIG51bWJlcl9jb2Rlcy8yXHJcblx0XHRcIm51bWJlcl9jb2Rlcy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyLCBudW0gPSBhdG9tLmFyZ3NbMF0sIGxpc3QgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBudW0gKSAmJiBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG51bSApICYmICFwbC50eXBlLmlzX251bWJlciggbnVtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcIm51bWJlclwiLCBudW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbGlzdCApICYmICFwbC50eXBlLmlzX2xpc3QoIGxpc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGlzdmFyID0gcGwudHlwZS5pc192YXJpYWJsZSggbnVtICk7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgKSB7XHRcclxuXHRcdFx0XHRcdHZhciBwb2ludGVyID0gbGlzdDtcclxuXHRcdFx0XHRcdHZhciB0b3RhbCA9IHRydWU7XHJcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xyXG5cdFx0XHRcdFx0d2hpbGUoIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0XHRpZiggIXBsLnR5cGUuaXNfY2hhcmFjdGVyX2NvZGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRvdGFsID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlci5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3Rlcl9jb2RlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyICs9IGZyb21Db2RlUG9pbnQoIHBvaW50ZXIuYXJnc1swXS52YWx1ZSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0b3RhbCA9IHRvdGFsICYmIHBsLnR5cGUuaXNfZW1wdHlfbGlzdCggcG9pbnRlciApO1xyXG5cdFx0XHRcdFx0aWYoICFwbC50eXBlLmlzX2VtcHR5X2xpc3QoIHBvaW50ZXIgKSAmJiAhcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCAhdG90YWwgJiYgaXN2YXIgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIHRvdGFsICkge1xyXG5cdFx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApICYmIGlzdmFyICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgZXhwciA9IHRocmVhZC5wYXJzZSggc3RyICk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG51bTIgPSBleHByLnZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGlmKCAhcGwudHlwZS5pc19udW1iZXIoIG51bTIgKSB8fCBleHByLnRva2Vuc1tleHByLnRva2Vucy5sZW5ndGgtMV0uc3BhY2UgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnN5bnRheF9ieV9wcmVkaWNhdGUoIFwicGFyc2VhYmxlX251bWJlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW251bSwgbnVtMl0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggIWlzdmFyICkge1xyXG5cdFx0XHRcdFx0c3RyID0gbnVtLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0XHR2YXIgbGlzdDIgPSBuZXcgVGVybSggXCJbXVwiICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBpID0gc3RyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xyXG5cdFx0XHRcdFx0XHRsaXN0MiA9IG5ldyBUZXJtKCBcIi5cIiwgWyBuZXcgTnVtKCBjb2RlUG9pbnRBdChzdHIsaSksIGZhbHNlICksIGxpc3QyIF0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2xpc3QsIGxpc3QyXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIHVwY2FzZV9hdG9tLzJcclxuXHRcdFwidXBjYXNlX2F0b20vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG9yaWdpbmFsID0gYXRvbS5hcmdzWzBdLCB1cGNhc2UgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcmlnaW5hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIG9yaWdpbmFsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3JpZ2luYWwsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggdXBjYXNlICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggdXBjYXNlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgdXBjYXNlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbdXBjYXNlLCBuZXcgVGVybSggb3JpZ2luYWwuaWQudG9VcHBlckNhc2UoKSwgW10gKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGRvd25jYXNlX2F0b20vMlxyXG5cdFx0XCJkb3duY2FzZV9hdG9tLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBvcmlnaW5hbCA9IGF0b20uYXJnc1swXSwgZG93bmNhc2UgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcmlnaW5hbCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIG9yaWdpbmFsICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgb3JpZ2luYWwsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZG93bmNhc2UgKSAmJiAhcGwudHlwZS5pc19hdG9tKCBkb3duY2FzZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGRvd25jYXNlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbZG93bmNhc2UsIG5ldyBUZXJtKCBvcmlnaW5hbC5pZC50b0xvd2VyQ2FzZSgpLCBbXSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gYXRvbWljX2NvbmNhdC8zXHJcblx0XHRcImF0b21pY19jb25jYXQvM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGF0b21pYzEgPSBhdG9tLmFyZ3NbMF0sIGF0b21pYzIgPSBhdG9tLmFyZ3NbMV0sIGNvbmNhdCA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b21pYzEgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBhdG9taWMyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbWljKCBhdG9taWMxICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBhdG9taWMxLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbWljKCBhdG9taWMyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBhdG9taWMyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvbmNhdCApICYmICFwbC50eXBlLmlzX2F0b20oIGNvbmNhdCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIGNvbmNhdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBpZCA9IFwiXCI7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbSggYXRvbWljMSApICkge1xyXG5cdFx0XHRcdFx0aWQgKz0gYXRvbWljMS5pZDtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWQgKz0gXCJcIiArIGF0b21pYzEudmFsdWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b20oIGF0b21pYzIgKSApIHtcclxuXHRcdFx0XHRcdGlkICs9IGF0b21pYzIuaWQ7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlkICs9IFwiXCIgKyBhdG9taWMyLnZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgYXRvbSA9IG5ldyBUZXJtKGlkLCBbXSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbYXRvbSwgY29uY2F0XSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBhdG9taWNfbGlzdF9jb25jYXQvMlxyXG5cdFx0XCJhdG9taWNfbGlzdF9jb25jYXQvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF0sIGNvbmNhdCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiYXRvbWljX2xpc3RfY29uY2F0XCIsIFtsaXN0LCBuZXcgVGVybSggXCJcIiwgW10gKSwgY29uY2F0XSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b21pY19saXN0X2NvbmNhdC8zXHJcblx0XHRcImF0b21pY19saXN0X2NvbmNhdC8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IGF0b20uYXJnc1swXSwgc2VwYXJhdG9yID0gYXRvbS5hcmdzWzFdLCBjb25jYXQgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzZXBhcmF0b3IgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsaXN0ICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggY29uY2F0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGxpc3QgKSAmJiAhcGwudHlwZS5pc19saXN0KCBsaXN0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgbGlzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIHNlcGFyYXRvciApICYmICFwbC50eXBlLmlzX251bWJlciggc2VwYXJhdG9yICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21pY1wiLCBzZXBhcmF0b3IsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY29uY2F0ICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggY29uY2F0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImF0b21cIiwgY29uY2F0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGlkID0gXCJcIjtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IGxpc3Q7XHJcblx0XHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybSggcG9pbnRlciApICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19hdG9tKCBwb2ludGVyLmFyZ3NbMF0gKSAmJiAhcGwudHlwZS5pc19udW1iZXIoIHBvaW50ZXIuYXJnc1swXSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbWljXCIsIHBvaW50ZXIuYXJnc1swXSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggaWQgIT09IFwiXCIgKVxyXG5cdFx0XHRcdFx0XHRpZCArPSBzZXBhcmF0b3IuaWQ7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc19hdG9tKCBwb2ludGVyLmFyZ3NbMF0gKSApXHJcblx0XHRcdFx0XHRcdGlkICs9IHBvaW50ZXIuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0aWQgKz0gXCJcIiArIHBvaW50ZXIuYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlkID0gbmV3IFRlcm0oIGlkLCBbXSApO1xyXG5cdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3Rlcm0oIHBvaW50ZXIgKSB8fCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBsaXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW2lkLCBjb25jYXRdICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVEVSTSBDT01QQVJJU09OXHJcblx0XHRcclxuXHRcdFwiQD08LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApIDw9IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiPT0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLmNvbXBhcmUoIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICkgPT09IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiXFxcXD09LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApICE9PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHRcIkA8LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0XCJAPi8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwuY29tcGFyZSggYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKSA+IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiQD49LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC5jb21wYXJlKCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApID49IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdFwiY29tcGFyZS8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb3JkZXIgPSBhdG9tLmFyZ3NbMF0sIGxlZnQgPSBhdG9tLmFyZ3NbMV0sIHJpZ2h0ID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG9yZGVyICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggb3JkZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBvcmRlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfYXRvbSggb3JkZXIgKSAmJiBbXCI8XCIsIFwiPlwiLCBcIj1cIl0uaW5kZXhPZiggb3JkZXIuaWQgKSA9PT0gLTEgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwib3JkZXJcIiwgb3JkZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgY29tcGFyZSA9IHBsLmNvbXBhcmUoIGxlZnQsIHJpZ2h0ICk7XHJcblx0XHRcdFx0Y29tcGFyZSA9IGNvbXBhcmUgPT09IDAgPyBcIj1cIiA6IChjb21wYXJlID09PSAtMSA/IFwiPFwiIDogXCI+XCIpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW29yZGVyLCBuZXcgVGVybSggY29tcGFyZSwgW10gKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIEVWQUxVQVRJT05cclxuXHRcdFxyXG5cdFx0Ly8gaXMvMlxyXG5cdFx0XCJpcy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgb3AgPSBhdG9tLmFyZ3NbMV0uaW50ZXJwcmV0KCB0aHJlYWQgKTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX251bWJlciggb3AgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIG9wICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbYXRvbS5hcmdzWzBdLCBvcF0sIGF0b20uaW5kaWNhdG9yICkgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBiZXR3ZWVuLzNcclxuXHRcdFwiYmV0d2Vlbi8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbG93ZXIgPSBhdG9tLmFyZ3NbMF0sIHVwcGVyID0gYXRvbS5hcmdzWzFdLCBiZXQgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBsb3dlciApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIHVwcGVyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggbG93ZXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBsb3dlciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2ludGVnZXIoIHVwcGVyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgdXBwZXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYmV0ICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggYmV0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgYmV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGJldCApICkge1xyXG5cdFx0XHRcdFx0aWYoIGxvd2VyLnZhbHVlIDw9IHVwcGVyLnZhbHVlICkge1xyXG5cdFx0XHRcdFx0XHR2YXIgc3RhdGVzID0gW25ldyBTdGF0ZSggcG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtiZXQsIGxvd2VyXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV07XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiYmV0d2VlblwiLCBbbmV3IE51bSggbG93ZXIudmFsdWUrMSwgZmFsc2UgKSwgdXBwZXIsIGJldF0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICkgKTtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIHN0YXRlcyApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiggbG93ZXIudmFsdWUgPD0gYmV0LnZhbHVlICYmIHVwcGVyLnZhbHVlID49IGJldC52YWx1ZSApIHtcclxuXHRcdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gc3VjYy8yXHJcblx0XHRcInN1Y2MvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG4gPSBhdG9tLmFyZ3NbMF0sIG0gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBuICkgJiYgcGwudHlwZS5pc192YXJpYWJsZSggbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBuICkgJiYgIXBsLnR5cGUuaXNfaW50ZWdlciggbiApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIG4sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggbSApICYmICFwbC50eXBlLmlzX2ludGVnZXIoIG0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW50ZWdlclwiLCBtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIG4gKSAmJiBuLnZhbHVlIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJub3RfbGVzc190aGFuX3plcm9cIiwgbiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBtICkgJiYgbS52YWx1ZSA8IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwibm90X2xlc3NfdGhhbl96ZXJvXCIsIG0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggbSApIHx8IG0udmFsdWUgPiAwICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG4gKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbiwgbmV3IE51bSggbS52YWx1ZS0xLCBmYWxzZSApXSApICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW20sIG5ldyBOdW0oIG4udmFsdWUrMSwgZmFsc2UgKV0gKSApLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50ICldICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA9Oj0vMlxyXG5cdFx0XCI9Oj0vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNtcCA9IHBsLmFyaXRobWV0aWNfY29tcGFyZSggdGhyZWFkLCBhdG9tLmFyZ3NbMF0sIGF0b20uYXJnc1sxXSApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc190ZXJtKCBjbXAgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGNtcCApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIGNtcCA9PT0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPVxcPS8yXHJcblx0XHRcIj1cXFxcPS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wICE9PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA8LzJcclxuXHRcdFwiPC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wIDwgMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gPTwvMlxyXG5cdFx0XCI9PC8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgY21wID0gcGwuYXJpdGhtZXRpY19jb21wYXJlKCB0aHJlYWQsIGF0b20uYXJnc1swXSwgYXRvbS5hcmdzWzFdICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3Rlcm0oIGNtcCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggY21wICk7XHJcblx0XHRcdH0gZWxzZSBpZiggY21wIDw9IDAgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vID4vMlxyXG5cdFx0XCI+LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgPiAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyA+PS8yXHJcblx0XHRcIj49LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBjbXAgPSBwbC5hcml0aG1ldGljX2NvbXBhcmUoIHRocmVhZCwgYXRvbS5hcmdzWzBdLCBhdG9tLmFyZ3NbMV0gKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggY21wICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBjbXAgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBjbXAgPj0gMCApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gVFlQRSBURVNUXHJcblx0XHRcclxuXHRcdC8vIHZhci8xXHJcblx0XHRcInZhci8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGF0b20vMVxyXG5cdFx0XCJhdG9tLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b20oIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhdG9taWMvMVxyXG5cdFx0XCJhdG9taWMvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfYXRvbWljKCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gY29tcG91bmQvMVxyXG5cdFx0XCJjb21wb3VuZC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc19jb21wb3VuZCggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGludGVnZXIvMVxyXG5cdFx0XCJpbnRlZ2VyLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2ludGVnZXIoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBmbG9hdC8xXHJcblx0XHRcImZsb2F0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX2Zsb2F0KCBhdG9tLmFyZ3NbMF0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gbnVtYmVyLzFcclxuXHRcdFwibnVtYmVyLzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX251bWJlciggYXRvbS5hcmdzWzBdICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIG5vbnZhci8xXHJcblx0XHRcIm5vbnZhci8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHRpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGF0b20uYXJnc1swXSApICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBncm91bmQvMVxyXG5cdFx0XCJncm91bmQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0aWYoIGF0b20udmFyaWFibGVzKCkubGVuZ3RoID09PSAwICkge1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBhY3ljbGljX3Rlcm0vMVxyXG5cdFx0XCJhY3ljbGljX3Rlcm0vMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHRlc3QgPSBwb2ludC5zdWJzdGl0dXRpb24uYXBwbHkoIHBvaW50LnN1YnN0aXR1dGlvbiApO1xyXG5cdFx0XHR2YXIgdmFyaWFibGVzID0gYXRvbS5hcmdzWzBdLnZhcmlhYmxlcygpO1xyXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IHZhcmlhYmxlcy5sZW5ndGg7IGkrKyApXHJcblx0XHRcdFx0aWYoIHBvaW50LnN1YnN0aXR1dGlvbi5saW5rc1t2YXJpYWJsZXNbaV1dICE9PSB1bmRlZmluZWQgJiYgIXBvaW50LnN1YnN0aXR1dGlvbi5saW5rc1t2YXJpYWJsZXNbaV1dLmVxdWFscyggdGVzdC5saW5rc1t2YXJpYWJsZXNbaV1dICkgKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIGNhbGxhYmxlLzFcclxuXHRcdFwiY2FsbGFibGUvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGNhbGxhYmxlID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3Rlcm0oY2FsbGFibGUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gaXNfbGlzdC8xXHJcblx0XHRcImlzX2xpc3QvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGxpc3QgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0oIGxpc3QgKSAmJiBsaXN0LmluZGljYXRvciA9PT0gXCIuLzJcIiApXHJcblx0XHRcdFx0bGlzdCA9IGxpc3QuYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdGVybSggbGlzdCApICYmIGxpc3QuaW5kaWNhdG9yID09PSBcIltdLzBcIiApXHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gU1RSRUFNIFNFTEVDVElPTiBBTkQgQ09OVFJPTFxyXG5cclxuXHRcdC8vIGN1cnJlbnRfaW5wdXQvMVxyXG5cdFx0XCJjdXJyZW50X2lucHV0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHN0cmVhbSlcclxuXHRcdFx0JiYgKCFwbC50eXBlLmlzX3N0cmVhbShzdHJlYW0pIHx8ICF0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhzdHJlYW0uYWxpYXMpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgJiYgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5pZCkpXHJcblx0XHRcdCYmICghcGwudHlwZS5pc19hdG9tKHN0cmVhbSkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5pZCkpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvcikgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX2F0b20oc3RyZWFtKSlcclxuXHRcdFx0XHRcdHN0cmVhbSA9IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5pZCk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCI9XCIsIFtzdHJlYW0sIHRocmVhZC5nZXRfY3VycmVudF9pbnB1dCgpXSkpLFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnQpXHJcblx0XHRcdFx0XSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGN1cnJlbnRfb3V0cHV0LzFcclxuXHRcdFwiY3VycmVudF9vdXRwdXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoc3RyZWFtKVxyXG5cdFx0XHQmJiAoIXBsLnR5cGUuaXNfc3RyZWFtKHN0cmVhbSkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKHN0cmVhbS5hbGlhcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgICAmJiAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmlkKSlcclxuXHRcdFx0JiYgKCFwbC50eXBlLmlzX2F0b20oc3RyZWFtKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoc3RyZWFtLmlkKSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbihcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHBsLnR5cGUuaXNfYXRvbShzdHJlYW0pKVxyXG5cdFx0XHRcdFx0c3RyZWFtID0gdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwiPVwiLCBbc3RyZWFtLCB0aHJlYWQuZ2V0X2N1cnJlbnRfb3V0cHV0KCldKSksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludClcclxuXHRcdFx0XHRdICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc2V0X2lucHV0LzFcclxuXHRcdFwic2V0X2lucHV0LzFcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBpbnB1dCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IHBsLnR5cGUuaXNfc3RyZWFtKCBpbnB1dCApID8gaW5wdXQgOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggaW5wdXQuaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGlucHV0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBpbnB1dCApICYmICFwbC50eXBlLmlzX2F0b20oIGlucHV0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIGlucHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSB8fCAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoaW5wdXQuYWxpYXMpXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JiYgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKGlucHV0LmlkKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgaW5wdXQsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0ub3V0cHV0ID09PSB0cnVlICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBpbnB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocmVhZC5zZXRfY3VycmVudF9pbnB1dCggc3RyZWFtICk7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc2V0X291dHB1dC8xXHJcblx0XHRcInNldF9vdXRwdXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIG91dHB1dCA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IHBsLnR5cGUuaXNfc3RyZWFtKCBvdXRwdXQgKSA/IG91dHB1dCA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBvdXRwdXQuaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIG91dHB1dCApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggb3V0cHV0ICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggb3V0cHV0ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIG91dHB1dCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgfHwgIXRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKG91dHB1dC5hbGlhcylcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQmJiAhdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMob3V0cHV0LmlkKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgb3V0cHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtLmlucHV0ID09PSB0cnVlICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJzdHJlYW1cIiwgb3V0cHV0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnNldF9jdXJyZW50X291dHB1dCggc3RyZWFtICk7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gb3Blbi8zXHJcblx0XHRcIm9wZW4vM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGRlc3QgPSBhdG9tLmFyZ3NbMF0sIG1vZGUgPSBhdG9tLmFyZ3NbMV0sIHN0cmVhbSA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKG5ldyBUZXJtKFwib3BlblwiLCBbZGVzdCwgbW9kZSwgc3RyZWFtLCBuZXcgVGVybShcIltdXCIsIFtdKV0pKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gb3Blbi80XHJcblx0XHRcIm9wZW4vNFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIGRlc3QgPSBhdG9tLmFyZ3NbMF0sIG1vZGUgPSBhdG9tLmFyZ3NbMV0sIHN0cmVhbSA9IGF0b20uYXJnc1syXSwgb3B0aW9ucyA9IGF0b20uYXJnc1szXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGRlc3QgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBtb2RlICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBtb2RlICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggbW9kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIG1vZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnVuaW5zdGFudGlhdGlvbiggc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfYXRvbSggZGVzdCApICYmICFwbC50eXBlLmlzX3N0cmVhbWFibGUoIGRlc3QgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzb3VyY2Vfc2lua1wiLCBkZXN0LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW9fbW9kZSggbW9kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcImlvX21vZGVcIiwgbW9kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBvYmpfb3B0aW9ucyA9IHt9O1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gb3B0aW9ucztcclxuXHRcdFx0XHR2YXIgcHJvcGVydHk7XHJcblx0XHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdHByb3BlcnR5ID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbV9vcHRpb24oIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcHRpb25cIiwgcHJvcGVydHksIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0b2JqX29wdGlvbnNbcHJvcGVydHkuaWRdID0gcHJvcGVydHkuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApIClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dmFyIGFsaWFzID0gb2JqX29wdGlvbnNbXCJhbGlhc1wiXTtcclxuXHRcdFx0XHRcdGlmKCBhbGlhcyAmJiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyhhbGlhcykgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvcGVuXCIsIFwic291cmNlX3NpbmtcIiwgbmV3IFRlcm0oXCJhbGlhc1wiLCBbbmV3IFRlcm0oYWxpYXMsIFtdKV0pLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCAhb2JqX29wdGlvbnNbXCJ0eXBlXCJdIClcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbXCJ0eXBlXCJdID0gXCJ0ZXh0XCI7XHJcblx0XHRcdFx0XHR2YXIgZmlsZTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX2F0b20oIGRlc3QgKSApXHJcblx0XHRcdFx0XHRcdGZpbGUgPSB0aHJlYWQuZmlsZV9zeXN0ZW1fb3BlbiggZGVzdC5pZCwgb2JqX29wdGlvbnNbXCJ0eXBlXCJdLCBtb2RlLmlkICk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdGZpbGUgPSBkZXN0LnN0cmVhbSggb2JqX29wdGlvbnNbXCJ0eXBlXCJdLCBtb2RlLmlkICk7XHJcblx0XHRcdFx0XHRpZiggZmlsZSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvcGVuXCIsIFwic291cmNlX3NpbmtcIiwgZGVzdCwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoIGZpbGUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInNvdXJjZV9zaW5rXCIsIGRlc3QsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIG5ld3N0cmVhbSA9IG5ldyBTdHJlYW0oXHJcblx0XHRcdFx0XHRcdGZpbGUsIG1vZGUuaWQsXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW1wiYWxpYXNcIl0sXHJcblx0XHRcdFx0XHRcdG9ial9vcHRpb25zW1widHlwZVwiXSxcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbXCJyZXBvc2l0aW9uXCJdID09PSBcInRydWVcIixcclxuXHRcdFx0XHRcdFx0b2JqX29wdGlvbnNbXCJlb2ZfYWN0aW9uXCJdICk7XHJcblx0XHRcdFx0XHRpZiggYWxpYXMgKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc2Vzc2lvbi5zdHJlYW1zW2FsaWFzXSA9IG5ld3N0cmVhbTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uc3RyZWFtc1tuZXdzdHJlYW0uaWRdID0gbmV3c3RyZWFtO1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbc3RyZWFtLCBuZXdzdHJlYW1dICkgKSxcclxuXHRcdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0KV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY2xvc2UvMVxyXG5cdFx0XCJjbG9zZS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UobmV3IFRlcm0oXCJjbG9zZVwiLCBbc3RyZWFtLCBuZXcgVGVybShcIltdXCIsIFtdKV0pKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gY2xvc2UvMlxyXG5cdFx0XCJjbG9zZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBvcHRpb25zID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBHZXQgb3B0aW9uc1xyXG5cdFx0XHRcdHZhciBvYmpfb3B0aW9ucyA9IHt9O1xyXG5cdFx0XHRcdHZhciBwb2ludGVyID0gb3B0aW9ucztcclxuXHRcdFx0XHR2YXIgcHJvcGVydHk7XHJcblx0XHRcdFx0d2hpbGUoIHBsLnR5cGUuaXNfdGVybShwb2ludGVyKSAmJiBwb2ludGVyLmluZGljYXRvciA9PT0gXCIuLzJcIiApIHtcclxuXHRcdFx0XHRcdHByb3BlcnR5ID0gcG9pbnRlci5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2Nsb3NlX29wdGlvbiggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwiY2xvc2Vfb3B0aW9uXCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG9ial9vcHRpb25zW3Byb3BlcnR5LmlkXSA9IHByb3BlcnR5LmFyZ3NbMF0uaWQgPT09IFwidHJ1ZVwiO1xyXG5cdFx0XHRcdFx0cG9pbnRlciA9IHBvaW50ZXIuYXJnc1sxXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIHBvaW50ZXIuaW5kaWNhdG9yICE9PSBcIltdLzBcIiApIHtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwb2ludGVyICkgKVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZihzdHJlYW0yID09PSB0aHJlYWQuc2Vzc2lvbi5zdGFuZGFyZF9pbnB1dCB8fCBzdHJlYW0yID09PSB0aHJlYWQuc2Vzc2lvbi5zdGFuZGFyZF9vdXRwdXQgfHwgc3RyZWFtMiA9PT0gdGhyZWFkLnNlc3Npb24uc3RhbmRhcmRfZXJyb3IpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMiA9PT0gdGhyZWFkLnNlc3Npb24uY3VycmVudF9pbnB1dCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uY3VycmVudF9pbnB1dCA9IHRocmVhZC5zZXNzaW9uLnN0YW5kYXJkX2lucHV0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yID09PSB0aHJlYWQuc2Vzc2lvbi5jdXJyZW50X291dHB1dCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnNlc3Npb24uY3VycmVudF9vdXRwdXQgPSB0aHJlYWQuc2Vzc2lvbi5zdGFuZGFyZF9vdXRwdXQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtMi5hbGlhcyAhPT0gbnVsbCAmJiBzdHJlYW0yLmFsaWFzICE9PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRcdFx0XHRkZWxldGUgdGhyZWFkLnNlc3Npb24uc3RyZWFtc1tzdHJlYW0yLmFsaWFzXTtcclxuXHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRocmVhZC5zZXNzaW9uLnN0cmVhbXNbc3RyZWFtMi5pZF07XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtMi5vdXRwdXQgKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnN0cmVhbS5mbHVzaCgpO1xyXG5cdFx0XHRcdFx0dmFyIGNsb3NlZCA9IHN0cmVhbTIuc3RyZWFtLmNsb3NlKCk7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnN0cmVhbSA9IG51bGw7XHJcblx0XHRcdFx0XHRpZiggb2JqX29wdGlvbnMuZm9yY2UgPT09IHRydWUgfHwgY2xvc2VkID09PSB0cnVlICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZmx1c2hfb3V0cHV0LzBcclxuXHRcdFwiZmx1c2hfb3V0cHV0LzBcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImZsdXNoX291dHB1dFwiLCBbXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcImZsdXNoX291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBmbHVzaF9vdXRwdXQvMVxyXG5cdFx0XCJmbHVzaF9vdXRwdXQvMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5pbnB1dCA9PT0gdHJ1ZSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHN0cmVhbTIuc3RyZWFtLmZsdXNoKCk7XHJcblx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc3RyZWFtX3Byb3BlcnR5LzJcclxuXHRcdFwic3RyZWFtX3Byb3BlcnR5LzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIHByb3BlcnR5ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgKCFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHByb3BlcnR5ICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtX3Byb3BlcnR5KCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9wcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1zID0gW107XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdHZhciBwcm9wdmFyID0gcGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSk7XHJcblx0XHRcdFx0aWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApXHJcblx0XHRcdFx0XHRzdHJlYW1zLnB1c2goIHN0cmVhbTIgKTtcclxuXHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRmb3IoIHZhciBrZXkgaW4gdGhyZWFkLnNlc3Npb24uc3RyZWFtcyApXHJcblx0XHRcdFx0XHRcdHN0cmVhbXMucHVzaCggdGhyZWFkLnNlc3Npb24uc3RyZWFtc1trZXldICk7XHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBzdHJlYW1zLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSBbXTtcclxuXHRcdFx0XHRcdC8vIGZpbGVfbmFtZS8xXHJcblx0XHRcdFx0XHRpZiggKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcImZpbGVfbmFtZS8xXCIpICYmIHN0cmVhbXNbaV0uZmlsZW5hbWUgKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcImZpbGVfbmFtZVwiLCBbbmV3IFRlcm0oc3RyZWFtc1tpXS5maWxlX25hbWUsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gbW9kZS8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJtb2RlLzFcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJtb2RlXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLm1vZGUsIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gaW5wdXQvMCBvciBvdXRwdXQvMFxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwiaW5wdXQvMFwiIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJvdXRwdXQvMFwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBzdHJlYW1zW2ldLmlucHV0ID8gXCJpbnB1dFwiIDogXCJvdXRwdXRcIiwgW10gKSApO1xyXG5cdFx0XHRcdFx0Ly8gYWxpYXMvMVxyXG5cdFx0XHRcdFx0aWYoIChwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJhbGlhcy8xXCIpICYmIHN0cmVhbXNbaV0uYWxpYXMgKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcImFsaWFzXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLmFsaWFzLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIHBvc2l0aW9uLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcInBvc2l0aW9uLzFcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJwb3NpdGlvblwiLCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRlcm0oXCJwb3NpdGlvblwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgTnVtKHN0cmVhbXNbaV0uY2hhcl9jb3VudCwgZmFsc2UpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE51bShzdHJlYW1zW2ldLmxpbmVfY291bnQsIGZhbHNlKSxcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBOdW0oc3RyZWFtc1tpXS5saW5lX3Bvc2l0aW9uLCBmYWxzZSlcclxuXHRcdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XHRdICkgKTtcclxuXHRcdFx0XHRcdC8vIGVuZF9vZl9zdHJlYW0vMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwiZW5kX29mX3N0cmVhbS8xXCIpXHJcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucHVzaCggbmV3IFRlcm0oIFwiZW5kX29mX3N0cmVhbVwiLCBbbmV3IFRlcm0oXHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtc1tpXS5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgfHwgc3RyZWFtc1tpXS5zdHJlYW0uZW9mICYmIHN0cmVhbXNbaV0uc3RyZWFtLmVvZihzdHJlYW1zW2ldLnBvc2l0aW9uKSA/IFwiYXRcIiA6XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtc1tpXS5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiA/IFwicGFzdFwiIDpcclxuXHRcdFx0XHRcdFx0XHRcIm5vdFwiLCBbXSldICkgKTtcclxuXHRcdFx0XHRcdC8vIGVvZl9hY3Rpb24vMVxyXG5cdFx0XHRcdFx0aWYocHJvcHZhciB8fCBwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwiZW9mX2FjdGlvbi8xXCIpXHRcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJlb2ZfYWN0aW9uXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLmVvZl9hY3Rpb24sIFtdKV0gKSApO1xyXG5cdFx0XHRcdFx0Ly8gcmVwb3NpdGlvbi8xXHJcblx0XHRcdFx0XHRpZihwcm9wdmFyIHx8IHByb3BlcnR5LmluZGljYXRvciA9PT0gXCJyZXBvc2l0aW9uLzFcIilcclxuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBuZXcgVGVybSggXCJyZXBvc2l0aW9uXCIsIFtuZXcgVGVybShzdHJlYW1zW2ldLnJlcG9zaXRpb24gPyBcInRydWVcIiA6IFwiZmFsc2VcIiwgW10pXSApICk7XHJcblx0XHRcdFx0XHQvLyB0eXBlLzFcclxuXHRcdFx0XHRcdGlmKHByb3B2YXIgfHwgcHJvcGVydHkuaW5kaWNhdG9yID09PSBcInR5cGUvMVwiKVxyXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIG5ldyBUZXJtKCBcInR5cGVcIiwgW25ldyBUZXJtKHN0cmVhbXNbaV0udHlwZSwgW10pXSApICk7XHJcblx0XHRcdFx0XHRmb3IoIHZhciBqID0gMDsgaiA8IHByb3BlcnRpZXMubGVuZ3RoOyBqKysgKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlcy5wdXNoKCBuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCIsXCIsIFtcclxuXHRcdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgPyBzdHJlYW0gOiBzdHJlYW0yLCBzdHJlYW1zW2ldXSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3Byb3BlcnR5LCBwcm9wZXJ0aWVzW2pdXSldKSApLFxyXG5cdFx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdFx0XHQpICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBzdHJlYW1fcG9zaXRpb25fZGF0YVxyXG5cdFx0XCJzdHJlYW1fcG9zaXRpb25fZGF0YS8zXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIGZpZWxkID0gYXRvbS5hcmdzWzBdLCBwb3NpdGlvbiA9IGF0b20uYXJnc1sxXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMl07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUocG9zaXRpb24pKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3Rlcm0ocG9zaXRpb24pIHx8IHBvc2l0aW9uLmluZGljYXRvciAhPT0gXCJwb3NpdGlvbi8zXCIpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuZG9tYWluKFwic3RyZWFtX3Bvc2l0aW9uXCIsIHBvc2l0aW9uLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoZmllbGQpICYmICFwbC50eXBlLmlzX2F0b20oZmllbGQpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJhdG9tXCIsIGZpZWxkLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUodmFsdWUpICYmICFwbC50eXBlLmlzX2ludGVnZXIodmFsdWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLnR5cGUoXCJpbnRlZ2VyXCIsIHZhbHVlLCBhdG9tLmluZGljYXRvcikpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBmaWVsZHMgPSBbXCJjaGFyX2NvdW50XCIsIFwibGluZV9jb3VudFwiLCBcImxpbmVfcG9zaXRpb25cIl07XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdHZhciBkYXRhX3BvcyA9IHtjaGFyX2NvdW50OiAwLCBsaW5lX2NvdW50OiAxLCBsaW5lX3Bvc2l0aW9uOiAyfTtcclxuXHRcdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKGZpZWxkKSkge1xyXG5cdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUocG9pbnQuZ29hbC5yZXBsYWNlKFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW25ldyBUZXJtKGZpZWxkc1tpXSksIGZpZWxkXSksXHJcblx0XHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIj1cIiwgW3ZhbHVlLCBwb3NpdGlvbi5hcmdzW2RhdGFfcG9zW2ZpZWxkc1tpXV1dXSlcclxuXHRcdFx0XHRcdFx0XHRdKVxyXG5cdFx0XHRcdFx0XHQpLCBwb2ludC5zdWJzdGl0dXRpb24sIHBvaW50KSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIGlmKGRhdGFfcG9zLmhhc093blByb3BlcnR5KGZpZWxkLmlkKSkge1xyXG5cdFx0XHRcdFx0c3RhdGVzLnB1c2gobmV3IFN0YXRlKHBvaW50LmdvYWwucmVwbGFjZShcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCI9XCIsIFt2YWx1ZSwgcG9zaXRpb24uYXJnc1tkYXRhX3Bvc1tmaWVsZC5pZF1dXSlcclxuXHRcdFx0XHRcdCksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBhdF9lbmRfb2Zfc3RyZWFtLzBcclxuXHRcdFwiYXRfZW5kX29mX3N0cmVhbS8wXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJhdF9lbmRfb2Zfc3RyZWFtXCIsIFtdKSwgbmV3IHBsLnR5cGUuVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwic3RyZWFtX3Byb3BlcnR5XCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVGVybShcImVuZF9vZl9zdHJlYW1cIiwgW25ldyBWYXIoXCJFXCIpXSldKSxuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiIVwiLCBbXSksbmV3IFRlcm0oXCI7XCIsIFtuZXcgVGVybShcIj1cIiwgW25ldyBWYXIoXCJFXCIpLG5ldyBUZXJtKFwiYXRcIiwgW10pXSksbmV3IFRlcm0oXCI9XCIsIFtuZXcgVmFyKFwiRVwiKSxuZXcgVGVybShcInBhc3RcIiwgW10pXSldKV0pXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gYXRfZW5kX29mX3N0cmVhbS8xXHJcblx0XHRcImF0X2VuZF9vZl9zdHJlYW0vMVwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGUgPSB0aHJlYWQubmV4dF9mcmVlX3ZhcmlhYmxlKCk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJzdHJlYW1fcHJvcGVydHlcIiwgW3N0cmVhbTIsbmV3IFRlcm0oXCJlbmRfb2Zfc3RyZWFtXCIsIFtlXSldKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcIiFcIiwgW10pLG5ldyBUZXJtKFwiO1wiLCBbbmV3IFRlcm0oXCI9XCIsIFtlLG5ldyBUZXJtKFwiYXRcIiwgW10pXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiPVwiLCBbZSxuZXcgVGVybShcInBhc3RcIiwgW10pXSldKV0pXSlcclxuXHRcdFx0XHRcdCksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gc2V0X3N0cmVhbV9wb3NpdGlvbi8yXHJcblx0XHRcInNldF9zdHJlYW1fcG9zaXRpb24vMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgcG9zaXRpb24gPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgfHwgcGwudHlwZS5pc192YXJpYWJsZSggcG9zaXRpb24gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtX3Bvc2l0aW9uKCBwb3NpdGlvbiApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9wb3NpdGlvblwiLCBwb3NpdGlvbiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucmVwb3NpdGlvbiA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcInJlcG9zaXRpb25cIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHBvc2l0aW9uLmluZGljYXRvciA9PT0gXCJwb3NpdGlvbi8zXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gcG9zaXRpb24uYXJnc1swXS52YWx1ZTtcclxuXHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCA9IHBvc2l0aW9uLmFyZ3NbMF0udmFsdWU7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQgPSBwb3NpdGlvbi5hcmdzWzFdLnZhbHVlO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gcG9zaXRpb24uYXJnc1syXS52YWx1ZTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IHBvc2l0aW9uLmlkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vICBDSEFSQUNURVIgSU5QVVQgT1VUUFVUXHJcblx0XHRcclxuXHRcdC8vIGdldF9jaGFyLzFcclxuXHRcdFwiZ2V0X2NoYXIvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwiZ2V0X2NoYXJcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwiZ2V0X2NoYXJcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gZ2V0X2NoYXIvMlxyXG5cdFx0XCJnZXRfY2hhci8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjaGFyID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBjaGFyICkgJiYgIXBsLnR5cGUuaXNfaW5fY2hhcmFjdGVyKCBjaGFyICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImluX2NoYXJhY3RlclwiLCBjaGFyLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2NoYXI7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IFwiZW5kX29mX2ZpbGVcIjtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY2hhciA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0aWYoIHN0cmVhbV9jaGFyID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnJlcHJlc2VudGF0aW9uKCBcImNoYXJhY3RlclwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fY2hhciA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRcdGlmKHN0cmVhbV9jaGFyID09PSBcIlxcblwiKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gMDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oc3RyZWFtX2NoYXIsW10pLCBjaGFyXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gZ2V0X2NvZGUvMVxyXG5cdFx0XCJnZXRfY29kZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJnZXRfY29kZVwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJnZXRfY29kZVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBnZXRfY29kZS8yXHJcblx0XHRcImdldF9jb2RlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNvZGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgY29kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICYmICFwbC50eXBlLmlzX2luX2NoYXJhY3Rlcl9jb2RlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJpbl9jaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9jb2RlO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gLTE7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IC0xO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2NvZGUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9jb2RlID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IC0xO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gY29kZVBvaW50QXQoIHN0cmVhbV9jb2RlLCAwICk7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0XHRpZihzdHJlYW1fY29kZSA9PT0gMTApIHtcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQrKztcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSAwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFtuZXcgTnVtKHN0cmVhbV9jb2RlLCBmYWxzZSksIGNvZGVdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBwZWVrX2NoYXIvMVxyXG5cdFx0XCJwZWVrX2NoYXIvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicGVla19jaGFyXCIsIFtuZXcgVmFyKFwiQ1wiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInBlZWtfY2hhclwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIkNcIildKV0pKVxyXG5cdFx0XSxcclxuXHJcblx0XHQvLyBwZWVrX2NoYXIvMlxyXG5cdFx0XCJwZWVrX2NoYXIvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY2hhciA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggY2hhciApICYmICFwbC50eXBlLmlzX2luX2NoYXJhY3RlciggY2hhciApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbl9jaGFyYWN0ZXJcIiwgY2hhciwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9jaGFyO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBcImVuZF9vZl9maWxlXCI7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NoYXIgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fY2hhciA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2NoYXIgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jaGFyID0gXCJlbmRfb2ZfZmlsZVwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oc3RyZWFtX2NoYXIsW10pLCBjaGFyXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcGVla19jb2RlLzFcclxuXHRcdFwicGVla19jb2RlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInBlZWtfY29kZVwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwZWVrX2NvZGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcGVla19jb2RlLzJcclxuXHRcdFwicGVla19jb2RlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGNvZGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGNvZGUgKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgY29kZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICYmICFwbC50eXBlLmlzX2luX2NoYXJhY3Rlcl9jb2RlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJpbl9jaGFyYWN0ZXJfY29kZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApICYmICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHN0cmVhbV9jb2RlO1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcImVuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gLTE7XHJcblx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2NvZGUgPSBzdHJlYW0yLnN0cmVhbS5nZXQoIDEsIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fY29kZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJjaGFyYWN0ZXJcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYoc3RyZWFtX2NvZGUgPT09IFwiZW5kX29mX3N0cmVhbVwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbV9jb2RlID0gLTE7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fY29kZSA9IGNvZGVQb2ludEF0KCBzdHJlYW1fY29kZSwgMCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IE51bShzdHJlYW1fY29kZSwgZmFsc2UpLCBjb2RlXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcHV0X2NoYXIvMVxyXG5cdFx0XCJwdXRfY2hhci8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwdXRfY2hhclwiLCBbbmV3IFZhcihcIkNcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicHV0X2NoYXJcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJDXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcHV0X2NoYXIvMlxyXG5cdFx0XCJwdXRfY2hhci8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBjaGFyID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGNoYXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXIoIGNoYXIgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2hhcmFjdGVyXCIsIGNoYXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIuaW5wdXQgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwiYmluYXJ5XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIuc3RyZWFtLnB1dCggY2hhci5pZCwgc3RyZWFtMi5wb3NpdGlvbiApICkge1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIHN0cmVhbTIucG9zaXRpb24gPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRpZihjaGFyLmlkID09PSBcIlxcblwiKSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9jb3VudCsrO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhyZWFkLnN1Y2Nlc3MoIHBvaW50ICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHB1dF9jb2RlLzFcclxuXHRcdFwicHV0X2NvZGUvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicHV0X2NvZGVcIiwgW25ldyBWYXIoXCJDXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X291dHB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcInB1dF9jb2RlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQ1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHB1dF9jb2RlLzJcclxuXHRcdFwicHV0X2NvZGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgY29kZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBjb2RlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIGNvZGUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19jaGFyYWN0ZXJfY29kZSggY29kZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyX2NvZGVcIiwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5pbnB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5zdHJlYW0ucHV0KCBmcm9tQ29kZVBvaW50KCBjb2RlLnZhbHVlICksIHN0cmVhbTIucG9zaXRpb24gKSApIHtcclxuXHRcdFx0XHRcdGlmKHR5cGVvZiBzdHJlYW0yLnBvc2l0aW9uID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uKys7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQrKztcclxuXHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0aWYoY29kZS52YWx1ZSA9PT0gMTApIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbiA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gbmwvMFxyXG5cdFx0XCJubC8wXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJubFwiKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicHV0X2NoYXJcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBUZXJtKFwiXFxuXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gbmwvMVxyXG5cdFx0XCJubC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybShcInB1dF9jaGFyXCIsIFtzdHJlYW0sIG5ldyBUZXJtKFwiXFxuXCIsIFtdKV0pICksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gQllURSBJTlBVVC9PVVRQVVRcclxuXHJcblx0XHQvLyBnZXRfYnl0ZS8xXHJcblx0XHRcImdldF9ieXRlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcImdldF9ieXRlXCIsIFtuZXcgVmFyKFwiQlwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9pbnB1dFwiLCBbbmV3IFZhcihcIlNcIildKSxuZXcgVGVybShcImdldF9ieXRlXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiQlwiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIGdldF9ieXRlLzJcclxuXHRcdFwiZ2V0X2J5dGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgYnl0ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggYnl0ZSApICYmICFwbC50eXBlLmlzX2luX2J5dGUoIGJ5dGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiaW5fYnl0ZVwiLCBieXRlLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19hdG9tKCBzdHJlYW0gKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJzdHJlYW1fb3JfYWxpYXNcIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0yICkgfHwgc3RyZWFtMi5zdHJlYW0gPT09IG51bGwgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5leGlzdGVuY2UoIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIub3V0cHV0ICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnR5cGUgPT09IFwidGV4dFwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInRleHRfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIgJiYgc3RyZWFtMi5lb2ZfYWN0aW9uID09PSBcImVycm9yXCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcImlucHV0XCIsIFwicGFzdF9lbmRfb2Zfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdHJlYW1fYnl0ZTtcclxuXHRcdFx0XHRpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgKSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0cmVhbV9ieXRlID0gc3RyZWFtMi5zdHJlYW0uZ2V0X2J5dGUoIHN0cmVhbTIucG9zaXRpb24gKTtcclxuXHRcdFx0XHRcdGlmKCBzdHJlYW1fYnl0ZSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5yZXByZXNlbnRhdGlvbiggXCJieXRlXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKHN0cmVhbV9ieXRlID09PSBcImVuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IC0xO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uID0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIjtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0c3RyZWFtMi5jaGFyX2NvdW50Kys7XHJcblx0XHRcdFx0XHRcdHN0cmVhbTIubGluZV9wb3NpdGlvbisrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbbmV3IE51bShzdHJlYW1fYnl0ZSxmYWxzZSksIGJ5dGVdICkgKSxcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gcGVla19ieXRlLzFcclxuXHRcdFwicGVla19ieXRlLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInBlZWtfYnl0ZVwiLCBbbmV3IFZhcihcIkJcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfaW5wdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJwZWVrX2J5dGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJCXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcGVla19ieXRlLzJcclxuXHRcdFwicGVla19ieXRlLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBzdHJlYW0gPSBhdG9tLmFyZ3NbMF0sIGJ5dGUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdHZhciBzdHJlYW0yID0gcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApID8gc3RyZWFtIDogdGhyZWFkLmdldF9zdHJlYW1fYnlfYWxpYXMoIHN0cmVhbS5pZCApO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGJ5dGUgKSAmJiAhcGwudHlwZS5pc19pbl9ieXRlKCBieXRlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImluX2J5dGVcIiwgYnl0ZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcInRleHRcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJ0ZXh0X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcInBhc3RfZW5kX29mX3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgc3RyZWFtX2J5dGU7XHJcblx0XHRcdFx0aWYoIHN0cmVhbTIucG9zaXRpb24gPT09IFwiZW5kX29mX3N0cmVhbVwiICkge1xyXG5cdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSAtMTtcclxuXHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24gPSBcInBhc3RfZW5kX29mX3N0cmVhbVwiO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdHJlYW1fYnl0ZSA9IHN0cmVhbTIuc3RyZWFtLmdldF9ieXRlKCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggc3RyZWFtX2J5dGUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiYnl0ZVwiLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZihzdHJlYW1fYnl0ZSA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIpIHtcclxuXHRcdFx0XHRcdFx0c3RyZWFtX2J5dGUgPSAtMTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW25ldyBOdW0oc3RyZWFtX2J5dGUsZmFsc2UpLCBieXRlXSApICksXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gcHV0X2J5dGUvMVxyXG5cdFx0XCJwdXRfYnl0ZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJwdXRfYnl0ZVwiLCBbbmV3IFZhcihcIkJcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicHV0X2J5dGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJCXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcHV0X2J5dGUvMlxyXG5cdFx0XCJwdXRfYnl0ZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCBieXRlID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIGJ5dGUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19ieXRlKCBieXRlICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImJ5dGVcIiwgYnl0ZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSAmJiAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5pbnB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJ0ZXh0XCIgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5wZXJtaXNzaW9uKCBcIm91dHB1dFwiLCBcInRleHRfc3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKCBzdHJlYW0yLnN0cmVhbS5wdXRfYnl0ZSggYnl0ZS52YWx1ZSwgc3RyZWFtMi5wb3NpdGlvbiApICkge1xyXG5cdFx0XHRcdFx0aWYodHlwZW9mIHN0cmVhbTIucG9zaXRpb24gPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdHN0cmVhbTIuY2hhcl9jb3VudCsrO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uKys7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cclxuXHJcblx0XHQvLyBURVJNIElOUFVUL09VVFBVVFxyXG5cclxuXHRcdC8vIHJlYWQvMVxyXG5cdFx0XCJyZWFkLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcInJlYWRcIiwgW25ldyBWYXIoXCJUXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicmVhZF90ZXJtXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKSxuZXcgVGVybShcIltdXCIpXSldKSlcclxuXHRcdF0sXHJcblxyXG5cdFx0Ly8gcmVhZC8yXHJcblx0XHRcInJlYWQvMlwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwicmVhZFwiLCBbbmV3IFZhcihcIlNcIiksIG5ldyBWYXIoXCJUXCIpXSksIG5ldyBUZXJtKFwicmVhZF90ZXJtXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKSxuZXcgVGVybShcIltdXCIpXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHJlYWRfdGVybS8yXHJcblx0XHRcInJlYWRfdGVybS8yXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJyZWFkX3Rlcm1cIiwgW25ldyBWYXIoXCJUXCIpLG5ldyBWYXIoXCJPXCIpXSksIG5ldyBUZXJtKFwiLFwiLCBbbmV3IFRlcm0oXCJjdXJyZW50X2lucHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwicmVhZF90ZXJtXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKSxuZXcgVmFyKFwiT1wiKV0pXSkpXHJcblx0XHRdLFxyXG5cclxuXHRcdC8vIHJlYWRfdGVybS8zXHJcblx0XHRcInJlYWRfdGVybS8zXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCB0ZXJtID0gYXRvbS5hcmdzWzFdLCBvcHRpb25zID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgc3RyZWFtMiA9IHBsLnR5cGUuaXNfc3RyZWFtKCBzdHJlYW0gKSA/IHN0cmVhbSA6IHRocmVhZC5nZXRfc3RyZWFtX2J5X2FsaWFzKCBzdHJlYW0uaWQgKTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHN0cmVhbSApIHx8IHBsLnR5cGUuaXNfdmFyaWFibGUoIG9wdGlvbnMgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19saXN0KCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImxpc3RcIiwgb3B0aW9ucywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgJiYgIXBsLnR5cGUuaXNfYXRvbSggc3RyZWFtICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwic3RyZWFtX29yX2FsaWFzXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtMiApIHx8IHN0cmVhbTIuc3RyZWFtID09PSBudWxsICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZXhpc3RlbmNlKCBcInN0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLm91dHB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi50eXBlID09PSBcImJpbmFyeVwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJpbnB1dFwiLCBcImJpbmFyeV9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwiaW5wdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5wb3NpdGlvbiA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiAmJiBzdHJlYW0yLmVvZl9hY3Rpb24gPT09IFwiZW9mX2NvZGVcIiApIHtcclxuXHRcdFx0XHRleHByID0ge1xyXG5cdFx0XHRcdFx0dmFsdWU6IG5ldyBUZXJtKFwiZW5kX29mX2ZpbGVcIiwgW10pLFxyXG5cdFx0XHRcdFx0dHlwZTogU1VDQ0VTUyxcclxuXHRcdFx0XHRcdGxlbjogLTFcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIEdldCBvcHRpb25zXHJcblx0XHRcdFx0dmFyIG9ial9vcHRpb25zID0ge307XHJcblx0XHRcdFx0dmFyIHBvaW50ZXIgPSBvcHRpb25zO1xyXG5cdFx0XHRcdHZhciBwcm9wZXJ0eTtcclxuXHRcdFx0XHR3aGlsZSggcGwudHlwZS5pc190ZXJtKHBvaW50ZXIpICYmIHBvaW50ZXIuaW5kaWNhdG9yID09PSBcIi4vMlwiICkge1xyXG5cdFx0XHRcdFx0cHJvcGVydHkgPSBwb2ludGVyLmFyZ3NbMF07XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcHJvcGVydHkgKSApIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfcmVhZF9vcHRpb24oIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInJlYWRfb3B0aW9uXCIsIHByb3BlcnR5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG9ial9vcHRpb25zW3Byb3BlcnR5LmlkXSA9IHByb3BlcnR5LmFyZ3NbMF07XHJcblx0XHRcdFx0XHRwb2ludGVyID0gcG9pbnRlci5hcmdzWzFdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZiggcG9pbnRlci5pbmRpY2F0b3IgIT09IFwiW10vMFwiICkge1xyXG5cdFx0XHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIHBvaW50ZXIgKSApXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibGlzdFwiLCBvcHRpb25zLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHZhciBjaGFyLCB0b2tlbml6ZXIsIGV4cHI7XHJcblx0XHRcdFx0XHR2YXIgdGV4dCA9IFwiXCI7XHJcblx0XHRcdFx0XHR2YXIgdG9rZW5zID0gW107XHJcblx0XHRcdFx0XHR2YXIgbGFzdF90b2tlbiA9IG51bGw7XHJcblx0XHRcdFx0XHR2YXIgbGV4aWNhbF9lcnJvciA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0Ly8gR2V0IHRlcm1cclxuXHRcdFx0XHRcdHdoaWxlKCBsYXN0X3Rva2VuID09PSBudWxsIHx8IGxleGljYWxfZXJyb3IgfHwgbGFzdF90b2tlbi5uYW1lICE9PSBcImF0b21cIiB8fCBsYXN0X3Rva2VuLnZhbHVlICE9PSBcIi5cIiB8fCB0b2tlbnMubGVuZ3RoID4gMCAmJiBleHByLnR5cGUgPT09IEVSUk9SICkge1xyXG5cdFx0XHRcdFx0XHRjaGFyID0gc3RyZWFtMi5zdHJlYW0uZ2V0KCAxLCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRcdHdoaWxlKGNoYXIgIT09IG51bGwgJiYgY2hhciAhPT0gXCIuXCIgJiYgY2hhciAhPT0gXCJlbmRfb2Zfc3RyZWFtXCIgJiYgY2hhciAhPT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIikge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0XHR0ZXh0ICs9IGNoYXI7XHJcblx0XHRcdFx0XHRcdFx0Y2hhciA9IHN0cmVhbTIuc3RyZWFtLmdldCggMSwgc3RyZWFtMi5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKCBjaGFyID09PSBudWxsICkge1xyXG5cdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucmVwcmVzZW50YXRpb24oIFwiY2hhcmFjdGVyXCIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiggY2hhciA9PT0gXCJlbmRfb2Zfc3RyZWFtXCIgfHwgY2hhciA9PT0gXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiApIHtcclxuXHRcdFx0XHRcdFx0XHRpZih0b2tlbnMgPT09IG51bGwgfHwgdG9rZW5zLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c3RyZWFtMi5wb3NpdGlvbiA9IFwicGFzdF9lbmRfb2Zfc3RyZWFtXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRleHByID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZTogbmV3IFRlcm0oXCJlbmRfb2ZfZmlsZVwiLCBbXSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFNVQ0NFU1MsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGxlbjogLTFcclxuXHRcdFx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYoZXhwcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5zeW50YXgoIGxhc3RfdG9rZW4sIFwidW5leHBlY3RlZCBlbmQgb2YgZmlsZVwiLCBmYWxzZSApICk7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3Iuc3ludGF4KCBsYXN0X3Rva2VuLCBcInRva2VuIG5vdCBmb3VuZFwiLCB0cnVlICkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZihjaGFyID09PSBcIi5cIikge1xyXG5cdFx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0XHR0ZXh0ICs9IGNoYXI7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0dG9rZW5pemVyID0gbmV3IFRva2VuaXplciggdGhyZWFkICk7XHJcblx0XHRcdFx0XHRcdHRva2VuaXplci5uZXdfdGV4dCggdGV4dCApO1xyXG5cdFx0XHRcdFx0XHR0b2tlbnMgPSB0b2tlbml6ZXIuZ2V0X3Rva2VucygpO1xyXG5cdFx0XHRcdFx0XHRudW1fdG9rZW4gPSB0b2tlbnMgIT09IG51bGwgJiYgdG9rZW5zLmxlbmd0aCA+IDEgPyB0b2tlbnNbdG9rZW5zLmxlbmd0aC0yXSA6IG51bGw7XHJcblx0XHRcdFx0XHRcdGxhc3RfdG9rZW4gPSB0b2tlbnMgIT09IG51bGwgJiYgdG9rZW5zLmxlbmd0aCA+IDAgPyB0b2tlbnNbdG9rZW5zLmxlbmd0aC0xXSA6IG51bGw7XHJcblx0XHRcdFx0XHRcdGlmKHRva2VucyA9PT0gbnVsbClcclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0bGV4aWNhbF9lcnJvciA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAmJiAhbGV4aWNhbF9lcnJvcjsgaSsrKVxyXG5cdFx0XHRcdFx0XHRcdGxleGljYWxfZXJyb3IgPSB0b2tlbnNbaV0ubmFtZSA9PT0gXCJsZXhpY2FsXCI7XHJcblx0XHRcdFx0XHRcdGlmKGxleGljYWxfZXJyb3IpXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdGV4cHIgPSBwYXJzZUV4cHIodGhyZWFkLCB0b2tlbnMsIDAsIHRocmVhZC5fX2dldF9tYXhfcHJpb3JpdHkoKSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRpZihudW1fdG9rZW4gJiYgbnVtX3Rva2VuLm5hbWUgPT09IFwibnVtYmVyXCIgJiYgIW51bV90b2tlbi5mbG9hdCAmJiAhbnVtX3Rva2VuLmJsYW5rICYmIGxhc3RfdG9rZW4udmFsdWUgPT09IFwiLlwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG5leHRfY2hhciA9IHN0cmVhbTIuc3RyZWFtLmdldCgxLCBzdHJlYW0yLnBvc2l0aW9uKTtcclxuXHRcdFx0XHRcdFx0XHRpZihuZXh0X2NoYXIgPj0gJzAnICYmIG5leHRfY2hhciA8PSAnOScpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHN0cmVhbTIucG9zaXRpb24rKztcclxuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gbmV4dF9jaGFyO1xyXG5cdFx0XHRcdFx0XHRcdFx0bGFzdF90b2tlbiA9IG51bGw7XHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKGxhc3RfdG9rZW4pIHtcclxuXHRcdFx0XHRcdFx0aWYobGFzdF90b2tlbi5saW5lX3Bvc2l0aW9uID09PSBsYXN0X3Rva2VuLmxlbilcclxuXHRcdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gKz0gbGFzdF90b2tlbi5saW5lX3Bvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdFx0c3RyZWFtMi5saW5lX3Bvc2l0aW9uID0gbGFzdF90b2tlbi5saW5lX3Bvc2l0aW9uO1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfY291bnQgKz0gbGFzdF90b2tlbi5saW5lX2NvdW50O1xyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQgKz0gbGFzdF90b2tlbi5sZW47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHQvLyBTdWNjZWVkIGFuYWx5emluZyB0ZXJtXHJcblx0XHRcdFx0XHRpZiggZXhwci50eXBlID09PSBTVUNDRVNTICYmIChleHByLmxlbiA9PT0gLTEgfHwgZXhwci5sZW4gPT09IHRva2Vucy5sZW5ndGgtMSAmJiBsYXN0X3Rva2VuLnZhbHVlID09PSBcIi5cIiApKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzID0ge307XHJcblx0XHRcdFx0XHRcdGV4cHIgPSBleHByLnZhbHVlLnJlbmFtZSggdGhyZWFkICk7XHJcblx0XHRcdFx0XHRcdHZhciBlcSA9IG5ldyBUZXJtKCBcIj1cIiwgW3Rlcm0sIGV4cHJdICk7XHJcblx0XHRcdFx0XHRcdC8vIFZhcmlhYmxlc1xyXG5cdFx0XHRcdFx0XHRpZiggb2JqX29wdGlvbnMudmFyaWFibGVzICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciB2YXJzID0gYXJyYXlUb0xpc3QoIG1hcCggbnViKCBleHByLnZhcmlhYmxlcygpICksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIG5ldyBWYXIodik7IH0gKSApO1xyXG5cdFx0XHRcdFx0XHRcdGVxID0gbmV3IFRlcm0oIFwiLFwiLCBbZXEsIG5ldyBUZXJtKCBcIj1cIiwgW29ial9vcHRpb25zLnZhcmlhYmxlcywgdmFyc10gKV0gKVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIFZhcmlhYmxlIG5hbWVzXHJcblx0XHRcdFx0XHRcdGlmKCBvYmpfb3B0aW9ucy52YXJpYWJsZV9uYW1lcyApIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFycyA9IG51YihleHByLnZhcmlhYmxlcygpKTtcclxuXHRcdFx0XHRcdFx0XHR2YXIgcGx2YXJzID0gW107XHJcblx0XHRcdFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHZhcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciB2ID0gdmFyc1tpXTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvciggdmFyIHByb3AgaW4gdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlcy5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKCB0aHJlYWQuc2Vzc2lvbi5yZW5hbWVkX3ZhcmlhYmxlc1sgcHJvcCBdID09PSB2ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cGx2YXJzLnB1c2gobmV3IFRlcm0oIFwiPVwiLCBbbmV3IFRlcm0oIHByb3AsIFtdKSwgbmV3IFZhcih2KV0gKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cGx2YXJzID0gYXJyYXlUb0xpc3QocGx2YXJzKTtcclxuXHRcdFx0XHRcdFx0XHRlcSA9IG5ldyBUZXJtKCBcIixcIiwgW2VxLCBuZXcgVGVybSggXCI9XCIsIFtvYmpfb3B0aW9ucy52YXJpYWJsZV9uYW1lcywgcGx2YXJzXSApXSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIFNpbmdsZXRvbnNcclxuXHRcdFx0XHRcdFx0aWYoIG9ial9vcHRpb25zLnNpbmdsZXRvbnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHZhcnMgPSBudWIobmV3IFJ1bGUoZXhwciwgbnVsbCkuc2luZ2xldG9uX3ZhcmlhYmxlcyh0cnVlKSk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHBsdmFycyA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdiA9IHZhcnNbaV07XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IoIHZhciBwcm9wIGluIHRocmVhZC5zZXNzaW9uLnJlbmFtZWRfdmFyaWFibGVzICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiggdGhyZWFkLnNlc3Npb24ucmVuYW1lZF92YXJpYWJsZXNbIHByb3AgXSA9PT0gdiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHBsdmFycy5wdXNoKG5ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBwcm9wLCBbXSksIG5ldyBWYXIodildICkpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHBsdmFycyA9IGFycmF5VG9MaXN0KHBsdmFycyk7XHJcblx0XHRcdFx0XHRcdFx0ZXEgPSBuZXcgVGVybSggXCIsXCIsIFtlcSwgbmV3IFRlcm0oIFwiPVwiLCBbb2JqX29wdGlvbnMuc2luZ2xldG9ucywgcGx2YXJzXSApXSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGVxICksIHBvaW50LnN1YnN0aXR1dGlvbiwgcG9pbnQgKV0gKTtcclxuXHRcdFx0XHRcdC8vIEZhaWxlZCBhbmFseXppbmcgdGVybVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0aWYoIGV4cHIudHlwZSA9PT0gU1VDQ0VTUyApXHJcblx0XHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5zeW50YXgoIHRva2Vuc1tleHByLmxlbl0sIFwidW5leHBlY3RlZCB0b2tlblwiLCBmYWxzZSApICk7XHJcblx0XHRcdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIGV4cHIudmFsdWUgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gd3JpdGUvMVxyXG5cdFx0XCJ3cml0ZS8xXCI6IFtcclxuXHRcdFx0bmV3IFJ1bGUobmV3IFRlcm0oXCJ3cml0ZVwiLCBbbmV3IFZhcihcIlRcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwid3JpdGVcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpXSldKSlcclxuXHRcdF0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlLzJcclxuXHRcdFwid3JpdGUvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgdGVybSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oXCJ3cml0ZV90ZXJtXCIsIFtzdHJlYW0sIHRlcm0sXHJcblx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwicXVvdGVkXCIsIFtuZXcgVGVybShcImZhbHNlXCIsIFtdKV0pLFxyXG5cdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwiaWdub3JlX29wc1wiLCBbbmV3IFRlcm0oXCJmYWxzZVwiKV0pLFxyXG5cdFx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJudW1iZXJ2YXJzXCIsIFtuZXcgVGVybShcInRydWVcIildKSwgbmV3IFRlcm0oXCJbXVwiLFtdKV0pXSldKV0pICksXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZXEvMVxyXG5cdFx0XCJ3cml0ZXEvMVwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwid3JpdGVxXCIsIFtuZXcgVmFyKFwiVFwiKV0pLCBuZXcgVGVybShcIixcIiwgW25ldyBUZXJtKFwiY3VycmVudF9vdXRwdXRcIiwgW25ldyBWYXIoXCJTXCIpXSksbmV3IFRlcm0oXCJ3cml0ZXFcIiwgW25ldyBWYXIoXCJTXCIpLG5ldyBWYXIoXCJUXCIpXSldKSlcclxuXHRcdF0sXHJcblx0XHRcclxuXHRcdC8vIHdyaXRlcS8yXHJcblx0XHRcIndyaXRlcS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgc3RyZWFtID0gYXRvbS5hcmdzWzBdLCB0ZXJtID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZSggXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybShcIndyaXRlX3Rlcm1cIiwgW3N0cmVhbSwgdGVybSxcclxuXHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJxdW90ZWRcIiwgW25ldyBUZXJtKFwidHJ1ZVwiLCBbXSldKSxcclxuXHRcdFx0XHRcdFx0bmV3IFRlcm0oXCIuXCIsIFtuZXcgVGVybShcImlnbm9yZV9vcHNcIiwgW25ldyBUZXJtKFwiZmFsc2VcIildKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwibnVtYmVydmFyc1wiLCBbbmV3IFRlcm0oXCJ0cnVlXCIpXSksIG5ldyBUZXJtKFwiW11cIixbXSldKV0pXSldKSApLFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGVfY2Fub25pY2FsLzFcclxuXHRcdFwid3JpdGVfY2Fub25pY2FsLzFcIjogW1xyXG5cdFx0XHRuZXcgUnVsZShuZXcgVGVybShcIndyaXRlX2Nhbm9uaWNhbFwiLCBbbmV3IFZhcihcIlRcIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwid3JpdGVfY2Fub25pY2FsXCIsIFtuZXcgVmFyKFwiU1wiKSxuZXcgVmFyKFwiVFwiKV0pXSkpXHJcblx0XHRdLFxyXG5cdFx0XHJcblx0XHQvLyB3cml0ZV9jYW5vbmljYWwvMlxyXG5cdFx0XCJ3cml0ZV9jYW5vbmljYWwvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgdGVybSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoIFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oXCJ3cml0ZV90ZXJtXCIsIFtzdHJlYW0sIHRlcm0sXHJcblx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwicXVvdGVkXCIsIFtuZXcgVGVybShcInRydWVcIiwgW10pXSksXHJcblx0XHRcdFx0XHRcdG5ldyBUZXJtKFwiLlwiLCBbbmV3IFRlcm0oXCJpZ25vcmVfb3BzXCIsIFtuZXcgVGVybShcInRydWVcIildKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVGVybShcIi5cIiwgW25ldyBUZXJtKFwibnVtYmVydmFyc1wiLCBbbmV3IFRlcm0oXCJmYWxzZVwiKV0pLCBuZXcgVGVybShcIltdXCIsW10pXSldKV0pXSkgKSxcclxuXHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0KV0gKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gd3JpdGVfdGVybS8yXHJcblx0XHRcIndyaXRlX3Rlcm0vMlwiOiBbXHJcblx0XHRcdG5ldyBSdWxlKG5ldyBUZXJtKFwid3JpdGVfdGVybVwiLCBbbmV3IFZhcihcIlRcIiksbmV3IFZhcihcIk9cIildKSwgbmV3IFRlcm0oXCIsXCIsIFtuZXcgVGVybShcImN1cnJlbnRfb3V0cHV0XCIsIFtuZXcgVmFyKFwiU1wiKV0pLG5ldyBUZXJtKFwid3JpdGVfdGVybVwiLCBbbmV3IFZhcihcIlNcIiksbmV3IFZhcihcIlRcIiksbmV3IFZhcihcIk9cIildKV0pKVxyXG5cdFx0XSxcclxuXHRcdFxyXG5cdFx0Ly8gd3JpdGVfdGVybS8zXHJcblx0XHRcIndyaXRlX3Rlcm0vM1wiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHN0cmVhbSA9IGF0b20uYXJnc1swXSwgdGVybSA9IGF0b20uYXJnc1sxXSwgb3B0aW9ucyA9IGF0b20uYXJnc1syXTtcclxuXHRcdFx0dmFyIHN0cmVhbTIgPSBwbC50eXBlLmlzX3N0cmVhbSggc3RyZWFtICkgPyBzdHJlYW0gOiB0aHJlYWQuZ2V0X3N0cmVhbV9ieV9hbGlhcyggc3RyZWFtLmlkICk7XHJcblx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBzdHJlYW0gKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBvcHRpb25zICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfbGlzdCggb3B0aW9ucyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbSApICYmICFwbC50eXBlLmlzX2F0b20oIHN0cmVhbSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInN0cmVhbV9vcl9hbGlhc1wiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19zdHJlYW0oIHN0cmVhbTIgKSB8fCBzdHJlYW0yLnN0cmVhbSA9PT0gbnVsbCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmV4aXN0ZW5jZSggXCJzdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggc3RyZWFtMi5pbnB1dCApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwic3RyZWFtXCIsIHN0cmVhbSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIHN0cmVhbTIudHlwZSA9PT0gXCJiaW5hcnlcIiApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwib3V0cHV0XCIsIFwiYmluYXJ5X3N0cmVhbVwiLCBzdHJlYW0sIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCBzdHJlYW0yLnBvc2l0aW9uID09PSBcInBhc3RfZW5kX29mX3N0cmVhbVwiICYmIHN0cmVhbTIuZW9mX2FjdGlvbiA9PT0gXCJlcnJvclwiICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IucGVybWlzc2lvbiggXCJvdXRwdXRcIiwgXCJwYXN0X2VuZF9vZl9zdHJlYW1cIiwgc3RyZWFtLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gR2V0IG9wdGlvbnNcclxuXHRcdFx0XHR2YXIgb2JqX29wdGlvbnMgPSB7fTtcclxuXHRcdFx0XHR2YXIgcG9pbnRlciA9IG9wdGlvbnM7XHJcblx0XHRcdFx0dmFyIHByb3BlcnR5O1xyXG5cdFx0XHRcdHdoaWxlKCBwbC50eXBlLmlzX3Rlcm0ocG9pbnRlcikgJiYgcG9pbnRlci5pbmRpY2F0b3IgPT09IFwiLi8yXCIgKSB7XHJcblx0XHRcdFx0XHRwcm9wZXJ0eSA9IHBvaW50ZXIuYXJnc1swXTtcclxuXHRcdFx0XHRcdGlmKCBwbC50eXBlLmlzX3ZhcmlhYmxlKCBwcm9wZXJ0eSApICkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc193cml0ZV9vcHRpb24oIHByb3BlcnR5ICkgKSB7XHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcIndyaXRlX29wdGlvblwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihwcm9wZXJ0eS5pbmRpY2F0b3IgPT09IFwidmFyaWFibGVfbmFtZXMvMVwiKVxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1twcm9wZXJ0eS5pZF0gPSBwcm9wZXJ0eS5hcmdzWzBdO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRvYmpfb3B0aW9uc1twcm9wZXJ0eS5pZF0gPSBwcm9wZXJ0eS5hcmdzWzBdLmlkID09PSBcInRydWVcIjtcclxuXHRcdFx0XHRcdHBvaW50ZXIgPSBwb2ludGVyLmFyZ3NbMV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCBwb2ludGVyLmluZGljYXRvciAhPT0gXCJbXS8wXCIgKSB7XHJcblx0XHRcdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggcG9pbnRlciApIClcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJsaXN0XCIsIG9wdGlvbnMsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0b2JqX29wdGlvbnMuc2Vzc2lvbiA9IHRocmVhZC5zZXNzaW9uO1xyXG5cdFx0XHRcdFx0dmFyIHRleHQgPSB0ZXJtLnRvU3RyaW5nKCBvYmpfb3B0aW9ucyApO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5zdHJlYW0ucHV0KCB0ZXh0LCBzdHJlYW0yLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRpZiggdHlwZW9mIHN0cmVhbTIucG9zaXRpb24gPT09IFwibnVtYmVyXCIgKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLnBvc2l0aW9uICs9IHRleHQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0dmFyIG5sID0gKHRleHQubWF0Y2goL1xcbi9nKSB8fCBbXSkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0c3RyZWFtMi5saW5lX2NvdW50ICs9IG5sO1xyXG5cdFx0XHRcdFx0aWYobmwgPiAwKVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gPSB0ZXh0Lmxlbmd0aCAtIHRleHQubGFzdEluZGV4T2YoXCJcXG5cIikgLSAxO1xyXG5cdFx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0XHRzdHJlYW0yLmxpbmVfcG9zaXRpb24gKz0gdGV4dC5sZW5ndGg7XHJcblx0XHRcdFx0XHRzdHJlYW0yLmNoYXJfY291bnQgKz0gdGV4dC5sZW5ndGg7XHJcblx0XHRcdFx0XHR0aHJlYWQuc3VjY2VzcyggcG9pbnQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRcclxuXHRcdC8vIElNUExFTUVOVEFUSU9OIERFRklORUQgSE9PS1NcclxuXHRcdFxyXG5cdFx0Ly8gaGFsdC8wXHJcblx0XHRcImhhbHQvMFwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgXyApIHtcclxuXHRcdFx0aWYoIHRocmVhZC5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCIgKVxyXG5cdFx0XHRcdHByb2Nlc3MuZXhpdCgpO1xyXG5cdFx0XHR0aHJlYWQucG9pbnRzID0gW107XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBoYWx0LzFcclxuXHRcdFwiaGFsdC8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgaW50ID0gYXRvbS5hcmdzWzBdO1xyXG5cdFx0XHRpZiggcGwudHlwZS5pc192YXJpYWJsZSggaW50ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfaW50ZWdlciggaW50ICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcImludGVnZXJcIiwgaW50LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYoIHRocmVhZC5nZXRfZmxhZyhcIm5vZGVqc1wiKS5pbmRpY2F0b3IgPT09IFwidHJ1ZS8wXCIgKVxyXG5cdFx0XHRcdFx0cHJvY2Vzcy5leGl0KGludC52YWx1ZSk7XHJcblx0XHRcdFx0dGhyZWFkLnBvaW50cyA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0XHJcblx0XHQvLyBjdXJyZW50X3Byb2xvZ19mbGFnLzJcclxuXHRcdFwiY3VycmVudF9wcm9sb2dfZmxhZy8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZmxhZyA9IGF0b20uYXJnc1swXSwgdmFsdWUgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKCAhcGwudHlwZS5pc192YXJpYWJsZSggZmxhZyApICYmICFwbC50eXBlLmlzX2F0b20oIGZsYWcgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFyaWFibGUoIGZsYWcgKSAmJiAhcGwudHlwZS5pc19mbGFnKCBmbGFnICkgKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5kb21haW4oIFwicHJvbG9nX2ZsYWdcIiwgZmxhZywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBzdGF0ZXMgPSBbXTtcclxuXHRcdFx0XHRmb3IoIHZhciBuYW1lIGluIHBsLmZsYWcgKSB7XHJcblx0XHRcdFx0XHRpZighcGwuZmxhZy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkgY29udGludWU7XHJcblx0XHRcdFx0XHR2YXIgZ29hbCA9IG5ldyBUZXJtKCBcIixcIiwgW25ldyBUZXJtKCBcIj1cIiwgW25ldyBUZXJtKCBuYW1lICksIGZsYWddICksIG5ldyBUZXJtKCBcIj1cIiwgW3RocmVhZC5nZXRfZmxhZyhuYW1lKSwgdmFsdWVdICldICk7XHJcblx0XHRcdFx0XHRzdGF0ZXMucHVzaCggbmV3IFN0YXRlKCBwb2ludC5nb2FsLnJlcGxhY2UoIGdvYWwgKSwgcG9pbnQuc3Vic3RpdHV0aW9uLCBwb2ludCApICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBzdGF0ZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdFxyXG5cdFx0Ly8gc2V0X3Byb2xvZ19mbGFnLzJcclxuXHRcdFwic2V0X3Byb2xvZ19mbGFnLzJcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBmbGFnID0gYXRvbS5hcmdzWzBdLCB2YWx1ZSA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGZsYWcgKSB8fCBwbC50eXBlLmlzX3ZhcmlhYmxlKCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2F0b20oIGZsYWcgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiYXRvbVwiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfZmxhZyggZmxhZyApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuZG9tYWluKCBcInByb2xvZ19mbGFnXCIsIGZsYWcsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCAhcGwudHlwZS5pc19tb2RpZmlhYmxlX2ZsYWcoIGZsYWcgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnBlcm1pc3Npb24oIFwibW9kaWZ5XCIsIFwiZmxhZ1wiLCBmbGFnLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZiggIXBsLnR5cGUuaXNfdmFsdWVfZmxhZyggZmxhZywgdmFsdWUgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmRvbWFpbiggXCJmbGFnX3ZhbHVlXCIsIG5ldyBUZXJtKCBcIitcIiwgW2ZsYWcsIHZhbHVlXSApLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyZWFkLnNlc3Npb24uZmxhZ1tmbGFnLmlkXSA9IHZhbHVlO1xyXG5cdFx0XHRcdHRocmVhZC5zdWNjZXNzKCBwb2ludCApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHJcblxyXG5cdFx0Ly8gTE9BRCBQUk9MT0cgU09VUkNFIEZJTEVTXHJcblxyXG5cdFx0Ly8gY29uc3VsdC8xXHJcblx0XHRcImNvbnN1bHQvMVwiOiBmdW5jdGlvbih0aHJlYWQsIHBvaW50LCBhdG9tKSB7XHJcblx0XHRcdHZhciBzcmMgPSBhdG9tLmFyZ3NbMF07XHJcblx0XHRcdHZhciBjb250ZXh0X21vZHVsZSA9IFwidXNlclwiO1xyXG5cdFx0XHRpZihzcmMuaW5kaWNhdG9yID09PSBcIjovMlwiKSB7XHJcblx0XHRcdFx0Y29udGV4dF9tb2R1bGUgPSBzcmMuYXJnc1swXS5pZDtcclxuXHRcdFx0XHRzcmMgPSBzcmMuYXJnc1sxXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHNyYykpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX2F0b20oc3JjKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJhdG9tXCIsIHNyYywgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHRocmVhZC5jb25zdWx0KHNyYy5pZCwge1xyXG5cdFx0XHRcdFx0Y29udGV4dF9tb2R1bGU6IGNvbnRleHRfbW9kdWxlLFxyXG5cdFx0XHRcdFx0dGV4dDogZmFsc2UsXHJcblx0XHRcdFx0XHRodG1sOiBmYWxzZSxcclxuXHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHR0aHJlYWQuc3VjY2Vzcyhwb2ludCk7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5hZ2FpbigpO1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdGVycm9yOiBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKGVycik7XHJcblx0XHRcdFx0XHRcdHRocmVhZC5hZ2FpbigpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIFRJTUUgQU5EIERBVEVTXHJcblxyXG5cdFx0Ly8gZ2V0X3RpbWUvMVxyXG5cdFx0XCJnZXRfdGltZS8xXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgdGltZSA9IGF0b20uYXJnc1swXTtcclxuXHRcdFx0aWYoIXBsLnR5cGUuaXNfdmFyaWFibGUodGltZSkgJiYgIXBsLnR5cGUuaXNfbnVtYmVyKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci50eXBlKCBcIm51bWJlclwiLCB0aW1lLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGN1cnJlbnQgPSBuZXcgTnVtKERhdGUubm93KCksIHRydWUpO1xyXG5cdFx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCI9XCIsIFt0aW1lLCBjdXJyZW50XSApICksIFxyXG5cdFx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHQpXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHRpbWVfcHJvcGVydHlcclxuXHRcdFwidGltZV9wcm9wZXJ0eS8yXCI6IGZ1bmN0aW9uKHRocmVhZCwgcG9pbnQsIGF0b20pIHtcclxuXHRcdFx0dmFyIHRpbWUgPSBhdG9tLmFyZ3NbMF0sIHByb3BlcnR5ID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKHBsLmVycm9yLmluc3RhbnRpYXRpb24oYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKHRpbWUpICYmICFwbC50eXBlLmlzX251bWJlcih0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvcihwbC5lcnJvci50eXBlKFwibnVtYmVyXCIsIHRpbWUsIGF0b20uaW5kaWNhdG9yKSk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkgJiYgIXBsLnR5cGUuaXNfdGltZV9wcm9wZXJ0eShwcm9wZXJ0eSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IocGwuZXJyb3IuZG9tYWluKFwidGltZV9wcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgYXRvbS5pbmRpY2F0b3IpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgcHJvcHM7XHJcblx0XHRcdFx0aWYocGwudHlwZS5pc192YXJpYWJsZShwcm9wZXJ0eSkpIHtcclxuXHRcdFx0XHRcdHByb3BzID0gW1wieWVhclwiLCBcIm1vbnRoXCIsIFwiZGF5XCIsIFwiaG91cnNcIiwgXCJtaW51dGVzXCIsIFwic2Vjb25kc1wiLCBcIm1pbGxpc2Vjb25kc1wiLCBcIndlZWtkYXlcIl07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHByb3BzID0gW3Byb3BlcnR5LmlkXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lLnZhbHVlKTtcclxuXHRcdFx0XHR2YXIgdmFsdWU7XHJcblx0XHRcdFx0dmFyIHN0YXRlcyA9IFtdO1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0c3dpdGNoKHByb3BzW2ldKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJ5ZWFyXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcInllYXJcIiwgW25ldyBOdW0oZGF0ZS5nZXRGdWxsWWVhcigpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIm1vbnRoXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcIm1vbnRoXCIsIFtuZXcgTnVtKGRhdGUuZ2V0TW9udGgoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJkYXlcIjpcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IG5ldyBUZXJtKFwiZGF5XCIsIFtuZXcgTnVtKGRhdGUuZ2V0RGF0ZSgpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcImhvdXJzXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcImhvdXJzXCIsIFtuZXcgTnVtKGRhdGUuZ2V0SG91cnMoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJtaW51dGVzXCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcIm1pbnV0ZXNcIiwgW25ldyBOdW0oZGF0ZS5nZXRNaW51dGVzKCksIGZhbHNlKV0pO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRjYXNlIFwic2Vjb25kc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJzZWNvbmRzXCIsIFtuZXcgTnVtKGRhdGUuZ2V0U2Vjb25kcygpLCBmYWxzZSldKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSBcIm1pbGxpc2Vjb25kc1wiOlxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gbmV3IFRlcm0oXCJtaWxsaXNlY29uZHNcIiwgW25ldyBOdW0oZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgXCJ3ZWVrZGF5XCI6XHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBuZXcgVGVybShcIndlZWtkYXlcIiwgW25ldyBOdW0oZGF0ZS5nZXREYXkoKSwgZmFsc2UpXSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdGF0ZXMucHVzaChuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbcHJvcGVydHksIHZhbHVlXSApICksIFxyXG5cdFx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoc3RhdGVzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyB0aW1lX3llYXIvMlxyXG5cdFx0XCJ0aW1lX3llYXIvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHRpbWUgPSBhdG9tLmFyZ3NbMF0sIHllYXIgPSBhdG9tLmFyZ3NbMV07XHJcblx0XHRcdGlmKHBsLnR5cGUuaXNfdmFyaWFibGUodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLmluc3RhbnRpYXRpb24oIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX251bWJlcih0aW1lKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJudW1iZXJcIiwgdGltZSwgYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXBsLnR5cGUuaXNfdmFyaWFibGUoeWVhcikgJiYgIXBsLnR5cGUuaXNfaW50ZWdlcih5ZWFyKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIHllYXIsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgdmFsdWUgPSBuZXcgTnVtKG5ldyBEYXRlKHRpbWUudmFsdWUpLmdldEZ1bGxZZWFyKCksIGZhbHNlKTtcclxuXHRcdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiPVwiLCBbeWVhciwgdmFsdWVdICkgKSwgXHJcblx0XHRcdFx0XHRwb2ludC5zdWJzdGl0dXRpb24sXHJcblx0XHRcdFx0XHRwb2ludFxyXG5cdFx0XHRcdCldICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gdGltZV9tb250aC8yXHJcblx0XHRcInRpbWVfbW9udGgvMlwiOiBmdW5jdGlvbiggdGhyZWFkLCBwb2ludCwgYXRvbSApIHtcclxuXHRcdFx0dmFyIHRpbWUgPSBhdG9tLmFyZ3NbMF0sIG1vbnRoID0gYXRvbS5hcmdzWzFdO1xyXG5cdFx0XHRpZihwbC50eXBlLmlzX3ZhcmlhYmxlKHRpbWUpKSB7XHJcblx0XHRcdFx0dGhyZWFkLnRocm93X2Vycm9yKCBwbC5lcnJvci5pbnN0YW50aWF0aW9uKCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSBpZighcGwudHlwZS5pc19udW1iZXIodGltZSkpIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwibnVtYmVyXCIsIHRpbWUsIGF0b20uaW5kaWNhdG9yICkgKTtcclxuXHRcdFx0fSBlbHNlIGlmKCFwbC50eXBlLmlzX3ZhcmlhYmxlKG1vbnRoKSAmJiAhcGwudHlwZS5pc19pbnRlZ2VyKG1vbnRoKSkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IudHlwZSggXCJpbnRlZ2VyXCIsIG1vbnRoLCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIHZhbHVlID0gbmV3IE51bShuZXcgRGF0ZSh0aW1lLnZhbHVlKS5nZXRNb250aCgpLCBmYWxzZSk7XHJcblx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIj1cIiwgW21vbnRoLCB2YWx1ZV0gKSApLCBcclxuXHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdHBvaW50XHJcblx0XHRcdFx0KV0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIEdSQU1NQVJTXHJcblxyXG5cdFx0Ly8gcGhyYXNlLzNcclxuXHRcdFwicGhyYXNlLzNcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBncmJvZHkgPSBhdG9tLmFyZ3NbMF0sIHMwID0gYXRvbS5hcmdzWzFdLCBzID0gYXRvbS5hcmdzWzJdO1xyXG5cdFx0XHR2YXIgY29udGV4dF9tb2R1bGUgPSBcInVzZXJcIjtcclxuXHRcdFx0aWYoZ3Jib2R5LmluZGljYXRvciA9PT0gXCI6LzJcIikge1xyXG5cdFx0XHRcdGNvbnRleHRfbW9kdWxlID0gZ3Jib2R5LmFyZ3NbMF0uaWQ7XHJcblx0XHRcdFx0Z3Jib2R5ID0gZ3Jib2R5LmFyZ3NbMV07XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIHBsLnR5cGUuaXNfdmFyaWFibGUoIGdyYm9keSApICkge1xyXG5cdFx0XHRcdHRocmVhZC50aHJvd19lcnJvciggcGwuZXJyb3IuaW5zdGFudGlhdGlvbiggYXRvbS5pbmRpY2F0b3IgKSApO1xyXG5cdFx0XHR9IGVsc2UgaWYoICFwbC50eXBlLmlzX2NhbGxhYmxlKCBncmJvZHkgKSApIHtcclxuXHRcdFx0XHR0aHJlYWQudGhyb3dfZXJyb3IoIHBsLmVycm9yLnR5cGUoIFwiY2FsbGFibGVcIiwgZ3Jib2R5LCBhdG9tLmluZGljYXRvciApICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGdvYWwgPSBib2R5X3RvX2RjZyggZ3Jib2R5LmNsb25lKCksIHMwLCB0aHJlYWQgKTtcclxuXHRcdFx0XHRnb2FsLnZhbHVlID0gbmV3IFRlcm0oXCI6XCIsIFtuZXcgVGVybShjb250ZXh0X21vZHVsZSksIG5ldyBUZXJtKFwiY2FsbFwiLCBbZ29hbC52YWx1ZV0pXSk7XHJcblx0XHRcdFx0aWYoZ29hbCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwiLFwiLCBbZ29hbC52YWx1ZSwgbmV3IFRlcm0oXCI9XCIsIFtnb2FsLnZhcmlhYmxlLCBzXSldICkgKSwgXHJcblx0XHRcdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XHRcdCldICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIHBocmFzZS8yXHJcblx0XHRcInBocmFzZS8yXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgZ3Jib2R5ID0gYXRvbS5hcmdzWzBdLCBzMCA9IGF0b20uYXJnc1sxXTtcclxuXHRcdFx0dGhyZWFkLnByZXBlbmQoIFtuZXcgU3RhdGUoXHJcblx0XHRcdFx0cG9pbnQuZ29hbC5yZXBsYWNlKCBuZXcgVGVybSggXCJwaHJhc2VcIiwgW2dyYm9keSwgczAsIG5ldyBUZXJtKFwiW11cIiwgW10pXSApICksIFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cclxuXHRcdC8vIFRBVSBQUk9MT0cgSU5GT1JNQVRJT05cclxuXHJcblx0XHQvLyB2ZXJzaW9uLzBcclxuXHRcdFwidmVyc2lvbi8wXCI6IGZ1bmN0aW9uKCB0aHJlYWQsIHBvaW50LCBhdG9tICkge1xyXG5cdFx0XHR2YXIgbXNnID0gXCJXZWxjb21lIHRvIFRhdSBQcm9sb2cgdmVyc2lvbiBcIiArIHZlcnNpb24ubWFqb3IgKyBcIi5cIiArIHZlcnNpb24ubWlub3IgKyBcIi5cIiArIHZlcnNpb24ucGF0Y2ggKyBcIlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJUYXUgUHJvbG9nIGNvbWVzIHdpdGggQUJTT0xVVEVMWSBOTyBXQVJSQU5UWS4gVGhpcyBpcyBmcmVlIHNvZnR3YXJlLlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJQbGVhc2UgcnVuID8tIGxpY2Vuc2UuIGZvciBsZWdhbCBkZXRhaWxzLlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJGb3Igb25saW5lIGhlbHAgYW5kIGJhY2tncm91bmQsIHZpc2l0IGh0dHA6L3RhdS1wcm9sb2cub3JnXCI7XHJcblx0XHRcdHRocmVhZC5wcmVwZW5kKCBbbmV3IFN0YXRlKFxyXG5cdFx0XHRcdHBvaW50LmdvYWwucmVwbGFjZSggbmV3IFRlcm0oIFwid3JpdGVcIiwgW25ldyBUZXJtKCBtc2csIFtdICldICkgKSwgXHJcblx0XHRcdFx0cG9pbnQuc3Vic3RpdHV0aW9uLFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdCldICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIGxpY2Vuc2UvMFxyXG5cdFx0XCJsaWNlbnNlLzBcIjogZnVuY3Rpb24oIHRocmVhZCwgcG9pbnQsIGF0b20gKSB7XHJcblx0XHRcdHZhciBtc2cgPSBcIlRhdSBQcm9sb2cuIEEgUHJvbG9nIGludGVycHJldGVyIGluIEphdmFTY3JpcHQuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIkNvcHlyaWdodCAoQykgMjAxNyAtIDIwMjIgSm9zw6kgQW50b25pbyBSaWF6YSBWYWx2ZXJkZVxcblxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCJSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIjEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXG5cIjtcclxuXHRcdFx0bXNnICs9IFwiMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxcblwiO1xyXG5cdFx0XHRtc2cgKz0gXCIzLiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSBjb3B5cmlnaHQgaG9sZGVyIG5vciB0aGUgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIlRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXFxcIkFTIElTXFxcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuXFxuXCI7XHJcblx0XHRcdG1zZyArPSBcIllvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVwiO1xyXG5cdFx0XHR0aHJlYWQucHJlcGVuZCggW25ldyBTdGF0ZShcclxuXHRcdFx0XHRwb2ludC5nb2FsLnJlcGxhY2UoIG5ldyBUZXJtKCBcIndyaXRlXCIsIFtuZXcgVGVybSggbXNnLCBbXSApXSApICksIFxyXG5cdFx0XHRcdHBvaW50LnN1YnN0aXR1dGlvbixcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHQpXSApO1xyXG5cdFx0fVxyXG5cclxuXHR9LCBcImFsbFwiLCB7XHJcblx0XHRtZXRhX3ByZWRpY2F0ZXM6IHtcclxuXHRcdFx0Ly8gJyRmaW5kYWxsJyg/LCAwLCAtLCA/KVxyXG5cdFx0XHRcIiRmaW5kYWxsLzRcIjogbmV3IFRlcm0oXCIkZmluZGFsbFwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IFRlcm0oXCItXCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gJyRiYWdvZicoPywgXiwgLSlcclxuXHRcdFx0XCIkYmFnb2YvM1wiOiBuZXcgVGVybShcIiRiYWdvZlwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIl5cIiksIG5ldyBUZXJtKFwiLVwiKV0pLFxyXG5cdFx0XHQvLyAnJHNldG9mJyg/LCBeLCAtKVxyXG5cdFx0XHRcIiRzZXRvZi8zXCI6IG5ldyBUZXJtKFwiJHNldG9mXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiXlwiKSwgbmV3IFRlcm0oXCItXCIpXSksXHJcblx0XHRcdC8vICckaWYnKDAsIDAsIDApXHJcblx0XHRcdFwiJGlmLzNcIjogbmV3IFRlcm0oXCIkaWZcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gKDA7MClcclxuXHRcdFx0XCI7LzJcIjogbmV3IFRlcm0oXCI7XCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gKDAtPjApXHJcblx0XHRcdFwiLT4vMlwiOiBuZXcgVGVybShcIi0+XCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IE51bSgwLCBmYWxzZSldKSxcclxuXHRcdFx0Ly8gKDAtPjApXHJcblx0XHRcdFwiKi0+LzJcIjogbmV3IFRlcm0oXCIqLT5cIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyAoXFwrMClcclxuXHRcdFx0XCJcXFxcKy8xXCI6IG5ldyBUZXJtKFwiXFxcXCtcIiwgW25ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIGFib2xpc2goOilcclxuXHRcdFx0XCJhYm9saXNoLzFcIjogbmV3IFRlcm0oXCJhYm9saXNoXCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gYXNzZXJ0YSg6KVxyXG5cdFx0XHRcImFzc2VydGEvMVwiOiBuZXcgVGVybShcImFzc2VydGFcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBhc3NlcnR6KDopXHJcblx0XHRcdFwiYXNzZXJ0ei8xXCI6IG5ldyBUZXJtKFwiYXNzZXJ0elwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIGJhZ29mKD8sIF4sIC0pXHJcblx0XHRcdFwiYmFnb2YvM1wiOiBuZXcgVGVybShcImJhZ29mXCIsIFtuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiXlwiKSwgbmV3IFRlcm0oXCItXCIpXSksXHJcblx0XHRcdC8vIGNhbGwoMClcclxuXHRcdFx0XCJjYWxsLzFcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDEsID8pXHJcblx0XHRcdFwiY2FsbC8yXCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSgxLCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDIsID8sID8pXHJcblx0XHRcdFwiY2FsbC8zXCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSgyLCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoMywgPywgPywgPylcclxuXHRcdFx0XCJjYWxsLzRcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDMsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDQsID8sID8sID8sID8pXHJcblx0XHRcdFwiY2FsbC81XCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSg0LCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDUsID8sID8sID8sID8sID8pXHJcblx0XHRcdFwiY2FsbC82XCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSg1LCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIGNhbGwoNiwgPywgPywgPywgPywgPywgPylcclxuXHRcdFx0XCJjYWxsLzdcIjogbmV3IFRlcm0oXCJjYWxsXCIsIFtuZXcgTnVtKDYsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsKDcsID8sID8sID8sID8sID8sID8sID8pXHJcblx0XHRcdFwiY2FsbC84XCI6IG5ldyBUZXJtKFwiY2FsbFwiLCBbbmV3IE51bSg2LCBmYWxzZSksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIj9cIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjYWxsX2NsZWFudXAoMCwgMClcclxuXHRcdFx0XCJjYWxsX2NsZWFudXAvMlwiOiBuZXcgVGVybShcImNhbGxfY2xlYW51cFwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpXSksXHJcblx0XHRcdC8vIGNhdGNoKDAsID8sIDApXHJcblx0XHRcdFwiY2F0Y2gvM1wiOiBuZXcgVGVybShcImNhdGNoXCIsIFtuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IFRlcm0oXCI/XCIpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBjb25zdWx0KDopXHJcblx0XHRcdFwiY29uc3VsdC8xXCI6IG5ldyBUZXJtKFwiY29uc3VsdFwiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIGNsYXVzZSg6LCA/KVxyXG5cdFx0XHRcImNsYXVzZS8yXCI6IG5ldyBUZXJtKFwiY2xhdXNlXCIsIFtuZXcgVGVybShcIjpcIiksIG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBjdXJyZW50X3ByZWRpY2F0ZSg/LCA6KVxyXG5cdFx0XHRcImN1cnJlbnRfcHJlZGljYXRlLzJcIjogbmV3IFRlcm0oXCJjdXJyZW50X3ByZWRpY2F0ZVwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gZmluZGFsbCg/LCAwLCAtKVxyXG5cdFx0XHRcImZpbmRhbGwvM1wiOiBuZXcgVGVybShcImZpbmRhbGxcIiwgW25ldyBUZXJtKFwiP1wiKSwgbmV3IE51bSgwLCBmYWxzZSksIG5ldyBUZXJtKFwiLVwiKV0pLFxyXG5cdFx0XHQvLyBmaW5kYWxsKD8sIDAsIC0sID8pXHJcblx0XHRcdFwiZmluZGFsbC80XCI6IG5ldyBUZXJtKFwiZmluZGFsbFwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgTnVtKDAsIGZhbHNlKSwgbmV3IFRlcm0oXCItXCIpLCBuZXcgVGVybShcIj9cIildKSxcclxuXHRcdFx0Ly8gZm9yYWxsKDAsIDApXHJcblx0XHRcdFwiZm9yYWxsLzJcIjogbmV3IFRlcm0oXCJmb3JhbGxcIiwgW25ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBsaXN0aW5nKDopXHJcblx0XHRcdFwibGlzdGluZy8xXCI6IG5ldyBUZXJtKFwibGlzdGluZ1wiLCBbbmV3IFRlcm0oXCI6XCIpXSksXHJcblx0XHRcdC8vIG9uY2UoMClcclxuXHRcdFx0XCJvbmNlLzFcIjogbmV3IFRlcm0oXCJvbmNlXCIsIFtuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBwaHJhc2UoOiwgPylcclxuXHRcdFx0XCJwaHJhc2UvMlwiOiBuZXcgVGVybShcInBocmFzZVwiLCBbbmV3IFRlcm0oXCI6XCIpLG5ldyBUZXJtKFwiP1wiKV0pLFxyXG5cdFx0XHQvLyBwaHJhc2UoOiwgPywgPylcclxuXHRcdFx0XCJwaHJhc2UvM1wiOiBuZXcgVGVybShcInBocmFzZVwiLCBbbmV3IFRlcm0oXCI6XCIpLG5ldyBUZXJtKFwiP1wiKSwgbmV3IFRlcm0oXCI/XCIpXSksXHJcblx0XHRcdC8vIHJldHJhY3QoOilcclxuXHRcdFx0XCJyZXRyYWN0LzFcIjogbmV3IFRlcm0oXCJyZXRyYWN0XCIsIFtuZXcgVGVybShcIjpcIildKSxcclxuXHRcdFx0Ly8gcmV0cmFjdGFsbCg6KVxyXG5cdFx0XHRcInJldHJhY3RhbGwvMVwiOiBuZXcgVGVybShcInJldHJhY3RhbGxcIiwgW25ldyBUZXJtKFwiOlwiKV0pLFxyXG5cdFx0XHQvLyBzZXR1cF9jYWxsX2NsZWFudXAoMCwgMCwgMClcclxuXHRcdFx0XCJzZXR1cF9jYWxsX2NsZWFudXAvM1wiOiBuZXcgVGVybShcInNldHVwX2NhbGxfY2xlYW51cFwiLCBbbmV3IE51bSgwLCBmYWxzZSksIG5ldyBOdW0oMCwgZmFsc2UpLCBuZXcgTnVtKDAsIGZhbHNlKV0pLFxyXG5cdFx0XHQvLyBzZXRvZig/LCBeLCAtKVxyXG5cdFx0XHRcInNldG9mLzNcIjogbmV3IFRlcm0oXCJzZXRvZlwiLCBbbmV3IFRlcm0oXCI/XCIpLCBuZXcgVGVybShcIl5cIiksIG5ldyBUZXJtKFwiLVwiKV0pXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyApIHtcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gcGw7XHJcblx0fSBlbHNlIHtcclxuXHRcdHdpbmRvdy5wbCA9IHBsO1xyXG5cdH1cclxuXHRcclxufSkoKTtcclxuIiwidmFyIHBsO1xyXG4oZnVuY3Rpb24ocGwpIHtcclxuXHJcblx0Ly8gRXh0ZW5kIFRhdSBQcm9sb2cgcHJvdG90eXBlc1xyXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbihwbCkge1xyXG5cclxuXHRcdC8vIENvbnN1bHQgYSBwcm9ncmFtIGZyb20gYSBzdHJpbmdcclxuXHRcdHBsLnR5cGUuU2Vzc2lvbi5wcm90b3R5cGUucHJvbWlzZUNvbnN1bHQgPSBmdW5jdGlvbihwcm9ncmFtLCBvcHRpb25zKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLnRocmVhZC5wcm9taXNlQ29uc3VsdChwcm9ncmFtLCBvcHRpb25zKTtcclxuXHRcdH07XHJcblxyXG5cdFx0cGwudHlwZS5UaHJlYWQucHJvdG90eXBlLnByb21pc2VDb25zdWx0ID0gZnVuY3Rpb24ocHJvZ3JhbSwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0XHRcdHZhciBvcHRzID0ge307XHJcblx0XHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/IHt9IDogb3B0aW9ucztcclxuXHRcdFx0XHRvcHRzLmNvbnRleHRfbW9kdWxlID0gb3B0aW9ucy5jb250ZXh0X21vZHVsZTtcclxuXHRcdFx0XHRvcHRzLnRleHQgPSBvcHRpb25zLnRleHQ7XHJcblx0XHRcdFx0b3B0cy5odG1sID0gb3B0aW9ucy5odG1sO1xyXG5cdFx0XHRcdG9wdHMudXJsID0gb3B0aW9ucy51cmw7XHJcblx0XHRcdFx0b3B0cy5maWxlID0gb3B0aW9ucy5maWxlO1xyXG5cdFx0XHRcdG9wdHMuc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQ7XHJcblx0XHRcdFx0b3B0cy5zdWNjZXNzID0gcmVzb2x2ZTtcclxuXHRcdFx0XHRvcHRzLmVycm9yID0gcmVqZWN0O1xyXG5cdFx0XHRcdHRocmVhZC5jb25zdWx0KHByb2dyYW0sIG9wdHMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gUXVlcnkgZ29hbCBmcm9tIGEgc3RyaW5nICh3aXRob3V0ID8tKVxyXG5cdFx0cGwudHlwZS5TZXNzaW9uLnByb3RvdHlwZS5wcm9taXNlUXVlcnkgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGhyZWFkLnByb21pc2VRdWVyeShzdHJpbmcpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRwbC50eXBlLlRocmVhZC5wcm90b3R5cGUucHJvbWlzZVF1ZXJ5ID0gZnVuY3Rpb24oc3RyaW5nKSB7XHJcblx0XHRcdHZhciB0aHJlYWQgPSB0aGlzO1xyXG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblx0XHRcdFx0dGhyZWFkLnF1ZXJ5KHN0cmluZywge1xyXG5cdFx0XHRcdFx0c3VjY2VzczogcmVzb2x2ZSxcclxuXHRcdFx0XHRcdGVycm9yOiByZWplY3RcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEZpbmQgbmV4dCBjb21wdXRlZCBhbnN3ZXJcclxuXHRcdHBsLnR5cGUuU2Vzc2lvbi5wcm90b3R5cGUucHJvbWlzZUFuc3dlciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy50aHJlYWQucHJvbWlzZUFuc3dlcigpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRwbC50eXBlLlRocmVhZC5wcm90b3R5cGUucHJvbWlzZUFuc3dlciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdGhyZWFkID0gdGhpcztcclxuXHRcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0XHRcdHRocmVhZC5hbnN3ZXIoe1xyXG5cdFx0XHRcdFx0c3VjY2VzczogcmVzb2x2ZSxcclxuXHRcdFx0XHRcdGZhaWw6IHJlc29sdmUsXHJcblx0XHRcdFx0XHRlcnJvcjogcmVqZWN0LFxyXG5cdFx0XHRcdFx0bGltaXQ6IHJlamVjdFxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gRmluZCBhbGwgY29tcHV0ZWQgYW5zd2VycyAoYXN5bmNocm9ub3VzIGdlbmVyYXRvciBmdW5jdGlvbilcclxuXHRcdHBsLnR5cGUuU2Vzc2lvbi5wcm90b3R5cGUucHJvbWlzZUFuc3dlcnMgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMudGhyZWFkLnByb21pc2VBbnN3ZXJzKCk7XHJcblx0XHR9O1xyXG5cdFx0cGwudHlwZS5UaHJlYWQucHJvdG90eXBlLnByb21pc2VBbnN3ZXJzID0gYXN5bmMgZnVuY3Rpb24qKCkge1xyXG5cdFx0XHR3aGlsZSh0cnVlKSB7XHJcblx0XHRcdFx0dmFyIGFuc3dlciA9IGF3YWl0IHRoaXMucHJvbWlzZUFuc3dlcigpO1xyXG5cdFx0XHRcdGlmKGFuc3dlciAhPT0gZmFsc2UpXHJcblx0XHRcdFx0XHR5aWVsZCBhbnN3ZXI7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdGlmKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHApIHtcclxuXHRcdFx0cGwgPSBwO1xyXG5cdFx0XHRleHRlbmQocGwpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZXh0ZW5kKHBsKTtcclxuXHR9XHJcblxyXG59KShwbCk7IiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiYmlnXCIsXG4gICAgXCJzbWFsbFwiLFxuICAgIFwiaGVscGZ1bFwiLFxuICAgIFwicmVkXCIsXG4gICAgXCJibGFja1wiLFxuICAgIFwiZ3JlYXRcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImlzXCIsXG4gICAgXCJhcmVcIixcbiAgICBcImJlXCJcbl0iLCJleHBvcnQgZGVmYXVsdFtcbiAgICBcInRoZVwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwic29tZVwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZG9cIixcbiAgICBcImRvZXNcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImFcIixcbiAgICBcImFuXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJleGlzdFwiLFxuICAgIFwiZXhpc3RzXCIsXG4gICAgXCJydW5cIixcbiAgICBcImdyb3dcIixcbiAgICBcImRpZVwiLFxuICAgIFwibGl2ZVwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiZWF0XCIsXG4gICAgXCJkcmlua1wiLFxuICAgIFwid2F0Y2hcIixcbiAgICBcIm1ha2VcIixcbiAgICBcImhpdFwiLFxuICAgIFwiY2xpY2tcIlxuXSIsImV4cG9ydCBkZWZhdWx0IFtcbiAgICBcImRvZXNuJ3RcIixcbiAgICBcImRvZXMgbm90XCIsXG4gICAgJ25vdCcsXG4gICAgXCJkb24ndFwiLFxuICAgICdkbyBub3QnXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiYW5kXCIsXG4gICAgXCJvclwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiY2F0XCIsXG4gICAgXCJtYXRcIixcbiAgICBcInRhYmxlXCIsXG4gICAgXCJkb2dcIixcbiAgICBcIm5vZGVqc1wiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImJ1dHRvblwiLFxuICAgIFwiZGl2XCIsXG4gICAgXCJwcmVzaWRlbnRcIixcbiAgICBcInRydW1wXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJ0b1wiLFxuICAgIFwid2l0aFwiLFxuICAgIFwiZnJvbVwiLFxuICAgIFwib2ZcIixcbiAgICBcIm92ZXJcIixcbiAgICBcIm9uXCIsXG4gICAgXCJhdFwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwidGhhdFwiXG5dIiwiZXhwb3J0IGRlZmF1bHQgW1xuICAgIFwiaWZcIixcbiAgICBcIndoZW5cIixcbiAgICBcImJlY2F1c2VcIixcbiAgICBcIndoaWxlXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJ0aGVuXCJcbl0iLCJleHBvcnQgZGVmYXVsdCBbXG4gICAgXCJldmVyeVwiLFxuICAgIFwiYWxsXCIsXG4gICAgXCJlYWNoXCIsXG4gICAgXCJhbnlcIlxuXSIsImltcG9ydCBCcmFpbiwgeyBBc3NlcnRPcHRzIH0gZnJvbSBcIi4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgeyBDbGF1c2UgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCB7IElkIH0gZnJvbSBcIi4uL2NsYXVzZXMvSWRcIjtcbmltcG9ydCB7IGdldEFjdGlvbiB9IGZyb20gXCIuL2FjdGlvbnMvQWN0aW9uXCI7XG5pbXBvcnQgeyBFZCB9IGZyb20gXCIuL0VkXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVyZmFjZSBBY3R1YXRvciB7XG4gICAgb25VcGRhdGUoY2xhdXNlczogQ2xhdXNlW10pOiBQcm9taXNlPHZvaWQ+IC8vIHVwZGF0ZSBmcm9tIHRvcCAoQnJhaW4pXG4gICAgcG9pbnRPdXQoaWRzOiBJZFtdKTogUHJvbWlzZTx2b2lkPlxuICAgIG9uU2Vuc2UoY2xhdXNlczogQ2xhdXNlW10sIG9wdHM/OkFzc2VydE9wdHMpOiBQcm9taXNlPHZvaWQ+IC8vIHVwZGF0ZSBmcm9tIGJvdHRvbSAoQWN0aW9uLCBTZW5zb3IgLi4uKVxuICAgIHJlYWRvbmx5IGVkOiBFZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0dWF0b3IoYnJhaW46IEJyYWluKTogQWN0dWF0b3Ige1xuICAgIHJldHVybiBuZXcgQmFzZUFjdHVhdG9yKGJyYWluKVxufVxuXG5jbGFzcyBCYXNlQWN0dWF0b3IgaW1wbGVtZW50cyBBY3R1YXRvciB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBicmFpbjogQnJhaW4sIHJlYWRvbmx5IGVkID0gYnJhaW4uZWQpIHtcblxuICAgIH1cblxuICAgIG9uVXBkYXRlID0gYXN5bmMgKGNsYXVzZXM6IENsYXVzZVtdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG5cbiAgICAgICAgY2xhdXNlcy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgZ2V0QWN0aW9uKGMsIHRoaXMuYnJhaW4uZWQsIHRoaXMpLnJ1bigpXG4gICAgICAgIH0pXG5cbiAgICB9XG5cbiAgICBwb2ludE91dCA9IGFzeW5jIChpZHM6IElkW10pOiBQcm9taXNlPHZvaWQ+ID0+IHtcblxuICAgICAgICB0aGlzLmJyYWluLmVkLnZhbHVlcy5mb3JFYWNoKG8gPT4ge1xuICAgICAgICAgICAgby5zdHlsZT8gby5zdHlsZS5vdXRsaW5lID0gJycgOiAwXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWRzLmZvckVhY2goaWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbSA9IHRoaXMuYnJhaW4uZWQuZ2V0KGlkKVxuICAgICAgICAgICAgZWxlbSAmJiBlbGVtLnN0eWxlID8gZWxlbS5zdHlsZS5vdXRsaW5lID0gJyNmMDAgc29saWQgMnB4JyA6IDBcbiAgICAgICAgfSlcblxuICAgIH1cblxuICAgIG9uU2Vuc2UgPSBhc3luYyAoY2xhdXNlczogQ2xhdXNlW10sIG9wdHM/OkFzc2VydE9wdHMpOiBQcm9taXNlPHZvaWQ+ID0+IHtcblxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY2xhdXNlcykge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5icmFpbi5hc3NlcnQoYywgb3B0cylcbiAgICAgICAgfVxuXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi4vY2xhdXNlcy9JZFwiO1xuXG4vKipcbiAqIEVudGl0eSBEaWN0aW9uYXJ5Li4uIChvciBFdmVyZXR0IER1Y2tsYWlyKVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEVkIHtcbiAgICBnZXQoaWQ6IElkKTogYW55XG4gICAgc2V0KGlkOiBJZCwgb2JqZWN0OiBhbnkpOiB2b2lkXG4gICAgZ2V0IGtleXMoKTpJZFtdXG4gICAgZ2V0IHZhbHVlcygpOmFueVtdXG5cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RWQoKTogRWQge1xuICAgIHJldHVybiBuZXcgQmFzZUVkKClcbn1cblxuXG5jbGFzcyBCYXNlRWQgaW1wbGVtZW50cyBFZCB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBkaWN0aW9uYXJ5OiB7IFtpZDogSWRdOiBhbnkgfSA9IHt9KSB7XG5cbiAgICB9XG5cbiAgICBnZXQoaWQ6IElkKSB7IC8vVE9ETyBjb25zaWRlciBtYWtpbmcgYXN5bmMgXG4gICAgICAgIHJldHVybiB0aGlzLmRpY3Rpb25hcnlbaWRdXG4gICAgfVxuXG4gICAgc2V0KGlkOiBJZCwgb2JqZWN0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaWN0aW9uYXJ5W2lkXSA9IG9iamVjdFxuICAgIH1cblxuICAgIGdldCBrZXlzKCk6SWRbXXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGljdGlvbmFyeSlcbiAgICB9XG5cbiAgICBnZXQgdmFsdWVzKCk6SWRbXXtcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5kaWN0aW9uYXJ5KVxuICAgIH1cblxufSIsImltcG9ydCB7IEJhc2ljQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQmFzaWNDbGF1c2VcIjtcbmltcG9ydCB7IENsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IEFjdHVhdG9yIGZyb20gXCIuLi9BY3R1YXRvclwiO1xuaW1wb3J0IHsgRWQgfSBmcm9tIFwiLi4vRWRcIjtcbmltcG9ydCB7IENoYW5nZUNvbG9yIH0gZnJvbSBcIi4vQ2hhbmdlQ29sb3JcIjtcbmltcG9ydCB7IE1ha2VCdXR0b24gfSBmcm9tIFwiLi9NYWtlQnV0dG9uXCI7XG5pbXBvcnQgeyBOb09wIH0gZnJvbSBcIi4vTm9PcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgQWN0aW9uIHtcbiAgICBydW4oKTogUHJvbWlzZTx2b2lkPlxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uKGNsYXVzZTogQ2xhdXNlLCBlZDogRWQsIGFjdHVhdG9yOkFjdHVhdG9yKTogQWN0aW9uIHtcblxuICAgIGlmIChjbGF1c2UgaW5zdGFuY2VvZiBCYXNpY0NsYXVzZSkgeyAvLyBUT0RPOiBET04nVCBFWFBPU0UgQ0xBU1MhIVxuXG4gICAgICAgIHN3aXRjaCAoY2xhdXNlLnByZWRpY2F0ZSkge1xuXG4gICAgICAgICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFrZUJ1dHRvbihjbGF1c2UuYXJnc1swXSwgZWQsIGFjdHVhdG9yKVxuXG4gICAgICAgICAgICBjYXNlICdyZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlQ29sb3IoY2xhdXNlLmFyZ3NbMF0sICdyZWQnLCBlZClcblxuICAgICAgICAgICAgY2FzZSAnZ3JlZW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhbmdlQ29sb3IoY2xhdXNlLmFyZ3NbMF0sICdncmVlbicsIGVkKVxuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTm9PcChjbGF1c2UpXG5cbn1cblxuIiwiaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9JZFwiO1xuaW1wb3J0IHsgRWQgfSBmcm9tIFwiLi4vRWRcIjtcbmltcG9ydCBBY3Rpb24gZnJvbSBcIi4vQWN0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBDaGFuZ2VDb2xvciBpbXBsZW1lbnRzIEFjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBpZDogSWQsIHJlYWRvbmx5IGNvbG9yOiBzdHJpbmcsIHJlYWRvbmx5IGVkOiBFZCkge1xuXG4gICAgfVxuXG4gICAgYXN5bmMgcnVuKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIGNvbnN0IG9iamVjdDogSFRNTEVsZW1lbnQgPSB0aGlzLmVkLmdldCh0aGlzLmlkKVxuICAgICAgICBvYmplY3Quc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuY29sb3JcblxuICAgIH1cbn1cbiIsImltcG9ydCB7IGNsYXVzZU9mIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBnZXRSYW5kb21JZCwgSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9JZFwiO1xuaW1wb3J0IEFjdHVhdG9yIGZyb20gXCIuLi9BY3R1YXRvclwiO1xuaW1wb3J0IHsgRWQgfSBmcm9tIFwiLi4vRWRcIjtcbmltcG9ydCB7IG1ha2VTZW5zb3IgfSBmcm9tIFwiLi4vc2Vuc29ycy9TZW5zb3JcIjtcbmltcG9ydCBBY3Rpb24gZnJvbSBcIi4vQWN0aW9uXCI7XG5cbmV4cG9ydCBjbGFzcyBNYWtlQnV0dG9uIGltcGxlbWVudHMgQWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGlkOiBJZCwgcmVhZG9ubHkgZWQ6IEVkLCByZWFkb25seSBhY3R1YXRvcjpBY3R1YXRvcikge1xuICAgICAgICBcbiAgICB9XG5cbiAgICBhc3luYyBydW4oKTogUHJvbWlzZTx2b2lkPiB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVkLmdldCh0aGlzLmlkKSkge1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJylcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lclRleHQgPSAnYnV0dG9uJ1xuICAgICAgICAgICAgYnV0dG9uLmlkID0gdGhpcy5pZC50b1N0cmluZygpXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJ1dHRvbilcbiAgICAgICAgICAgIHRoaXMuZWQuc2V0KHRoaXMuaWQsIGJ1dHRvbilcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAvLyBhZGRpbmcgYSBzdHlsZS1vZi1idXR0b24gZW50aXR5XG4gICAgICAgICAgICBjb25zdCBzdHlsZUlkID0gZ2V0UmFuZG9tSWQoKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYnV0dG9uLmlkLCBzdHlsZUlkKVxuICAgICAgICAgICAgY29uc3QgY2xhdXNlcyA9IFtjbGF1c2VPZignc3R5bGUnLCBzdHlsZUlkKSwgY2xhdXNlT2YoJ29mJywgc3R5bGVJZCwgdGhpcy5pZCkgICAgICAgIF1cbiAgICAgICAgICAgIHRoaXMuZWQuc2V0KHN0eWxlSWQsIGJ1dHRvbi5zdHlsZSlcbiAgICAgICAgICAgIHRoaXMuYWN0dWF0b3Iub25TZW5zZShjbGF1c2VzLCB7IG5vQW5hcGhvcmEgOiB0cnVlIH0pXG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgbWFrZVNlbnNvcih0aGlzLmFjdHVhdG9yLCB0aGlzLmlkLCBidXR0b24pXG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsImltcG9ydCB7IENsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IEFjdGlvbiBmcm9tIFwiLi9BY3Rpb25cIjtcblxuZXhwb3J0IGNsYXNzIE5vT3AgaW1wbGVtZW50cyBBY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY2xhdXNlOiBDbGF1c2UpIHtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgYXN5bmMgcnVuKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIGFjdGlvbiBjb3JyZXNwb25kaW5nIHRvIHByZWRpY2F0ZTogJHt0aGlzLmNsYXVzZS50b1Byb2xvZygpfWApXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2xhdXNlT2YgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCB7IElkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvSWRcIjtcbmltcG9ydCBBY3R1YXRvciBmcm9tIFwiLi4vQWN0dWF0b3JcIjtcbmltcG9ydCB7IFNlbnNvciB9IGZyb20gXCIuL1NlbnNvclwiO1xuXG5leHBvcnQgY2xhc3MgQ2xpY2tTZW5zb3IgaW1wbGVtZW50cyBTZW5zb3Ige1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgaWQ6IElkLCByZWFkb25seSBvYmplY3Q6IEVsZW1lbnQsIHJlYWRvbmx5IGFjdHVhdG9yOiBBY3R1YXRvcikge1xuXG4gICAgICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGFjdHVhdG9yLm9uU2Vuc2UoW2NsYXVzZU9mKCdjbGlja2VkJywgaWQpXSk7XG4gICAgICAgIH0pO1xuXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9JZFwiO1xuaW1wb3J0IEFjdHVhdG9yIGZyb20gXCIuLi9BY3R1YXRvclwiO1xuaW1wb3J0IHsgQ2xpY2tTZW5zb3IgfSBmcm9tIFwiLi9DbGlja1NlbnNvclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNlbnNvciB7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTZW5zb3IoYWN0dWF0b3I6IEFjdHVhdG9yLCBpZDogSWQsIG9iamVjdDogRWxlbWVudCk6IFNlbnNvciB7XG4gICAgcmV0dXJuIG5ldyBDbGlja1NlbnNvcihpZCwgb2JqZWN0LCBhY3R1YXRvcilcbn1cblxuXG4iLCJpbXBvcnQgeyBUb0NsYXVzZU9wdHMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlLCBjbGF1c2VPZiB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IHsgZ2V0UmFuZG9tSWQsIElkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvSWRcIjtcbmltcG9ydCBQaHJhc2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvUGhyYXNlXCI7XG5pbXBvcnQgUHJlcG9zaXRpb24gZnJvbSBcIi4uL3Rva2Vucy9QcmVwb3NpdGlvblwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4vTm91blBocmFzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wbGVtZW50IGltcGxlbWVudHMgUGhyYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHByZXBvc2l0aW9uOiBQcmVwb3NpdGlvbiwgcmVhZG9ubHkgbm91blBocmFzZTogTm91blBocmFzZSkge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvQ2xhdXNlT3B0cyk6IENsYXVzZSB7IC8vIHByZXBvc2l0aW9uKGFyZ3Muc3ViamVjdCwgWSkgKyBub3VucGhyYXNlLnRvUHJvbG9nKHN1YmplY3Q9WSlcblxuICAgICAgICBjb25zdCBzdWJqSWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyAoKCk6IElkID0+IHsgdGhyb3cgbmV3IEVycm9yKCd1bmRlZmluZWQgc3ViamVjdCBpZCcpIH0pKClcbiAgICAgICAgY29uc3QgbmV3SWQgPSBnZXRSYW5kb21JZCgpXG5cbiAgICAgICAgcmV0dXJuIGNsYXVzZU9mKHRoaXMucHJlcG9zaXRpb24uc3RyaW5nLCBzdWJqSWQsIG5ld0lkKVxuICAgICAgICAgICAgLmFuZCh0aGlzLm5vdW5QaHJhc2UudG9DbGF1c2UoeyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBuZXdJZCB9IH0pKVxuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxufSIsImltcG9ydCB7IFRvQ2xhdXNlT3B0cyB9IGZyb20gXCIuLi9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgeyBDbGF1c2UgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCBTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IENvcHVsYSBmcm9tIFwiLi4vdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tIFwiLi4vdG9rZW5zL1JlbGF0aXZlUHJvbm91blwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4vTm91blBocmFzZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSBpbXBsZW1lbnRzIFN1Ym9yZGluYXRlQ2xhdXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHJlYWRvbmx5IHJlbHByb246IFJlbGF0aXZlUHJvbm91biwgcmVhZG9ubHkgcHJlZGljYXRlOiBOb3VuUGhyYXNlLCByZWFkb25seSBjb3B1bGE6IENvcHVsYSkge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvQ2xhdXNlT3B0cyk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWRpY2F0ZS50b0NsYXVzZSh7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IGFyZ3M/LnJvbGVzPy5zdWJqZWN0IH0gfSlcbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG59IiwiaW1wb3J0IFBocmFzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9QaHJhc2VcIjtcbmltcG9ydCBBZGplY3RpdmUgZnJvbSBcIi4uL3Rva2Vucy9BZGplY3RpdmVcIjtcbmltcG9ydCBBcnRpY2xlIGZyb20gXCIuLi90b2tlbnMvQXJ0aWNsZVwiO1xuaW1wb3J0IE5vdW4gZnJvbSBcIi4uL3Rva2Vucy9Ob3VuXCI7XG5pbXBvcnQgUXVhbnRpZmllciBmcm9tIFwiLi4vdG9rZW5zL1F1YW50aWZpZXJcIjtcbmltcG9ydCBDb21wbGVtZW50IGZyb20gXCIuL0NvbXBsZW1lbnRcIjtcbmltcG9ydCBTdWJvcmRpbmF0ZUNsYXVzZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IHsgVG9DbGF1c2VPcHRzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgY2xhdXNlT2YsIGVtcHR5Q2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBnZXRSYW5kb21JZCB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0lkXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdW5QaHJhc2UgaW1wbGVtZW50cyBQaHJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgYWRqZWN0aXZlczogQWRqZWN0aXZlW10sXG4gICAgICAgIHJlYWRvbmx5IGNvbXBsZW1lbnRzOiBDb21wbGVtZW50W10sXG4gICAgICAgIHJlYWRvbmx5IG5vdW4/OiBOb3VuLFxuICAgICAgICByZWFkb25seSBxdWFudGlmaWVyPzogUXVhbnRpZmllcixcbiAgICAgICAgcmVhZG9ubHkgYXJ0aWNsZT86IEFydGljbGUsXG4gICAgICAgIHJlYWRvbmx5IHN1Ym9yZENsYXVzZT86IFN1Ym9yZGluYXRlQ2xhdXNlKSB7XG5cbiAgICB9XG5cbiAgICBpc1VuaVF1YW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWFudGlmaWVyPy5pc1VuaXZlcnNhbCgpID8/IGZhbHNlXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvQ2xhdXNlT3B0cyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoKVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgICAgIC5hZGplY3RpdmVzXG4gICAgICAgICAgICAubWFwKGEgPT4gYS5zdHJpbmcpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMubm91biA/IFt0aGlzLm5vdW4uc3RyaW5nXSA6IFtdKVxuICAgICAgICAgICAgLm1hcChwID0+IGNsYXVzZU9mKHAsIHN1YmplY3RJZCkpXG4gICAgICAgICAgICAucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMiksIGVtcHR5Q2xhdXNlKCkpXG4gICAgICAgICAgICAuYW5kKHRoaXMuY29tcGxlbWVudHMubWFwKGMgPT4gYy50b0NsYXVzZShuZXdBcmdzKSkucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMiksIGVtcHR5Q2xhdXNlKCkpKVxuICAgICAgICAgICAgLmFuZCh0aGlzLnN1Ym9yZENsYXVzZT8udG9DbGF1c2UobmV3QXJncykgPz8gZW1wdHlDbGF1c2UoKSlcblxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbn0iLCJpbXBvcnQgQ29tcG91bmRTZW50ZW5jZSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db21wb3VuZFNlbnRlbmNlXCI7XG5pbXBvcnQgeyBUb0NsYXVzZU9wdHMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBnZXRSYW5kb21JZCB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0lkXCI7XG5pbXBvcnQgU2ltcGxlU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvU2ltcGxlU2VudGVuY2VcIjtcbmltcG9ydCBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZnJvbSBcIi4uL3Rva2Vucy9TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb25cIjtcblxuLyoqXG4gKiBBIHNlbnRlbmNlIHRoYXQgcmVsYXRlcyB0d28gc2ltcGxlIHNlbnRlbmNlcyBoeXBvdGFjdGljYWxseSwgaW4gYSBcbiAqIGNvbmRpdGlvbi1vdXRjb21lIHJlbGF0aW9uc2hpcC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcGxleFNlbnRlbmNlIGltcGxlbWVudHMgQ29tcG91bmRTZW50ZW5jZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBjb25kaXRpb246IFNpbXBsZVNlbnRlbmNlLFxuICAgICAgICByZWFkb25seSBvdXRjb21lOiBTaW1wbGVTZW50ZW5jZSxcbiAgICAgICAgcmVhZG9ubHkgc3ViY29uajogU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uKSB7XG5cbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9DbGF1c2VPcHRzKTogQ2xhdXNlIHtcblxuICAgICAgICAvLyBUT0RPOiBzb21ldGltZXMgdGhlIGNvbmRpdGlvbiBhbmQgb3V0Y29tZSBoYXZlIHRoZSBTQU1FIHN1YmplY3RcbiAgICAgICAgY29uc3QgbmV3QXJnczEgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IGdldFJhbmRvbUlkKCkgfSB9XG4gICAgICAgIGNvbnN0IG5ld0FyZ3MyID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBnZXRSYW5kb21JZCgpIH0gfVxuXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMuY29uZGl0aW9uLnRvQ2xhdXNlKG5ld0FyZ3MxKVxuICAgICAgICBjb25zdCBvdXRjb21lID0gdGhpcy5vdXRjb21lLnRvQ2xhdXNlKG5ld0FyZ3MyKVxuXG4gICAgICAgIHJldHVybiBjb25kaXRpb24uaW1wbGllcyhvdXRjb21lKVxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBCaW5hcnlRdWVzdGlvbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9CaW5hcnlRdWVzdGlvblwiO1xuaW1wb3J0IHsgVG9DbGF1c2VPcHRzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IHsgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9JZFwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IENvcHVsYSBmcm9tIFwiLi4vdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IENvcHVsYVNlbnRlbmNlIGZyb20gXCIuL0NvcHVsYVNlbnRlbmNlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHVsYVF1ZXN0aW9uIGltcGxlbWVudHMgQmluYXJ5UXVlc3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSwgcmVhZG9ubHkgcHJlZGljYXRlOiBOb3VuUGhyYXNlLCByZWFkb25seSBjb3B1bGE6IENvcHVsYSkge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvQ2xhdXNlT3B0cyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoeyBhc1ZhcjogdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSB9KVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgLy9UT0RPOiBpbiBjYXNlIG9mIGEgdW5pdmVyc2FsbHkgcXVhbnRpZmllZCBxdWVzdGlvbiBlZzogXCJhcmUgYWxsIGNhdHMgc21hcnQ/XCIgdGhlIHByb2xvZ1xuICAgICAgICAvLyBwcm9kdWNlZCBzaG91bGQgTk9UIGJlIGFuIGltcGxpY2F0aW9uLCBidXQgcmF0aGVyIGEgY2hlY2sgdGhhdCBhbGwgY2F0cyBhcmUgc21hcnQuXG5cbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGFTZW50ZW5jZSh0aGlzLnN1YmplY3QsIHRoaXMuY29wdWxhLCB0aGlzLnByZWRpY2F0ZSkudG9DbGF1c2UobmV3QXJncylcblxuICAgIH1cblxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBUb0NsYXVzZU9wdHMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBnZXRSYW5kb21JZCB9IGZyb20gXCIuLi8uLi9jbGF1c2VzL0lkXCI7XG5pbXBvcnQgU2ltcGxlU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvU2ltcGxlU2VudGVuY2VcIjtcbmltcG9ydCBOb3VuUGhyYXNlIGZyb20gXCIuLi9waHJhc2VzL05vdW5QaHJhc2VcIjtcbmltcG9ydCBDb3B1bGEgZnJvbSBcIi4uL3Rva2Vucy9Db3B1bGFcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vdG9rZW5zL05lZ2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHVsYVNlbnRlbmNlIGltcGxlbWVudHMgU2ltcGxlU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSwgcmVhZG9ubHkgY29wdWxhOiBDb3B1bGEsIHJlYWRvbmx5IHByZWRpY2F0ZTogTm91blBocmFzZSwgcmVhZG9ubHkgbmVnYXRpb24/OiBOZWdhdGlvbikge1xuXG4gICAgfVxuXG4gICAgdG9DbGF1c2UoYXJncz86IFRvQ2xhdXNlT3B0cyk6IENsYXVzZSB7XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdElkID0gYXJncz8ucm9sZXM/LnN1YmplY3QgPz8gZ2V0UmFuZG9tSWQoeyBhc1ZhcjogdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSB9KVxuICAgICAgICBjb25zdCBuZXdBcmdzID0geyAuLi5hcmdzLCByb2xlczogeyBzdWJqZWN0OiBzdWJqZWN0SWQgfSB9XG5cbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMuc3ViamVjdC50b0NsYXVzZShuZXdBcmdzKVxuICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSB0aGlzLnByZWRpY2F0ZS50b0NsYXVzZShuZXdBcmdzKS5jb3B5KHsgbmVnYXRlOiAhIXRoaXMubmVnYXRpb24gfSlcblxuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0LmlzVW5pUXVhbnQoKSA/XG4gICAgICAgICAgICBzdWJqZWN0LmltcGxpZXMocHJlZGljYXRlKSA6XG4gICAgICAgICAgICBzdWJqZWN0LmFuZChwcmVkaWNhdGUsIHsgYXNSaGVtZTogdHJ1ZSB9KVxuXG4gICAgfVxuXG4gICAgZ2V0IGlzU2lkZUVmZmVjdHkoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgVG9DbGF1c2VPcHRzIH0gZnJvbSBcIi4uL2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCB7IENsYXVzZSwgY2xhdXNlT2YgfSBmcm9tIFwiLi4vLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCB7IGdldFJhbmRvbUlkIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvSWRcIjtcbmltcG9ydCBWZXJiU2VudGVuY2UgZnJvbSBcIi4uL2ludGVyZmFjZXMvVmVyYlNlbnRlbmNlXCI7XG5pbXBvcnQgQ29tcGxlbWVudCBmcm9tIFwiLi4vcGhyYXNlcy9Db21wbGVtZW50XCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi4vcGhyYXNlcy9Ob3VuUGhyYXNlXCI7XG5pbXBvcnQgSVZlcmIgZnJvbSBcIi4uL3Rva2Vucy9JVmVyYlwiO1xuaW1wb3J0IE5lZ2F0aW9uIGZyb20gXCIuLi90b2tlbnMvTmVnYXRpb25cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW50cmFuc2l0aXZlU2VudGVuY2UgaW1wbGVtZW50cyBWZXJiU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSxcbiAgICAgICAgcmVhZG9ubHkgaXZlcmI6IElWZXJiLFxuICAgICAgICByZWFkb25seSBjb21wbGVtZW50czogQ29tcGxlbWVudFtdLFxuICAgICAgICByZWFkb25seSBuZWdhdGlvbj86IE5lZ2F0aW9uKSB7XG5cbiAgICB9XG5cbiAgICBnZXQgaXNTaWRlRWZmZWN0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICB0b0NsYXVzZShhcmdzPzogVG9DbGF1c2VPcHRzKTogQ2xhdXNlIHtcblxuICAgICAgICBjb25zdCBzdWJqZWN0SWQgPSBhcmdzPy5yb2xlcz8uc3ViamVjdCA/PyBnZXRSYW5kb21JZCh7IGFzVmFyOiB0aGlzLnN1YmplY3QuaXNVbmlRdWFudCgpIH0pXG4gICAgICAgIGNvbnN0IG5ld0FyZ3MgPSB7IC4uLmFyZ3MsIHJvbGVzOiB7IHN1YmplY3Q6IHN1YmplY3RJZCB9IH1cblxuICAgICAgICBjb25zdCB0aGVtZSA9IHRoaXMuc3ViamVjdC50b0NsYXVzZShuZXdBcmdzKVxuICAgICAgICBjb25zdCByaGVtZSA9IGNsYXVzZU9mKHRoaXMuaXZlcmIuc3RyaW5nLCBzdWJqZWN0SWQpXG4gICAgICAgICAgICAuYW5kKHRoaXMuY29tcGxlbWVudHMubWFwKGMgPT4gYy50b0NsYXVzZShuZXdBcmdzKSkucmVkdWNlKChjMSwgYzIpID0+IGMxLmFuZChjMikpKVxuXG4gICAgICAgIHJldHVybiB0aGVtZS5hbmQocmhlbWUsIHsgYXNSaGVtZTogdHJ1ZSB9KVxuICAgIH1cblxufVxuXG4iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgeyBUb0NsYXVzZU9wdHMgfSBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Db25zdGl0dWVudFwiO1xuaW1wb3J0IHsgQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgVmVyYlNlbnRlbmNlIGZyb20gXCIuLi9pbnRlcmZhY2VzL1ZlcmJTZW50ZW5jZVwiO1xuaW1wb3J0IENvbXBsZW1lbnQgZnJvbSBcIi4uL3BocmFzZXMvQ29tcGxlbWVudFwiO1xuaW1wb3J0IE5vdW5QaHJhc2UgZnJvbSBcIi4uL3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IE1WZXJiIGZyb20gXCIuLi90b2tlbnMvTVZlcmJcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vdG9rZW5zL05lZ2F0aW9uXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vbm90cmFuc2l0aXZlU2VudGVuY2UgaW1wbGVtZW50cyBWZXJiU2VudGVuY2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc3ViamVjdDogTm91blBocmFzZSxcbiAgICAgICAgICAgICAgICByZWFkb25seSBtdmVyYjogTVZlcmIsXG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgb2JqZWN0OiBOb3VuUGhyYXNlLFxuICAgICAgICAgICAgICAgIHJlYWRvbmx5IGNvbXBsZW1lbnRzOiBDb21wbGVtZW50W10sXG4gICAgICAgICAgICAgICAgcmVhZG9ubHkgbmVnYXRpb24/OiBOZWdhdGlvbikge1xuXG4gICAgfVxuICAgIFxuICAgIGdldCBpc1NpZGVFZmZlY3R5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBcbiAgICB0b0NsYXVzZShhcmdzPzogVG9DbGF1c2VPcHRzIHwgdW5kZWZpbmVkKTogQ2xhdXNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfVxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFRva2VuIGltcGxlbWVudHMgVG9rZW57XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBzdHJpbmc6c3RyaW5nKXtcblxuICAgIH0gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFkamVjdGl2ZSBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IGRlZmluaXRlX2FydGljbGVzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL2RlZmluaXRlX2FydGljbGVzXCI7XG5pbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFydGljbGUgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuXG4gICAgaXNEZWZpbml0ZSgpe1xuICAgICAgICByZXR1cm4gZGVmaW5pdGVfYXJ0aWNsZXMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKXtcbiAgICAgICAgcmV0dXJuIGBBcnRpY2xlKCR7dGhpcy5zdHJpbmd9LCBpc0RlZmluaXRlPSR7dGhpcy5pc0RlZmluaXRlKCl9KWBcbiAgICB9XG5cbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29wdWxhIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRnVsbFN0b3AgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVmVyYiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElWZXJiIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICBcbn0iLCJpbXBvcnQgQnJhaW4gZnJvbSBcIi4uLy4uL2JyYWluL0JyYWluXCI7XG5pbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2ludGVyZmFjZXMvVG9rZW5cIjtcbmltcG9ydCBBYnN0cmFjdFRva2VuIGZyb20gXCIuL0Fic3RyYWN0VG9rZW5cIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTVZlcmIgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOZWdhdGlvbiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOb25TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuXG59IiwiaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE5vdW4gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcmVwb3NpdGlvbiBleHRlbmRzIEFic3RyYWN0VG9rZW57XG4gICAgICAgXG59IiwiaW1wb3J0IGV4aXN0ZW50aWFsX3F1YW50aWZpZXJzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL2V4aXN0ZW50aWFsX3F1YW50aWZpZXJzXCI7XG5pbXBvcnQgdW5pdmVyc2FsX3F1YW50aWZpZXJzIGZyb20gXCIuLi8uLi8uLi9yZXMvdG9rZW5zL3VuaXZlcnNhbF9xdWFudGlmaWVyc1wiO1xuaW1wb3J0IEJyYWluIGZyb20gXCIuLi8uLi9icmFpbi9CcmFpblwiO1xuaW1wb3J0IFRva2VuIGZyb20gXCIuLi9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgQWJzdHJhY3RUb2tlbiBmcm9tIFwiLi9BYnN0cmFjdFRva2VuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFF1YW50aWZpZXIgZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxuICAgIGlzVW5pdmVyc2FsKCl7XG4gICAgICAgIHJldHVybiB1bml2ZXJzYWxfcXVhbnRpZmllcnMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuXG4gICAgaXNFeGlzdGVudGlhbCgpe1xuICAgICAgICByZXR1cm4gZXhpc3RlbnRpYWxfcXVhbnRpZmllcnMuaW5jbHVkZXModGhpcy5zdHJpbmcpXG4gICAgfVxuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWxhdGl2ZVByb25vdW4gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZXh0ZW5kcyBBYnN0cmFjdFRva2Vue1xuICAgIFxufSIsImltcG9ydCBCcmFpbiBmcm9tIFwiLi4vLi4vYnJhaW4vQnJhaW5cIjtcbmltcG9ydCBUb2tlbiBmcm9tIFwiLi4vaW50ZXJmYWNlcy9Ub2tlblwiO1xuaW1wb3J0IEFic3RyYWN0VG9rZW4gZnJvbSBcIi4vQWJzdHJhY3RUb2tlblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaGVuIGV4dGVuZHMgQWJzdHJhY3RUb2tlbntcbiAgICAgXG59IiwiaW1wb3J0IEFjdHVhdG9yLCB7IGdldEFjdHVhdG9yIH0gZnJvbSBcIi4uL2FjdHVhdG9yL0FjdHVhdG9yXCI7XG5pbXBvcnQgeyBDbGF1c2UgfSBmcm9tIFwiLi4vY2xhdXNlcy9DbGF1c2VcIjtcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuLi9jbGF1c2VzL0lkXCI7XG5pbXBvcnQgeyBBc3NlcnRPcHRzIH0gZnJvbSBcIi4vQnJhaW5cIjtcbmltcG9ydCBQcm9sb2dCcmFpbiBmcm9tIFwiLi9Qcm9sb2dCcmFpblwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBY3R1YXRvckJyYWluIGV4dGVuZHMgUHJvbG9nQnJhaW4ge1xuXG4gICAgcmVhZG9ubHkgYWN0dWF0b3I6IEFjdHVhdG9yXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmFjdHVhdG9yID0gZ2V0QWN0dWF0b3IodGhpcylcbiAgICB9XG5cbiAgICBvdmVycmlkZSBhc3luYyBleGVjdXRlKG5hdGxhbmc6IHN0cmluZyk6IFByb21pc2U8TWFwW10+IHtcblxuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgc3VwZXIuZXhlY3V0ZShuYXRsYW5nKVxuICAgICAgICBjb25zdCBwb2ludGVkT3V0SWRzID0gcmVzdWx0cy5mbGF0TWFwKG0gPT4gT2JqZWN0LnZhbHVlcyhtKSkuZmlsdGVyKGlkID0+IGlkLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ2lkJykpXG4gICAgICAgIHRoaXMuYWN0dWF0b3IucG9pbnRPdXQocG9pbnRlZE91dElkcylcblxuICAgICAgICByZXR1cm4gcmVzdWx0c1xuICAgIH1cblxuICAgIG92ZXJyaWRlIGFzeW5jIGFzc2VydChjbGF1c2U6IENsYXVzZSwgb3B0cz86IEFzc2VydE9wdHMpOiBQcm9taXNlPE1hcFtdPiB7XG5cbiAgICAgICAgY29uc3QgYmVmb3JlID0gYXdhaXQgdGhpcy5zbmFwc2hvdCgpXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBzdXBlci5hc3NlcnQoY2xhdXNlLCBvcHRzKVxuICAgICAgICB0aGlzLmFjdHVhdG9yLm9uVXBkYXRlKGF3YWl0IHRoaXMuZGlmZihiZWZvcmUpKVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2xhdXNlLCBlbXB0eUNsYXVzZSB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IHsgSWQsIGlzVmFyLCBNYXAsIHRvVmFyIH0gZnJvbSBcIi4uL2NsYXVzZXMvSWRcIjtcbmltcG9ydCBCcmFpbiwgeyBnZXRCcmFpbiB9IGZyb20gXCIuL0JyYWluXCI7XG5cbi8qKlxuICogRW50aXRpZXMgaW4gYSBuZXcgc2VudGVuY2UgcG90ZW50aWFsbHkgcG9pbnQgdG8gZXhpc3RpbmcgZW50aXRpZXNcbiAqIGluIHRoZSB1bml2ZXJzZSAoaWU6IHtAbGluayBCcmFpbn0pLiB7QGxpbmsgQW5hcGhvcmF9IHJlc29sdmVzIHRoZSBhbmFwaG9yYS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBbmFwaG9yYSB7XG4gICAgbWFwVG8odW5pdmVyc2U6IEJyYWluKTogUHJvbWlzZTxNYXA+XG4gICAgbWFwVG9DbGF1c2UoY2xhdXNlOiBDbGF1c2UpOiBQcm9taXNlPE1hcD5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFuYXBob3JhKGNsYXVzZTogQ2xhdXNlKTogQW5hcGhvcmEge1xuICAgIHJldHVybiBuZXcgQmFzZUFuYXBob3JhKGNsYXVzZSlcbn1cblxuY2xhc3MgQmFzZUFuYXBob3JhIGltcGxlbWVudHMgQW5hcGhvcmEge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY2xhdXNlOiBDbGF1c2UpIHtcblxuICAgIH1cblxuICAgIGFzeW5jIG1hcFRvKHVuaXZlcnNlOiBCcmFpbik6IFByb21pc2U8TWFwPiB7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xhdXNlLmVudGl0aWVzLmV2ZXJ5KGUgPT4gaXNWYXIoZSkpKSB7IC8vIHRoaXMgaXMgYSBwdXJlIGltcGxpY2F0aW9uIC8vVE9ETzogcG9zc2JpbGUgcHJvYmxlbTogZXZlcnkgY2F0IHRoYXQgaXMgb24gdGhlIG1hdFxuICAgICAgICAgICAgcmV0dXJuIHt9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aGVtZUVudHMgPSB0aGlzLmNsYXVzZS50aGVtZS5lbnRpdGllc1xuXG4gICAgICAgIC8vIGdldCBkZXNjcmlwdGlvbnMgb2YgZW50aXRpZXMgaW4gdGhlbWUgb21pdHRpbmcgcmVsYXRpb25zIHdpdGggZW50aXRpZXMgaW4gcmhlbWVcbiAgICAgICAgY29uc3QgdGhlbWVEZXNjcyA9IHRoaXMuY2xhdXNlLnRoZW1lLmZsYXRMaXN0KClcblxuICAgICAgICAvLyBnZXQgZGVzY3JpcHRpb25zIG9mIGVudGl0aWVzIGluIHJoZW1lIG9taXR0aW5nIHJlbGF0aW9ucyB3aXRoIGVudGl0aWVzIGluIHRoZW1lXG4gICAgICAgIGNvbnN0IHJoZW1lRGVzY3MgPSB0aGlzLmNsYXVzZS5yaGVtZS5mbGF0TGlzdCgpXG4gICAgICAgICAgICAuZmlsdGVyKGMgPT4gdGhlbWVFbnRzLmV2ZXJ5KGUgPT4gIWMuZW50aXRpZXMuaW5jbHVkZXMoZSkpKVxuXG4gICAgICAgIGNvbnN0IG1hcFRvVmFyID0gdGhpcy5jbGF1c2UuZW50aXRpZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoeyBbZV06IHRvVmFyKGUpIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICBjb25zdCByZXZlcnNlTWFwVG9WYXIgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMobWFwVG9WYXIpLm1hcChlID0+IFtlWzFdLCBlWzBdXSkpXG5cbiAgICAgICAgY29uc3QgYmlnRGVzY0NsYXVzZSA9IHRoZW1lRGVzY3NcbiAgICAgICAgICAgIC5jb25jYXQocmhlbWVEZXNjcylcbiAgICAgICAgICAgIC5yZWR1Y2UoKGMxLCBjMikgPT4gYzEuYW5kKGMyKSwgZW1wdHlDbGF1c2UoKSlcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBtYXBUb1ZhciB9KVxuXG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBhd2FpdCB1bml2ZXJzZS5xdWVyeShiaWdEZXNjQ2xhdXNlKVxuICAgICAgICBjb25zdCBjaG9zZW4gPSBjYW5kaWRhdGVzWzBdID8/IHt9IC8vVE9ETzogYmV0dGVyIGNyaXRlcmlvbiAhISFcblxuICAgICAgICBjb25zdCBhbmFwaG9yYSA9IE9iamVjdFxuICAgICAgICAgICAgLmtleXMoY2hvc2VuKVxuICAgICAgICAgICAgLm1hcChrID0+ICh7IFtyZXZlcnNlTWFwVG9WYXJba11dOiBjaG9zZW5ba10gPz8gcmV2ZXJzZU1hcFRvVmFyW2tdIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSwge30pXG5cbiAgICAgICAgcmV0dXJuIGFuYXBob3JhXG4gICAgfVxuXG4gICAgYXN5bmMgbWFwVG9DbGF1c2UoY2xhdXNlOiBDbGF1c2UpOiBQcm9taXNlPE1hcD4ge1xuICAgICAgICBjb25zdCBicmFpbiA9IGF3YWl0IGdldEJyYWluKHsgd2l0aEFjdHVhdG9yOiBmYWxzZSB9KVxuICAgICAgICBhd2FpdCBicmFpbi5hc3NlcnQoY2xhdXNlKVxuICAgICAgICByZXR1cm4gdGhpcy5tYXBUbyhicmFpbilcbiAgICB9XG5cbn1cblxuIiwiaW1wb3J0IHsgRWQgfSBmcm9tIFwiLi4vYWN0dWF0b3IvRWRcIlxuaW1wb3J0IHsgQ2xhdXNlIH0gZnJvbSBcIi4uL2NsYXVzZXMvQ2xhdXNlXCJcbmltcG9ydCB7IE1hcCB9IGZyb20gXCIuLi9jbGF1c2VzL0lkXCJcbmltcG9ydCBBY3R1YXRvckJyYWluIGZyb20gXCIuL0FjdHVhdG9yQnJhaW5cIlxuaW1wb3J0IHsgZ2V0T250b2xvZ3ksIE9udG9sb2d5IH0gZnJvbSBcIi4vT250b2xvZ3lcIlxuaW1wb3J0IFByb2xvZ0JyYWluIGZyb20gXCIuL1Byb2xvZ0JyYWluXCJcblxuLyoqXG4gKiBUaGUgbWFpbiBmYWNhZGUgY29udHJvbGxlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIEJyYWluIHtcbiAgICBleGVjdXRlKG5hdGxhbmc6IHN0cmluZyk6IFByb21pc2U8TWFwW10+XG4gICAgcXVlcnkocXVlcnk6IENsYXVzZSk6IFByb21pc2U8TWFwW10+XG4gICAgYXNzZXJ0KGNvZGU6IENsYXVzZSwgb3B0cz86IEFzc2VydE9wdHMpOiBQcm9taXNlPE1hcFtdPlxuICAgIGluamVjdChvbnRvbG9neTogT250b2xvZ3kpOiBQcm9taXNlPEJyYWluPlxuICAgIHNuYXBzaG90KCk6IFByb21pc2U8QnJhaW5TdGF0ZT5cbiAgICBkaWZmKGJlZm9yZTogQnJhaW5TdGF0ZSk6IFByb21pc2U8Q2xhdXNlW10+XG4gICAgcmVhZG9ubHkgZWQ6IEVkXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcmFpbihvcHRzPzogR2V0QnJhaW5PcHRzKTogUHJvbWlzZTxCcmFpbj4ge1xuXG4gICAgY29uc3QgY29ucyA9IG9wdHM/LndpdGhBY3R1YXRvciA/IEFjdHVhdG9yQnJhaW4gOiBQcm9sb2dCcmFpblxuICAgIHJldHVybiBuZXcgY29ucygpLmluamVjdChnZXRPbnRvbG9neSgpKVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXNzZXJ0T3B0cyB7XG4gICAgbm9BbmFwaG9yYTogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdldEJyYWluT3B0cyB7XG4gICAgd2l0aEFjdHVhdG9yOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJhaW5TdGF0ZSB7XG4gICAgYmU6IENsYXVzZVtdXG4gICAgcmVsOiBDbGF1c2VbXVxuICAgIGJlTm90OiBDbGF1c2VbXVxuICAgIHJlbE5vdDogQ2xhdXNlW11cbn0iLCJpbXBvcnQgeyBDbGF1c2UsIGNsYXVzZU9mIH0gZnJvbSBcIi4uL2NsYXVzZXMvQ2xhdXNlXCI7XG5pbXBvcnQgeyBJZCB9IGZyb20gXCIuLi9jbGF1c2VzL0lkXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgT250b2xvZ3kge1xuICAgIHJlYWRvbmx5IGNsYXVzZXM6IENsYXVzZVtdXG4gICAgcmVhZG9ubHkgb2JqZWN0czogW0lkLCBhbnldW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9udG9sb2d5KCk6IE9udG9sb2d5IHtcbiAgICByZXR1cm4gbmV3IEJhc2VPbnRvbG9neSgpXG59XG5cbmNsYXNzIEJhc2VPbnRvbG9neSBpbXBsZW1lbnRzIE9udG9sb2d5IHtcblxuICAgIGdldCBvYmplY3RzKCk6IFtJZCwgYW55XVtdIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFsnaWQxMDAnLCBkb2N1bWVudC5ib2R5XVxuICAgICAgICBdXG4gICAgfVxuXG4gICAgZ2V0IGNsYXVzZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjbGF1c2VPZignYm9keScsICdpZDEwMCcpXG4gICAgICAgIF1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ2xhdXNlLCBjbGF1c2VPZiB9IGZyb20gXCIuLi9jbGF1c2VzL0NsYXVzZVwiO1xuaW1wb3J0IHsgTWFwLCB0b1ZhciB9IGZyb20gXCIuLi9jbGF1c2VzL0lkXCI7XG5pbXBvcnQgeyBnZXRQYXJzZXIgfSBmcm9tIFwiLi4vcGFyc2VyL1BhcnNlclwiO1xuaW1wb3J0IHsgZ2V0UHJvbG9nIH0gZnJvbSBcIi4uL3Byb2xvZy9Qcm9sb2dcIjtcbmltcG9ydCBCcmFpbiwgeyBBc3NlcnRPcHRzLCBCcmFpblN0YXRlIH0gZnJvbSBcIi4vQnJhaW5cIjtcbmltcG9ydCB7IGdldEFuYXBob3JhIH0gZnJvbSBcIi4vQW5hcGhvcmFcIjtcbmltcG9ydCBnZXRFZCBmcm9tIFwiLi4vYWN0dWF0b3IvRWRcIjtcbmltcG9ydCB7IE9udG9sb2d5IH0gZnJvbSBcIi4vT250b2xvZ3lcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJvbG9nQnJhaW4gaW1wbGVtZW50cyBCcmFpbiB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBrYiA9IGdldFByb2xvZygpLCByZWFkb25seSBlZCA9IGdldEVkKCkpIHtcblxuICAgIH1cblxuICAgIGFzeW5jIGluamVjdChvbnRvbG9neTogT250b2xvZ3kpOiBQcm9taXNlPEJyYWluPiB7XG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIG9udG9sb2d5LmNsYXVzZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXNzZXJ0KGMpXG4gICAgICAgIH1cblxuICAgICAgICBvbnRvbG9neS5vYmplY3RzLmZvckVhY2gobyA9PiB7XG4gICAgICAgICAgICB0aGlzLmVkLnNldChvWzBdLCBvWzFdKVxuICAgICAgICB9KVxuXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgYXN5bmMgZXhlY3V0ZShuYXRsYW5nOiBzdHJpbmcpOiBQcm9taXNlPE1hcFtdPiB7XG5cbiAgICAgICAgbGV0IHg6IE1hcFtdID0gW11cblxuICAgICAgICBmb3IgKGNvbnN0IGFzdCBvZiBnZXRQYXJzZXIobmF0bGFuZykucGFyc2VBbGwoKSkge1xuICAgICAgICAgICAgeCA9IGF3YWl0IChhc3QuaXNTaWRlRWZmZWN0eSA/IHRoaXMuYXNzZXJ0KGFzdC50b0NsYXVzZSgpKSA6IHRoaXMucXVlcnkoYXN0LnRvQ2xhdXNlKCkpKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coeClcbiAgICAgICAgcmV0dXJuIHhcbiAgICB9XG5cbiAgICBhc3luYyBxdWVyeShxdWVyeTogQ2xhdXNlKTogUHJvbWlzZTxNYXBbXT4ge1xuXG4gICAgICAgIGNvbnN0IG1hcFRvVmFyID0gcXVlcnkuZW50aXRpZXNcbiAgICAgICAgICAgIC5tYXAoZSA9PiAoeyBbZV06IHRvVmFyKGUpIH0pKVxuICAgICAgICAgICAgLnJlZHVjZSgoYSwgYikgPT4gKHsgLi4uYSwgLi4uYiB9KSlcblxuICAgICAgICBjb25zdCBxID0gcXVlcnlcbiAgICAgICAgICAgIC5jb3B5KHsgbWFwOiBtYXBUb1ZhciB9KVxuICAgICAgICAgICAgLnRvUHJvbG9nKHsgYW55RmFjdElkOiB0cnVlIH0pXG4gICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiBgJHthfSwgJHtifWApICsgJy4nIC8vIFRPRE86IGRlYWwgd2l0aCBkb3QgYXQgYSBsb3dlciBsZXZlbCA/XG5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMua2IucXVlcnkocSlcbiAgICB9XG5cbiAgICBhc3luYyBhc3NlcnQoY2xhdXNlOiBDbGF1c2UsIG9wdHM/OiBBc3NlcnRPcHRzKTogUHJvbWlzZTxNYXBbXT4ge1xuXG4gICAgICAgIGNvbnN0IGFuYXBob3JhTWFwID0gb3B0cz8ubm9BbmFwaG9yYSA/IHt9IDogYXdhaXQgZ2V0QW5hcGhvcmEoY2xhdXNlKS5tYXBUbyh0aGlzKVxuXG4gICAgICAgIGNvbnN0IHRvQmVBc3NlcnRlZCA9IGNsYXVzZVxuICAgICAgICAgICAgLmNvcHkoeyBtYXA6IGFuYXBob3JhTWFwIH0pXG4gICAgICAgICAgICAudG9Qcm9sb2coeyBhbnlGYWN0SWQ6IGZhbHNlIH0pXG5cbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRvQmVBc3NlcnRlZCkgeyAvLyBUT0RPOiBidWcgZmluZGluZyBvbmUgZW50aXR5IG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYXNzZXJ0aW5nJywgYylcbiAgICAgICAgICAgIGF3YWl0IHRoaXMua2IuYXNzZXJ0KGMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW11cbiAgICB9XG5cbiAgICBhc3luYyBzbmFwc2hvdCgpOiBQcm9taXNlPEJyYWluU3RhdGU+IHtcblxuICAgICAgICBjb25zdCBpcyA9IChhd2FpdCB0aGlzLnF1ZXJ5KGNsYXVzZU9mKCdYJywgJ1knKSkpXG4gICAgICAgICAgICAubWFwKGUgPT4gY2xhdXNlT2YoZS5YIGFzIHN0cmluZywgZS5ZKSlcblxuICAgICAgICBjb25zdCBkb2VzID0gKGF3YWl0IHRoaXMucXVlcnkoY2xhdXNlT2YoJ1AnLCAnQScsICdCJykpKVxuICAgICAgICAgICAgLm1hcChlID0+IGNsYXVzZU9mKGUuUCBhcyBzdHJpbmcsIGUuQSwgZS5CKSlcblxuICAgICAgICBjb25zdCBpc05vdCA9IChhd2FpdCB0aGlzLnF1ZXJ5KGNsYXVzZU9mKCdYJywgJ1knKS5jb3B5KHsgbmVnYXRlOiB0cnVlIH0pKSlcbiAgICAgICAgICAgIC5tYXAoZSA9PiBjbGF1c2VPZihlLlggYXMgc3RyaW5nLCBlLlkpKVxuXG4gICAgICAgIGNvbnN0IGRvZXNOb3QgPSAoYXdhaXQgdGhpcy5xdWVyeShjbGF1c2VPZignUCcsICdBJywgJ0InKS5jb3B5KHsgbmVnYXRlOiB0cnVlIH0pKSlcbiAgICAgICAgICAgIC5tYXAoZSA9PiBjbGF1c2VPZihlLlAgYXMgc3RyaW5nLCBlLkEsIGUuQikpXG5cbiAgICAgICAgcmV0dXJuIHsgYmU6IGlzLCByZWw6IGRvZXMsIHJlbE5vdDogZG9lc05vdCwgYmVOb3Q6IGlzTm90IH1cbiAgICB9XG5cbiAgICBhc3luYyBkaWZmKGJlZm9yZTogQnJhaW5TdGF0ZSk6IFByb21pc2U8Q2xhdXNlW10+IHtcblxuICAgICAgICBjb25zdCBub3cgPSBhd2FpdCB0aGlzLnNuYXBzaG90KClcbiAgICAgICAgY29uc3QgYmVEaWZmID0gbm93LmJlLmZpbHRlcihjID0+ICEoYmVmb3JlLmJlLm1hcChjID0+IGMuaGFzaENvZGUpKS5pbmNsdWRlcyhjLmhhc2hDb2RlKSlcbiAgICAgICAgY29uc3QgcmVsRGlmZiA9IG5vdy5yZWwuZmlsdGVyKGMgPT4gIShiZWZvcmUucmVsLm1hcChjID0+IGMuaGFzaENvZGUpKS5pbmNsdWRlcyhjLmhhc2hDb2RlKSlcbiAgICAgICAgY29uc3QgcmVzID0gYmVEaWZmLmNvbmNhdChyZWxEaWZmKVxuXG4gICAgICAgIHJldHVybiByZXMuZmlsdGVyKChlLCBpKSA9PiByZXMubWFwKGMgPT4gYy5oYXNoQ29kZSkuaW5kZXhPZihlLmhhc2hDb2RlKSA9PT0gaSkgLy9UT0RPOiBkZS11Z2xpZnkgZGVkdXBsaWNhdGlvblxuICAgIH1cblxufSIsImltcG9ydCB7IENsYXVzZSwgQW5kT3B0cywgQ29weU9wdHMsIFRvUHJvbG9nT3B0cywgaGFzaFN0cmluZyB9IGZyb20gXCIuL0NsYXVzZVwiO1xuaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi9JZFwiO1xuaW1wb3J0IEltcGx5IGZyb20gXCIuL0ltcGx5XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuZCBpbXBsZW1lbnRzIENsYXVzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBjbGF1c2VzOiBDbGF1c2VbXSxcbiAgICAgICAgcmVhZG9ubHkgbmVnYXRlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSBpc0ltcGx5ID0gZmFsc2UsXG4gICAgICAgIHJlYWRvbmx5IGhhc2hDb2RlID0gaGFzaFN0cmluZyhKU09OLnN0cmluZ2lmeShhcmd1bWVudHMpKSxcbiAgICAgICAgcmVhZG9ubHkgdGhlbWUgPSBjbGF1c2VzWzBdLFxuICAgICAgICByZWFkb25seSByaGVtZSA9IGNsYXVzZXNbMV0pIHtcblxuICAgIH1cblxuICAgIGFuZChvdGhlcjogQ2xhdXNlLCBvcHRzPzogQW5kT3B0cyk6IENsYXVzZSB7XG5cbiAgICAgICAgcmV0dXJuIG9wdHM/LmFzUmhlbWUgP1xuICAgICAgICAgICAgbmV3IEFuZChbdGhpcywgb3RoZXJdKSA6XG4gICAgICAgICAgICBuZXcgQW5kKFsuLi50aGlzLmZsYXRMaXN0KCksIC4uLm90aGVyLmZsYXRMaXN0KCldKVxuXG4gICAgfVxuXG4gICAgY29weShvcHRzPzogQ29weU9wdHMpOiBBbmQge1xuICAgICAgICByZXR1cm4gbmV3IEFuZCh0aGlzLmNsYXVzZXMubWFwKGMgPT4gYy5jb3B5KHsgLi4ub3B0cywgbmVnYXRlOiBmYWxzZSB9KSksIG9wdHM/Lm5lZ2F0ZSA/ICF0aGlzLm5lZ2F0ZWQgOiB0aGlzLm5lZ2F0ZWQpXG4gICAgfVxuXG4gICAgZmxhdExpc3QoKTogQ2xhdXNlW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGVkID8gW3RoaXNdIDogdGhpcy5jbGF1c2VzLmZsYXRNYXAoYyA9PiBjLmZsYXRMaXN0KCkpXG4gICAgfVxuXG4gICAgZ2V0IGVudGl0aWVzKCk6IElkW10ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRoaXMuY2xhdXNlcy5mbGF0TWFwKGMgPT4gYy5lbnRpdGllcykpKVxuICAgIH1cblxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbXBseSh0aGlzLCBjb25jbHVzaW9uKVxuICAgIH1cblxuICAgIHRvUHJvbG9nKG9wdHM/OiBUb1Byb2xvZ09wdHMpOiBzdHJpbmdbXSB7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2xhdXNlcy5sZW5ndGggPT09IDEgJiYgdGhpcy5uZWdhdGVkID8gLy9UT0RPOiBmaXggdGhpcyBjcmFwXG4gICAgICAgICAgICB0aGlzLmNsYXVzZXNbMF0uY29weSh7IG5lZ2F0ZTogdHJ1ZSB9KS50b1Byb2xvZyhvcHRzKSA6XG4gICAgICAgICAgICB0aGlzLmNsYXVzZXMuZmxhdE1hcChjID0+IGMudG9Qcm9sb2cob3B0cykpXG5cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBDbGF1c2UsIEFuZE9wdHMsIENvcHlPcHRzLCBlbXB0eUNsYXVzZSwgVG9Qcm9sb2dPcHRzLCBoYXNoU3RyaW5nIH0gZnJvbSBcIi4vQ2xhdXNlXCI7XG5pbXBvcnQgeyBJZCwgZ2V0UmFuZG9tSWQgfSBmcm9tIFwiLi9JZFwiO1xuaW1wb3J0IEltcGx5IGZyb20gXCIuL0ltcGx5XCI7XG5pbXBvcnQgQW5kIGZyb20gXCIuL0FuZFwiO1xuXG5cbmV4cG9ydCBjbGFzcyBCYXNpY0NsYXVzZSBpbXBsZW1lbnRzIENsYXVzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWFkb25seSBwcmVkaWNhdGU6IHN0cmluZywgcmVhZG9ubHkgYXJnczogSWRbXSwgcmVhZG9ubHkgbmVnYXRlZCA9IGZhbHNlLCByZWFkb25seSBpc0ltcGx5ID0gZmFsc2UsIHJlYWRvbmx5IGhhc2hDb2RlID0gaGFzaFN0cmluZyhKU09OLnN0cmluZ2lmeShhcmd1bWVudHMpKSwgcmVhZG9ubHkgcmhlbWUgPSBlbXB0eUNsYXVzZSgpKSB7XG5cbiAgICB9XG5cbiAgICBhbmQob3RoZXI6IENsYXVzZSwgb3B0cz86IEFuZE9wdHMpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gbmV3IEFuZCh0aGlzLmZsYXRMaXN0KCkuY29uY2F0KG90aGVyLmZsYXRMaXN0KCkpKVxuICAgIH1cblxuICAgIGNvcHkob3B0cz86IENvcHlPcHRzKTogQmFzaWNDbGF1c2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2ljQ2xhdXNlKHRoaXMucHJlZGljYXRlLCB0aGlzLmFyZ3MubWFwKGEgPT4gb3B0cz8ubWFwID8gb3B0cz8ubWFwW2FdID8/IGEgOiBhKSwgb3B0cz8ubmVnYXRlID8gIXRoaXMubmVnYXRlZCA6IHRoaXMubmVnYXRlZClcbiAgICB9XG5cbiAgICBmbGF0TGlzdCgpOiBDbGF1c2VbXSB7XG4gICAgICAgIHJldHVybiBbdGhpc11cbiAgICB9XG5cbiAgICB0b1Byb2xvZyhvcHRzPzogVG9Qcm9sb2dPcHRzKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IHByZWQgPSB0aGlzLmFyZ3MubGVuZ3RoID09PSAxID8gJ2JlJyA6ICdyZWwnXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbb3B0cz8uYW55RmFjdElkID8gJ18nIDogZ2V0UmFuZG9tSWQoKSwgLi4udGhpcy5hcmdzLnNsaWNlKDAsIDIpLCB0aGlzLnByZWRpY2F0ZSwgIXRoaXMubmVnYXRlZF1cbiAgICAgICAgcmV0dXJuIFtgJHtwcmVkfSgke2FyZ3MucmVkdWNlKChhLCBiKSA9PiBhICsgJywgJyArIGIpfSlgXVxuXG4gICAgfVxuXG4gICAgZ2V0IGVudGl0aWVzKCk6IElkW10ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRoaXMuYXJncykpXG4gICAgfVxuXG4gICAgZ2V0IHRoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaW1wbGllcyhjb25jbHVzaW9uOiBDbGF1c2UpOiBDbGF1c2Uge1xuICAgICAgICByZXR1cm4gbmV3IEltcGx5KHRoaXMsIGNvbmNsdXNpb24pXG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQmFzaWNDbGF1c2UgfSBmcm9tIFwiLi9CYXNpY0NsYXVzZVwiXG5pbXBvcnQgQW5kIGZyb20gXCIuL0FuZFwiXG5pbXBvcnQgeyBJZCwgTWFwIH0gZnJvbSBcIi4vSWRcIlxuXG5cbi8qKlxuICogQSAnbGFuZ3VhZ2UtYWdub3N0aWMnIGZpcnN0IG9yZGVyIGxvZ2ljIHJlcHJlc2VudGF0aW9uLlxuKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xhdXNlIHtcbiAgICByZWFkb25seSBuZWdhdGVkOiBib29sZWFuXG4gICAgcmVhZG9ubHkgaXNJbXBseTogYm9vbGVhblxuICAgIHJlYWRvbmx5IGhhc2hDb2RlOiBudW1iZXJcbiAgICByZWFkb25seSBlbnRpdGllczpJZFtdXG4gICAgcmVhZG9ubHkgdGhlbWU6IENsYXVzZVxuICAgIHJlYWRvbmx5IHJoZW1lOiBDbGF1c2VcbiAgICBjb3B5KG9wdHM/OiBDb3B5T3B0cyk6IENsYXVzZVxuICAgIGFuZChvdGhlcjogQ2xhdXNlLCBvcHRzPzogQW5kT3B0cyk6IENsYXVzZVxuICAgIGltcGxpZXMoY29uY2x1c2lvbjogQ2xhdXNlKTogQ2xhdXNlXG4gICAgZmxhdExpc3QoKTogQ2xhdXNlW11cbiAgICB0b1Byb2xvZyhvcHRzPzogVG9Qcm9sb2dPcHRzKTogc3RyaW5nW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXVzZU9mKHByZWRpY2F0ZTogc3RyaW5nLCAuLi5hcmdzOiBJZFtdKTogQ2xhdXNlIHtcbiAgICByZXR1cm4gbmV3IEJhc2ljQ2xhdXNlKHByZWRpY2F0ZSwgYXJncylcbn1cblxuZXhwb3J0IGNvbnN0IGVtcHR5Q2xhdXNlID0gKCk6IENsYXVzZSA9PiBuZXcgQW5kKFtdKVxuXG5leHBvcnQgaW50ZXJmYWNlIENvcHlPcHRzIHtcbiAgICBuZWdhdGU/OiBib29sZWFuXG4gICAgbWFwPzogTWFwXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5kT3B0cyB7XG4gICAgYXNSaGVtZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUb1Byb2xvZ09wdHMge1xuICAgIGFueUZhY3RJZD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2hTdHJpbmcoc3RyaW5nOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnNwbGl0KCcnKS5tYXAoYyA9PiBjLmNoYXJDb2RlQXQoMCkpLnJlZHVjZSgoaGFzaCwgY2MpID0+IHtcbiAgICAgICAgY29uc3QgaDEgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNjO1xuICAgICAgICByZXR1cm4gaDEgJiBoMTsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfSlcbn0iLCIvKipcbiAqIElkIG9mIGFuIGVudGl0eS5cbiAqL1xuZXhwb3J0IHR5cGUgSWQgPSBudW1iZXIgfCBzdHJpbmdcblxuLyoqXG4gKiBJZCB0byBJZCBtYXBwaW5nLCBmcm9tIG9uZSBcInVuaXZlcnNlXCIgdG8gYW5vdGhlci5cbiAqL1xuZXhwb3J0IHR5cGUgTWFwID0geyBbYTogSWRdOiBJZCB9XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5kb21JZChvcHRzPzogR2V0UmFuZG9tSWRPcHRzKTogSWQge1xuICAgIGNvbnN0IG5ld0lkID0gYGlkJHtwYXJzZUludCgxMDAwICogTWF0aC5yYW5kb20oKSArICcnKX1gXG4gICAgcmV0dXJuIG9wdHM/LmFzVmFyID8gdG9WYXIobmV3SWQpIDogbmV3SWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBHZXRSYW5kb21JZE9wdHMge1xuICAgIGFzVmFyOiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b1ZhcihpZDogSWQpOiBJZCB7XG4gICAgcmV0dXJuICghTnVtYmVyLmlzTmFOKE51bWJlcihpZCkpID8gYGlkJHtpZH1gIDogaWQgKyAnJykudG9VcHBlckNhc2UoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWYXIoZTogSWQpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlcihlKSkgJiYgKGUudG9TdHJpbmcoKVswXSA9PT0gZS50b1N0cmluZygpWzBdLnRvVXBwZXJDYXNlKCkpXG59XG5cbiIsImltcG9ydCB7IENsYXVzZSwgQW5kT3B0cywgQ29weU9wdHMsIFRvUHJvbG9nT3B0cywgaGFzaFN0cmluZyB9IGZyb20gXCIuL0NsYXVzZVwiO1xuaW1wb3J0IHsgSWQgfSBmcm9tIFwiLi9JZFwiO1xuaW1wb3J0IEFuZCBmcm9tIFwiLi9BbmRcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1wbHkgaW1wbGVtZW50cyBDbGF1c2Uge1xuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgY29uZGl0aW9uOiBDbGF1c2UsXG4gICAgICAgIHJlYWRvbmx5IGNvbmNsdXNpb246IENsYXVzZSxcbiAgICAgICAgcmVhZG9ubHkgbmVnYXRlZCA9IGZhbHNlLFxuICAgICAgICByZWFkb25seSBpc0ltcGx5ID0gdHJ1ZSxcbiAgICAgICAgcmVhZG9ubHkgaGFzaENvZGUgPSBoYXNoU3RyaW5nKEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50cykpLFxuICAgICAgICByZWFkb25seSB0aGVtZSA9IGNvbmRpdGlvbi50aGVtZSkge1xuXG4gICAgfVxuXG4gICAgYW5kKG90aGVyOiBDbGF1c2UsIG9wdHM/OiBBbmRPcHRzKTogQ2xhdXNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbmQoW3RoaXMsIG90aGVyXSlcbiAgICB9XG5cbiAgICBjb3B5KG9wdHM/OiBDb3B5T3B0cyk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiBuZXcgSW1wbHkodGhpcy5jb25kaXRpb24uY29weShvcHRzKSwgdGhpcy5jb25jbHVzaW9uLmNvcHkob3B0cyksIG9wdHM/Lm5lZ2F0ZSA/ICF0aGlzLm5lZ2F0ZWQgOiB0aGlzLm5lZ2F0ZWQpXG4gICAgfVxuXG4gICAgZmxhdExpc3QoKTogQ2xhdXNlW10ge1xuICAgICAgICByZXR1cm4gW3RoaXNdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIGhvcm4gY2xhdXNlcywgb25lIGZvciBlYWNoIGNvbmNsdXNpb24uIFxuICAgICAqIFNpbmNlIHByb2xvZyBvbmx5IHN1cHBvcnRzIHRoYXQga2luZCBvZiBpbXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBcbiAgICAgKi9cbiAgICB0b1Byb2xvZyhvcHRzPzogVG9Qcm9sb2dPcHRzKTogc3RyaW5nW10ge1xuXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvblN0cmluZyA9IHRoaXMuY29uZGl0aW9uXG4gICAgICAgICAgICAudG9Qcm9sb2coeyAuLi5vcHRzLCBhbnlGYWN0SWQ6IHRydWUgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGMxLCBjMikgPT4gYCR7YzF9LCAke2MyfWApXG5cbiAgICAgICAgY29uc3QgY29uY2x1c2lvbnMgPSB0aGlzLmNvbmNsdXNpb24uZmxhdExpc3QoKVxuICAgICAgICByZXR1cm4gY29uY2x1c2lvbnMubWFwKGMgPT4gYCR7Yy50b1Byb2xvZyh7IC4uLm9wdHMsIGFueUZhY3RJZDogdHJ1ZSB9KVswXX0gOi0gJHtjb25kaXRpb25TdHJpbmd9YCkgLy9UT0RPOiBbMF0gaXMgdG8gYmUgZGVhbHQgd2l0aCBiZXR0ZXJcblxuICAgIH1cblxuICAgIGdldCBlbnRpdGllcygpOiBJZFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uLmVudGl0aWVzLmNvbmNhdCh0aGlzLmNvbmNsdXNpb24uZW50aXRpZXMpXG4gICAgfVxuXG4gICAgZ2V0IHJoZW1lKCk6IENsYXVzZSB7XG4gICAgICAgIHJldHVybiB0aGlzIC8vIGR1bm5vIHdoYXQgSSdtIGRvaW4nXG4gICAgfVxuXG4gICAgaW1wbGllcyhjb25jbHVzaW9uOiBDbGF1c2UpOiBDbGF1c2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCEnKVxuICAgIH1cblxufSIsImltcG9ydCBwbCwgeyBmb3JtYXRfYW5zd2VyIH0gZnJvbSAndGF1LXByb2xvZydcbmltcG9ydCBOb3VuUGhyYXNlIGZyb20gJy4vYXN0L3BocmFzZXMvTm91blBocmFzZSc7XG5pbXBvcnQgQ29wdWxhUXVlc3Rpb24gZnJvbSAnLi9hc3Qvc2VudGVuY2VzL0NvcHVsYVF1ZXN0aW9uJztcbmltcG9ydCBBcnRpY2xlIGZyb20gJy4vYXN0L3Rva2Vucy9BcnRpY2xlJztcbmltcG9ydCBDb3B1bGEgZnJvbSAnLi9hc3QvdG9rZW5zL0NvcHVsYSc7XG5pbXBvcnQgTm91biBmcm9tICcuL2FzdC90b2tlbnMvTm91bic7XG5pbXBvcnQgeyBnZXRCcmFpbiB9IGZyb20gJy4vYnJhaW4vQnJhaW4nO1xuaW1wb3J0IHsgZ2V0QW5hcGhvcmEgfSBmcm9tICcuL2JyYWluL0FuYXBob3JhJztcbmltcG9ydCB7IEJhc2ljQ2xhdXNlIH0gZnJvbSAnLi9jbGF1c2VzL0Jhc2ljQ2xhdXNlJztcbmltcG9ydCB7IGNsYXVzZU9mIH0gZnJvbSAnLi9jbGF1c2VzL0NsYXVzZSc7XG5pbXBvcnQgeyBnZXRMZXhlciB9IGZyb20gJy4vbGV4ZXIvTGV4ZXInO1xuaW1wb3J0IHsgZ2V0UGFyc2VyIH0gZnJvbSAnLi9wYXJzZXIvUGFyc2VyJztcbmltcG9ydCBQcm9sb2csIHsgZ2V0UHJvbG9nIH0gZnJvbSAnLi9wcm9sb2cvUHJvbG9nJztcbmltcG9ydCBUYXVQcm9sb2cgZnJvbSAnLi9wcm9sb2cvVGF1UHJvbG9nJztcbmltcG9ydCBjb21waWxlTG9naWNUZXN0IGZyb20gJy4vdGVzdHMvY29tcGlsZS1sb2dpYy10ZXN0JztcbmltcG9ydCBwbGF5Z3JvdW5kIGZyb20gJy4vdGVzdHMvcGxheWdyb3VuZCc7XG5pbXBvcnQgcHJvbG9nUGxheSBmcm9tICcuL3Rlc3RzL3Byb2xvZy1wbGF5Z3JvdW5kJztcblxuXG4vLyBQUk9MT0cgVEVTVCAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnN0IHBybyA9IGdldFByb2xvZygpO1xuLy8gKHdpbmRvdyBhcyBhbnkpLnBybyA9IHBybztcbi8vIChhc3luYyAoKSA9PiB7XG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnY2FwcmEoc2NlbW8pJylcbi8vICAgICBhd2FpdCBwcm8uYXNzZXJ0KCdtYW1tYWwocGVsb3NvKScpXG4vLyAgICAgYXdhaXQgcHJvLmFzc2VydCgnbWFtbWFsKGZpZG8pJylcbi8vICAgICBhd2FpdCBwcm8uYXNzZXJ0KCdtYW1tYWwoWCkgOi0gY2FwcmEoWCknKVxuLy8gICAgIGNvbnNvbGUubG9nKGF3YWl0IHByby5xdWVyeSgnbWFtbWFsKFgpLicpKVxuLy8gICAgIGF3YWl0IHByby5yZXRyYWN0KCdjYXByYShzY2VtbyknKVxuLy8gICAgIGNvbnNvbGUubG9nKGF3YWl0IHByby5xdWVyeSgnbWFtbWFsKFgpLicpKVxuLy8gfSkoKTtcbi8vIC8vICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbnNvbGUubG9nKCh0b2tlbk9mKCdhJykgYXMgQXJ0aWNsZSkuaXNEZWZpbml0ZSgpKVxuLy8gY29uc29sZS5sb2codG9rZW5PZignYScpICBpbnN0YW5jZW9mIEFydGljbGUpXG4vLyBjb25zb2xlLmxvZyh0b2tlbk9mKCdhJykgIGluc3RhbmNlb2YgUXVhbnRpZmllcilcbi8vIGNvbnNvbGUubG9nKHRva2VuT2YoJ2V2ZXJ5JykgIGluc3RhbmNlb2YgUXVhbnRpZmllcilcbi8vIGNvbnNvbGUubG9nKHRva2VuT2YoJ2EnKS50b1N0cmluZygpKVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29uc3QgbGV4ZXIgPSBnZXRMZXhlcigndGhlIGNhdCBpcyBhIGNhdC4nKVxuLy8gY29uc29sZS5sb2cobGV4ZXIpXG4vLyBjb25zb2xlLmxvZygnaXMgaXQgYSBub3VuPycsIGxleGVyLmFzc2VydChOb3VuLCB7ZXJyb3JPdXQ6ZmFsc2V9KSApXG4vLyBjb25zb2xlLmxvZyhsZXhlci5wZWVrKVxuLy8gY29uc29sZS5sb2coJ2lzIGl0IGEgY29wdWxhPycsIGxleGVyLmFzc2VydChDb3B1bGEsIHtlcnJvck91dDpmYWxzZX0pIClcbi8vIGNvbnNvbGUubG9nKGxleGVyLnBlZWspXG4vLyBjb25zb2xlLmxvZygnaXMgaXQgYW4gYXJ0aWNsZT8nLCBsZXhlci5hc3NlcnQoQXJ0aWNsZSwge2Vycm9yT3V0OmZhbHNlfSkgKVxuLy8gY29uc29sZS5sb2cobGV4ZXIucGVlaylcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBjYXQgaXMgYmlnJykucGFyc2UoKSlcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGJpZyBjYXQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcigndGhlIGJpZyBjYXQgb24gdGhlIHRhYmxlIGlzIGVhdGluZyB0dW5hJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ3RoZSBiaWcgY2F0IG9uIHRoZSBtYXQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcignZXZlcnkgZG9nIGlzIHN0dXBpZCcpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgY2F0IHRoYXQgaXMgc21hcnQnKS5wYXJzZSgpIClcbi8vIGNvbnNvbGUubG9nKGdldFBhcnNlcignbm9kZWpzIGlzIG5vdCBoZWxwZnVsJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZyhnZXRQYXJzZXIoJ2lmIHRoZSBkb2cgaXMgc3R1cGlkIHRoZW4gdGhlIGNhdCBpcyBoYXBweScpLnBhcnNlKCkgKVxuLy8gY29uc29sZS5sb2coZ2V0UGFyc2VyKCd0aGUgY2F0IGlzIGhhcHB5IGlmIHRoZSBkb2cgaXMgc3R1cGlkJykucGFyc2UoKSApXG4vLyBjb25zb2xlLmxvZygod2luZG93IGFzIGFueSkuYXN0ID0gZ2V0UGFyc2VyKCd0aGUgY29sb3Igb2YgdGhlIGJ1dHRvbiBpcyByZWQnKS5wYXJzZSgpKVxuLy8gY29uc29sZS5sb2coKHdpbmRvdyBhcyBhbnkpLmFzdCA9IGdldFBhcnNlcigndGhlIGNvbG9yIG9mIHRoZSBidXR0b24gb24gdGhlIGJsYWNrIGRpdiBpcyByZWQnKS5wYXJzZSgpKVxuXG4vLyBDT01QSUxFUiBURVNUU1xuLy8gZnVuY3Rpb24gdGVzdChzdHJpbmc6IHN0cmluZykge1xuLy8gICAgIGNvbnNvbGUubG9nKHN0cmluZylcbi8vICAgICBjb25zdCBjbGF1c2UgPSBnZXRQYXJzZXIoc3RyaW5nKS5wYXJzZSgpLnRvQ2xhdXNlKCkuY29weSh7IG1hcDogeyAnaWQxJzogMTAwMCwgJ2lkMic6IDIwMDAgfSB9KVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsYXVzZS5mbGF0TGlzdCgpLm1hcChjID0+IGMudG9TdHJpbmcoKSkpXG4vLyAgICAgY29uc29sZS5sb2coY2xhdXNlLnRvUHJvbG9nKCkpXG4vLyAgICAgLy8gY29uc29sZS5sb2coY2xhdXNlKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKCdlbnRpdGllcycsIGNsYXVzZS5lbnRpdGllcylcbi8vICAgICAvLyBjb25zb2xlLmxvZygndGhlbWUnLCBjbGF1c2UudGhlbWUpXG4vLyAgICAgLy8gY29uc29sZS5sb2coJ3JoZW1lJywgY2xhdXNlLnJoZW1lKVxuLy8gICAgIC8vIGNvbnNvbGUubG9nKGNsYXVzZS5hYm91dCgnaWQwJykpXG4vLyB9XG5cbi8vIHRlc3QoJ3RoZSBjYXQgaXMgb24gdGhlIG1hdCcpXG4vLyAvLyB0ZXN0KCd0aGUgY2F0IHRoYXQgaXMgcmVkIGlzIG9uIHRoZSBtYXQnKVxuLy8gLy8gdGVzdCgndGhlIGJpZyBjYXQgdGhhdCBpcyBvbiB0aGUgbWF0IGlzIGJsYWNrJylcbi8vIHRlc3QoJ2V2ZXJ5IGNhdCBpcyByZWQnKVxuLy8gdGVzdCgnZXZlcnkgcmVkIGNhdCBpcyBvbiB0aGUgbWF0Jylcbi8vIC8vIHRlc3QoJ3RoZSBjYXQgZXhpc3RzIG9uIHRoZSBtYXQnKVxuLy8gdGVzdCgnaWYgdGhlIGNhdCBpcyBvbiB0aGUgbWF0IHRoZW4gdGhlIGNhdCBpcyByZWQnKVxuLy8gLy8gdGVzdCgndGhlIGNhdCBpcyBub3QgcmVkJylcbi8vIHRlc3QoJ2V2ZXJ5IGNhdCBpcyBub3QgcmVkJylcbi8vIHRlc3QoJ3RydW1wIGlzIG5vdCBhIGdyZWF0IHByZXNpZGVudCcpOyAvLyBwcm9iYWJseSBuZWVkIGFuIGFuZCBwcmVkaWNhdGVcblxuLy8gRU5EIENPTVBJTEVSIFRFU1RTXG5cblxuLy8gKGFzeW5jICgpID0+IHtcbi8vICAgICBjb25zdCBicmFpbiA9IGF3YWl0IGdldEJyYWluKCk7XG4vLyAgICAgY29uc3QgYyA9IGNsYXVzZU9mKCdjYXByYScsICd1bm8nKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsIDIpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsIDMpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCd3aGl0ZScsIDMpKVxuLy8gICAgICAgICAuY29uY2F0KGNsYXVzZU9mKCdjYXQnLCA0KSlcbi8vICAgICAgICAgLmNvbmNhdChjbGF1c2VPZignd2hpdGUnLCA0KSlcblxuLy8gICAgIGF3YWl0IGJyYWluLmFzc2VydChjKTtcbi8vICAgICBjb25zb2xlLmxvZyhhd2FpdCBicmFpbi5xdWVyeShjbGF1c2VPZignd2hpdGUnLCAnWCcpLmNvbmNhdChjbGF1c2VPZignY2F0JywgJ1gnKSkpKVxuLy8gfSkoKVxuXG4vLyAoYXN5bmMgKCkgPT4ge1xuXG4vLyAgICAgY29uc3Qgc3RhdGUgPSB7XG4vLyAgICAgICAgIHRpbWVyIDogc2V0VGltZW91dCgoKT0+e30sMCksXG4vLyAgICAgICAgIGJyYWluIDogYXdhaXQgZ2V0QnJhaW4oKSxcbi8vICAgICAgICAgZGVib3VuY2luZ1RpbWUgOiAwXG4vLyAgICAgfVxuXG4vLyAgICAgY29uc3QgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuLy8gICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyb290Jyk/LmFwcGVuZENoaWxkKHApXG5cbi8vICAgICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJylcbi8vICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnNTB2aCdcbi8vICAgICB0ZXh0YXJlYS5zdHlsZS53aWR0aCA9ICc1MHZ3J1xuXG4vLyAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jvb3QnKT8uYXBwZW5kQ2hpbGQodGV4dGFyZWEpXG5cbi8vICAgICBjb25zdCBvbklucHV0ID0gYXN5bmMgKCkgPT4ge1xuLy8gICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dGFyZWEudmFsdWVcbi8vICAgICAgICAgY29uc3QgYXN0ID0gZ2V0UGFyc2VyKHRleHQpLnBhcnNlKClcbi8vICAgICAgICAgY29uc3QgY2xhdXNlID0gYXN0LnRvUHJvbG9nKClcblxuLy8gICAgICAgICBpZiAoIWNsYXVzZSl7XG4vLyAgICAgICAgICAgICByZXR1cm4gXG4vLyAgICAgICAgIH1cblxuLy8gICAgICAgICBjb25zdCBtYXBwaW5nID0gZ2V0U2FuZGJveChjbGF1c2UpLm1hcFRvKHN0YXRlLmJyYWluKVxuXG5cbi8vICAgICAgICAgcC5pbm5lckhUTUwgPSBgJHsoYXN0IGFzIGFueSkuY29uc3RydWN0b3IubmFtZX06ICR7Y2xhdXNlLnRvU3RyaW5nKCl9YFxuXG4vLyAgICAgICAgIGlmIChhc3QgaW5zdGFuY2VvZiBDb3B1bGFRdWVzdGlvbil7XG4vLyAgICAgICAgICAgICBjb25zb2xlLmxvZyhhd2FpdCBzdGF0ZS5icmFpbi5xdWVyeShjbGF1c2UpKVxuLy8gICAgICAgICB9ZWxzZXtcbi8vICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhc3NlcnRlZDonLCBjbGF1c2UudG9TdHJpbmcoKSlcbi8vICAgICAgICAgfVxuXG4vLyAgICAgfVxuXG4vLyAgICAgdGV4dGFyZWEub25pbnB1dCA9IGUgPT4ge1xuLy8gICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZXIpXG4vLyAgICAgICAgIHN0YXRlLnRpbWVyID0gc2V0VGltZW91dCgoKT0+e1xuLy8gICAgICAgICAgICAgb25JbnB1dCgpXG4vLyAgICAgICAgIH0sIHN0YXRlLmRlYm91bmNpbmdUaW1lKVxuLy8gICAgIH1cblxuLy8gfSkoKTtcblxuXG5cbi8vIChhc3luYyAoKSA9PiB7XG5cbi8vICAgICBjb25zdCBwcm9sb2cgPSBhd2FpdCBnZXRCcmFpbigpO1xuLy8gICAgICh3aW5kb3cgYXMgYW55KS5wcm9sb2cgPSBwcm9sb2dcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCdjYXQnLCAnYScpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2NhdCcsICdiJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignY2F0JywgJ2MnKSlcbi8vICAgICBhd2FpdCBwcm9sb2cuYXNzZXJ0KGNsYXVzZU9mKCd3aGl0ZScsICdhJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZG9nJywgJ2QnKSlcblxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdhJywgJ3JhYmJpdCcpKVxuLy8gICAgIGF3YWl0IHByb2xvZy5hc3NlcnQoY2xhdXNlT2YoJ2VhdCcsICdhJywgJ21vdXNlJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZWF0JywgJ2EnLCAnYmlyZGllJykpXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZignZWF0JywgJ2QnLCAnYm9uZScpKVxuXG4vLyAgICAgYXdhaXQgcHJvbG9nLmFzc2VydChjbGF1c2VPZigndGFibGUnLCAndGIxJykpXG5cbi8vICAgICAvLyBjb25zdCByZXMgPSBhd2FpdCBwcm9sb2cucXVlcnkoY2xhdXNlT2YoJ2NhdCcsICdYJykuY29uY2F0KGNsYXVzZU9mKCdlYXQnLCAnWCcsICdZJykuY29uY2F0KGNsYXVzZU9mKCdkb2cnLCAnWicpKSkpXG4vLyAgICAgLy8gY29uc3QgY2xhdXNlID0gY2xhdXNlT2YoJ2NhdCcsICdpZDAnKS5jb25jYXQoY2xhdXNlT2YoJ2RvZycsICdpZDEnKSkuY29uY2F0KGNsYXVzZU9mKCdjYXByYScsICdpZDU1JykpIFxuLy8gICAgIC8vIGNvbnN0IGNsYXVzZSA9IGdldFBhcnNlcigndGhlIGNhdCB0aGF0IGlzIGJsYWNrIGlzIHNtYXJ0JykucGFyc2UoKS50b1Byb2xvZygpXG4vLyAgICAgY29uc3QgY2xhdXNlID0gZ2V0UGFyc2VyKCd0aGUgY2F0IHRoYXQgaXMgd2hpdGUgaXMgb24gdGhlIHRhYmxlJykucGFyc2UoKS50b1Byb2xvZygpXG4vLyAgICAgY29uc29sZS5sb2coY2xhdXNlLnRvU3RyaW5nKCkpXG5cbi8vICAgICBjb25zdCByZXMgPSBhd2FpdCBnZXRTYW5kYm94KGNsYXVzZSkubWFwVG8ocHJvbG9nKVxuLy8gICAgIGNvbnNvbGUubG9nKHJlcylcbi8vICAgICBjb25zb2xlLmxvZyhjbGF1c2UucmhlbWUuY29weSh7IG1hcDogcmVzIH0pLnRvU3RyaW5nKCkpXG5cbi8vIH0pKCk7XG5cblxuLy8gcHJvbG9nUGxheSgpXG4vLyBjb21waWxlTG9naWNUZXN0KClcblxuLy8gY29uc3QgeCA9IGdldFBhcnNlcigndGhlIGNhdCBpcyBibGFjaycpLnBhcnNlKCkudG9DbGF1c2UoKS50b1Byb2xvZyh7YW55RmFjdElkOmZhbHNlfSlcbi8vIGNvbnNvbGUubG9nKHgpXG5cbi8vIGNvbnN0IHkgPSBnZXRQYXJzZXIoJ2lzIHRoZSBjYXQgYmxhY2snKS5wYXJzZSgpLnRvQ2xhdXNlKCkudG9Qcm9sb2coe2FueUZhY3RJZCA6dHJ1ZX0pXG4vLyBjb25zb2xlLmxvZyh5KVxuXG4vLyBjb25zdCB4ID0gZ2V0UGFyc2VyKCd0aGUgY2F0IGlzIG9uIHRoZSBtYXQuIHRoZSBjYXQgaXMgcmVkLiB0aGUgY2F0IGlzIGJsYWNrJylcbi8vICAgICAgICAgLnBhcnNlQWxsKClcbi8vICAgICAgICAgLm1hcChjPT5jLnRvQ2xhdXNlKCkudG9Qcm9sb2coKSlcblxuLy8gY29uc29sZS5sb2coeClcblxuXG4vLyAoYXN5bmMgKCk9Pntcbi8vICAgICBjb25zdCBtYXAgPSBhd2FpdCBnZXRBbmFwaG9yYShnZXRQYXJzZXIoJ3RoZSBibGFjayBjYXQnKS5wYXJzZSgpLnRvQ2xhdXNlKCkpLm1hcFRvQ2xhdXNlKGdldFBhcnNlcigndGhlIGJsYWNrIGNhdCcpLnBhcnNlKCkudG9DbGF1c2UoKSlcbi8vICAgICBjb25zb2xlLmxvZyhtYXApXG5cbi8vICAgICBjb25zdCBtYXAyID0gYXdhaXQgZ2V0QW5hcGhvcmEoZ2V0UGFyc2VyKCd0aGUgcmVkIGNhdCcpLnBhcnNlKCkudG9DbGF1c2UoKSkubWFwVG9DbGF1c2UoZ2V0UGFyc2VyKCd0aGUgYmxhY2sgY2F0JykucGFyc2UoKS50b0NsYXVzZSgpKVxuLy8gICAgIGNvbnNvbGUubG9nKG1hcDIpXG4vLyB9KSgpXG5cblxuKGFzeW5jICgpPT57XG4gICAgLy8gaWYgdGhlIGJ1dHRvbiBpcyByZWQgdGhlbiB0aGUgYnV0dG9uIGlzIGdyZWVuXG5cbiAgICBjb25zdCBzbWFsbCA9IGdldFBhcnNlcigndGhlIGJ1dHRvbiBpcyByZWQnKS5wYXJzZSgpLnRvQ2xhdXNlKClcbiAgICBjb25zdCB1bml2ZXJzZSA9IGdldFBhcnNlcigndGhlIHN0dXBpZCBidXR0b24gaXMgZ3JlZW4nKS5wYXJzZSgpLnRvQ2xhdXNlKClcblxuICAgIGNvbnN0IG1hcCA9IGF3YWl0IGdldEFuYXBob3JhKHNtYWxsKS5tYXBUb0NsYXVzZSh1bml2ZXJzZSlcbiAgICBjb25zb2xlLmxvZyhtYXApXG59KSgpXG5cblxuLy8gcGxheWdyb3VuZCgpXG4iLCJpbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1Rva2VuXCI7XG5pbXBvcnQgTGV4ZXIsIHsgQXNzZXJ0QXJncywgQ29uc3RydWN0b3IgfSBmcm9tIFwiLi9MZXhlclwiO1xuaW1wb3J0IHRva2VuT2YgZnJvbSBcIi4vdG9rZW5PZlwiO1xuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVhZ2VyTGV4ZXIgaW1wbGVtZW50cyBMZXhlciB7XG5cbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgdG9rZW5zOiBUb2tlbltdXG4gICAgcHJvdGVjdGVkIF9wb3M6IG51bWJlclxuXG4gICAgY29uc3RydWN0b3IocmVhZG9ubHkgc291cmNlQ29kZTogc3RyaW5nKSB7XG4gICAgICAgIC8vVE9ETzogcmVjb25zdHJ1Y3QgXCJkbyBub3RcIiBhbmQgXCJkb2VzIG5vdFwiIHRva2Vuc1xuICAgICAgICAvL1RPRE86IG5vdW5zIHZzIGFkamVjdGl2ZXNcbiAgICAgICAgdGhpcy50b2tlbnMgPSBzb3VyY2VDb2RlLnRyaW0oKS5zcGxpdCgvXFxzK3xcXC4vKS5tYXAoZSA9PiAhZSA/ICcuJyA6IGUpLm1hcCh0b2tlbk9mKVxuICAgICAgICBjb25zb2xlLmRlYnVnKCd0b2tlbnMnLCB0aGlzLnRva2VucylcbiAgICAgICAgdGhpcy5fcG9zID0gMFxuICAgIH1cblxuICAgIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BvcysrXG4gICAgfVxuXG4gICAgZ2V0IHBvcygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zXG4gICAgfVxuXG4gICAgYmFja1RvKHBvczogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3BvcyA9IHBvc1xuICAgIH1cblxuICAgIGdldCBwZWVrKCk6IFRva2VuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuX3Bvc11cbiAgICB9XG5cbiAgICBjcm9hayhlcnJvck1zZzogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlcnJvck1zZ30gYXQgJHt0aGlzLl9wb3N9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGN1cnJlbnQgdG9rZW4gaWZmIG9mIGdpdmVuIHR5cGUgYW5kIG1vdmUgdG8gbmV4dDsgXG4gICAgICogZWxzZSByZXR1cm4gdW5kZWZpbmVkIGFuZCBkb24ndCBtb3ZlLlxuICAgICAqIEBwYXJhbSBhcmdzIFxuICAgICAqIEByZXR1cm5zIFxuICAgICAqL1xuICAgIGFzc2VydDxUPihjbGF6ejogQ29uc3RydWN0b3I8VD4sIGFyZ3M6IEFzc2VydEFyZ3MpOiBUIHwgdW5kZWZpbmVkIHtcblxuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5wZWVrXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBjbGF6eikge1xuICAgICAgICAgICAgdGhpcy5uZXh0KClcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50XG4gICAgICAgIH0gZWxzZSBpZiAoYXJncy5lcnJvck91dCA/PyB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmNyb2FrKGFyZ3MuZXJyb3JNc2cgPz8gJycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdldCBpc0VuZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID49IHRoaXMudG9rZW5zLmxlbmd0aCBcbiAgICB9XG5cbn0iLCJpbXBvcnQgVG9rZW4gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1Rva2VuXCJcbmltcG9ydCBFYWdlckxleGVyIGZyb20gXCIuL0VhZ2VyTGV4ZXJcIlxuXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgTGV4ZXJ7XG4gICAgZ2V0IHBlZWsoKTpUb2tlblxuICAgIGdldCBwb3MoKTpudW1iZXJcbiAgICBnZXQgaXNFbmQoKTpib29sZWFuXG4gICAgbmV4dCgpOnZvaWRcbiAgICBiYWNrVG8ocG9zOm51bWJlcik6dm9pZFxuICAgIGNyb2FrKGVycm9yTXNnOnN0cmluZyk6dm9pZCAgIFxuICAgIGFzc2VydCA8VD4oY2xheno6Q29uc3RydWN0b3I8VD4sIGFyZ3M6QXNzZXJ0QXJncyk6IFR8dW5kZWZpbmVkIFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFzc2VydEFyZ3N7XG4gICAgZXJyb3JNc2c/OnN0cmluZ1xuICAgIGVycm9yT3V0Pzpib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZXhlcihzb3VyY2VDb2RlOnN0cmluZyk6TGV4ZXJ7XG4gICAgcmV0dXJuIG5ldyBFYWdlckxleGVyKHNvdXJjZUNvZGUpXG59XG5cbmV4cG9ydCB0eXBlIENvbnN0cnVjdG9yPFQ+ID0gbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gVFxuIiwiaW1wb3J0IGFkamVjdGl2ZXMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9hZGplY3RpdmVzJ1xuaW1wb3J0IGluZGVmaW5pdGVfYXJ0aWNsZXMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9pbmRlZmluaXRlX2FydGljbGVzJ1xuaW1wb3J0IGRlZmluaXRlX2FydGljbGVzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvZGVmaW5pdGVfYXJ0aWNsZXMnXG5pbXBvcnQgY29wdWxhcyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2NvcHVsYXMnXG5pbXBvcnQgaHZlcmJzIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvaHZlcmJzJ1xuaW1wb3J0IGl2ZXJicyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL2l2ZXJicydcbmltcG9ydCBtdmVyYnMgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9tdmVyYnMnXG5pbXBvcnQgbmVnYXRpb25zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbmVnYXRpb25zJ1xuaW1wb3J0IG5vbnN1YmNvbmogZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9ub25zdWJjb25qJ1xuaW1wb3J0IG5vdW5zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvbm91bnMnXG5pbXBvcnQgcHJlcG9zaXRpb25zIGZyb20gJy4uLy4uL3Jlcy90b2tlbnMvcHJlcG9zaXRpb25zJ1xuaW1wb3J0IGV4aXN0cXVhbnQgZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9leGlzdGVudGlhbF9xdWFudGlmaWVycydcbmltcG9ydCB1bmlxdWFudCBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL3VuaXZlcnNhbF9xdWFudGlmaWVycydcbmltcG9ydCByZWxwcm9ucyBmcm9tICcuLi8uLi9yZXMvdG9rZW5zL3JlbHByb25zJ1xuaW1wb3J0IHN1YmNvbmogZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy9zdWJjb25qJ1xuaW1wb3J0IHRoZW4gZnJvbSAnLi4vLi4vcmVzL3Rva2Vucy90aGVuJ1xuaW1wb3J0IEFydGljbGUgZnJvbSAnLi4vYXN0L3Rva2Vucy9BcnRpY2xlJ1xuaW1wb3J0IENvcHVsYSBmcm9tICcuLi9hc3QvdG9rZW5zL0NvcHVsYSdcbmltcG9ydCBIVmVyYiBmcm9tICcuLi9hc3QvdG9rZW5zL0hWZXJiJ1xuaW1wb3J0IElWZXJiIGZyb20gJy4uL2FzdC90b2tlbnMvSVZlcmInXG5pbXBvcnQgTVZlcmIgZnJvbSAnLi4vYXN0L3Rva2Vucy9NVmVyYidcbmltcG9ydCBOZWdhdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL05lZ2F0aW9uJ1xuaW1wb3J0IE5vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL05vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbidcbmltcG9ydCBQcmVwb3NpdGlvbiBmcm9tICcuLi9hc3QvdG9rZW5zL1ByZXBvc2l0aW9uJ1xuaW1wb3J0IFF1YW50aWZpZXIgZnJvbSAnLi4vYXN0L3Rva2Vucy9RdWFudGlmaWVyJ1xuaW1wb3J0IFRoZW4gZnJvbSAnLi4vYXN0L3Rva2Vucy9UaGVuJ1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tICcuLi9hc3QvdG9rZW5zL1JlbGF0aXZlUHJvbm91bidcbmltcG9ydCBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24gZnJvbSAnLi4vYXN0L3Rva2Vucy9TdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24nXG5pbXBvcnQgTm91biBmcm9tICcuLi9hc3QvdG9rZW5zL05vdW4nXG5pbXBvcnQgQWRqZWN0aXZlIGZyb20gJy4uL2FzdC90b2tlbnMvQWRqZWN0aXZlJ1xuaW1wb3J0IFRva2VuIGZyb20gJy4uL2FzdC9pbnRlcmZhY2VzL1Rva2VuJ1xuaW1wb3J0IEZ1bGxTdG9wIGZyb20gJy4uL2FzdC90b2tlbnMvRnVsbFN0b3AnXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRva2VuT2Yoc3RyaW5nOnN0cmluZyk6VG9rZW57XG4gICAgXG4gICAgaWYgKGluZGVmaW5pdGVfYXJ0aWNsZXMuY29uY2F0KGRlZmluaXRlX2FydGljbGVzKS5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnRpY2xlKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoY29wdWxhcy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGEoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChodmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgSFZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChpdmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgSVZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChtdmVyYnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgTVZlcmIoc3RyaW5nKVxuICAgIH1lbHNlIGlmIChuZWdhdGlvbnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgTmVnYXRpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChub25zdWJjb25qLmluY2x1ZGVzKHN0cmluZykpe1xuICAgICAgICByZXR1cm4gbmV3IE5vblN1Ym9yZGluYXRpbmdDb25qdW5jdGlvbihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKHByZXBvc2l0aW9ucy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBQcmVwb3NpdGlvbihzdHJpbmcpXG4gICAgfWVsc2UgaWYgKGV4aXN0cXVhbnQuY29uY2F0KHVuaXF1YW50KS5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBRdWFudGlmaWVyKHN0cmluZylcbiAgICB9ZWxzZSBpZiAodGhlbi5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGVuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAocmVscHJvbnMuaW5jbHVkZXMoc3RyaW5nKSl7XG4gICAgICAgIHJldHVybiBuZXcgUmVsYXRpdmVQcm9ub3VuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoc3ViY29uai5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24oc3RyaW5nKVxuICAgIH1lbHNlIGlmIChub3Vucy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3VuKHN0cmluZylcbiAgICB9ZWxzZSBpZiAoYWRqZWN0aXZlcy5pbmNsdWRlcyhzdHJpbmcpKXtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGplY3RpdmUoc3RyaW5nKVxuICAgIH1lbHNlIGlmICgnLicgPT09IHN0cmluZyl7XG4gICAgICAgIHJldHVybiBuZXcgRnVsbFN0b3AoJy4nKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgQWRqZWN0aXZlKHN0cmluZylcbn0iLCJpbXBvcnQgQXN0IGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Bc3RcIjtcbmltcG9ydCBCaW5hcnlRdWVzdGlvbiBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQmluYXJ5UXVlc3Rpb25cIjtcbmltcG9ydCBDb21wb3VuZFNlbnRlbmNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9Db21wb3VuZFNlbnRlbmNlXCI7XG5pbXBvcnQgRGVjbGFyYXRpb24gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL0RlY2xhcmF0aW9uXCI7XG5pbXBvcnQgUXVlc3Rpb24gZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1F1ZXN0aW9uXCI7XG5pbXBvcnQgU2ltcGxlU2VudGVuY2UgZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL1NpbXBsZVNlbnRlbmNlXCI7XG5pbXBvcnQgVmVyYlNlbnRlbmNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9WZXJiU2VudGVuY2VcIjtcbmltcG9ydCBDb21wbGVtZW50IGZyb20gXCIuLi9hc3QvcGhyYXNlcy9Db21wbGVtZW50XCI7XG5pbXBvcnQgTm91blBocmFzZSBmcm9tIFwiLi4vYXN0L3BocmFzZXMvTm91blBocmFzZVwiO1xuaW1wb3J0IFN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9hc3QvaW50ZXJmYWNlcy9TdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IENvbXBsZXhTZW50ZW5jZSBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db21wbGV4U2VudGVuY2VcIjtcbmltcG9ydCBDb25qdW5jdGl2ZVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL0Nvbmp1bmN0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBDb3B1bGFRdWVzdGlvbiBmcm9tIFwiLi4vYXN0L3NlbnRlbmNlcy9Db3B1bGFRdWVzdGlvblwiO1xuaW1wb3J0IENvcHVsYVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL0NvcHVsYVNlbnRlbmNlXCI7XG5pbXBvcnQgSW50cmFuc2l0aXZlU2VudGVuY2UgZnJvbSBcIi4uL2FzdC9zZW50ZW5jZXMvSW50cmFuc2l0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBNb25vdHJhbnNpdGl2ZVNlbnRlbmNlIGZyb20gXCIuLi9hc3Qvc2VudGVuY2VzL01vbm90cmFuc2l0aXZlU2VudGVuY2VcIjtcbmltcG9ydCBBZGplY3RpdmUgZnJvbSBcIi4uL2FzdC90b2tlbnMvQWRqZWN0aXZlXCI7XG5pbXBvcnQgQXJ0aWNsZSBmcm9tIFwiLi4vYXN0L3Rva2Vucy9BcnRpY2xlXCI7XG5pbXBvcnQgQ29wdWxhIGZyb20gXCIuLi9hc3QvdG9rZW5zL0NvcHVsYVwiO1xuaW1wb3J0IElWZXJiIGZyb20gXCIuLi9hc3QvdG9rZW5zL0lWZXJiXCI7XG5pbXBvcnQgTVZlcmIgZnJvbSBcIi4uL2FzdC90b2tlbnMvTVZlcmJcIjtcbmltcG9ydCBOZWdhdGlvbiBmcm9tIFwiLi4vYXN0L3Rva2Vucy9OZWdhdGlvblwiO1xuaW1wb3J0IE5vdW4gZnJvbSBcIi4uL2FzdC90b2tlbnMvTm91blwiO1xuaW1wb3J0IFByZXBvc2l0aW9uIGZyb20gXCIuLi9hc3QvdG9rZW5zL1ByZXBvc2l0aW9uXCI7XG5pbXBvcnQgUXVhbnRpZmllciBmcm9tIFwiLi4vYXN0L3Rva2Vucy9RdWFudGlmaWVyXCI7XG5pbXBvcnQgU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uIGZyb20gXCIuLi9hc3QvdG9rZW5zL1N1Ym9yZGluYXRpbmdDb25qdW5jdGlvblwiO1xuaW1wb3J0IFRoZW4gZnJvbSBcIi4uL2FzdC90b2tlbnMvVGhlblwiO1xuaW1wb3J0IExleGVyLCB7IGdldExleGVyIH0gZnJvbSBcIi4uL2xleGVyL0xleGVyXCI7XG5pbXBvcnQgUGFyc2VyIGZyb20gXCIuL1BhcnNlclwiO1xuaW1wb3J0IENvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlIGZyb20gXCIuLi9hc3QvcGhyYXNlcy9Db3B1bGFTdWJvcmRpbmF0ZUNsYXVzZVwiO1xuaW1wb3J0IFJlbGF0aXZlUHJvbm91biBmcm9tIFwiLi4vYXN0L3Rva2Vucy9SZWxhdGl2ZVByb25vdW5cIjtcbmltcG9ydCBDb25zdGl0dWVudCBmcm9tIFwiLi4vYXN0L2ludGVyZmFjZXMvQ29uc3RpdHVlbnRcIjtcbmltcG9ydCBGdWxsU3RvcCBmcm9tIFwiLi4vYXN0L3Rva2Vucy9GdWxsU3RvcFwiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNpY1BhcnNlciBpbXBsZW1lbnRzIFBhcnNlciB7XG5cbiAgICBwcm90ZWN0ZWQgbHg6IExleGVyXG5cbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VDb2RlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5seCA9IGdldExleGVyKHNvdXJjZUNvZGUpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHRyeTxUIGV4dGVuZHMgQXN0PihtZXRob2Q6ICgpID0+IFQpIHtcblxuICAgICAgICBjb25zdCBtZW1lbnRvID0gdGhpcy5seC5wb3NcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCgpXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKChlcnJvciBhcyBFcnJvcikubWVzc2FnZSlcbiAgICAgICAgICAgIHRoaXMubHguYmFja1RvKG1lbWVudG8pXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBlcnJvck91dChlcnJvck1zZzogc3RyaW5nKTogQ29uc3RpdHVlbnQge1xuICAgICAgICB0aGlzLmx4LmNyb2FrKGVycm9yTXNnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpXG4gICAgfVxuXG4gICAgcGFyc2VBbGwoKTogQ29uc3RpdHVlbnRbXSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0czogQ29uc3RpdHVlbnRbXSA9IFtdXG5cbiAgICAgICAgd2hpbGUgKCF0aGlzLmx4LmlzRW5kKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy5wYXJzZSgpKVxuICAgICAgICAgICAgdGhpcy5seC5hc3NlcnQoRnVsbFN0b3AsIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0c1xuICAgIH1cblxuICAgIHBhcnNlKCk6IENvbnN0aXR1ZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJ5KHRoaXMucGFyc2VRdWVzdGlvbilcbiAgICAgICAgICAgID8/IHRoaXMudHJ5KHRoaXMucGFyc2VEZWNsYXJhdGlvbilcbiAgICAgICAgICAgID8/IHRoaXMudHJ5KHRoaXMucGFyc2VOb3VuUGhyYXNlKSAvLyBmb3IgcXVpY2sgdG9waWMgcmVmZXJlbmNlXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZSgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VEZWNsYXJhdGlvbiA9ICgpOiBEZWNsYXJhdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlQ29tcG91bmQpXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlU2ltcGxlKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VEZWNsYXJhdGlvbigpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VRdWVzdGlvbiA9ICgpOiBRdWVzdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlQmluYXJ5UXVlc3Rpb24pXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZVF1ZXN0aW9uKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZVNpbXBsZSA9ICgpOiBTaW1wbGVTZW50ZW5jZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlQ29wdWxhU2VudGVuY2UpXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlVmVyYlNlbnRlbmNlKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VTaW1wbGUoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29tcG91bmQgPSAoKTogQ29tcG91bmRTZW50ZW5jZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlQ29tcGxleClcbiAgICAgICAgICAgID8/IHRoaXMudHJ5KHRoaXMucGFyc2VDb25qdW5jdGl2ZSlcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlQ29tcG91bmQoKScpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlVmVyYlNlbnRlbmNlID0gKCk6IFZlcmJTZW50ZW5jZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlSW50cmFuc2l0aXZlU2VudGVuY2UpXG4gICAgICAgICAgICA/PyB0aGlzLnRyeSh0aGlzLnBhcnNlTW9ub3RyYW5zaXRpdmVTZW50ZW5jZSlcbiAgICAgICAgICAgID8/IHRoaXMuZXJyb3JPdXQoJ3BhcnNlVmVyYlNlbnRlbmNlKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUNvcHVsYVNlbnRlbmNlID0gKCk6IENvcHVsYVNlbnRlbmNlID0+IHtcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgY29uc3QgY29wdWxhID0gdGhpcy5seC5hc3NlcnQoQ29wdWxhLCB7IGVycm9yTXNnOiAncGFyc2VDb3B1bGFTZW50ZW5jZSgpLCBleHBlY3RlZCBjb3B1bGEnIH0pXG4gICAgICAgIGNvbnN0IG5lZ2F0aW9uID0gdGhpcy5seC5hc3NlcnQoTmVnYXRpb24sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGFTZW50ZW5jZShzdWJqZWN0LCBjb3B1bGEgYXMgQ29wdWxhLCBwcmVkaWNhdGUsIG5lZ2F0aW9uKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUNvbXBsZXggPSAoKTogQ29tcGxleFNlbnRlbmNlID0+IHtcblxuICAgICAgICBjb25zdCBzdWJjb25qID0gdGhpcy5seC5hc3NlcnQoU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuXG4gICAgICAgIGlmIChzdWJjb25qKSB7XG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLnBhcnNlU2ltcGxlKClcbiAgICAgICAgICAgIHRoaXMubHguYXNzZXJ0KFRoZW4sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgICAgICBjb25zdCBvdXRjb21lID0gdGhpcy5wYXJzZVNpbXBsZSgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbXBsZXhTZW50ZW5jZShjb25kaXRpb24sIG91dGNvbWUsIHN1YmNvbmopXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvdXRjb21lID0gdGhpcy5wYXJzZVNpbXBsZSgpXG4gICAgICAgICAgICBjb25zdCBzdWJjb25qID0gdGhpcy5seC5hc3NlcnQoU3Vib3JkaW5hdGluZ0Nvbmp1bmN0aW9uLCB7IGVycm9yT3V0OiB0cnVlLCBlcnJvck1zZzogJ2V4cGVjdGVkIHN1Ym9yZGluYXRpbmcgY29uanVuY3Rpb24nIH0pXG4gICAgICAgICAgICBjb25zdCBjb25kaXRpb24gPSB0aGlzLnBhcnNlU2ltcGxlKClcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29tcGxleFNlbnRlbmNlKGNvbmRpdGlvbiwgb3V0Y29tZSwgc3ViY29uaiBhcyBTdWJvcmRpbmF0aW5nQ29uanVuY3Rpb24pXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUludHJhbnNpdGl2ZVNlbnRlbmNlID0gKCk6IEludHJhbnNpdGl2ZVNlbnRlbmNlID0+IHtcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgY29uc3QgbmVnYXRpb24gPSB0aGlzLmx4LmFzc2VydChOZWdhdGlvbiwgeyBlcnJvck91dDogZmFsc2UgfSlcbiAgICAgICAgY29uc3QgaXZlcmIgPSB0aGlzLmx4LmFzc2VydChJVmVyYiwgeyBlcnJvck1zZzogJ3BhcnNlSW50cmFuc2l0aXZlU2VudGVuY2UoKSwgZXhwZWN0ZWQgaS12ZXJiJyB9KVxuICAgICAgICBjb25zdCBjb21wbGVtZW50cyA9IHRoaXMucGFyc2VDb21wbGVtZW50cygpXG4gICAgICAgIHJldHVybiBuZXcgSW50cmFuc2l0aXZlU2VudGVuY2Uoc3ViamVjdCwgaXZlcmIgYXMgSVZlcmIsIGNvbXBsZW1lbnRzLCBuZWdhdGlvbilcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VNb25vdHJhbnNpdGl2ZVNlbnRlbmNlID0gKCk6IE1vbm90cmFuc2l0aXZlU2VudGVuY2UgPT4ge1xuICAgICAgICBjb25zdCBzdWJqZWN0ID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICBjb25zdCBuZWdhdGlvbiA9IHRoaXMubHguYXNzZXJ0KE5lZ2F0aW9uLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuICAgICAgICBjb25zdCBtdmVyYiA9IHRoaXMubHguYXNzZXJ0KE1WZXJiLCB7IGVycm9yTXNnOiAncGFyc2VNb25vdHJhbnNpdGl2ZVNlbnRlbmNlKCksIGV4cGVjdGVkIGktdmVyYicgfSlcbiAgICAgICAgY29uc3QgY3MxID0gdGhpcy5wYXJzZUNvbXBsZW1lbnRzKClcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICBjb25zdCBjczIgPSB0aGlzLnBhcnNlQ29tcGxlbWVudHMoKVxuICAgICAgICByZXR1cm4gbmV3IE1vbm90cmFuc2l0aXZlU2VudGVuY2Uoc3ViamVjdCwgbXZlcmIgYXMgTVZlcmIsIG9iamVjdCwgY3MxLmNvbmNhdChjczIpLCBuZWdhdGlvbilcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VCaW5hcnlRdWVzdGlvbiA9ICgpOiBCaW5hcnlRdWVzdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyeSh0aGlzLnBhcnNlQ29wdWxhUXVlc3Rpb24pXG4gICAgICAgICAgICA/PyB0aGlzLmVycm9yT3V0KCdwYXJzZUJpbmFyeVF1ZXN0aW9uKCknKVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBwYXJzZUNvcHVsYVF1ZXN0aW9uID0gKCk6IENvcHVsYVF1ZXN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgY29wdWxhID0gdGhpcy5seC5hc3NlcnQoQ29wdWxhLCB7IGVycm9yTXNnOiAncGFyc2VDb3B1bGFRdWVzdGlvbigpLCBleHBlY3RlZCBjb3B1bGEnIH0pXG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnBhcnNlTm91blBocmFzZSgpXG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGFRdWVzdGlvbihzdWJqZWN0LCBwcmVkaWNhdGUsIGNvcHVsYSBhcyBDb3B1bGEpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlTm91blBocmFzZSA9ICgpOiBOb3VuUGhyYXNlID0+IHtcbiAgICAgICAgY29uc3QgcXVhbnRpZmllciA9IHRoaXMubHguYXNzZXJ0KFF1YW50aWZpZXIsIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIGNvbnN0IGFydGljbGUgPSB0aGlzLmx4LmFzc2VydChBcnRpY2xlLCB7IGVycm9yT3V0OiBmYWxzZSB9KVxuXG4gICAgICAgIGxldCBhZGplY3RpdmVzID0gW11cbiAgICAgICAgbGV0IGFkalxuXG4gICAgICAgIHdoaWxlIChhZGogPSB0aGlzLmx4LmFzc2VydChBZGplY3RpdmUsIHsgZXJyb3JPdXQ6IGZhbHNlIH0pKSB7XG4gICAgICAgICAgICBhZGplY3RpdmVzLnB1c2goYWRqKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgbm91biA9IHRoaXMubHguYXNzZXJ0KE5vdW4sIHsgZXJyb3JPdXQ6IGZhbHNlIH0pXG4gICAgICAgIGNvbnN0IHN1Ym9yZGluYXRlQ2xhdXNlID0gdGhpcy50cnkodGhpcy5wYXJzZVN1Ym9yZGluYXRlQ2xhdXNlKVxuICAgICAgICBjb25zdCBjb21wbGVtZW50cyA9IHRoaXMucGFyc2VDb21wbGVtZW50cygpXG5cbiAgICAgICAgcmV0dXJuIG5ldyBOb3VuUGhyYXNlKGFkamVjdGl2ZXMsIGNvbXBsZW1lbnRzLCBub3VuLCBxdWFudGlmaWVyLCBhcnRpY2xlLCBzdWJvcmRpbmF0ZUNsYXVzZSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb21wbGVtZW50cyA9ICgpOiBDb21wbGVtZW50W10gPT4ge1xuXG4gICAgICAgIGNvbnN0IGNvbXBsZW1lbnRzID0gW11cbiAgICAgICAgbGV0IGNvbXBcblxuICAgICAgICB3aGlsZSAoY29tcCA9IHRoaXMudHJ5KHRoaXMucGFyc2VDb21wbGVtZW50KSkge1xuICAgICAgICAgICAgY29tcGxlbWVudHMucHVzaChjb21wKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbXBsZW1lbnRzXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlQ29tcGxlbWVudCA9ICgpOiBDb21wbGVtZW50ID0+IHtcbiAgICAgICAgY29uc3QgcHJlcG9zaXRpb24gPSB0aGlzLmx4LmFzc2VydChQcmVwb3NpdGlvbiwgeyBlcnJvck1zZzogJ3BhcnNlQ29tcGxlbWVudCgpIGV4cGVjdGVkIHByZXBvc2l0aW9uJyB9KVxuICAgICAgICBjb25zdCBub3VuUGhyYXNlID0gdGhpcy5wYXJzZU5vdW5QaHJhc2UoKVxuICAgICAgICByZXR1cm4gbmV3IENvbXBsZW1lbnQocHJlcG9zaXRpb24gYXMgUHJlcG9zaXRpb24sIG5vdW5QaHJhc2UpXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlU3Vib3JkaW5hdGVDbGF1c2UgPSAoKTogU3Vib3JkaW5hdGVDbGF1c2UgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50cnkodGhpcy5wYXJzZUNvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlKVxuICAgICAgICAgICAgPz8gdGhpcy5lcnJvck91dCgncGFyc2VTdWJvcmRpbmF0ZUNsYXVzZSgpJylcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSA9ICgpOiBDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbHByb24gPSB0aGlzLmx4LmFzc2VydChSZWxhdGl2ZVByb25vdW4sIHsgZXJyb3JNc2c6ICdwYXJzZUNvcHVsYVN1Ym9yZGluYXRlQ2xhdXNlKCkgZXhwZWN0ZWQgcmVsYXRpdmUgcHJvbm91bicgfSlcbiAgICAgICAgY29uc3QgY29wdWxhID0gdGhpcy5seC5hc3NlcnQoQ29wdWxhLCB7IGVycm9yTXNnOiAncGFyc2VDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZSgpIGV4cGVjdGVkIGNvcHVsYScgfSlcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMucGFyc2VOb3VuUGhyYXNlKClcbiAgICAgICAgcmV0dXJuIG5ldyBDb3B1bGFTdWJvcmRpbmF0ZUNsYXVzZShyZWxwcm9uIGFzIFJlbGF0aXZlUHJvbm91biwgc3ViamVjdCwgY29wdWxhIGFzIENvcHVsYSlcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcGFyc2VDb25qdW5jdGl2ZSA9ICgpOiBDb25qdW5jdGl2ZVNlbnRlbmNlID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgSU1QTEVNRU5URUQhIFRPRE8hJylcbiAgICB9XG5cbn0iLCJpbXBvcnQgQ29uc3RpdHVlbnQgZnJvbSBcIi4uL2FzdC9pbnRlcmZhY2VzL0NvbnN0aXR1ZW50XCI7XG5pbXBvcnQgQmFzaWNQYXJzZXIgZnJvbSBcIi4vQmFzaWNQYXJzZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJmYWNlIFBhcnNlcntcbiAgICBwYXJzZSgpOkNvbnN0aXR1ZW50ICAgXG4gICAgcGFyc2VBbGwoKTpDb25zdGl0dWVudFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJzZXIoc291cmNlQ29kZTpzdHJpbmcpOlBhcnNlcntcbiAgICByZXR1cm4gbmV3IEJhc2ljUGFyc2VyKHNvdXJjZUNvZGUpXG59IiwiaW1wb3J0IHsgTWFwIH0gZnJvbSBcIi4uL2NsYXVzZXMvSWRcIlxuaW1wb3J0IFRhdVByb2xvZyBmcm9tIFwiLi9UYXVQcm9sb2dcIlxuXG5leHBvcnQgZGVmYXVsdCBpbnRlcmZhY2UgUHJvbG9nIHtcbiAgICBhc3NlcnQoY2xhdXNlOiBzdHJpbmcsIG9wdHM/OiBBc3NlcnRPcHRzKTogUHJvbWlzZTxNYXBbXT5cbiAgICByZXRyYWN0KGNsYXVzZTogc3RyaW5nKTogUHJvbWlzZTxNYXBbXT5cbiAgICBxdWVyeShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPE1hcFtdPlxuICAgIHByZWRpY2F0ZXMob3B0cz86IFByZWlkY2F0ZXNPcHRzKTogc3RyaW5nW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBc3NlcnRPcHRzIHtcbiAgICAvKiogaWYgdHJ1ZSBjYWxscyBhc3NlcnR6ICovXG4gICAgejogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWlkY2F0ZXNPcHRzIHtcbiAgICBhcml0eTogbnVtYmVyXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9sb2coKTogUHJvbG9nIHtcbiAgICByZXR1cm4gbmV3IFRhdVByb2xvZygpXG59IiwiaW1wb3J0IFByb2xvZywgeyBBc3NlcnRPcHRzLCBQcmVpZGNhdGVzT3B0cyB9IGZyb20gXCIuL1Byb2xvZ1wiO1xuaW1wb3J0IHBsIGZyb20gJ3RhdS1wcm9sb2cnXG5pbXBvcnQgeyBNYXAgfSBmcm9tIFwiLi4vY2xhdXNlcy9JZFwiO1xucmVxdWlyZShcInRhdS1wcm9sb2cvbW9kdWxlcy9wcm9taXNlcy5qc1wiKShwbCk7XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGF1UHJvbG9nIGltcGxlbWVudHMgUHJvbG9nIHtcblxuICAgIHByb3RlY3RlZCBzZXNzaW9uOiBwbC50eXBlLlNlc3Npb25cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBwbC5jcmVhdGUoKVxuICAgIH1cblxuICAgIGFzeW5jIGFzc2VydChjbGF1c2U6IHN0cmluZywgb3B0cz86IEFzc2VydE9wdHMpOiBQcm9taXNlPE1hcFtdPiB7XG4gICAgICAgIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlUXVlcnkoYGFzc2VydCR7b3B0cz8ueiA/ICd6JyA6ICdhJ30oICggJHtjbGF1c2V9ICkgKS5gKVxuICAgICAgICBhd2FpdCAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZUFuc3dlcigpXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGFzeW5jIHJldHJhY3QoY2xhdXNlOiBzdHJpbmcpOiBQcm9taXNlPE1hcFtdPiB7XG4gICAgICAgIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlUXVlcnkoYHJldHJhY3QoJHtjbGF1c2V9KS5gKVxuICAgICAgICBhd2FpdCAodGhpcy5zZXNzaW9uIGFzIGFueSkucHJvbWlzZUFuc3dlcigpXG4gICAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtUXVlcnkoY29kZTogc3RyaW5nKTogUHJvbWlzZTxNYXBbXT4ge1xuXG4gICAgICAgIGF3YWl0ICh0aGlzLnNlc3Npb24gYXMgYW55KS5wcm9taXNlUXVlcnkoY29kZSlcbiAgICAgICAgbGV0IGFuc3dlcnM6IE1hcFtdID0gW11cblxuICAgICAgICBmb3IgYXdhaXQgKGxldCBhbnMgb2YgKHRoaXMuc2Vzc2lvbiBhcyBhbnkpLnByb21pc2VBbnN3ZXJzKCkpIHtcblxuICAgICAgICAgICAgY29uc3QgbGlua3MgPSBhbnMubGlua3NcblxuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBPYmplY3Qua2V5cyhsaW5rcylcbiAgICAgICAgICAgICAgICAubWFwKGsgPT4gKHsgW2tdOiBsaW5rc1trXS52YWx1ZSA/PyBsaW5rc1trXS5pZCB9KSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhLCBiKSA9PiAoeyAuLi5hLCAuLi5iIH0pKVxuXG4gICAgICAgICAgICBhbnN3ZXJzLnB1c2goZW50cnkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYW5zd2Vyc1xuICAgIH1cblxuICAgIGFzeW5jIHF1ZXJ5KGNvZGU6IHN0cmluZyk6IFByb21pc2U8TWFwW10+IHtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMucGVyZm9ybVF1ZXJ5KGNvZGUpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLnBhcnNlRXJyb3IoZSkpXG4gICAgICAgICAgICByZXR1cm4gW10gLy9UT0RPOiBmaXggYnVnIGlmIGVycm9yIG5vdCBmaW5kaW5nIGFueXRoaW5nIGFsdGhvdWdoIHRoZXJlIGNvdWxkIGJlIHNvbWV0aGluZyFcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHBhcnNlRXJyb3IoZTogYW55KSB7XG5cbiAgICAgICAgY29uc3QgZXJyb3IgPSAoZSBhcyBhbnkpLmFyZ3NbMF0uYXJnc1swXS5pZFxuXG4gICAgICAgIGlmIChlcnJvciA9PSAnZXhpc3RlbmNlX2Vycm9yJykge1xuICAgICAgICAgICAgY29uc3QgbWlzc2luZ1ByZWRpY2F0ZSA9IChlIGFzIGFueSkuYXJnc1swXS5hcmdzWzBdLmFyZ3NbMV0uYXJnc1swXS5pZFxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IsIG1pc3NpbmdQcmVkaWNhdGUgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJlZGljYXRlcyhvcHRzPzogUHJlaWRjYXRlc09wdHMpOiBzdHJpbmdbXSB7XG5cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2Vzc2lvbi5ydWxlcylcbiAgICAgICAgICAgIC5tYXAociA9PiByLnNwbGl0KCcvJykpXG4gICAgICAgICAgICAuZmlsdGVyKHQgPT4gb3B0cz8uYXJpdHkgIT09IHVuZGVmaW5lZCA/IHBhcnNlSW50KHRbMV0pID09PSBvcHRzPy5hcml0eSA6IHRydWUpXG4gICAgICAgICAgICAubWFwKHQgPT4gdFswXSlcblxuICAgIH1cblxuXG59IiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLyogKGlnbm9yZWQpICovIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiIiwiLy8gc3RhcnR1cFxuLy8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxudmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKFwiLi9hcHAvc3JjL2luZGV4LnRzXCIpO1xuIiwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9